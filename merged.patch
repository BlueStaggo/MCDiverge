--- net/minecraft/server/gui/ServerGUI.java
+++ net/minecraft/server/gui/ServerGUI.java
@@ -4,13 +4,7 @@
 import java.awt.Component;
 import java.awt.Dimension;
 import java.util.logging.Logger;
-import javax.swing.JComponent;
-import javax.swing.JFrame;
-import javax.swing.JPanel;
-import javax.swing.JScrollPane;
-import javax.swing.JTextArea;
-import javax.swing.JTextField;
-import javax.swing.UIManager;
+import javax.swing.*;
 import javax.swing.border.EtchedBorder;
 import javax.swing.border.TitledBorder;
 import net.minecraft.server.MinecraftServer;
@@ -59,7 +53,7 @@
 
 	private JComponent getPlayerListComponent() {
 		PlayerListBox var1 = new PlayerListBox(this.mcServer);
-		JScrollPane var2 = new JScrollPane(var1, 22, 30);
+		JScrollPane var2 = new JScrollPane(var1, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
 		var2.setBorder(new TitledBorder(new EtchedBorder(), "Players"));
 		return var2;
 	}
@@ -68,7 +62,7 @@
 		JPanel var1 = new JPanel(new BorderLayout());
 		JTextArea var2 = new JTextArea();
 		logger.addHandler(new GuiLogOutputHandler(var2));
-		JScrollPane var3 = new JScrollPane(var2, 22, 30);
+		JScrollPane var3 = new JScrollPane(var2, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
 		var2.setEditable(false);
 		JTextField var4 = new JTextField();
 		var4.addActionListener(new ServerGuiCommandListener(this, var4));
--- net/minecraft/game/world/terrain/generate/TerrainGenNetherCaves.java
+++ net/minecraft/game/world/terrain/generate/TerrainGenNetherCaves.java
@@ -6,6 +6,8 @@
 import net.minecraft.util.MathHelper;
 
 public class TerrainGenNetherCaves extends TerrainGenerator {
+	private long caveSeed;
+
 	protected void generateLargeCaveNode(int var1, int var2, byte[] var3, double var4, double var6, double var8) {
 		this.generateCaveNode(var1, var2, var3, var4, var6, var8, 1.0F + this.rand.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5D);
 	}
@@ -15,7 +17,7 @@
 		double var19 = (double)(var2 * 16 + 8);
 		float var21 = 0.0F;
 		float var22 = 0.0F;
-		Random var23 = new Random(this.rand.nextLong());
+		Random var23 = new Random(caveSeed);
 		if(var14 <= 0) {
 			int var24 = this.range * 16 - 16;
 			var14 = var24 - var23.nextInt(var24 / 4);
@@ -102,7 +104,7 @@
 					for(var40 = var52; !var55 && var40 < var34; ++var40) {
 						for(int var41 = var54; !var55 && var41 < var38; ++var41) {
 							for(int var42 = var36 + 1; !var55 && var42 >= var53 - 1; --var42) {
-								var43 = (var40 * 16 + var41) * 128 + var42;
+								var43 = var42 << 8 | var41 << 4 | var40;
 								if(var42 >= 0 && var42 < 128) {
 									if(var3[var43] == Block.flowingLava.blockID || var3[var43] == Block.stillLava.blockID) {
 										var55 = true;
@@ -122,7 +124,7 @@
 
 							for(var43 = var54; var43 < var38; ++var43) {
 								double var44 = ((double)(var43 + var2 * 16) + 0.5D - var8) / var27;
-								int var46 = (var40 * 16 + var43) * 128 + var36;
+								int var46 = var36 << 8 | var43 << 4 | var40;
 
 								for(int var47 = var36 - 1; var47 >= var53; --var47) {
 									double var48 = ((double)var47 + 0.5D - var6) / var29;
@@ -160,6 +162,7 @@
 			double var13 = (double)(var3 * 16 + this.rand.nextInt(16));
 			int var15 = 1;
 			if(this.rand.nextInt(4) == 0) {
+				caveSeed = this.rand.nextLong();
 				this.generateLargeCaveNode(var4, var5, var6, var9, var11, var13);
 				var15 += this.rand.nextInt(4);
 			}
@@ -168,6 +171,7 @@
 				float var17 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
 				float var18 = (this.rand.nextFloat() - 0.5F) * 2.0F / 8.0F;
 				float var19 = this.rand.nextFloat() * 2.0F + this.rand.nextFloat();
+				caveSeed = this.rand.nextLong();
 				this.generateCaveNode(var4, var5, var6, var9, var11, var13, var19 * 2.0F, var17, var18, 0, 0, 0.5D);
 			}
 		}
--- net/minecraft/game/world/biome/SwamplandBiome.java
+++ /dev/null
@@ -1,4 +1,0 @@
-package net.minecraft.game.world.biome;
-
-public class SwamplandBiome extends Biome {
-}
--- net/minecraft/game/world/save/SaveConverterMcRegion.java
+++ net/minecraft/game/world/save/SaveConverterMcRegion.java
@@ -43,7 +43,7 @@
 						var10 = var7;
 					}
 
-					var1.add(new SaveFormatComparator(var7, var10, var8.getLastTimePlayed(), var8.getSizeOnDisk(), var9));
+					var1.add(new SaveFormatComparator(var7, var10, var8.getLastTimePlayed(), var8.getSizeOnDisk(), var9, var8.isCreative()));
 				}
 			}
 		}
--- argo/J_JsonFalseNodeBuilder.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package argo;
-
-final class J_JsonFalseNodeBuilder implements J_JsonNodeBuilder {
-	public J_JsonNode func_27234_b() {
-		return J_JsonNodeFactories.func_27314_c();
-	}
-}
--- net/minecraft/client/render/entity/RenderPlayer.java
+++ net/minecraft/client/render/entity/RenderPlayer.java
@@ -3,7 +3,8 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.model.BipedModel;
-import net.minecraft.client.player.ClientPlayerEntity;
+import net.minecraft.client.model.PlayerModel;
+import net.minecraft.client.model.SlimPlayerModel;
 import net.minecraft.client.render.RenderBlocks;
 import net.minecraft.client.render.Tessellator;
 import net.minecraft.game.entity.Entity;
@@ -17,13 +18,15 @@
 import org.lwjgl.opengl.GL11;
 
 public class RenderPlayer extends RenderLiving {
-	private BipedModel modelBipedMain = (BipedModel)this.mainModel;
+	private PlayerModel modelBipedMain = (PlayerModel)this.mainModel;
+	private PlayerModel modelClassic = new PlayerModel(0.0F);
+	private SlimPlayerModel modelSlim = new SlimPlayerModel(0.0F);
 	private BipedModel modelArmorChestplate = new BipedModel(1.0F);
 	private BipedModel modelArmor = new BipedModel(0.5F);
 	private static final String[] armorFilenamePrefix = new String[]{"cloth", "chain", "iron", "diamond", "gold"};
 
 	public RenderPlayer() {
-		super(new BipedModel(0.0F), 0.5F);
+		super(new PlayerModel(0.0F), 0.5F);
 	}
 
 	protected boolean setArmorModel(PlayerEntity var1, int var2, float var3) {
@@ -50,15 +53,23 @@
 	}
 
 	public void renderPlayer(PlayerEntity var1, double var2, double var4, double var6, float var8, float var9) {
+		this.mainModel = var1.isSlim ? this.modelSlim : this.modelClassic;
+		this.modelBipedMain = var1.isSlim ? this.modelSlim : this.modelClassic;
+
 		ItemStack var10 = var1.inventory.getCurrentItem();
 		this.modelArmorChestplate.field_1278_i = this.modelArmor.field_1278_i = this.modelBipedMain.field_1278_i = var10 != null;
 		this.modelArmorChestplate.isSneak = this.modelArmor.isSneak = this.modelBipedMain.isSneak = var1.isSneaking();
 		double var11 = var4 - (double)var1.yOffset;
-		if(var1.isSneaking() && !(var1 instanceof ClientPlayerEntity)) {
-			var11 -= 0.125D;
+		if(var1.isSneaking()) {
+			var11 -= 0.1D;
 		}
 
+		GL11.glDisable(GL11.GL_CULL_FACE);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		super.doRenderLiving(var1, var2, var11, var6, var8, var9);
+		GL11.glDisable(GL11.GL_BLEND);
+		GL11.glEnable(GL11.GL_CULL_FACE);
 		this.modelArmorChestplate.isSneak = this.modelArmor.isSneak = this.modelBipedMain.isSneak = false;
 		this.modelArmorChestplate.field_1278_i = this.modelArmor.field_1278_i = this.modelBipedMain.field_1278_i = false;
 	}
@@ -233,10 +244,20 @@
 		GL11.glScalef(var3, var3, var3);
 	}
 
-	public void drawFirstPersonHand() {
+	public void drawFirstPersonHand(PlayerEntity player) {
+		this.mainModel = player.isSlim ? this.modelSlim : this.modelClassic;
+		this.modelBipedMain = player.isSlim ? this.modelSlim : this.modelClassic;
+
 		this.modelBipedMain.onGround = 0.0F;
 		this.modelBipedMain.setRotationAngles(0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F / 16.0F);
+
+		GL11.glDisable(GL11.GL_CULL_FACE);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		this.modelBipedMain.bipedRightArm.render(1.0F / 16.0F);
+		this.modelBipedMain.rightArmOverlay.render(1.0F / 16.0F);
+		GL11.glDisable(GL11.GL_BLEND);
+		GL11.glEnable(GL11.GL_CULL_FACE);
 	}
 
 	protected void func_22016_b(PlayerEntity var1, double var2, double var4, double var6) {
--- /dev/null
+++ net/mine_diver/smoothbeta/entity/SmoothEntityRegistry.java
@@ -1,0 +1,78 @@
+package net.mine_diver.smoothbeta.entity;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import net.minecraft.game.entity.Entity;
+import com.mojang.nbt.CompoundTag;
+import net.minecraft.game.world.World;
+
+import java.lang.invoke.LambdaMetafactory;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Function;
+
+import static java.lang.invoke.MethodType.methodType;
+
+public class SmoothEntityRegistry {
+    private static final Function<World, Entity> EMPTY_CONSTRUCTOR = level -> null;
+    private static final Map<String, Function<World, Entity>> STRING_ID_TO_CONSTRUCTOR = new HashMap<>();
+    private static final Int2ObjectMap<Function<World, Entity>> ID_TO_CONSTRUCTOR;
+
+    static {
+        Int2ObjectMap<Function<World, Entity>> idToConstructor = new Int2ObjectOpenHashMap<>();
+        idToConstructor.defaultReturnValue(EMPTY_CONSTRUCTOR);
+        ID_TO_CONSTRUCTOR = idToConstructor;
+    }
+
+    private static Function<World, Entity> findConstructor(Class<? extends Entity> entityClass) throws Throwable {
+        MethodHandles.Lookup lookup = MethodHandles.lookup();
+        MethodHandle mh = lookup.findConstructor(entityClass, methodType(void.class, World.class));
+        //noinspection unchecked
+        return (Function<World, Entity>) LambdaMetafactory.metafactory(
+                lookup,
+                "apply", methodType(Function.class),
+                mh.type().generic(), mh, mh.type()
+        ).getTarget().invokeExact();
+    }
+
+    public static void register(Class<? extends Entity> entityClass, String identifier, int id) {
+        Function<World, Entity> constructor;
+        try {
+            constructor = findConstructor(entityClass);
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        }
+        STRING_ID_TO_CONSTRUCTOR.put(identifier, constructor);
+        ID_TO_CONSTRUCTOR.put(id, constructor);
+    }
+
+    public static void registerNoID(Class<? extends Entity> entityClass, String identifier) {
+        try {
+            STRING_ID_TO_CONSTRUCTOR.put(identifier, findConstructor(entityClass));
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static Entity create(String identifier, World level) {
+        return STRING_ID_TO_CONSTRUCTOR.getOrDefault(identifier, EMPTY_CONSTRUCTOR).apply(level);
+    }
+
+    public static Entity create(CompoundTag tag, World level) {
+        Entity var2 = STRING_ID_TO_CONSTRUCTOR.getOrDefault(tag.getString("id"), EMPTY_CONSTRUCTOR).apply(level);
+        if (var2 == null)
+            System.out.println("Skipping Entity with id " + tag.getString("id"));
+        else
+            var2.readFromNBT(tag);
+        return var2;
+    }
+
+    public static Entity create(int id, World level) {
+        Entity var2 = ID_TO_CONSTRUCTOR.get(id).apply(level);
+        if (var2 == null)
+            System.out.println("Skipping Entity with id " + id);
+        return var2;
+    }
+}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/VertexFormatElement.java
@@ -1,0 +1,99 @@
+package net.mine_diver.smoothbeta.client.render;
+
+/**
+ * Represents a singular field within a larger {@link
+ * VertexFormat vertex format}.
+ * 
+ * <p>This element comprises a component type, the number of components,
+ * and a type that describes how the components should be interpreted.
+ */
+public class VertexFormatElement {
+    private final ComponentType componentType;
+    private final Type type;
+    private final int uvIndex;
+    private final int componentCount;
+    /**
+     * The total length of this element (in bytes).
+     */
+    private final int byteLength;
+
+    public VertexFormatElement(int uvIndex, ComponentType componentType, Type type, int componentCount) {
+        if (!this.isValidType(uvIndex, type))
+            throw new IllegalStateException("Multiple vertex elements of the same type other than UVs are not supported");
+        this.type = type;
+        this.componentType = componentType;
+        this.uvIndex = uvIndex;
+        this.componentCount = componentCount;
+        this.byteLength = componentType.getByteLength() * this.componentCount;
+    }
+
+    private boolean isValidType(int uvIndex, Type type) {
+        return uvIndex == 0 || type == Type.UV;
+    }
+
+    public String toString() {
+        return this.componentCount + "," + this.type.getName() + "," + this.componentType.getName();
+    }
+
+    public final int getByteLength() {
+        return this.byteLength;
+    }
+
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || this.getClass() != o.getClass()) return false;
+        VertexFormatElement vertexFormatElement = (VertexFormatElement)o;
+        if (this.componentCount != vertexFormatElement.componentCount) return false;
+        if (this.uvIndex != vertexFormatElement.uvIndex) return false;
+        if (this.componentType != vertexFormatElement.componentType) return false;
+        return this.type == vertexFormatElement.type;
+    }
+
+    public int hashCode() {
+        int i = this.componentType.hashCode();
+        i = 31 * i + this.type.hashCode();
+        i = 31 * i + this.uvIndex;
+        i = 31 * i + this.componentCount;
+        return i;
+    }
+
+    public enum Type {
+        POSITION("Position"),
+        NORMAL("Normal"),
+        COLOR("Vertex Color"),
+        UV("UV"),
+        PADDING("Padding");
+
+        private final String name;
+
+        Type(String name) {
+            this.name = name;
+        }
+
+        public String getName() {
+            return this.name;
+        }
+    }
+
+    public enum ComponentType {
+        FLOAT(4, "Float"),
+        UBYTE(1, "Unsigned Byte"),
+        BYTE(1, "Byte");
+
+        private final int byteLength;
+        private final String name;
+
+        ComponentType(int byteLength, String name) {
+            this.byteLength = byteLength;
+            this.name = name;
+        }
+
+        public int getByteLength() {
+            return this.byteLength;
+        }
+
+        public String getName() {
+            return this.name;
+        }
+    }
+}
--- argo/J_InvalidSyntaxException.java
+++ /dev/null
@@ -1,18 +1,0 @@
-package argo;
-
-public final class J_InvalidSyntaxException extends Exception {
-	private final int field_27191_a;
-	private final int field_27190_b;
-
-	J_InvalidSyntaxException(String var1, J_ThingWithPosition var2) {
-		super("At line " + var2.func_27330_b() + ", column " + var2.func_27331_a() + ":  " + var1);
-		this.field_27191_a = var2.func_27331_a();
-		this.field_27190_b = var2.func_27330_b();
-	}
-
-	J_InvalidSyntaxException(String var1, Throwable var2, J_ThingWithPosition var3) {
-		super("At line " + var3.func_27330_b() + ", column " + var3.func_27331_a() + ":  " + var1, var2);
-		this.field_27191_a = var3.func_27331_a();
-		this.field_27190_b = var3.func_27330_b();
-	}
-}
--- /dev/null
+++ net/minecraft/game/item/CreativeInventoryBuilder.java
@@ -1,0 +1,44 @@
+package net.minecraft.game.item;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class CreativeInventoryBuilder {
+	private final List<ItemStack> items = new ArrayList<>();
+	private final Map<Integer, String> labels = new HashMap<>();
+
+	public void addLabel(String label) {
+		this.lineBreak();
+		this.newLine();
+		this.labels.put(this.items.size() / 8, label);
+	}
+
+	public void lineBreak() {
+		if (this.items.size() % 8 != 0)
+			newLine();
+	}
+
+	public void newLine() {
+		int emptyItems = 8 - (this.items.size() % 8);
+		for (int i = 0; i < emptyItems; i++) {
+			this.items.add(null);
+		}
+	}
+
+	public void addItem(int id, int meta) {
+		if (id <= 0 || meta < 0) {
+			this.items.add(null);
+			return;
+		}
+
+		ItemStack item = new ItemStack(id, 1, meta);
+		if (Item.itemsList[id] == null) item = null;
+		this.items.add(item);
+	}
+
+	public InventoryReadonly toInventory() {
+		return new InventoryReadonly(items.toArray(new ItemStack[0]), true, labels);
+	}
+}
--- net/minecraft/util/MathHelper.java
+++ net/minecraft/util/MathHelper.java
@@ -53,6 +53,99 @@
 		return var0 == null || var0.length() == 0;
 	}
 
+    public static int roundUpToMultiple(int value, int divisor) {
+        return ceilDiv(value, divisor) * divisor;
+    }
+
+    public static int ceilDiv(int a, int b) {
+        return -Math.floorDiv(-a, b);
+    }
+
+	public static float lerp(float a, float b, float t) {
+		return a + (b - a) * t;
+	}
+
+	public static double lerp(double a, double b, double t) {
+		return a + (b - a) * t;
+	}
+
+	public static double lerp(double n00, double n01, double n10, double n11, double t0, double t1) {
+		return lerp(lerp(n00, n01, t0), lerp(n10, n11, t0), t1);
+	}
+
+	public static void lerp3DPoints(DoubleArray3D src, DoubleArray3D dst, int rh, int rv) {
+		double[] srcArr = src.getArray();
+		int sw = src.width;
+		int sh = src.height;
+		int sl = src.length;
+		int shl = sh * sl;
+		int s2hl = sh * sl + sh;
+
+		for (int x = 0; x < sw - 1; x++) {
+			for (int y = 0; y < sh - 1; y++) {
+				for (int z = 0; z < sl - 1; z++) {
+					int i = (x * sl + z) * sh + y;
+
+					double n000 = srcArr[i];
+					double n010 = srcArr[i + 1];
+					double n001 = srcArr[i + sh];
+					double n011 = srcArr[i + sh + 1];
+					double n100 = srcArr[i + shl];
+					double n110 = srcArr[i + shl + 1];
+					double n101 = srcArr[i + s2hl];
+					double n111 = srcArr[i + s2hl + 1];
+
+					for (int lx = 0; lx < rh; lx++) {
+						double n00 = n000 + (n100 - n000) * ((lx % rh) / (double)rh);
+						double n01 = n001 + (n101 - n001) * ((lx % rh) / (double)rh);
+						double n10 = n010 + (n110 - n010) * ((lx % rh) / (double)rh);
+						double n11 = n011 + (n111 - n011) * ((lx % rh) / (double)rh);
+
+						for (int ly = 0; ly < rv; ly++) {
+							double n0 = n00 + (n10 - n00) * ((ly % rv) / (double)rv);
+							double n1 = n01 + (n11 - n01) * ((ly % rv) / (double)rv);
+
+							for (int lz = 0; lz < rh; lz++) {
+								double n = n0 + (n1 - n0) * ((lz % rh) / (double)rh);
+
+								dst.set(x * rh + lx, y * rv + ly, z * rh + lz, n);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public static int clamp(int x, int min, int max) {
+		return Math.min(Math.max(x, min), max);
+	}
+
+	public static float clamp(float x, float min, float max) {
+		return Math.min(Math.max(x, min), max);
+	}
+
+	public static double clamp(double x, double min, double max) {
+		return Math.min(Math.max(x, min), max);
+	}
+
+	public static float floorMod(float x, float y) {
+		float mod = x % y;
+		if (mod < 0) {
+			mod += y;
+		}
+		return mod;
+	}
+
+	public static int intBits(int i) {
+		int bits = 0;
+		while (i != 0) {
+			i >>= 1;
+			bits++;
+		}
+		return bits;
+	}
+
 	static {
 		for(int var0 = 0; var0 < 65536; ++var0) {
 			SIN_TABLE[var0] = (float)Math.sin((double)var0 * Math.PI * 2.0D / 65536.0D);
--- /dev/null
+++ net/mine_diver/smoothbeta/util/LinkedListFromHell.java
@@ -1,0 +1,198 @@
+package net.mine_diver.smoothbeta.util;
+
+import java.util.Iterator;
+
+public class LinkedListFromHell<T> implements Iterable<LinkedListFromHell.Node<T>> {
+    private Node<T> first;
+    private Node<T> last;
+    private int size;
+
+    public void addFirst(Node<T> node) {
+        this.checkNoParent(node);
+
+        if (this.isEmpty()) {
+            this.first = node;
+            this.last = node;
+        } else {
+            Node<T> nodenext = this.first;
+            node.setNext(nodenext);
+            nodenext.setPrev(node);
+            this.first = node;
+        }
+
+        node.setParent(this);
+        ++this.size;
+    }
+
+    public void addLast(Node<T> node) {
+        this.checkNoParent(node);
+
+        if (this.isEmpty()) this.first = node;
+        else {
+            Node<T> nodeprev = this.last;
+            node.setPrev(nodeprev);
+            nodeprev.setNext(node);
+        }
+        this.last = node;
+
+        node.setParent(this);
+        ++this.size;
+    }
+
+    public void addAfter(Node<T> nodePrev, Node<T> node) {
+        if (nodePrev == null) this.addFirst(node);
+        else if (nodePrev == this.last) this.addLast(node);
+        else {
+            this.checkParent(nodePrev);
+            this.checkNoParent(node);
+            Node<T> nodenext = nodePrev.getNext();
+            nodePrev.setNext(node);
+            node.setPrev(nodePrev);
+            nodenext.setPrev(node);
+            node.setNext(nodenext);
+            node.setParent(this);
+            ++this.size;
+        }
+    }
+
+    public Node<T> remove(Node<T> node) {
+        this.checkParent(node);
+        Node<T> prev = node.getPrev();
+        Node<T> node1 = node.getNext();
+
+        if (prev != null) prev.setNext(node1);
+        else this.first = node1;
+
+        if (node1 != null) node1.setPrev(prev);
+        else this.last = prev;
+
+        node.setPrev(null);
+        node.setNext(null);
+        node.setParent(null);
+        --this.size;
+        return node;
+    }
+
+    public void moveAfter(Node<T> nodePrev, Node<T> node) {
+        this.remove(node);
+        this.addAfter(nodePrev, node);
+    }
+
+    public boolean find(Node<T> nodeFind, Node<T> nodeFrom, Node<T> nodeTo) {
+        this.checkParent(nodeFrom);
+
+        if (nodeTo != null) this.checkParent(nodeTo);
+
+        Node<T> node;
+
+        for (node = nodeFrom; node != null && node != nodeTo; node = node.getNext()) if (node == nodeFind) return true;
+
+        if (node != nodeTo)
+            throw new IllegalArgumentException("Sublist is not linked, from: " + nodeFrom + ", to: " + nodeTo);
+        else return false;
+    }
+
+    private void checkParent(Node<T> node) {
+        if (node.parent != this)
+            throw new IllegalArgumentException("Node has different parent, node: " + node + ", parent: " + node.parent + ", this: " + this);
+    }
+
+    private void checkNoParent(Node<T> node) {
+        if (node.parent != null)
+            throw new IllegalArgumentException("Node has different parent, node: " + node + ", parent: " + node.parent + ", this: " + this);
+    }
+
+    public boolean contains(Node<T> node) {
+        return node.parent == this;
+    }
+
+    @Override
+    public Iterator<Node<T>> iterator() {
+        return new Iterator<Node<T>>() {
+            Node<T> node = LinkedListFromHell.this.getFirst();
+
+            public boolean hasNext() {
+                return this.node != null;
+            }
+
+            public Node<T> next() {
+                Node<T> node = this.node;
+
+                if (this.node != null)
+                    this.node = this.node.next;
+
+                return node;
+            }
+        };
+    }
+
+    public Node<T> getFirst()
+    {
+        return this.first;
+    }
+
+    public Node<T> getLast()
+    {
+        return this.last;
+    }
+
+    public int getSize()
+    {
+        return this.size;
+    }
+
+    public boolean isEmpty()
+    {
+        return this.size <= 0;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        for (Iterator<Node<T>> it = iterator(); it.hasNext();) {
+            Node<T> node = it.next();
+            if (sb.length() > 0) sb.append(", ");
+            sb.append(node.getItem());
+        }
+        return this.size + " [" + sb + "]";
+    }
+
+    public static class Node<T> {
+        private final T item;
+        private Node<T> prev;
+        private Node<T> next;
+        private LinkedListFromHell<T> parent;
+
+        public Node(T item) {
+            this.item = item;
+        }
+
+        public T getItem() {
+            return this.item;
+        }
+
+        public Node<T> getPrev() {
+            return this.prev;
+        }
+
+        public Node<T> getNext() {
+            return this.next;
+        }
+
+        private void setPrev(Node<T> prev) {
+            this.prev = prev;
+        }
+
+        private void setNext(Node<T> next) {
+            this.next = next;
+        }
+
+        private void setParent(LinkedListFromHell<T> parent) {
+            this.parent = parent;
+        }
+
+        public String toString() {
+            return "" + this.item;
+        }
+    }
+}
--- net/minecraft/game/world/biome/ForestBiome.java
+++ net/minecraft/game/world/biome/ForestBiome.java
@@ -4,16 +4,35 @@
 import net.minecraft.game.entity.animal.WolfEntity;
 import net.minecraft.game.world.SpawnListEntry;
 import net.minecraft.game.world.terrain.feature.BigTreeFeature;
-import net.minecraft.game.world.terrain.feature.BirchTreeFeature;
 import net.minecraft.game.world.terrain.feature.Feature;
 import net.minecraft.game.world.terrain.feature.TreeFeature;
 
 public class ForestBiome extends Biome {
-	public ForestBiome() {
+	private final boolean blooming;
+
+	public ForestBiome(int i) {
+		this(i, false);
+	}
+
+	public ForestBiome(int i, boolean blooming) {
+		super(i);
+		this.blooming = blooming;
 		this.spawnableCreatureList.add(new SpawnListEntry(WolfEntity.class, 2));
 	}
 
 	public Feature getRandomTreeFeature(Random var1) {
-		return (Feature)(var1.nextInt(5) == 0 ? new BirchTreeFeature() : (var1.nextInt(3) == 0 ? new BigTreeFeature() : new TreeFeature()));
+		int meta = this.blooming && var1.nextInt(3) != 0 ? 64 : 0;
+		return var1.nextInt(5) == 0 ? new BigTreeFeature(0, meta) : new TreeFeature(0, meta);
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return treeBonus + treeNoise + 5;
+	}
+
+	public Feature modifyGrownTree(Feature var1, Random var2) {
+		if (this.blooming && (var1 instanceof TreeFeature || var1 instanceof BigTreeFeature)) {
+			return this.getRandomTreeFeature(var2);
+		}
+		return super.modifyGrownTree(var1, var2);
 	}
 }
--- net/minecraft/game/world/block/tileentity/PistonTileEntity.java
+++ net/minecraft/game/world/block/tileentity/PistonTileEntity.java
@@ -12,7 +12,7 @@
 public class PistonTileEntity extends TileEntity {
 	private int storedBlockID;
 	private int storedMetadata;
-	private int storedOrientation;
+	private Direction storedOrientation;
 	private boolean isExtending;
 	private boolean midExtending;
 	private float progress;
@@ -22,7 +22,7 @@
 	public PistonTileEntity() {
 	}
 
-	public PistonTileEntity(int var1, int var2, int var3, boolean var4, boolean var5) {
+	public PistonTileEntity(int var1, int var2, Direction var3, boolean var4, boolean var5) {
 		this.storedBlockID = var1;
 		this.storedMetadata = var2;
 		this.storedOrientation = var3;
@@ -42,7 +42,7 @@
 		return this.isExtending;
 	}
 
-	public int getOrientation() {
+	public Direction getOrientation() {
 		return this.storedOrientation;
 	}
 
@@ -59,15 +59,15 @@
 	}
 
 	public float getXProgress(float var1) {
-		return this.isExtending ? (this.getProgress(var1) - 1.0F) * (float)Direction.faceToX[this.storedOrientation] : (1.0F - this.getProgress(var1)) * (float)Direction.faceToX[this.storedOrientation];
+		return this.isExtending ? (this.getProgress(var1) - 1.0F) * (float)this.storedOrientation.X : (1.0F - this.getProgress(var1)) * (float)this.storedOrientation.X;
 	}
 
 	public float getYProgress(float var1) {
-		return this.isExtending ? (this.getProgress(var1) - 1.0F) * (float)Direction.faceToY[this.storedOrientation] : (1.0F - this.getProgress(var1)) * (float)Direction.faceToY[this.storedOrientation];
+		return this.isExtending ? (this.getProgress(var1) - 1.0F) * (float)this.storedOrientation.Y : (1.0F - this.getProgress(var1)) * (float)this.storedOrientation.Y;
 	}
 
 	public float getZProgress(float var1) {
-		return this.isExtending ? (this.getProgress(var1) - 1.0F) * (float)Direction.faceToZ[this.storedOrientation] : (1.0F - this.getProgress(var1)) * (float)Direction.faceToZ[this.storedOrientation];
+		return this.isExtending ? (this.getProgress(var1) - 1.0F) * (float)this.storedOrientation.Z : (1.0F - this.getProgress(var1)) * (float)this.storedOrientation.Z;
 	}
 
 	private void pushEntities(float var1, float var2) {
@@ -86,7 +86,7 @@
 
 				while(var5.hasNext()) {
 					Entity var6 = (Entity)var5.next();
-					var6.moveEntity((double)(var2 * (float)Direction.faceToX[this.storedOrientation]), (double)(var2 * (float)Direction.faceToY[this.storedOrientation]), (double)(var2 * (float)Direction.faceToZ[this.storedOrientation]));
+					var6.moveEntity((double)(var2 * (float)this.storedOrientation.X), (double)(var2 * (float)this.storedOrientation.Y), (double)(var2 * (float)this.storedOrientation.Z));
 				}
 
 				pushingEntities.clear();
@@ -134,7 +134,7 @@
 		super.readFromNBT(var1);
 		this.storedBlockID = var1.getInteger("blockId");
 		this.storedMetadata = var1.getInteger("blockData");
-		this.storedOrientation = var1.getInteger("facing");
+		this.storedOrientation = Direction.values()[var1.getInteger("facing")];
 		this.lastProgress = this.progress = var1.getFloat("progress");
 		this.isExtending = var1.getBoolean("extending");
 	}
@@ -143,7 +143,7 @@
 		super.writeToNBT(var1);
 		var1.setInteger("blockId", this.storedBlockID);
 		var1.setInteger("blockData", this.storedMetadata);
-		var1.setInteger("facing", this.storedOrientation);
+		var1.setInteger("facing", this.storedOrientation.ordinal());
 		var1.setFloat("progress", this.lastProgress);
 		var1.setBoolean("extending", this.isExtending);
 	}
--- argo/J_JsonNodeDoesNotMatchJsonNodeSelectorException.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package argo;
-
-public class J_JsonNodeDoesNotMatchJsonNodeSelectorException extends IllegalArgumentException {
-	J_JsonNodeDoesNotMatchJsonNodeSelectorException(String var1) {
-		super(var1);
-	}
-}
--- net/minecraft/game/item/recipe/RecipesTools.java
+++ net/minecraft/game/item/recipe/RecipesTools.java
@@ -14,10 +14,10 @@
 
 			for(int var4 = 0; var4 < this.recipeItems.length - 1; ++var4) {
 				Item var5 = (Item)this.recipeItems[var4 + 1][var2];
-				var1.addRecipe(new ItemStack(var5), new Object[]{this.recipePatterns[var4], Character.valueOf('#'), Item.stick, Character.valueOf('X'), var3});
+				var1.addRecipe(new ItemStack(var5), this.recipePatterns[var4], '#', Item.stick, 'X', var3);
 			}
 		}
 
-		var1.addRecipe(new ItemStack(Item.shears), new Object[]{" #", "# ", Character.valueOf('#'), Item.ironIngot});
+		var1.addRecipe(new ItemStack(Item.shears), " #", "# ", '#', Item.ironIngot);
 	}
 }
--- argo/J_JsonNullNodeBuilder.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package argo;
-
-final class J_JsonNullNodeBuilder implements J_JsonNodeBuilder {
-	public J_JsonNode func_27234_b() {
-		return J_JsonNodeFactories.func_27310_a();
-	}
-}
--- net/minecraft/game/world/MetadataChunkBlock.java
+++ net/minecraft/game/world/MetadataChunkBlock.java
@@ -57,14 +57,6 @@
 					}
 
 					if(var14) {
-						if(this.minY < 0) {
-							this.minY = 0;
-						}
-
-						if(this.maxY >= 128) {
-							this.maxY = 127;
-						}
-
 						for(int var27 = this.minY; var27 <= this.maxY; ++var27) {
 							int var16 = var1.getSavedLightValue(this.lightType, var10, var27, var11);
 							boolean var17 = false;
--- net/minecraft/game/world/chunk/ChunkCoordIntPair.java
+++ net/minecraft/game/world/chunk/ChunkCoordIntPair.java
@@ -9,12 +9,23 @@
 		this.chunkZPos = var2;
 	}
 
-	public static int chunkXZ2Int(int var0, int var1) {
-		return (var0 < 0 ? Integer.MIN_VALUE : 0) | (var0 & Short.MAX_VALUE) << 16 | (var1 < 0 ? -Short.MIN_VALUE : 0) | var1 & Short.MAX_VALUE;
+	public static long chunkXZ2Int(int var0, int var1) {
+        return (long)var0 & 4294967295L | ((long)var1 & 4294967295L) << 32;
+	}
+
+	public static int getChunkX(long packedChunkCoord) {
+		return (int)(packedChunkCoord & 4294967295L);
+	}
+
+	public static int getChunkZ(long packedChunkCoord) {
+		return (int)(packedChunkCoord >>> 32 & 4294967295L);
 	}
 
 	public int hashCode() {
-		return chunkXZ2Int(this.chunkXPos, this.chunkZPos);
+		long j1 = chunkXZ2Int(this.chunkXPos, this.chunkZPos);
+		int i3 = (int)j1;
+		int i4 = (int)(j1 >> 32);
+		return i3 ^ i4;
 	}
 
 	public boolean equals(Object var1) {
--- argo/J_Functor.java
+++ /dev/null
@@ -1,9 +1,0 @@
-package argo;
-
-interface J_Functor {
-	boolean func_27058_a(Object var1);
-
-	Object func_27059_b(Object var1);
-
-	String func_27060_a();
-}
--- /dev/null
+++ argo/jdom/JsonNodeDoesNotMatchPathElementsException.java
@@ -1,0 +1,40 @@
+package argo.jdom;
+
+import argo.format.CompactJsonFormatter;
+import argo.format.JsonFormatter;
+
+public final class JsonNodeDoesNotMatchPathElementsException extends JsonNodeDoesNotMatchJsonNodeSelectorException {
+	private static final JsonFormatter JSON_FORMATTER = new CompactJsonFormatter();
+
+	static JsonNodeDoesNotMatchPathElementsException func_27319_a(JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, Object[] var1, JsonRootNode var2) {
+		return new JsonNodeDoesNotMatchPathElementsException(var0, var1, var2);
+	}
+
+	private JsonNodeDoesNotMatchPathElementsException(JsonNodeDoesNotMatchChainedJsonNodeSelectorException var1, Object[] var2, JsonRootNode var3) {
+		super(formatMessage(var1, var2, var3));
+	}
+
+	private static String formatMessage(JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, Object[] var1, JsonRootNode var2) {
+		return "Failed to find " + var0.failedNode.toString() + " at [" + JsonNodeDoesNotMatchChainedJsonNodeSelectorException.getShortFormFailPath(var0.failPath) + "] while resolving [" + func_27317_a(var1) + "] in " + JSON_FORMATTER.format(var2) + ".";
+	}
+
+	private static String func_27317_a(Object[] var0) {
+		StringBuilder var1 = new StringBuilder();
+		boolean var2 = true;
+
+        for (Object var6 : var0) {
+            if (!var2) {
+                var1.append(".");
+            }
+
+            var2 = false;
+            if (var6 instanceof String) {
+                var1.append("\"").append(var6).append("\"");
+            } else {
+                var1.append(var6);
+            }
+        }
+
+		return var1.toString();
+	}
+}
--- /dev/null
+++ argo/jdom/JsonNodeBuilder.java
@@ -1,0 +1,5 @@
+package argo.jdom;
+
+public interface JsonNodeBuilder {
+	JsonNode buildNode();
+}
--- net/minecraft/game/entity/monster/CreeperEntity.java
+++ net/minecraft/game/entity/monster/CreeperEntity.java
@@ -17,8 +17,8 @@
 
 	protected void entityInit() {
 		super.entityInit();
-		this.properties.addProperty(16, Byte.valueOf((byte)-1));
-		this.properties.addProperty(17, Byte.valueOf((byte)0));
+		this.properties.addProperty(16, (byte) -1);
+		this.properties.addProperty(17, (byte) 0);
 	}
 
 	public void writeEntityToNBT(CompoundTag var1) {
@@ -31,7 +31,7 @@
 
 	public void readEntityFromNBT(CompoundTag var1) {
 		super.readEntityFromNBT(var1);
-		this.properties.updateProperty(17, Byte.valueOf((byte)(var1.getBoolean("powered") ? 1 : 0)));
+		this.properties.updateProperty(17, (byte) (var1.getBoolean("powered") ? 1 : 0));
 	}
 
 	protected void attackBlockedEntity(Entity var1, float var2) {
@@ -132,20 +132,16 @@
 		return ((float)this.lastActiveTime + (float)(this.timeSinceIgnited - this.lastActiveTime) * var1) / 28.0F;
 	}
 
-	protected int getDropItemId() {
-		return Item.gunpowder.itemID;
-	}
-
 	private int getCreeperState() {
 		return this.properties.getByte(16);
 	}
 
 	private void setCreeperState(int var1) {
-		this.properties.updateProperty(16, Byte.valueOf((byte)var1));
+		this.properties.updateProperty(16, (byte) var1);
 	}
 
 	public void onStruckByLightning(LightningBoltEntity var1) {
 		super.onStruckByLightning(var1);
-		this.properties.updateProperty(17, Byte.valueOf((byte)1));
+		this.properties.updateProperty(17, (byte) 1);
 	}
 }
--- net/minecraft/client/gui/stats/GeneralStatsSlot.java
+++ net/minecraft/client/gui/stats/GeneralStatsSlot.java
@@ -29,8 +29,8 @@
 		return this.getSize() * 10;
 	}
 
-	protected void drawBackground() {
-		this.field_27276_a.drawDefaultBackground();
+	protected void drawBackground(float var3) {
+		this.field_27276_a.drawDefaultBackground(var3);
 	}
 
 	protected void drawSlot(int var1, int var2, int var3, int var4, Tessellator var5) {
--- /dev/null
+++ net/minecraft/game/world/block/PlanksBlock.java
@@ -1,0 +1,36 @@
+package net.minecraft.game.world.block;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.SubtypedItem;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
+import net.minecraft.game.world.block.properties.StringProperty;
+import net.minecraft.game.world.material.Material;
+
+public class PlanksBlock extends Block {
+	private static final int[] TEX_TYPES = TerrainLayout.varyingTexCoord("planks", SharedProperties.WOOD_NAMES);
+
+	public static final StringProperty TYPE = SharedProperties.woodProperty("type");
+
+	protected PlanksBlock(int var1) {
+		super(var1, TEX_TYPES[0], Material.wood);
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(TYPE);
+	}
+
+	protected Item getItem() {
+		return new SubtypedItem(this.blockID - 256);
+	}
+
+	protected int damageDropped(int var1) {
+		return var1;
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		var2 = this.properties.getInt(var2, TYPE);
+		if (var2 >= TEX_TYPES.length) var2 = 0;
+		return TEX_TYPES[var2];
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/terrain/feature/PopulatorHost.java
@@ -1,0 +1,101 @@
+package net.minecraft.game.world.terrain.feature;
+
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.ChunkProvider;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+
+import java.util.Random;
+
+public class PopulatorHost {
+	public final ChunkProvider chunkProvider;
+	public final int x;
+	public final int z;
+	public final World worldObj;
+	public final Random rand;
+	public final PerlinNoiseOctaves noise;
+
+	public PopulatorHost(ChunkProvider chunkProvider, int x, int z, World worldObj, Random rand, PerlinNoiseOctaves noise) {
+		this.chunkProvider = chunkProvider;
+		this.x = x;
+		this.z = z;
+		this.worldObj = worldObj;
+		this.rand = rand;
+		this.noise = noise;
+	}
+
+	//#region Generate Methods
+	public void generate(Feature gen, int quantity) {
+		generate(gen, quantity, 0, 256, 0);
+	}
+
+	public void generate(Feature gen, int quantity, int minY, int maxY) {
+		generate(gen, quantity, minY, maxY, 0);
+	}
+
+	public void generate(Feature gen, int quantity, int minY, int maxY, int xzOffset) {
+		for (int i = 0; i < quantity; i++) {
+			int genX = x + rand.nextInt(16) + xzOffset;
+			int genY = minY == maxY ? minY : rand.nextInt(maxY - minY) + minY;
+			int genZ = z + rand.nextInt(16) + xzOffset;
+			gen.generate(worldObj, rand, genX, genY, genZ);
+		}
+	}
+
+	public void generateSurface(Feature gen, int quantity) {
+		generateSurface(gen, quantity, 0);
+	}
+
+	public void generateSurface(Feature gen, int quantity, int xzOffset) {
+		for (int i = 0; i < quantity; i++) {
+			int genX = x + rand.nextInt(16) + xzOffset;
+			int genZ = z + rand.nextInt(16) + xzOffset;
+			int genY = worldObj.getHeightValue(genX, genZ);
+			gen.generate(worldObj, rand, genX, genY, genZ);
+		}
+	}
+
+	public void generateChance(Feature gen, int chance) {
+		generateChance(gen, chance, 0, 256, 0);
+	}
+
+	public void generateChance(Feature gen, int chance, int minY, int maxY) {
+		generateChance(gen, chance, minY, maxY, 0);
+	}
+
+	public void generateChance(Feature gen, int chance, int minY, int maxY, int xzOffset) {
+		if (rand.nextInt(chance) == 0) {
+			int genX = x + rand.nextInt(16) + xzOffset;
+			int genY = rand.nextInt(maxY - minY) + minY;
+			int genZ = z + rand.nextInt(16) + xzOffset;
+			gen.generate(worldObj, rand, genX, genY, genZ);
+		}
+	}
+
+	public void generateMinable(Block block, int size, int quantity, int minY, int maxY) {
+		generate(new OreFeature(block.blockID, size), quantity, minY, maxY);
+	}
+
+	public void generateMinableInStone(Block block, int size, int quantity, int minY, int maxY) {
+		generate(new OreFeature(block.blockID, size), quantity, minY, maxY);
+	}
+
+	public void generateLapis(Block block, int size, int quantity, int minY, int spread) {
+		Feature gen = new OreFeature(block.blockID, size);
+		for (int i = 0; i < quantity; i++) {
+			int genX = x + rand.nextInt(16);
+			int genY = minY + rand.nextInt(spread) + rand.nextInt(spread);
+			int genZ = z + rand.nextInt(16);
+			gen.generate(worldObj, rand, genX, genY, genZ);
+		}
+	}
+
+//	public void generateMinable(Block block, int size, int quantity, int minY, int maxY, int metadata) {
+//		generate(new OreFeature(block.blockID, size, metadata), quantity, minY, maxY);
+//	}
+//
+//	public void generateMinableInStone(Block block, int size, int quantity, int minY, int maxY) {
+//		generate(new OreFeature(block.blockID, size).mergeWithStone(), quantity, minY, maxY);
+//	}
+	//#endregion Generate Methods
+}
--- /dev/null
+++ net/minecraft/client/model/PlayerModel.java
@@ -1,0 +1,93 @@
+package net.minecraft.client.model;
+
+import org.lwjgl.opengl.GL11;
+
+public class PlayerModel extends BipedModel {
+	public ModelRenderer leftArmOverlay;
+	public ModelRenderer rightArmOverlay;
+	public ModelRenderer leftLegOverlay;
+	public ModelRenderer rightLegOverlay;
+	public ModelRenderer bodyOverlay;
+	
+	public PlayerModel(float f) {
+		this(f, 0.0F);
+	}
+	
+	public PlayerModel(float f, float f1) {
+//		this.aimedBow = false;
+		this.isSneak = false;
+		this.bipedCloak = new ModelRenderer(0, 0).setTextureSize(64, 64);
+		this.bipedCloak.addBox(-5F, 0.0F, -1F, 10, 16, 1, f);
+		this.bipedEars = new ModelRenderer(24, 0).setTextureSize(64, 64);
+		this.bipedEars.addBox(-3F, -6F, -1F, 6, 6, 1, f);
+		this.leftArmOverlay = new ModelRenderer(48, 48).setTextureSize(64, 64);
+        this.leftArmOverlay.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, f + 0.25F);
+        this.leftArmOverlay.setRotationPoint(5.0F, 2.0F, 0.0F);
+        this.rightArmOverlay = new ModelRenderer(40, 32).setTextureSize(64, 64);
+        this.rightArmOverlay.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, f + 0.25F);
+        this.rightArmOverlay.setRotationPoint(-5.0F, 2.0F, 10.0F);
+		this.leftLegOverlay = new ModelRenderer(0, 48).setTextureSize(64, 64);
+        this.leftLegOverlay.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, f + 0.25F);
+        this.leftLegOverlay.setRotationPoint(1.9F, 12.0F, 0.0F);
+        this.rightLegOverlay = new ModelRenderer(0, 32).setTextureSize(64, 64);
+        this.rightLegOverlay.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, f + 0.25F);
+        this.rightLegOverlay.setRotationPoint(-1.9F, 12.0F, 0.0F);
+        this.bodyOverlay = new ModelRenderer(16, 32).setTextureSize(64, 64);
+        this.bodyOverlay.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, f + 0.25F);
+        this.bodyOverlay.setRotationPoint(0.0F, 0.0F, 0.0F);
+        this.bipedLeftArm = new ModelRenderer(32, 48).setTextureSize(64, 64);
+        this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, f);
+        this.bipedLeftArm.setRotationPoint(5.0F, 2.0F, 0.0F);
+        this.bipedLeftLeg = new ModelRenderer(16, 48).setTextureSize(64, 64);
+        this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, f);
+        this.bipedLeftLeg.setRotationPoint(1.9F, 12.0F, 0.0F);
+		this.bipedHead = new ModelRenderer(0, 0).setTextureSize(64, 64);
+		this.bipedHead.addBox(-4F, -8F, -4F, 8, 8, 8, f);
+		this.bipedHead.setRotationPoint(0.0F, 0.0F + f1, 0.0F);
+		this.bipedHeadwear = new ModelRenderer(32, 0).setTextureSize(64, 64);
+		this.bipedHeadwear.addBox(-4F, -8F, -4F, 8, 8, 8, f + 0.5F);
+		this.bipedHeadwear.setRotationPoint(0.0F, 0.0F + f1, 0.0F);
+		this.bipedBody = new ModelRenderer(16, 16).setTextureSize(64, 64);
+		this.bipedBody.addBox(-4F, 0.0F, -2F, 8, 12, 4, f);
+		this.bipedBody.setRotationPoint(0.0F, 0.0F + f1, 0.0F);
+		this.bipedRightArm = new ModelRenderer(40, 16).setTextureSize(64, 64);
+		this.bipedRightArm.addBox(-3F, -2F, -2F, 4, 12, 4, f);
+		this.bipedRightArm.setRotationPoint(-5F, 2.0F + f1, 0.0F);
+		this.bipedRightLeg = new ModelRenderer(0, 16).setTextureSize(64, 64);
+		this.bipedRightLeg.addBox(-2F, 0.0F, -2F, 4, 12, 4, f);
+		this.bipedRightLeg.setRotationPoint(-2F, 12F + f1, 0.0F);
+	}
+
+	@Override
+	public void render(float forward, float haltDelta, float tick, float yaw, float pitch, float unused) {
+		super.render(forward, haltDelta, tick, yaw, pitch, unused);
+		this.setRotationAngles(forward, haltDelta, tick, yaw, pitch, unused);
+		
+		GL11.glPushMatrix();
+		this.leftArmOverlay.render(unused);
+		this.rightArmOverlay.render(unused);
+		this.leftLegOverlay.render(unused);
+		this.rightLegOverlay.render(unused);
+		this.bodyOverlay.render(unused);
+		GL11.glPopMatrix();
+	}
+
+	@Override
+	public void setRotationAngles(float forward, float haltDelta, float tick, float yaw, float pitch, float unused) {
+		super.setRotationAngles(forward, haltDelta, tick, yaw, pitch, unused);
+		syncLayerAngles(this.bipedLeftLeg, this.leftLegOverlay);
+	    syncLayerAngles(this.bipedRightLeg, this.rightLegOverlay);
+	    syncLayerAngles(this.bipedLeftArm, this.leftArmOverlay);
+		syncLayerAngles(this.bipedRightArm, this.rightArmOverlay);
+		syncLayerAngles(this.bipedBody, this.bodyOverlay);
+	}
+	
+	public static void syncLayerAngles(ModelRenderer box1, ModelRenderer box2) {
+        box2.rotateAngleX = box1.rotateAngleX;
+        box2.rotateAngleY = box1.rotateAngleY;
+        box2.rotateAngleZ = box1.rotateAngleZ;
+        box2.rotationPointX = box1.rotationPointX;
+        box2.rotationPointY = box1.rotationPointY;
+        box2.rotationPointZ = box1.rotationPointZ;
+    }
+}
--- net/minecraft/game/world/block/TrapDoorBlock.java
+++ net/minecraft/game/world/block/TrapDoorBlock.java
@@ -9,13 +9,8 @@
 import net.minecraft.game.world.material.Material;
 
 public class TrapDoorBlock extends Block {
-	protected TrapDoorBlock(int var1, Material var2) {
-		super(var1, var2);
-		this.textureIndex = 84;
-		if(var2 == Material.iron) {
-			++this.textureIndex;
-		}
-
+	protected TrapDoorBlock(int var1, int var1a, Material var2) {
+		super(var1, var1a, var2);
 		float var3 = 0.5F;
 		float var4 = 1.0F;
 		this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var4, 0.5F + var3);
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/SmoothChunkRenderer.java
@@ -1,0 +1,9 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import net.mine_diver.smoothbeta.client.render.gl.VertexBuffer;
+
+public interface SmoothChunkRenderer {
+    VertexBuffer smoothbeta_getBuffer(int pass);
+
+    VertexBuffer smoothbeta_getCurrentBuffer();
+}
--- /dev/null
+++ net/minecraft/util/DoubleArray3D.java
@@ -1,0 +1,35 @@
+package net.minecraft.util;
+
+public class DoubleArray3D {
+	private final double[] array;
+	public final int width, length, height;
+
+	public DoubleArray3D(int width, int height, int length) {
+		this(null, width, height, length);
+	}
+
+	public DoubleArray3D(double[] array, int width, int height, int length) {
+		if (array == null) {
+			array = new double[width * height * length];
+		} else if (array.length < width * height * length) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.height = height;
+		this.length = length;
+	}
+
+	public double get(int x, int y, int z) {
+		return this.array[(x * this.length + z) * this.height + y];
+	}
+
+	public void set(int x, int y, int z, double value) {
+		this.array[(x * this.length + z) * this.height + y] = value;
+	}
+
+	public double[] getArray() {
+		return array;
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/BeachBiome.java
@@ -1,0 +1,34 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
+
+import java.util.Random;
+
+public class BeachBiome extends Biome {
+	public BeachBiome(int i) {
+		super(i);
+		this.topBlock = (byte)Block.sand.blockID;
+		this.fillerBlock = (byte)Block.sand.blockID;
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.heightOffset(1.0D)
+				.noiseStretch(4.0D)
+				.noiseUnderDamp(2.0D)
+				.selectorThreshold(1.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings();
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		int sandOffset = seaLevel + 5 + random.nextInt(3);
+		this.topBlock = surfaceHeight < sandOffset ? (byte)Block.sand.blockID : (byte)Block.grass.blockID;
+		this.fillerBlock = surfaceHeight < sandOffset ? (byte)Block.sand.blockID : (byte)Block.dirt.blockID;
+		super.buildSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/GenLayerPreviewer.java
@@ -1,0 +1,541 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.client.Minecraft;
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.util.IntArray2D;
+
+import javax.imageio.ImageIO;
+import java.awt.*;
+import java.awt.datatransfer.DataFlavor;
+import java.awt.datatransfer.Transferable;
+import java.awt.datatransfer.UnsupportedFlavorException;
+import java.awt.font.GlyphVector;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.List;
+import java.util.function.Function;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+
+public class GenLayerPreviewer {
+    // GenLayerPreviewer created by BlueStaggo 2023
+
+	// For GenLayerPreviewer to work properly, add "public final long seed"
+	// to Layer's fields and "this.seed = var1" to Layer's constructor.
+
+	// All results are copied to the clipboard unless otherwise stated.
+
+	// Format options:
+	// - MARKDOWN: Markdown table in text
+	// - WIKI: Markdown table with images from golden-age-wiki
+	// - ARRAY: Java array
+	// - HEATMAP: Image for values between 0 and 65536
+	// - HEATMAP_ANNOTATED: Heatmap with numbers on the squares
+	// - IMAGE: Image using biome colors
+	// - IMAGE_SEQUENCE: Sequence of images with information for each Layer
+	//                   saved as a GIF if FFmpeg is installed (images saved to .minecraft/genlayertester)
+	// - FREQUENCY_GRAPH: Shows the frequency of different biomes
+
+    private static final Random random = new Random();
+	private static final PrintMode format = PrintMode.IMAGE;
+	private static final long seed = "Glacier".hashCode(); // Set seed here
+
+	// To use a Minecraft font, drop the font file into %JAVA_HOME%/jre/lib/fonts.
+	// Otherwise, system fonts can be used instead.
+	private static final Font font = new Font("Minecraft", Font.PLAIN, 10);
+	private static final Font bigFont = new Font("Minecraft", Font.PLAIN, 20);
+	private static final Font titleFont = new Font("Minecraft", Font.PLAIN, 40);
+
+	private static final float[] heatmapColor = { 0.0F, 1.0F, 0.0F };
+	private static final File imageSequenceLocation = new File(Minecraft.getMinecraftDir(), "genlayertester");
+	private static final String gifScript = "ffmpeg -framerate 0.5 -i \"genLayer%d.png\" -sws_dither none -vf tpad=start_mode=clone:start_duration=1:stop_mode=clone:stop_duration=3 genLayers.gif";
+
+	// Layer input array
+	private static final int[] input = {
+		1,1,1,1,12,12,12,12,
+		1,1,1,1,12,12,12,12,
+		1,1,1,1,12,12,12,12,
+		1,1,1,1,16,16,16,16,
+		1,1,1,16,0,10,10,10,
+		16,16,16,16,0,15,15,15,
+		15,15,0,0,15,14,14,14,
+		14,14,15,0,15,14,14,14,
+	};
+	private static final Layer inputGenLayer = new GenLayerArray(new IntArray2D(input, 8, 8));
+	private static final List<Layer> genLayers = new ArrayList<>();
+	private static final HashMap<Integer, Integer> randCol = new HashMap<>();
+
+	public static void main(String[] args) {
+		final int x = -432;
+		final int y = -434;
+		final int width = 864;
+		final int height = 864;
+//		addGenLayers(Layer.getLayerArray(seed)[0]);
+		addGenLayer(g -> new LayerClimaticBiomes(1000));
+//		addGenLayer(LayerBlur::new);
+
+		setWorldSeed();
+		if (format.isSequenced()) {
+			format.sequencedPrint(genLayers, x, y, width, height);
+		} else if (getLastGenLayer() != null) {
+			IntArray2D array = getLastGenLayer().getData(x, y, width, height);
+			format.print(array, width, height);
+		}
+	}
+
+	// Nothing to see down here move along now
+
+	private static Layer getLastGenLayer() {
+		return genLayers.size() == 0 ? null : genLayers.get(genLayers.size() - 1);
+	}
+
+	private static Layer addGenLayer(Function<Layer, Layer> getGenLayer) {
+		Layer genLayer = getGenLayer.apply(getLastGenLayer());
+		genLayers.add(genLayer);
+		return genLayer;
+	}
+
+	private static void addGenLayers(Layer genLayer) {
+		while (genLayer != null) {
+			genLayers.add(0, genLayer);
+			genLayer = genLayer.parent;
+		}
+	}
+
+	private static void setWorldSeed() {
+		Layer genLayer = getLastGenLayer();
+		if (genLayer != null) {
+			genLayer.setWorldSeed(seed);
+		}
+	}
+
+	private static int getBiomeColor(int i) {
+		if (i >= 0 && i < 256 && Biome.biomeIndex[i] != null) {
+			Biome biome = Biome.biomeIndex[i];
+			if (biome.mapColor == 0) {
+				biome.mapColor = random.nextInt(0xFFFFFF);
+			}
+
+			return biome.mapColor;
+		}
+
+		if (!randCol.containsKey(i)) {
+			randCol.put(i, random.nextInt(0xFFFFFF));
+		}
+
+		return randCol.get(i);
+	}
+
+	private static void copyImage(BufferedImage image) {
+		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new ImageTransferable(image), null);
+	}
+
+	private static void printMarkdown(IntArray2D array, int width, int height) {
+		for (int x = 0; x < width; x++) {
+			System.out.print("|  ");
+		}
+		System.out.println("|");
+
+		for (int x = 0; x < width; x++) {
+			System.out.print("|--");
+		}
+		System.out.println("|");
+
+		for (int z = 0; z < height; z++) {
+			for (int x = 0; x < width; x++) {
+				int i = array.get(x, z);
+				System.out.printf("|%-2d", i);
+			}
+			System.out.println("|");
+		}
+	}
+
+	private static void printWiki(IntArray2D array, int width, int height) {
+		for (int x = 0; x < width; x++) {
+			System.out.print("|  ");
+		}
+		System.out.println("|");
+
+		for (int x = 0; x < width; x++) {
+			System.out.print("|--");
+		}
+		System.out.println("|");
+
+		for (int z = 0; z < height; z++) {
+			for (int x = 0; x < width; x++) {
+				int i = array.get(x, z);
+				System.out.print("|![" + i + "](/assets/biome/" + i + ".png)");
+			}
+			System.out.println("|");
+		}
+	}
+
+	private static void printArray(IntArray2D array, int width, int height) {
+		System.out.println("{");
+		int i = 0;
+		for (int z = 0; z < height; z++) {
+			System.out.print("\t");
+			for (int x = 0; x < width; x++) {
+				System.out.print(array.get(x, z));
+				if (i < width * height) {
+					System.out.print(",");
+				}
+			}
+			System.out.println();
+		}
+		System.out.println("}");
+	}
+
+	private static void printHeatmap(IntArray2D array, int width, int height) {
+		BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+
+		int[] color = new int[3];
+		for (int x = 0; x < width; x++) {
+			for (int z = 0; z < height; z++) {
+				for (int i = 0; i < color.length; i++) {
+					color[i] = lerpi(255, (int)(heatmapColor[i] * 255.0F), Math.min(Math.max(array.get(x, z) / 65536.0F, 0.0F), 1.0F));
+				}
+
+				img.setRGB(x, z, color[0] << 16 | color[1] << 8 | color[2]);
+			}
+		}
+
+		copyImage(img);
+	}
+
+	private static void printAnnotatedHeatmap(IntArray2D array, int width, int height) {
+		final int scale = 48;
+		BufferedImage img = new BufferedImage(width * scale, height * scale, BufferedImage.TYPE_INT_RGB);
+		Graphics2D gfx = img.createGraphics();
+
+		gfx.setStroke(new BasicStroke(2.0F));
+		gfx.setFont(font);
+
+		float[] color = new float[3];
+		for (int x = 0; x < width; x++) {
+			for (int z = 0; z < height; z++) {
+				for (int i = 0; i < color.length; i++) {
+					color[i] = lerp(1.0F, heatmapColor[i], Math.min(Math.max(array.get(x, z) / 65536.0F, 0.0F), 1.0F));
+				}
+
+				gfx.setColor(new Color(color[0], color[1], color[2]));
+				gfx.fillRect(x * scale, z * scale, scale, scale);
+
+				String text = String.valueOf(array.get(x, z));
+				GlyphVector glyphVector = gfx.getFont().createGlyphVector(gfx.getFontRenderContext(), text);
+				Shape textShape = glyphVector.getOutline();
+
+				gfx.translate(x * scale + 2, z * scale + 9);
+				gfx.setColor(Color.BLACK);
+				gfx.draw(textShape);
+				gfx.setColor(Color.WHITE);
+				gfx.fill(textShape);
+				gfx.translate(-(x * scale + 2), -(z * scale + 9));
+			}
+		}
+
+		gfx.dispose();
+		copyImage(img);
+	}
+
+	private static void printImage(IntArray2D array, int width, int height) {
+		BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+
+		for (int x = 0; x < width; x++) {
+			for (int z = 0; z < height; z++) {
+				int i = array.get(x, z);
+				int color = getBiomeColor(i);
+
+				img.setRGB(x, z, color);
+			}
+		}
+
+		copyImage(img);
+	}
+
+	private static void printImageSequence(List<Layer> genLayers, int x, int z, int width, int height) {
+		imageSequenceLocation.mkdirs();
+
+		for (File file : Objects.requireNonNull(imageSequenceLocation.listFiles())) {
+			if (!file.isDirectory()) {
+				file.delete();
+			}
+		}
+
+		for (int n = 0; n < genLayers.size(); n++) {
+			Layer genLayer = genLayers.get(n);
+			String name = genLayer.getClass().getSimpleName();
+			System.out.println((n + 1) + " / " + genLayers.size() + ": " + name);
+			IntArray2D array = genLayer.getData(x, z, width, height);
+
+			BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+			Graphics2D gfx = img.createGraphics();
+
+			for (int xx = 0; xx < width; xx++) {
+				for (int zz = 0; zz < height; zz++) {
+					int i = array.get(xx, zz);
+					int color = getBiomeColor(i);
+
+					img.setRGB(xx, zz, color);
+				}
+			}
+
+
+			gfx.setStroke(new BasicStroke(2.0F));
+			gfx.setFont(titleFont);
+			gfx.translate(10, 40);
+
+			GlyphVector glyphVector = gfx.getFont().createGlyphVector(gfx.getFontRenderContext(), name);
+			Shape textShape = glyphVector.getOutline();
+
+			gfx.setColor(Color.BLACK);
+			gfx.draw(textShape);
+			gfx.setColor(Color.WHITE);
+			gfx.fill(textShape);
+
+			gfx.setFont(bigFont);
+			gfx.translate(0, 10);
+
+			String[] lines = {
+					"World Seed: " + seed,
+					"Seed: " + genLayer.seed,
+					"X: " + x,
+					"Z: " + z
+			};
+
+			for (String line : lines) {
+				gfx.translate(0, 20);
+				glyphVector = gfx.getFont().createGlyphVector(gfx.getFontRenderContext(), line);
+				textShape = glyphVector.getOutline();
+
+				gfx.setColor(Color.BLACK);
+				gfx.draw(textShape);
+				gfx.setColor(new Color(0x55FFFF));
+				gfx.fill(textShape);
+			}
+
+			gfx.dispose();
+
+			try {
+				File imgFile = new File(imageSequenceLocation, "genLayer" + n + ".png");
+				imgFile.mkdirs();
+				imgFile.delete();
+				ImageIO.write(img, "png", imgFile);
+			} catch (IOException e) {
+				System.out.println("Failed to save image!");
+				e.printStackTrace();
+			}
+		}
+
+		boolean hasFFmpeg = Stream.of(System.getenv("PATH").split(Pattern.quote(File.pathSeparator)))
+		        .map(Paths::get)
+		        .anyMatch(path -> Files.exists(path.resolve("ffmpeg")) || Files.exists(path.resolve("ffmpeg.exe")));
+
+		if (hasFFmpeg) {
+			System.out.println("Creating GIF with FFmpeg...");
+			System.out.println(gifScript);
+
+			ProcessBuilder processBuilder = new ProcessBuilder();
+			processBuilder.inheritIO();
+			processBuilder.directory(imageSequenceLocation);
+			processBuilder.command(gifScript.split(" "));
+
+			try {
+				Process process = processBuilder.start();
+				process.waitFor();
+			} catch (IOException | InterruptedException e) {
+				System.out.println("Failed to create GIF!");
+				e.printStackTrace();
+			}
+		} else {
+			System.out.println("FFmpeg not found, GIF not created.");
+		}
+
+		try {
+			Desktop.getDesktop().open(imageSequenceLocation);
+
+			File gif = new File(imageSequenceLocation, "genLayers.gif");
+			if (gif.exists()) {
+				Desktop.getDesktop().open(gif);
+			}
+		} catch (IOException e) {
+			System.out.println("Failed to open output directory.");
+			e.printStackTrace();
+		}
+	}
+
+	private static void printFrequencyGraph(IntArray2D array, int width, int height) {
+		int barWidth = 50;
+		int barSpacing = 10;
+		int barHeight = 500;
+		int max = 0;
+
+		Map<Integer, Integer> biomeCounts = new TreeMap<>();
+
+		for (int i : array.getArray()) {
+			int val = biomeCounts.compute(i, (k, v) -> v == null ? 1 : v + 1);
+			if (val > max) {
+				max = val;
+			}
+		}
+		float maxPercent = (float)max / (width * height);
+
+		BufferedImage img = new BufferedImage((barWidth + barSpacing) * biomeCounts.size() + barSpacing, barHeight + barSpacing * 2, BufferedImage.TYPE_INT_RGB);
+		Graphics2D gfx = img.createGraphics();
+
+		gfx.setBackground(Color.WHITE);
+		gfx.clearRect(0, 0, img.getWidth(), img.getHeight());
+		gfx.setFont(font);
+		gfx.setColor(Color.BLACK);
+		gfx.setStroke(new BasicStroke(1.0F));
+		gfx.drawLine(0, barSpacing - 1, img.getWidth(), barSpacing - 1);
+		gfx.drawLine(0, barHeight + barSpacing, img.getWidth(), barHeight + barSpacing);
+		gfx.setStroke(new BasicStroke(2.0F));
+		gfx.translate(barSpacing, barHeight + barSpacing);
+
+		for (Map.Entry<Integer, Integer> count : biomeCounts.entrySet()) {
+			int i = count.getKey();
+			int color = getBiomeColor(i);
+			String name = i < 0 || i > 255 || Biome.biomeIndex[i] == null ? String.valueOf(i) : Biome.biomeIndex[i].name;
+			int thisBarHeight = (int)((float)count.getValue() / (width * height) / maxPercent * barHeight);
+			String percent = String.format("%.2f", (float)count.getValue() * 100.0F / (width * height)) + "%";
+			name += "  " + percent;
+
+			gfx.setStroke(new BasicStroke(1.0F));
+			gfx.setColor(new Color(0x3f000000, true));
+			gfx.drawRect(-1, -barHeight - 1, barWidth + 1, barHeight + 1);
+			gfx.setStroke(new BasicStroke(2.0F));
+			gfx.setColor(Color.BLACK);
+			gfx.drawRect(0, -thisBarHeight, barWidth, thisBarHeight);
+			gfx.setColor(new Color(color));
+			gfx.fillRect(0, -thisBarHeight, barWidth, thisBarHeight);
+
+			gfx.translate(11, -4);
+			gfx.rotate(-Math.PI / 2.0D);
+
+			GlyphVector glyphVector = gfx.getFont().createGlyphVector(gfx.getFontRenderContext(), name);
+			Shape textShape = glyphVector.getOutline();
+
+			gfx.setColor(Color.BLACK);
+			gfx.draw(textShape);
+			gfx.setColor(Color.WHITE);
+			gfx.fill(textShape);
+
+			gfx.rotate(Math.PI / 2.0D);
+			gfx.translate(-11, 4);
+
+			gfx.translate(barWidth + barSpacing, 0);
+		}
+
+		gfx.dispose();
+
+		copyImage(img);
+	}
+
+	private static int lerpi(int a, int b, float t) {
+		return (int)(a + (b - a) * t);
+	}
+
+	private static float lerp(float a, float b, float t) {
+		return a + (b - a) * t;
+	}
+
+	private enum PrintMode {
+		MARKDOWN,
+		WIKI,
+		ARRAY,
+		HEATMAP,
+		HEATMAP_ANNOTATED,
+		IMAGE,
+		IMAGE_SEQUENCE,
+		FREQUENCY_GRAPH;
+
+		static {
+			MARKDOWN.setFunction(GenLayerPreviewer::printMarkdown);
+			WIKI.setFunction(GenLayerPreviewer::printWiki);
+			ARRAY.setFunction(GenLayerPreviewer::printArray);
+			HEATMAP.setFunction(GenLayerPreviewer::printHeatmap);
+			HEATMAP_ANNOTATED.setFunction(GenLayerPreviewer::printAnnotatedHeatmap);
+			IMAGE.setFunction(GenLayerPreviewer::printImage);
+			IMAGE_SEQUENCE.setSequencedFunction(GenLayerPreviewer::printImageSequence);
+			FREQUENCY_GRAPH.setFunction(GenLayerPreviewer::printFrequencyGraph);
+		}
+
+		private GenLayerPrintFunction function;
+		private GenLayerSequencePrintFunction sequencedFunction;
+		private boolean sequenced;
+
+		private void setFunction(GenLayerPrintFunction function) {
+			this.function = function;
+			sequencedFunction = (genLayers, x, z, width, height) -> function.print(genLayers.get(genLayers.size() - 1).getData(x, z, width, height), width, height);
+		}
+
+		private void setSequencedFunction(GenLayerSequencePrintFunction function) {
+			this.function = (array, width, height) -> function.print(Collections.singletonList(new GenLayerArray(array)), 0, 0, width, height);
+			sequencedFunction = function;
+			sequenced = true;
+		}
+
+		public void print(IntArray2D array, int width, int height) {
+			function.print(array, width, height);
+		}
+
+		public void sequencedPrint(List<Layer> genLayers, int x, int z, int width, int height) {
+			sequencedFunction.print(genLayers, x, z, width, height);
+		}
+
+		public boolean isSequenced() {
+			return sequenced;
+		}
+	}
+
+	@FunctionalInterface
+	private interface GenLayerPrintFunction {
+		void print(IntArray2D array, int width, int height);
+	}
+
+	@FunctionalInterface
+	private interface GenLayerSequencePrintFunction {
+		void print(List<Layer> genLayers, int x, int z, int width, int height);
+	}
+
+	private static class GenLayerArray extends Layer {
+		private final IntArray2D array;
+
+		public GenLayerArray(IntArray2D array) {
+			super(0);
+			this.array = array;
+		}
+
+		public IntArray2D getData(int var1, int var2, int var3, int var4) {
+			return array;
+		}
+	}
+
+	private static class ImageTransferable implements Transferable {
+	    private final BufferedImage image;
+
+	    public ImageTransferable(BufferedImage image) {
+	        this.image = image;
+	    }
+
+	    public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {
+	        if (flavor.equals(DataFlavor.imageFlavor)) {
+		        return image;
+	        }
+            throw new UnsupportedFlavorException(flavor);
+	    }
+
+	    public DataFlavor[] getTransferDataFlavors() {
+	        return new DataFlavor[]{DataFlavor.imageFlavor};
+	    }
+
+	    public boolean isDataFlavorSupported(DataFlavor flavor) {
+	        return flavor.equals(DataFlavor.imageFlavor);
+	    }
+	}
+}
--- /dev/null
+++ argo/jdom/ChainedFunctor.java
@@ -1,0 +1,38 @@
+package argo.jdom;
+
+final class ChainedFunctor implements Functor {
+	private final JsonNodeSelector parentJsonNodeSelector;
+	private final JsonNodeSelector childJsonNodeSelector;
+
+	ChainedFunctor(JsonNodeSelector var1, JsonNodeSelector var2) {
+		this.parentJsonNodeSelector = var1;
+		this.childJsonNodeSelector = var2;
+	}
+
+	public boolean matchesNode(Object var1) {
+		return this.parentJsonNodeSelector.matches(var1) && this.childJsonNodeSelector.matches(this.parentJsonNodeSelector.getValue(var1));
+	}
+
+	public Object applyTo(Object var1) {
+		Object var2;
+		try {
+			var2 = this.parentJsonNodeSelector.getValue(var1);
+		} catch (JsonNodeDoesNotMatchChainedJsonNodeSelectorException var6) {
+			throw JsonNodeDoesNotMatchChainedJsonNodeSelectorException.func_27321_b(var6, this.parentJsonNodeSelector);
+		}
+
+		try {
+            return this.childJsonNodeSelector.getValue(var2);
+		} catch (JsonNodeDoesNotMatchChainedJsonNodeSelectorException var5) {
+			throw JsonNodeDoesNotMatchChainedJsonNodeSelectorException.func_27323_a(var5, this.parentJsonNodeSelector);
+		}
+	}
+
+	public String shortForm() {
+		return this.childJsonNodeSelector.shortForm();
+	}
+
+	public String toString() {
+		return this.parentJsonNodeSelector.toString() + ", with " + this.childJsonNodeSelector.toString();
+	}
+}
--- argo/J_JsonFormatter.java
+++ /dev/null
@@ -1,5 +1,0 @@
-package argo;
-
-public interface J_JsonFormatter {
-	String func_27327_a(J_JsonRootNode var1);
-}
--- net/minecraft/game/world/save/SaveFormatComparator.java
+++ net/minecraft/game/world/save/SaveFormatComparator.java
@@ -6,13 +6,15 @@
 	private final long field_22169_c;
 	private final long field_22168_d;
 	private final boolean field_22167_e;
+	private final boolean creative;
 
-	public SaveFormatComparator(String var1, String var2, long var3, long var5, boolean var7) {
+	public SaveFormatComparator(String var1, String var2, long var3, long var5, boolean var7, boolean var8) {
 		this.fileName = var1;
 		this.displayName = var2;
 		this.field_22169_c = var3;
 		this.field_22168_d = var5;
 		this.field_22167_e = var7;
+		this.creative = var8;
 	}
 
 	public String getFileName() {
@@ -33,6 +35,10 @@
 
 	public long func_22163_e() {
 		return this.field_22169_c;
+	}
+
+	public boolean isCreative() {
+		return this.creative;
 	}
 
 	public int func_22160_a(SaveFormatComparator var1) {
--- net/minecraft/client/render/ItemRenderer.java
+++ net/minecraft/client/render/ItemRenderer.java
@@ -43,10 +43,10 @@
 
 			Tessellator var3 = Tessellator.instance;
 			int var4 = var1.getItemIcon(var2);
-			float var5 = ((float)(var4 % 16 * 16) + 0.0F) / 256.0F;
-			float var6 = ((float)(var4 % 16 * 16) + 15.99F) / 256.0F;
-			float var7 = ((float)(var4 / 16 * 16) + 0.0F) / 256.0F;
-			float var8 = ((float)(var4 / 16 * 16) + 15.99F) / 256.0F;
+			float var5 = ((float)(var4 % 32 * 16) + 0.0F) / 512.0F;
+			float var6 = ((float)(var4 % 32 * 16) + 15.99F) / 512.0F;
+			float var7 = ((float)(var4 / 32 * 16) + 0.0F) / 512.0F;
+			float var8 = ((float)(var4 / 32 * 16) + 15.99F) / 512.0F;
 			float var9 = 1.0F;
 			float var10 = 0.0F;
 			float var11 = 0.3F;
@@ -81,7 +81,7 @@
 			float var17;
 			for(var14 = 0; var14 < 16; ++var14) {
 				var15 = (float)var14 / 16.0F;
-				var16 = var6 + (var5 - var6) * var15 - 0.001953125F;
+				var16 = var6 + (var5 - var6) * var15 - (1.0F / 512.0F / 512.0F / 2.0F);
 				var17 = var9 * var15;
 				var3.addVertexWithUV((double)var17, 0.0D, (double)(0.0F - var13), (double)var16, (double)var8);
 				var3.addVertexWithUV((double)var17, 0.0D, 0.0D, (double)var16, (double)var8);
@@ -95,7 +95,7 @@
 
 			for(var14 = 0; var14 < 16; ++var14) {
 				var15 = (float)var14 / 16.0F;
-				var16 = var6 + (var5 - var6) * var15 - 0.001953125F;
+				var16 = var6 + (var5 - var6) * var15 - (1.0F / 512.0F / 512.0F / 2.0F);
 				var17 = var9 * var15 + 1.0F / 16.0F;
 				var3.addVertexWithUV((double)var17, 1.0D, (double)(0.0F - var13), (double)var16, (double)var7);
 				var3.addVertexWithUV((double)var17, 1.0D, 0.0D, (double)var16, (double)var7);
@@ -109,7 +109,7 @@
 
 			for(var14 = 0; var14 < 16; ++var14) {
 				var15 = (float)var14 / 16.0F;
-				var16 = var8 + (var7 - var8) * var15 - 0.001953125F;
+				var16 = var8 + (var7 - var8) * var15 - (1.0F / 512.0F / 512.0F / 2.0F);
 				var17 = var9 * var15 + 1.0F / 16.0F;
 				var3.addVertexWithUV(0.0D, (double)var17, 0.0D, (double)var6, (double)var16);
 				var3.addVertexWithUV((double)var9, (double)var17, 0.0D, (double)var5, (double)var16);
@@ -123,7 +123,7 @@
 
 			for(var14 = 0; var14 < 16; ++var14) {
 				var15 = (float)var14 / 16.0F;
-				var16 = var8 + (var7 - var8) * var15 - 0.001953125F;
+				var16 = var8 + (var7 - var8) * var15 - (1.0F / 512.0F / 512.0F / 2.0F);
 				var17 = var9 * var15;
 				var3.addVertexWithUV((double)var9, (double)var17, 0.0D, (double)var5, (double)var16);
 				var3.addVertexWithUV(0.0D, (double)var17, 0.0D, (double)var6, (double)var16);
@@ -198,7 +198,7 @@
 				RenderPlayer var12 = (RenderPlayer)var11;
 				float var13 = 1.0F;
 				GL11.glScalef(var13, var13, var13);
-				var12.drawFirstPersonHand();
+				var12.drawFirstPersonHand(mc.thePlayer);
 				GL11.glPopMatrix();
 			}
 
@@ -278,7 +278,7 @@
 			RenderPlayer var16 = (RenderPlayer)var15;
 			var10 = 1.0F;
 			GL11.glScalef(var10, var10, var10);
-			var16.drawFirstPersonHand();
+			var16.drawFirstPersonHand(mc.thePlayer);
 			GL11.glPopMatrix();
 		}
 
@@ -295,7 +295,7 @@
 			this.renderFireInFirstPerson(var1);
 		}
 
-		if(this.mc.thePlayer.isEntityInsideOpaqueBlock()) {
+		if(this.mc.thePlayer.isEntityInsideOpaqueBlock() && !this.mc.thePlayer.noClip) {
 			var2 = MathHelper.floor(this.mc.thePlayer.posX);
 			int var3 = MathHelper.floor(this.mc.thePlayer.posY);
 			int var4 = MathHelper.floor(this.mc.thePlayer.posZ);
@@ -344,10 +344,10 @@
 		float var8 = 1.0F;
 		float var9 = -0.5F;
 		float var10 = 0.0078125F;
-		float var11 = (float)(var2 % 16) / 256.0F - var10;
-		float var12 = ((float)(var2 % 16) + 15.99F) / 256.0F + var10;
-		float var13 = (float)(var2 / 16) / 256.0F - var10;
-		float var14 = ((float)(var2 / 16) + 15.99F) / 256.0F + var10;
+		float var11 = (float)(var2 % 32) / 512.0F - var10;
+		float var12 = ((float)(var2 % 32) + 15.99F) / 512.0F + var10;
+		float var13 = (float)(var2 / 32) / 512.0F - var10;
+		float var14 = ((float)(var2 / 32) + 15.99F) / 512.0F + var10;
 		var3.startDrawingQuads();
 		var3.addVertexWithUV((double)var5, (double)var7, (double)var9, (double)var12, (double)var14);
 		var3.addVertexWithUV((double)var6, (double)var7, (double)var9, (double)var11, (double)var14);
@@ -393,13 +393,13 @@
 
 		for(int var4 = 0; var4 < 2; ++var4) {
 			GL11.glPushMatrix();
-			int var5 = Block.fire.textureIndex + var4 * 16;
-			int var6 = (var5 & 15) << 4;
-			int var7 = var5 & 240;
-			float var8 = (float)var6 / 256.0F;
-			float var9 = ((float)var6 + 15.99F) / 256.0F;
-			float var10 = (float)var7 / 256.0F;
-			float var11 = ((float)var7 + 15.99F) / 256.0F;
+			int var5 = Block.fire.textureIndex + var4 * 32;
+			int var6 = (var5 & 31) << 4;
+			int var7 = (var5 & 992) >> 1;
+			float var8 = (float)var6 / 512.0F;
+			float var9 = ((float)var6 + 15.99F) / 512.0F;
+			float var10 = (float)var7 / 512.0F;
+			float var11 = ((float)var7 + 15.99F) / 512.0F;
 			float var12 = (0.0F - var3) / 2.0F;
 			float var13 = var12 + var3;
 			float var14 = 0.0F - var3 / 2.0F;
--- net/minecraft/client/gui/Gui.java
+++ net/minecraft/client/gui/Gui.java
@@ -50,10 +50,10 @@
 		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GL11.glColor4f(var7, var8, var9, var11);
 		var10.startDrawingQuads();
-		var10.addVertex((double)var1, (double)var4, 0.0D);
-		var10.addVertex((double)var3, (double)var4, 0.0D);
-		var10.addVertex((double)var3, (double)var2, 0.0D);
-		var10.addVertex((double)var1, (double)var2, 0.0D);
+		var10.addVertex((double)var1, (double)var4, this.zLevel);
+		var10.addVertex((double)var3, (double)var4, this.zLevel);
+		var10.addVertex((double)var3, (double)var2, this.zLevel);
+		var10.addVertex((double)var1, (double)var2, this.zLevel);
 		var10.draw();
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
 		GL11.glDisable(GL11.GL_BLEND);
@@ -76,11 +76,11 @@
 		Tessellator var15 = Tessellator.instance;
 		var15.startDrawingQuads();
 		var15.setColorRGBA_F(var8, var9, var10, var7);
-		var15.addVertex((double)var3, (double)var2, 0.0D);
-		var15.addVertex((double)var1, (double)var2, 0.0D);
+		var15.addVertex((double)var3, (double)var2, this.zLevel);
+		var15.addVertex((double)var1, (double)var2, this.zLevel);
 		var15.setColorRGBA_F(var12, var13, var14, var11);
-		var15.addVertex((double)var1, (double)var4, 0.0D);
-		var15.addVertex((double)var3, (double)var4, 0.0D);
+		var15.addVertex((double)var1, (double)var4, this.zLevel);
+		var15.addVertex((double)var3, (double)var4, this.zLevel);
 		var15.draw();
 		GL11.glShadeModel(GL11.GL_FLAT);
 		GL11.glDisable(GL11.GL_BLEND);
@@ -96,9 +96,25 @@
 		var1.drawStringWithShadow(var2, var3, var4, var5);
 	}
 
+	public void drawStringRight(FontRenderer var1, String var2, int var3, int var4, int var5) {
+		var1.drawStringWithShadow(var2, var3 - var1.getStringWidth(var2), var4, var5);
+	}
+
 	public void drawTexturedRect(int var1, int var2, int var3, int var4, int var5, int var6) {
 		float var7 = 0.00390625F;
 		float var8 = 0.00390625F;
+		Tessellator var9 = Tessellator.instance;
+		var9.startDrawingQuads();
+		var9.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), (double)this.zLevel, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + var6) * var8));
+		var9.addVertexWithUV((double)(var1 + var5), (double)(var2 + var6), (double)this.zLevel, (double)((float)(var3 + var5) * var7), (double)((float)(var4 + var6) * var8));
+		var9.addVertexWithUV((double)(var1 + var5), (double)(var2 + 0), (double)this.zLevel, (double)((float)(var3 + var5) * var7), (double)((float)(var4 + 0) * var8));
+		var9.addVertexWithUV((double)(var1 + 0), (double)(var2 + 0), (double)this.zLevel, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + 0) * var8));
+		var9.draw();
+	}
+
+	public void drawTexturedRect(int var1, int var2, int var3, int var4, int var5, int var6, int width, int height) {
+		float var7 = 1F / width;
+		float var8 = 1F / height;
 		Tessellator var9 = Tessellator.instance;
 		var9.startDrawingQuads();
 		var9.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), (double)this.zLevel, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + var6) * var8));
--- net/minecraft/server/player/PlayerInstance.java
+++ net/minecraft/server/player/PlayerInstance.java
@@ -2,6 +2,9 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.chunk.ChunkCoordIntPair;
@@ -16,25 +19,20 @@
 	private List players;
 	private int chunkX;
 	private int chunkZ;
-	private ChunkCoordIntPair currentChunk;
-	private short[] blocksToUpdate;
+	private long currentChunk;
+	private int[] blocksToUpdate;
 	private int numBlocksToUpdate;
-	private int minX;
-	private int maxX;
-	private int minY;
-	private int maxY;
-	private int minZ;
-	private int maxZ;
+	private IntSet modifiedLevels = new IntOpenHashSet();
 	final PlayerManager playerManager;
 
 	public PlayerInstance(PlayerManager var1, int var2, int var3) {
 		this.playerManager = var1;
 		this.players = new ArrayList();
-		this.blocksToUpdate = new short[10];
+		this.blocksToUpdate = new int[64];
 		this.numBlocksToUpdate = 0;
 		this.chunkX = var2;
 		this.chunkZ = var3;
-		this.currentChunk = new ChunkCoordIntPair(var2, var3);
+		this.currentChunk = ChunkCoordIntPair.chunkXZ2Int(var2, var3);
 		var1.getMinecraftServer().chunkProviderServer.prepareChunk(var2, var3);
 	}
 
@@ -43,7 +41,7 @@
 			throw new IllegalStateException("Failed to add player. " + var1 + " already is in chunk " + this.chunkX + ", " + this.chunkZ);
 		} else {
 			var1.field_420_ah.add(this.currentChunk);
-			var1.playerNetServerHandler.sendPacket(new Packet50PreChunk(this.currentChunk.chunkXPos, this.currentChunk.chunkZPos, true));
+			var1.playerNetServerHandler.sendPacket(new Packet50PreChunk(ChunkCoordIntPair.getChunkX(this.currentChunk), ChunkCoordIntPair.getChunkZ(this.currentChunk), true));
 			this.players.add(var1);
 			var1.loadedChunks.add(this.currentChunk);
 		}
@@ -53,7 +51,7 @@
 		if(this.players.contains(var1)) {
 			this.players.remove(var1);
 			if(this.players.size() == 0) {
-				long var2 = (long)this.chunkX + 2147483647L | (long)this.chunkZ + 2147483647L << 32;
+				long var2 = ChunkCoordIntPair.chunkXZ2Int(this.chunkX, this.chunkZ);
 				PlayerManager.getPlayerInstances(this.playerManager).remove(var2);
 				if(this.numBlocksToUpdate > 0) {
 					PlayerManager.getPlayerInstancesToUpdate(this.playerManager).remove(this);
@@ -73,37 +71,11 @@
 	public void markBlockNeedsUpdate(int var1, int var2, int var3) {
 		if(this.numBlocksToUpdate == 0) {
 			PlayerManager.getPlayerInstancesToUpdate(this.playerManager).add(this);
-			this.minX = this.maxX = var1;
-			this.minY = this.maxY = var2;
-			this.minZ = this.maxZ = var3;
-		}
-
-		if(this.minX > var1) {
-			this.minX = var1;
-		}
-
-		if(this.maxX < var1) {
-			this.maxX = var1;
-		}
-
-		if(this.minY > var2) {
-			this.minY = var2;
-		}
-
-		if(this.maxY < var2) {
-			this.maxY = var2;
-		}
-
-		if(this.minZ > var3) {
-			this.minZ = var3;
-		}
-
-		if(this.maxZ < var3) {
-			this.maxZ = var3;
-		}
-
-		if(this.numBlocksToUpdate < 10) {
-			short var4 = (short)(var1 << 12 | var3 << 8 | var2);
+		}
+
+		modifiedLevels.add(var2 >> 4);
+		if(this.numBlocksToUpdate < 64) {
+			int var4 = (int)((var2 + (1 << 23)) << 8 | var1 << 4 | var3);
 
 			for(int var5 = 0; var5 < this.numBlocksToUpdate; ++var5) {
 				if(this.blocksToUpdate[var5] == var4) {
@@ -133,39 +105,35 @@
 			int var3;
 			int var4;
 			if(this.numBlocksToUpdate == 1) {
-				var2 = this.chunkX * 16 + this.minX;
-				var3 = this.minY;
-				var4 = this.chunkZ * 16 + this.minZ;
+				var2 = this.chunkX * 16 + (this.blocksToUpdate[0] >>> 4 & 15);
+				var3 = (this.blocksToUpdate[0] >>> 8) - (1 << 23);
+				var4 = this.chunkZ * 16 + (this.blocksToUpdate[0] & 15);
 				this.sendPacketToPlayersInInstance(new Packet53BlockChange(var2, var3, var4, var1));
 				if(Block.isBlockContainer[var1.getBlockId(var2, var3, var4)]) {
 					this.updateTileEntity(var1.getBlockTileEntity(var2, var3, var4));
 				}
 			} else {
 				int var5;
-				if(this.numBlocksToUpdate == 10) {
-					this.minY = this.minY / 2 * 2;
-					this.maxY = (this.maxY / 2 + 1) * 2;
-					var2 = this.minX + this.chunkX * 16;
-					var3 = this.minY;
-					var4 = this.minZ + this.chunkZ * 16;
-					var5 = this.maxX - this.minX + 1;
-					int var6 = this.maxY - this.minY + 2;
-					int var7 = this.maxZ - this.minZ + 1;
-					this.sendPacketToPlayersInInstance(new Packet51MapChunk(var2, var3, var4, var5, var6, var7, var1));
-					List var8 = var1.getTileEntityList(var2, var3, var4, var2 + var5, var3 + var6, var4 + var7);
+				if(this.numBlocksToUpdate == 64) {
+					var2 = this.chunkX * 16;
+					var3 = this.chunkZ * 16;
+					this.sendPacketToPlayersInInstance(new Packet51MapChunk(this.chunkX, this.chunkZ, false, var1));
 
-					for(int var9 = 0; var9 < var8.size(); ++var9) {
-						this.updateTileEntity((TileEntity)var8.get(var9));
+					for (int modifiedLevel : this.modifiedLevels) {
+						int y = modifiedLevel << 4;
+						List tileEntities = var1.getTileEntityList(var2, y, var3, var2 + 16, y + 16, var3);
+						for (TileEntity tileEntity : (List<TileEntity>)tileEntities) {
+							this.updateTileEntity(tileEntity);
+						}
 					}
 				} else {
 					this.sendPacketToPlayersInInstance(new Packet52MultiBlockChange(this.chunkX, this.chunkZ, this.blocksToUpdate, this.numBlocksToUpdate, var1));
 
 					for(var2 = 0; var2 < this.numBlocksToUpdate; ++var2) {
-						var3 = this.chunkX * 16 + (this.numBlocksToUpdate >> 12 & 15);
-						var4 = this.numBlocksToUpdate & 255;
-						var5 = this.chunkZ * 16 + (this.numBlocksToUpdate >> 8 & 15);
+						var3 = this.chunkX * 16 + (this.blocksToUpdate[0] >>> 4 & 15);
+						var4 = (this.blocksToUpdate[0] >>> 8) - (1 << 23);
+						var5 = this.chunkZ * 16 + (this.blocksToUpdate[0] & 15);
 						if(Block.isBlockContainer[var1.getBlockId(var3, var4, var5)]) {
-							System.out.println("Sending!");
 							this.updateTileEntity(var1.getBlockTileEntity(var3, var4, var5));
 						}
 					}
@@ -173,6 +141,7 @@
 			}
 
 			this.numBlocksToUpdate = 0;
+			this.modifiedLevels.clear();
 		}
 	}
 
--- net/minecraft/game/world/block/SandstoneBlock.java
+++ net/minecraft/game/world/block/SandstoneBlock.java
@@ -3,11 +3,15 @@
 import net.minecraft.game.world.material.Material;
 
 public class SandstoneBlock extends Block {
+	private static final int TEX_TOP = TerrainLayout.texCoord("sandstone_top");
+	private static final int TEX_SIDE = TerrainLayout.texCoord("sandstone_side");
+	private static final int TEX_BOTTOM = TerrainLayout.texCoord("sandstone_bottom");
+
 	public SandstoneBlock(int var1) {
-		super(var1, 192, Material.stone);
+		super(var1, TEX_SIDE, Material.stone);
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex - 16 : (var1 == 0 ? this.textureIndex + 16 : this.textureIndex);
+		return var1 == 1 ? TEX_TOP : (var1 == 0 ? TEX_BOTTOM : TEX_SIDE);
 	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerBlur.java
@@ -1,0 +1,19 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.IntArray2D;
+
+public class LayerBlur extends Layer {
+	public LayerBlur(Layer parent) {
+		super(0L, parent);
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		return this.forEachWithNeighbors(x, z, width, length, true, true, ((i, ox, oy, neighbors) -> {
+			int sum = i;
+			for (int j = 0; j < 8; j++) {
+				sum += neighbors[j];
+			}
+			return Math.round(sum / 9.0F);
+		}));
+	}
+}
--- net/minecraft/game/world/chunk/ChunkProviderImpl.java
+++ net/minecraft/game/world/chunk/ChunkProviderImpl.java
@@ -2,40 +2,68 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.world.BlockPos;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.chunk.loader.ChunkLoader;
 import net.minecraft.util.ProgressUpdate;
 
 public class ChunkProviderImpl implements ChunkProvider {
-	private Set droppedChunksSet = new HashSet();
+	private LongSet droppedChunksSet = new LongOpenHashSet();
 	private Chunk emptyChunk;
 	private ChunkProvider chunkProvider;
 	private ChunkLoader chunkLoader;
-	private Map chunkMap = new HashMap();
+	private Map chunkMap;
 	private List chunkList = new ArrayList();
 	private World worldObj;
+	private Long2ObjectMap<Chunk> smoothbeta$serverChunkCache;
+	private int chunkListIndex;
 
 	public ChunkProviderImpl(World var1, ChunkLoader var2, ChunkProvider var3) {
 		this.emptyChunk = new EmptyChunk(var1, new byte[-Short.MIN_VALUE], 0, 0);
 		this.worldObj = var1;
 		this.chunkLoader = var2;
 		this.chunkProvider = var3;
+		smoothbeta$serverChunkCache = new Long2ObjectOpenHashMap<>();
+        chunkMap = smoothbeta$serverChunkCache;
 	}
 
 	public boolean chunkExists(int var1, int var2) {
-		return this.chunkMap.containsKey(Integer.valueOf(ChunkCoordIntPair.chunkXZ2Int(var1, var2)));
+		return smoothbeta$serverChunkCache.containsKey(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
+	}
+
+	public boolean chunkSaved(int var1, int var2) {
+		return this.chunkLoader.chunkExists(var1, var2) || this.chunkExists(var1, var2);
+	}
+
+	public void addChunkToDroppedChunksSet(int i1, int i2) {
+		BlockPos chunkCoordinates3 = this.worldObj.getSpawnPoint();
+		int i4 = i1 * 16 + 8 - chunkCoordinates3.x;
+		int i5 = i2 * 16 + 8 - chunkCoordinates3.z;
+		short s6 = 128;
+
+		if(i4 < -s6 || i4 > s6 || i5 < -s6 || i5 > s6) {
+			this.droppedChunksSet.add(ChunkCoordIntPair.chunkXZ2Int(i1, i2));
+		}
 	}
 
 	public Chunk prepareChunk(int var1, int var2) {
-		int var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
-		this.droppedChunksSet.remove(Integer.valueOf(var3));
-		Chunk var4 = (Chunk)this.chunkMap.get(Integer.valueOf(var3));
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		this.droppedChunksSet.remove(var3);
+		Chunk var4 = smoothbeta$serverChunkCache.get(var3);
 		if(var4 == null) {
+			int i6 = 2000004;
+			if(var1 < -i6 || var2 < -i6 || var1 >= i6 || var2 >= i6) {
+				return this.emptyChunk;
+			}
+
 			var4 = this.loadChunkFromFile(var1, var2);
 			if(var4 == null) {
 				if(this.chunkProvider == null) {
@@ -45,11 +73,12 @@
 				}
 			}
 
-			this.chunkMap.put(Integer.valueOf(var3), var4);
+			smoothbeta$serverChunkCache.put(var3, var4);
 			this.chunkList.add(var4);
 			if(var4 != null) {
 				var4.doNothing2();
 				var4.onChunkLoad();
+				var4.initLightingForRealNotJustHeightmap();
 			}
 
 			if(!var4.isTerrainPopulated && this.chunkExists(var1 + 1, var2 + 1) && this.chunkExists(var1, var2 + 1) && this.chunkExists(var1 + 1, var2)) {
@@ -73,7 +102,7 @@
 	}
 
 	public Chunk provideChunk(int var1, int var2) {
-		Chunk var3 = (Chunk)this.chunkMap.get(Integer.valueOf(ChunkCoordIntPair.chunkXZ2Int(var1, var2)));
+		Chunk var3 = (Chunk)smoothbeta$serverChunkCache.get(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
 		return var3 == null ? this.prepareChunk(var1, var2) : var3;
 	}
 
@@ -163,7 +192,7 @@
 	public boolean unload100OldestChunks() {
 		for(int var1 = 0; var1 < 100; ++var1) {
 			if(!this.droppedChunksSet.isEmpty()) {
-				Integer var2 = (Integer)this.droppedChunksSet.iterator().next();
+				long var2 = this.droppedChunksSet.iterator().nextLong();
 				Chunk var3 = (Chunk)this.chunkMap.get(var2);
 				var3.onChunkUnload();
 				this.saveChunk(var3);
@@ -171,6 +200,22 @@
 				this.droppedChunksSet.remove(var2);
 				this.chunkMap.remove(var2);
 				this.chunkList.remove(var3);
+			}
+		}
+
+		for(int i1 = 0; i1 < 10; ++i1) {
+			if(this.chunkListIndex >= this.chunkList.size()) {
+				this.chunkListIndex = 0;
+				break;
+			}
+
+			Chunk chunk4 = (Chunk)this.chunkList.get(this.chunkListIndex++);
+			PlayerEntity player = this.worldObj.getClosestPlayer((double)(chunk4.xPosition << 4) + 8.0D,
+															64.0D,
+															(double)(chunk4.zPosition << 4) + 8.0D, 288.0D);
+
+			if(player == null) {
+				this.addChunkToDroppedChunksSet(chunk4.xPosition, chunk4.zPosition);
 			}
 		}
 
--- argo/J_JsonStringNodeBuilder.java
+++ /dev/null
@@ -1,17 +1,0 @@
-package argo;
-
-public final class J_JsonStringNodeBuilder implements J_JsonNodeBuilder {
-	private final String field_27244_a;
-
-	J_JsonStringNodeBuilder(String var1) {
-		this.field_27244_a = var1;
-	}
-
-	public J_JsonStringNode func_27243_a() {
-		return J_JsonNodeFactories.func_27316_a(this.field_27244_a);
-	}
-
-	public J_JsonNode func_27234_b() {
-		return this.func_27243_a();
-	}
-}
--- /dev/null
+++ argo/jdom/JsonNodeSelector.java
@@ -1,0 +1,29 @@
+package argo.jdom;
+
+public final class JsonNodeSelector {
+	final Functor valueGetter;
+
+	JsonNodeSelector(Functor var1) {
+		this.valueGetter = var1;
+	}
+
+	public boolean matches(Object var1) {
+		return this.valueGetter.matchesNode(var1);
+	}
+
+	public Object getValue(Object var1) {
+		return this.valueGetter.applyTo(var1);
+	}
+
+	public JsonNodeSelector with(JsonNodeSelector var1) {
+		return new JsonNodeSelector(new ChainedFunctor(this, var1));
+	}
+
+	String shortForm() {
+		return this.valueGetter.shortForm();
+	}
+
+	public String toString() {
+		return this.valueGetter.toString();
+	}
+}
--- net/minecraft/client/GameSettings.java
+++ net/minecraft/client/GameSettings.java
@@ -5,6 +5,7 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
+
 import net.minecraft.game.stats.StatCollector;
 import net.minecraft.util.StringTranslate;
 import org.lwjgl.input.Keyboard;
@@ -14,17 +15,25 @@
 	private static final String[] DIFFICULTIES = new String[]{"options.difficulty.peaceful", "options.difficulty.easy", "options.difficulty.normal", "options.difficulty.hard"};
 	private static final String[] GUISCALES = new String[]{"options.guiScale.auto", "options.guiScale.small", "options.guiScale.normal", "options.guiScale.large"};
 	private static final String[] LIMIT_FRAMERATES = new String[]{"performance.max", "performance.balanced", "performance.powersaver"};
+	private static final String[] FOG_SHAPES = new String[]{"options.fogShape.disabled", "options.fogShape.circle", "options.fogShape.squircle", "options.fogShape.square"};
 	public float musicVolume = 1.0F;
 	public float soundVolume = 1.0F;
 	public float mouseSensitivity = 0.5F;
 	public boolean invertMouse = false;
-	public int renderDistance = 0;
+	public int renderDistance = 12;
+	public int simulationDistance = 8;
+	public int fogShape = 2;
+	public float fogDensity = 0.6F;
+	public float fogDistance = 1.2F;
 	public boolean viewBobbing = true;
+	public float fov = 4.0F / 9.0F;
 	public boolean anaglyph = false;
 	public boolean advancedOpengl = false;
 	public int limitFramerate = 1;
-	public boolean fancyGraphics = true;
+	public int maxFps = 250;
+	public int graphicsLevel = 2;
 	public boolean ambientOcclusion = true;
+	public boolean creativeDebug = false;
 	public String skin = "Default";
 	public KeyBinding keyBindForward = new KeyBinding("key.forward", 17);
 	public KeyBinding keyBindLeft = new KeyBinding("key.left", 30);
@@ -32,11 +41,13 @@
 	public KeyBinding keyBindRight = new KeyBinding("key.right", 32);
 	public KeyBinding keyBindJump = new KeyBinding("key.jump", 57);
 	public KeyBinding keyBindInventory = new KeyBinding("key.inventory", 18);
+	public KeyBinding keyBindCreative = new KeyBinding("key.creative", 48);
 	public KeyBinding keyBindDrop = new KeyBinding("key.drop", 16);
 	public KeyBinding keyBindChat = new KeyBinding("key.chat", 20);
 	public KeyBinding keyBindToggleFog = new KeyBinding("key.fog", 33);
 	public KeyBinding keyBindSneak = new KeyBinding("key.sneak", 42);
-	public KeyBinding[] keyBindings = new KeyBinding[]{this.keyBindForward, this.keyBindLeft, this.keyBindBack, this.keyBindRight, this.keyBindJump, this.keyBindSneak, this.keyBindDrop, this.keyBindInventory, this.keyBindChat, this.keyBindToggleFog};
+	public KeyBinding keyBindRun = new KeyBinding("key.run", 29);
+	public KeyBinding[] keyBindings = new KeyBinding[]{this.keyBindForward, this.keyBindLeft, this.keyBindBack, this.keyBindRight, this.keyBindJump, this.keyBindSneak, this.keyBindRun, this.keyBindDrop, this.keyBindInventory, this.keyBindChat, this.keyBindToggleFog};
 	protected Minecraft mc;
 	private File optionsFile;
 	public int difficulty = 2;
@@ -53,7 +64,7 @@
 
 	public GameSettings(Minecraft var1, File var2) {
 		this.mc = var1;
-		this.optionsFile = new File(var2, "options.txt");
+		this.optionsFile = new File(var2, "options_diverge.txt");
 		this.loadOptions();
 	}
 
@@ -89,6 +100,29 @@
 			this.mouseSensitivity = var2;
 		}
 
+		if(var1 == Option.MAX_FPS) {
+			this.maxFps = ((int)(var2 * 50.0F) * 5);
+		}
+
+		if(var1 == Option.RENDER_DISTANCE) {
+			this.renderDistance = (int)(var2 * 14.0F + 2);
+		}
+
+		if(var1 == Option.SIMULATION_DISTANCE) {
+			this.simulationDistance = (int)(var2 * 12.0F + 4);
+		}
+
+		if(var1 == Option.FOG_DENSITY) {
+			this.fogDensity = var2;
+		}
+
+		if(var1 == Option.FOG_DISTANCE) {
+			this.fogDistance = (int)(var2 * 40.0F) / 20.0F;
+		}
+
+		if(var1 == Option.FOV) {
+			this.fov = Math.round(var2 * 90.0F) / 90.0F;
+		}
 	}
 
 	public void setOptionValue(Option var1, int var2) {
@@ -97,11 +131,15 @@
 		}
 
 		if(var1 == Option.RENDER_DISTANCE) {
-			this.renderDistance = this.renderDistance + var2 & 3;
+			this.renderDistance = (this.renderDistance - var2) & 15;
+			if (this.renderDistance < 2) {
+				this.renderDistance = var2 < 0 ? 2 : 16;
+			}
 		}
 
 		if(var1 == Option.GUI_SCALE) {
 			this.guiScale = this.guiScale + var2 & 3;
+			this.mc.onGuiScaleChanged();
 		}
 
 		if(var1 == Option.VIEW_BOBBING) {
@@ -127,7 +165,7 @@
 		}
 
 		if(var1 == Option.GRAPHICS) {
-			this.fancyGraphics = !this.fancyGraphics;
+			this.graphicsLevel = (this.graphicsLevel + var2 & 3) % 3;
 			this.mc.worldRenderer.loadRenderers();
 		}
 
@@ -136,11 +174,24 @@
 			this.mc.worldRenderer.loadRenderers();
 		}
 
+		if(var1 == Option.FOG_SHAPE) {
+			this.fogShape = this.fogShape + var2 & 3;
+		}
+
 		this.saveOptions();
 	}
 
 	public float getOptionFloatValue(Option var1) {
-		return var1 == Option.MUSIC ? this.musicVolume : (var1 == Option.SOUND ? this.soundVolume : (var1 == Option.SENSITIVITY ? this.mouseSensitivity : 0.0F));
+		return var1 == Option.MUSIC ? this.musicVolume
+				: var1 == Option.SOUND ? this.soundVolume
+				: var1 == Option.SENSITIVITY ? this.mouseSensitivity
+				: var1 == Option.MAX_FPS ? this.maxFps / 250.0F
+				: var1 == Option.RENDER_DISTANCE ? (this.renderDistance - 2.0F) / 14.0F
+				: var1 == Option.SIMULATION_DISTANCE ? (this.simulationDistance - 4.0F) / 12.0F
+				: var1 == Option.FOG_DENSITY ? this.fogDensity
+				: var1 == Option.FOG_DISTANCE ? this.fogDistance / 2.0F
+				: var1 == Option.FOV ? this.fov
+				: 0.0F;
 	}
 
 	public boolean getOptionOrdinalValue(Option var1) {
@@ -165,12 +216,35 @@
 		String var3 = var2.translateKey(var1.getName()) + ": ";
 		if(var1.isSlider()) {
 			float var5 = this.getOptionFloatValue(var1);
-			return var1 == Option.SENSITIVITY ? (var5 == 0.0F ? var3 + var2.translateKey("options.sensitivity.min") : (var5 == 1.0F ? var3 + var2.translateKey("options.sensitivity.max") : var3 + (int)(var5 * 200.0F) + "%")) : (var5 == 0.0F ? var3 + var2.translateKey("options.off") : var3 + (int)(var5 * 100.0F) + "%");
+			int fov = (int) (30.0F + this.fov * 90.0F);
+			return var1 == Option.SENSITIVITY ? (var5 == 0.0F ? var3 + var2.translateKey("options.sensitivity.min") : (var5 == 1.0F ? var3 + var2.translateKey("options.sensitivity.max") : var3 + (int)(var5 * 200.0F) + "%"))
+					: var1 == Option.MAX_FPS ?
+							this.maxFps == 0 ? var3 + var2.translateKey("options.maxFps.vsync")
+							: this.maxFps == 250 ? var3 + var2.translateKey("options.maxFps.unlimited")
+							: var3 + this.maxFps
+					: var1 == Option.RENDER_DISTANCE ? var3 + this.renderDistance
+					: var1 == Option.SIMULATION_DISTANCE ? var3 + this.simulationDistance
+					: var1 == Option.FOG_DISTANCE ? var3 + (int)(this.fogDistance * 100.0F + 0.01F) + "%"
+					: var1 == Option.FOV ?
+						"FOV: " + (
+							fov == 30 ? "Eye Sore"
+									: fov == 70 ? "Normal"
+									: fov == 120 ? "Quake Pro"
+									: fov)
+					: var5 == 0.0F ? var3 + var2.translateKey("options.off") : var3 + (int)(var5 * 100.0F) + "%";
 		} else if(var1.isToggle()) {
 			boolean var4 = this.getOptionOrdinalValue(var1);
 			return var4 ? var3 + var2.translateKey("options.on") : var3 + var2.translateKey("options.off");
 		} else {
-			return var1 == Option.RENDER_DISTANCE ? var3 + var2.translateKey(RENDER_DISTANCES[this.renderDistance]) : (var1 == Option.DIFFICULTY ? var3 + var2.translateKey(DIFFICULTIES[this.difficulty]) : (var1 == Option.GUI_SCALE ? var3 + var2.translateKey(GUISCALES[this.guiScale]) : (var1 == Option.FRAMERATE_LIMIT ? var3 + StatCollector.translateToLocal(LIMIT_FRAMERATES[this.limitFramerate]) : (var1 == Option.GRAPHICS ? (this.fancyGraphics ? var3 + var2.translateKey("options.graphics.fancy") : var3 + var2.translateKey("options.graphics.fast")) : var3))));
+			return var1 == Option.DIFFICULTY ? var3 + var2.translateKey(DIFFICULTIES[this.difficulty])
+					: var1 == Option.GUI_SCALE ? var3 + var2.translateKey(GUISCALES[this.guiScale])
+					: var1 == Option.FRAMERATE_LIMIT ? var3 + StatCollector.translateToLocal(LIMIT_FRAMERATES[this.limitFramerate])
+					: var1 == Option.GRAPHICS ?
+							this.graphicsLevel >= 2 ? var3 + var2.translateKey("options.graphics.fabulous")
+							: this.graphicsLevel == 1 ? var3 + var2.translateKey("options.graphics.fancy")
+							: var3 + var2.translateKey("options.graphics.fast")
+					: var1 == Option.FOG_SHAPE ? var3 + var2.translateKey(FOG_SHAPES[this.fogShape])
+					: var3;
 		}
 	}
 
@@ -208,10 +282,26 @@
 						this.invertMouse = var3[1].equals("true");
 					}
 
-					if(var3[0].equals("viewDistance")) {
+					if(var3[0].equals("renderDistance")) {
 						this.renderDistance = Integer.parseInt(var3[1]);
 					}
 
+					if(var3[0].equals("simulationDistance")) {
+						this.simulationDistance = Integer.parseInt(var3[1]);
+					}
+
+					if(var3[0].equals("fogShape")) {
+						this.fogShape = Integer.parseInt(var3[1]);
+					}
+
+					if(var3[0].equals("fogDensity")) {
+						this.fogDensity = this.parseFloat(var3[1]);
+					}
+
+					if(var3[0].equals("fogDistance")) {
+						this.fogDistance = this.parseFloat(var3[1]);
+					}
+
 					if(var3[0].equals("guiScale")) {
 						this.guiScale = Integer.parseInt(var3[1]);
 					}
@@ -220,6 +310,10 @@
 						this.viewBobbing = var3[1].equals("true");
 					}
 
+					if(var3[0].equals("fov")) {
+						this.fov = this.parseFloat(var3[1]);
+					}
+
 					if(var3[0].equals("anaglyph3d")) {
 						this.anaglyph = var3[1].equals("true");
 					}
@@ -232,12 +326,16 @@
 						this.limitFramerate = Integer.parseInt(var3[1]);
 					}
 
+					if(var3[0].equals("maxFps")) {
+						this.maxFps = Integer.parseInt(var3[1]);
+					}
+
 					if(var3[0].equals("difficulty")) {
 						this.difficulty = Integer.parseInt(var3[1]);
 					}
 
-					if(var3[0].equals("fancyGraphics")) {
-						this.fancyGraphics = var3[1].equals("true");
+					if(var3[0].equals("graphicsLevel")) {
+						this.graphicsLevel = Integer.parseInt(var3[1]);
 					}
 
 					if(var3[0].equals("ao")) {
@@ -279,14 +377,20 @@
 			var1.println("sound:" + this.soundVolume);
 			var1.println("invertYMouse:" + this.invertMouse);
 			var1.println("mouseSensitivity:" + this.mouseSensitivity);
-			var1.println("viewDistance:" + this.renderDistance);
+			var1.println("renderDistance:" + this.renderDistance);
+			var1.println("simulationDistance:" + this.simulationDistance);
+			var1.println("fogShape:" + this.fogShape);
+			var1.println("fogDensity:" + this.fogDensity);
+			var1.println("fogDistance:" + this.fogDistance);
 			var1.println("guiScale:" + this.guiScale);
+			var1.println("fov:" + this.fov);
 			var1.println("bobView:" + this.viewBobbing);
 			var1.println("anaglyph3d:" + this.anaglyph);
 			var1.println("advancedOpengl:" + this.advancedOpengl);
 			var1.println("fpsLimit:" + this.limitFramerate);
+			var1.println("maxFps:" + this.maxFps);
 			var1.println("difficulty:" + this.difficulty);
-			var1.println("fancyGraphics:" + this.fancyGraphics);
+			var1.println("graphicsLevel:" + this.graphicsLevel);
 			var1.println("ao:" + this.ambientOcclusion);
 			var1.println("skin:" + this.skin);
 			var1.println("lastServer:" + this.lastServer);
--- net/minecraft/client/player/ReplicatedNetPlayerEntity.java
+++ net/minecraft/client/player/ReplicatedNetPlayerEntity.java
@@ -20,8 +20,9 @@
 		this.username = var2;
 		this.yOffset = 0.0F;
 		this.stepHeight = 0.0F;
-		if(var2 != null && var2.length() > 0) {
-			this.skinUrl = "http://s3.amazonaws.com/MinecraftSkins/" + var2 + ".png";
+
+		if (var2 != null && !var2.isEmpty()) {
+			this.updateCloak();
 		}
 
 		this.noClip = true;
--- net/minecraft/game/entity/EntityRegistry.java
+++ net/minecraft/game/entity/EntityRegistry.java
@@ -1,133 +1,122 @@
 package net.minecraft.game.entity;
 
 import com.mojang.nbt.CompoundTag;
-import java.util.HashMap;
-import java.util.Map;
-import net.minecraft.game.entity.animal.ChickenEntity;
-import net.minecraft.game.entity.animal.CowEntity;
-import net.minecraft.game.entity.animal.PigEntity;
-import net.minecraft.game.entity.animal.SheepEntity;
-import net.minecraft.game.entity.animal.SquidEntity;
-import net.minecraft.game.entity.animal.WolfEntity;
-import net.minecraft.game.entity.misc.FallingBlockEntity;
-import net.minecraft.game.entity.misc.ItemEntity;
-import net.minecraft.game.entity.misc.PaintingEntity;
-import net.minecraft.game.entity.misc.PrimedTNTEntity;
-import net.minecraft.game.entity.monster.CreeperEntity;
-import net.minecraft.game.entity.monster.GhastEntity;
-import net.minecraft.game.entity.monster.GiantZombieEntity;
-import net.minecraft.game.entity.monster.MobEntity;
-import net.minecraft.game.entity.monster.PigZombieEntity;
-import net.minecraft.game.entity.monster.SkeletonEntity;
-import net.minecraft.game.entity.monster.SlimeEntity;
-import net.minecraft.game.entity.monster.SpiderEntity;
-import net.minecraft.game.entity.monster.ZombieEntity;
-import net.minecraft.game.entity.projectile.ArrowEntity;
-import net.minecraft.game.entity.projectile.SnowballEntity;
-import net.minecraft.game.entity.vehicle.BoatEntity;
-import net.minecraft.game.entity.vehicle.MinecartEntity;
+
+import java.util.*;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.mine_diver.smoothbeta.entity.SmoothEntityRegistry;
+import net.minecraft.game.entity.animal.*;
+import net.minecraft.game.entity.loot.*;
+import net.minecraft.game.entity.misc.*;
+import net.minecraft.game.entity.monster.*;
+import net.minecraft.game.entity.projectile.*;
+import net.minecraft.game.entity.vehicle.*;
+import net.minecraft.game.item.Item;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.Block;
 
 public class EntityRegistry {
-	private static Map stringToClassMapping = new HashMap();
-	private static Map classToStringMapping = new HashMap();
-	private static Map IDtoClassMapping = new HashMap();
-	private static Map classToIDMapping = new HashMap();
-
-	private static void addMapping(Class var0, String var1, int var2) {
-		stringToClassMapping.put(var1, var0);
-		classToStringMapping.put(var0, var1);
-		IDtoClassMapping.put(Integer.valueOf(var2), var0);
-		classToIDMapping.put(var0, Integer.valueOf(var2));
-	}
-
-	public static Entity createEntityInWorld(String var0, World var1) {
-		Entity var2 = null;
-
-		try {
-			Class var3 = (Class)stringToClassMapping.get(var0);
-			if(var3 != null) {
-				var2 = (Entity)var3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
-			}
-		} catch (Exception var4) {
-			var4.printStackTrace();
-		}
-
-		return var2;
-	}
-
-	public static Entity createEntityFromNBT(CompoundTag var0, World var1) {
-		Entity var2 = null;
-
-		try {
-			Class var3 = (Class)stringToClassMapping.get(var0.getString("id"));
-			if(var3 != null) {
-				var2 = (Entity)var3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
-			}
-		} catch (Exception var4) {
-			var4.printStackTrace();
-		}
-
-		if(var2 != null) {
-			var2.readFromNBT(var0);
-		} else {
-			System.out.println("Skipping Entity with id " + var0.getString("id"));
-		}
-
-		return var2;
-	}
-
-	public static Entity createEntity(int var0, World var1) {
-		Entity var2 = null;
-
-		try {
-			Class var3 = (Class)IDtoClassMapping.get(Integer.valueOf(var0));
-			if(var3 != null) {
-				var2 = (Entity)var3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
-			}
-		} catch (Exception var4) {
-			var4.printStackTrace();
-		}
-
-		if(var2 == null) {
-			System.out.println("Skipping Entity with id " + var0);
-		}
-
-		return var2;
-	}
-
-	public static int getEntityID(Entity var0) {
-		return ((Integer)classToIDMapping.get(var0.getClass())).intValue();
-	}
-
-	public static String getEntityString(Entity var0) {
-		return (String)classToStringMapping.get(var0.getClass());
-	}
-
-	static {
-		addMapping(ArrowEntity.class, "Arrow", 10);
-		addMapping(SnowballEntity.class, "Snowball", 11);
-		addMapping(ItemEntity.class, "Item", 1);
-		addMapping(PaintingEntity.class, "Painting", 9);
-		addMapping(LivingEntity.class, "Mob", 48);
-		addMapping(MobEntity.class, "Monster", 49);
-		addMapping(CreeperEntity.class, "Creeper", 50);
-		addMapping(SkeletonEntity.class, "Skeleton", 51);
-		addMapping(SpiderEntity.class, "Spider", 52);
-		addMapping(GiantZombieEntity.class, "Giant", 53);
-		addMapping(ZombieEntity.class, "Zombie", 54);
-		addMapping(SlimeEntity.class, "Slime", 55);
-		addMapping(GhastEntity.class, "Ghast", 56);
-		addMapping(PigZombieEntity.class, "PigZombie", 57);
-		addMapping(PigEntity.class, "Pig", 90);
-		addMapping(SheepEntity.class, "Sheep", 91);
-		addMapping(CowEntity.class, "Cow", 92);
-		addMapping(ChickenEntity.class, "Chicken", 93);
-		addMapping(SquidEntity.class, "Squid", 94);
-		addMapping(WolfEntity.class, "Wolf", 95);
-		addMapping(PrimedTNTEntity.class, "PrimedTnt", 20);
-		addMapping(FallingBlockEntity.class, "FallingSand", 21);
-		addMapping(MinecartEntity.class, "Minecart", 40);
-		addMapping(BoatEntity.class, "Boat", 41);
-	}
+    private static final Map<String, Class<? extends Entity>> stringToClassMapping = new HashMap();
+    private static final Map<Class<? extends Entity>, String> classToStringMapping = new HashMap();
+    private static final Int2ObjectMap<Class<? extends Entity>> IDtoClassMapping = new Int2ObjectOpenHashMap<>();
+    private static final Object2IntMap<Class<? extends Entity>> classToIDMapping = new Object2IntOpenHashMap<>();
+    private static final Map<Class<? extends Entity>, List<EntityLootEntry>> entityLootRegistry = new HashMap<>();
+
+    private static void addMapping(Class<? extends Entity> var0, String var1, int var2) {
+        stringToClassMapping.put(var1, var0);
+        classToStringMapping.put(var0, var1);
+        IDtoClassMapping.put(var2, var0);
+        classToIDMapping.put(var0, var2);
+        SmoothEntityRegistry.register(var0, var1, var2);
+    }
+
+    private static void addLoot(Class<? extends Entity> entity, EntityLootEntry... loot) {
+        entityLootRegistry.put(entity, Collections.unmodifiableList(Arrays.asList(loot)));
+    }
+
+    public static Entity createEntityInWorld(String var0, World var1) {
+        return SmoothEntityRegistry.create(var0, var1);
+    }
+
+    public static Entity createEntityFromNBT(CompoundTag var0, World var1) {
+        return SmoothEntityRegistry.create(var0, var1);
+    }
+
+    public static Entity createEntity(int var0, World var1) {
+        return SmoothEntityRegistry.create(var0, var1);
+    }
+
+    public static int getEntityID(Entity var0) {
+        return classToIDMapping.getInt(var0.getClass());
+    }
+
+    public static String getEntityString(Entity var0) {
+        return classToStringMapping.get(var0.getClass());
+    }
+
+	public static List<EntityLootEntry> getLoot(Entity var0) {
+		return entityLootRegistry.get(var0.getClass());
+	}
+
+    static {
+        addMapping(ArrowEntity.class, "Arrow", 10);
+        addMapping(SnowballEntity.class, "Snowball", 11);
+        addMapping(ItemEntity.class, "Item", 1);
+        addMapping(PaintingEntity.class, "Painting", 9);
+        addMapping(LivingEntity.class, "Mob", 48);
+        addMapping(MobEntity.class, "Monster", 49);
+        addMapping(CreeperEntity.class, "Creeper", 50);
+        addMapping(SkeletonEntity.class, "Skeleton", 51);
+        addMapping(SpiderEntity.class, "Spider", 52);
+        addMapping(GiantZombieEntity.class, "Giant", 53);
+        addMapping(ZombieEntity.class, "Zombie", 54);
+        addMapping(SlimeEntity.class, "Slime", 55);
+        addMapping(GhastEntity.class, "Ghast", 56);
+        addMapping(PigZombieEntity.class, "PigZombie", 57);
+        addMapping(PigEntity.class, "Pig", 90);
+        addMapping(SheepEntity.class, "Sheep", 91);
+        addMapping(CowEntity.class, "Cow", 92);
+        addMapping(ChickenEntity.class, "Chicken", 93);
+        addMapping(SquidEntity.class, "Squid", 94);
+        addMapping(WolfEntity.class, "Wolf", 95);
+        addMapping(PrimedTNTEntity.class, "PrimedTnt", 20);
+        addMapping(FallingBlockEntity.class, "FallingSand", 21);
+        addMapping(MinecartEntity.class, "Minecart", 40);
+        addMapping(BoatEntity.class, "Boat", 41);
+
+        addLoot(CreeperEntity.class,
+		        new EntityLootItem(Item.gunpowder.itemID, 0, 3));
+        addLoot(SkeletonEntity.class,
+		        new EntityLootItem(Item.arrow.itemID, 0, 3),
+		        new EntityLootItem(Item.bone.itemID, 0, 3));
+        addLoot(SpiderEntity.class,
+		        new EntityLootItem(Item.string.itemID, 0, 3));
+		addLoot(ZombieEntity.class,
+		        new EntityLootItem(Item.feather.itemID, 0, 3));
+		addLoot(SlimeEntity.class,
+		        new ConditionalEntityLoot(e -> e instanceof SlimeEntity && ((SlimeEntity)e).getSlimeSize() == 1,
+				        new EntityLootItem(Item.string.itemID, 0, 3), null));
+		addLoot(GhastEntity.class,
+		        new EntityLootItem(Item.gunpowder.itemID, 0, 3));
+		addLoot(PigZombieEntity.class,
+		        new EntityLootItem(Item.cookedPorkchop.itemID, 0, 3));
+		addLoot(PigEntity.class,
+		        new ConditionalEntityLoot(Entity::isBurning,
+				        new EntityLootItem(Item.cookedPorkchop.itemID, 0, 3),
+				        new EntityLootItem(Item.rawPorkchop.itemID, 0, 3)));
+		addLoot(SheepEntity.class,
+		        new ConditionalEntityLoot(e -> e instanceof SheepEntity && ((SheepEntity)e).getSheared(),
+				        null, new EntityLootItem(Block.wool.blockID,
+				        e -> e instanceof SheepEntity ? ((SheepEntity)e).getFleeceColor() : 0, 1, 1, 1.0F)));
+		addLoot(CowEntity.class,
+		        new EntityLootItem(Item.leather.itemID, 0, 3));
+		addLoot(ChickenEntity.class,
+		        new EntityLootItem(Item.feather.itemID, 0, 3));
+		addLoot(SquidEntity.class,
+		        new EntityLootItem(Item.dye.itemID, 0, 1, 11));
+    }
 }
--- /dev/null
+++ argo/jdom/JsonNodeDoesNotMatchJsonNodeSelectorException.java
@@ -1,0 +1,7 @@
+package argo.jdom;
+
+public class JsonNodeDoesNotMatchJsonNodeSelectorException extends IllegalArgumentException {
+	JsonNodeDoesNotMatchJsonNodeSelectorException(String var1) {
+		super(var1);
+	}
+}
--- /dev/null
+++ net/minecraft/util/HalfByteArray3D.java
@@ -1,0 +1,43 @@
+package net.minecraft.util;
+
+import net.minecraft.game.world.chunk.ChunkSection;
+
+public class HalfByteArray3D {
+	private final byte[] array;
+	public final int shift;
+	public final int width, height, length;
+
+	public HalfByteArray3D(boolean upper, int width, int height, int length) {
+		this(null, upper, width, height, length);
+	}
+
+	public HalfByteArray3D(byte[] array, boolean upper, int width, int height, int length) {
+		if (array == null) {
+			array = new byte[width * height * length];
+		} else if (array.length < width * height * length) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.shift = upper ? 4 : 0;
+		this.width = width;
+		this.height = height;
+		this.length = length;
+	}
+
+	public int get(int x, int y, int z) {
+		int i = ChunkSection.getIndex(x, y, z);
+		byte value = this.array[i];
+//		return this.upper ? (value & 0xF0) >> 4 : value & 0xF;
+		return ((value >>> this.shift) & 0xF);
+	}
+
+	public void set(int x, int y, int z, int value) {
+		int i = ChunkSection.getIndex(x, y, z);
+		this.array[i] = (byte)((this.array[i] & (0xF0 >>> this.shift)) | (value << this.shift));
+	}
+
+	public byte[] getArray() {
+		return array;
+	}
+}
--- /dev/null
+++ net/minecraft/game/entity/loot/EntityLootChoice.java
@@ -1,0 +1,22 @@
+package net.minecraft.game.entity.loot;
+
+import net.minecraft.game.entity.LivingEntity;
+import net.minecraft.game.item.ItemStack;
+
+import java.util.Random;
+
+public class EntityLootChoice implements EntityLootEntry {
+	public final EntityLootEntry[] lootEntries;
+	public final float chance;
+
+	public EntityLootChoice(float chance, EntityLootEntry... lootEntries) {
+		this.chance = chance;
+		this.lootEntries = lootEntries;
+	}
+
+	public ItemStack getItem(LivingEntity entity, Random random) {
+		if (random.nextFloat() > this.chance) return null;
+		EntityLootEntry choice = this.lootEntries[random.nextInt(this.lootEntries.length)];
+		return choice.getItem(entity, random);
+	}
+}
--- /dev/null
+++ net/minecraft/game/entity/loot/EntityLootEntry.java
@@ -1,0 +1,10 @@
+package net.minecraft.game.entity.loot;
+
+import net.minecraft.game.entity.LivingEntity;
+import net.minecraft.game.item.ItemStack;
+
+import java.util.Random;
+
+public interface EntityLootEntry {
+	ItemStack getItem(LivingEntity entity, Random random);
+}
--- net/minecraft/game/world/block/PressurePlateBlock.java
+++ net/minecraft/game/world/block/PressurePlateBlock.java
@@ -9,9 +9,13 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.material.Material;
 
 public class PressurePlateBlock extends Block {
+	public static final BooleanProperty PRESSED = new BooleanProperty("pressed");
+
 	private MobType triggerMobType;
 
 	protected PressurePlateBlock(int var1, int var2, MobType var3, Material var4) {
@@ -20,6 +24,10 @@
 		this.setTickOnLoad(true);
 		float var5 = 1.0F / 16.0F;
 		this.setBlockBounds(var5, 0.0F, var5, 1.0F - var5, 0.03125F, 1.0F - var5);
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(PRESSED);
 	}
 
 	public int tickRate() {
--- net/minecraft/game/item/AxeItem.java
+++ net/minecraft/game/item/AxeItem.java
@@ -1,11 +1,7 @@
 package net.minecraft.game.item;
 
-import net.minecraft.game.world.block.Block;
-
 public class AxeItem extends ToolItem {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.planks, Block.bookshelf, Block.log, Block.chest};
-
 	protected AxeItem(int var1, ToolMaterial var2) {
-		super(var1, 3, var2, blocksEffectiveAgainst);
+		super(var1, 3, var2, ToolType.AXE);
 	}
 }
--- argo/J_JsonObjectNodeSelector.java
+++ /dev/null
@@ -1,29 +1,0 @@
-package argo;
-
-import java.util.Map;
-
-final class J_JsonObjectNodeSelector extends J_LeafFunctor {
-	public boolean func_27070_a(J_JsonNode var1) {
-		return EnumJsonNodeType.OBJECT == var1.func_27218_a();
-	}
-
-	public String func_27060_a() {
-		return "A short form object";
-	}
-
-	public Map func_27071_b(J_JsonNode var1) {
-		return var1.getFields();
-	}
-
-	public String toString() {
-		return "an object";
-	}
-
-	public Object func_27063_c(Object var1) {
-		return this.func_27071_b((J_JsonNode)var1);
-	}
-
-	public boolean func_27058_a(Object var1) {
-		return this.func_27070_a((J_JsonNode)var1);
-	}
-}
--- net/minecraft/network/NetworkManager.java
+++ net/minecraft/network/NetworkManager.java
@@ -138,7 +138,7 @@
 				this.readPackets.add(var2);
 				var1 = true;
 			} else {
-				this.networkShutdown("disconnect.endOfStream", new Object[0]);
+				this.networkShutdown("disconnect.endOfStream");
 			}
 
 			return var1;
@@ -153,7 +153,7 @@
 
 	private void onNetworkError(Exception var1) {
 		var1.printStackTrace();
-		this.networkShutdown("disconnect.genericReason", new Object[]{"Internal exception: " + var1.toString()});
+		this.networkShutdown("disconnect.genericReason", "Internal exception: " + var1.toString());
 	}
 
 	public void networkShutdown(String var1, Object... var2) {
@@ -187,12 +187,12 @@
 
 	public void processReadPackets() {
 		if(this.sendQueueByteLength > 1048576) {
-			this.networkShutdown("disconnect.overflow", new Object[0]);
+			this.networkShutdown("disconnect.overflow");
 		}
 
 		if(this.readPackets.isEmpty()) {
 			if(this.timeSinceLastRead++ == 1200) {
-				this.networkShutdown("disconnect.timeout", new Object[0]);
+				this.networkShutdown("disconnect.timeout");
 			}
 		} else {
 			this.timeSinceLastRead = 0;
--- argo/J_JsonListenerToJdomAdapter.java
+++ /dev/null
@@ -1,81 +1,0 @@
-package argo;
-
-import java.util.Stack;
-
-final class J_JsonListenerToJdomAdapter implements J_JsonListener {
-	private final Stack field_27210_a = new Stack();
-	private J_JsonNodeBuilder field_27209_b;
-
-	J_JsonRootNode func_27208_a() {
-		return (J_JsonRootNode)this.field_27209_b.func_27234_b();
-	}
-
-	public void func_27195_b() {
-	}
-
-	public void func_27204_c() {
-	}
-
-	public void func_27200_d() {
-		J_JsonArrayNodeBuilder var1 = J_JsonNodeBuilders.func_27249_e();
-		this.func_27207_a(var1);
-		this.field_27210_a.push(new J_ArrayNodeContainer(this, var1));
-	}
-
-	public void func_27197_e() {
-		this.field_27210_a.pop();
-	}
-
-	public void func_27194_f() {
-		J_JsonObjectNodeBuilder var1 = J_JsonNodeBuilders.func_27253_d();
-		this.func_27207_a(var1);
-		this.field_27210_a.push(new J_ObjectNodeContainer(this, var1));
-	}
-
-	public void func_27203_g() {
-		this.field_27210_a.pop();
-	}
-
-	public void func_27205_a(String var1) {
-		J_JsonFieldBuilder var2 = J_JsonFieldBuilder.func_27301_a().func_27304_a(J_JsonNodeBuilders.func_27254_b(var1));
-		((J_NodeContainer)this.field_27210_a.peek()).func_27289_a(var2);
-		this.field_27210_a.push(new J_FieldNodeContainer(this, var2));
-	}
-
-	public void func_27199_h() {
-		this.field_27210_a.pop();
-	}
-
-	public void func_27201_b(String var1) {
-		this.func_27206_b(J_JsonNodeBuilders.func_27250_a(var1));
-	}
-
-	public void func_27196_i() {
-		this.func_27206_b(J_JsonNodeBuilders.func_27251_b());
-	}
-
-	public void func_27198_c(String var1) {
-		this.func_27206_b(J_JsonNodeBuilders.func_27254_b(var1));
-	}
-
-	public void func_27193_j() {
-		this.func_27206_b(J_JsonNodeBuilders.func_27252_c());
-	}
-
-	public void func_27202_k() {
-		this.func_27206_b(J_JsonNodeBuilders.func_27248_a());
-	}
-
-	private void func_27207_a(J_JsonNodeBuilder var1) {
-		if(this.field_27209_b == null) {
-			this.field_27209_b = var1;
-		} else {
-			this.func_27206_b(var1);
-		}
-
-	}
-
-	private void func_27206_b(J_JsonNodeBuilder var1) {
-		((J_NodeContainer)this.field_27210_a.peek()).func_27290_a(var1);
-	}
-}
--- /dev/null
+++ net/minecraft/game/world/block/properties/IntProperty.java
@@ -1,0 +1,39 @@
+package net.minecraft.game.world.block.properties;
+
+public class IntProperty implements Property<Integer> {
+	private final String name;
+	private final int size;
+
+	public IntProperty(String name) {
+		this(name, PropertyList.MAX_BITS);
+	}
+
+	public IntProperty(String name, int size) {
+		this.name = name;
+		this.size = size;
+	}
+
+	public Integer getValue(int metadataSlice) {
+		return metadataSlice;
+	}
+
+	public int getIntValue(Integer value) {
+		return value;
+	}
+
+	public String toString(Integer value) {
+		return value.toString();
+	}
+
+	public int getSize() {
+		return this.size;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public boolean supportDynamicSize() {
+		return this.size >= PropertyList.MAX_BITS;
+	}
+}
--- net/minecraft/game/item/recipe/FurnaceRecipes.java
+++ net/minecraft/game/item/recipe/FurnaceRecipes.java
@@ -1,14 +1,16 @@
 package net.minecraft.game.item.recipe;
 
-import java.util.HashMap;
 import java.util.Map;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.block.Block;
 
 public class FurnaceRecipes {
 	private static final FurnaceRecipes smeltingBase = new FurnaceRecipes();
-	private Map smeltingList = new HashMap();
+	private final Int2ObjectMap<ItemStack> smeltingList = new Int2ObjectOpenHashMap<>();
 
 	public static final FurnaceRecipes smelting() {
 		return smeltingBase;
@@ -19,20 +21,21 @@
 		this.addSmelting(Block.goldOre.blockID, new ItemStack(Item.goldIngot));
 		this.addSmelting(Block.diamondOre.blockID, new ItemStack(Item.diamond));
 		this.addSmelting(Block.sand.blockID, new ItemStack(Block.glass));
+		this.addSmelting(Block.redSand.blockID, new ItemStack(Block.glass));
 		this.addSmelting(Item.rawPorkchop.itemID, new ItemStack(Item.cookedPorkchop));
 		this.addSmelting(Item.rawFish.itemID, new ItemStack(Item.cookedFish));
 		this.addSmelting(Block.cobblestone.blockID, new ItemStack(Block.stone));
 		this.addSmelting(Item.clay.itemID, new ItemStack(Item.brick));
-		this.addSmelting(Block.cactus.blockID, new ItemStack(Item.dye, 1, 2));
+		this.addSmelting(Block.cactus.blockID, new ItemStack(Item.dye, 1, 13));
 		this.addSmelting(Block.log.blockID, new ItemStack(Item.coal, 1, 1));
 	}
 
 	public void addSmelting(int var1, ItemStack var2) {
-		this.smeltingList.put(Integer.valueOf(var1), var2);
+		this.smeltingList.put(var1, var2);
 	}
 
 	public ItemStack getSmeltingResult(int var1) {
-		return (ItemStack)this.smeltingList.get(Integer.valueOf(var1));
+		return this.smeltingList.get(var1);
 	}
 
 	public Map getSmeltingList() {
--- /dev/null
+++ net/minecraft/game/world/block/properties/PropertyField.java
@@ -1,0 +1,21 @@
+package net.minecraft.game.world.block.properties;
+
+public class PropertyField {
+	private final int offset;
+	private final int mask;
+	private final int nmask;
+
+	public PropertyField(int offset, int size) {
+		this.offset = offset;
+		this.mask = ((1 << size) - 1) << offset;
+		this.nmask = ~this.mask;
+	}
+
+	protected final int getMetadataSlice(int metadata) {
+		return (metadata & mask) >>> offset;
+	}
+
+	protected final int modifyMetadataSlice(int metadata, int value) {
+		return (metadata & nmask) | ((value << offset) & mask);
+	}
+}
--- net/minecraft/client/gui/TexturePacksScreen.java
+++ net/minecraft/client/gui/TexturePacksScreen.java
@@ -25,6 +25,7 @@
 		this.fileLocation = (new File(Minecraft.getMinecraftDir(), "texturepacks")).getAbsolutePath();
 		this.guiTexturePackSlot = new TexturePackSlotGui(this);
 		this.guiTexturePackSlot.registerScrollButtons(this.controlList, 7, 8);
+		this.initialized = false;
 	}
 
 	protected void actionPerformed(GuiButton var1) {
--- net/minecraft/game/item/recipe/RecipesDyes.java
+++ net/minecraft/game/item/recipe/RecipesDyes.java
@@ -8,23 +8,24 @@
 public class RecipesDyes {
 	public void addRecipes(CraftingManager var1) {
 		for(int var2 = 0; var2 < 16; ++var2) {
-			var1.addShapelessRecipe(new ItemStack(Block.wool, 1, WoolBlock.funkyMetaStuffB(var2)), new Object[]{new ItemStack(Item.dye, 1, var2), new ItemStack(Item.itemsList[Block.wool.blockID], 1, 0)});
+			var1.addShapelessRecipe(new ItemStack(Block.wool, 1, var2), new ItemStack(Item.dye, 1, var2), new ItemStack(Item.itemsList[Block.wool.blockID], 1, 0));
+			var1.addShapelessRecipe(new ItemStack(Block.hardenedClay, 1, var2), new ItemStack(Item.dye, 1, var2), new ItemStack(Item.itemsList[Block.hardenedClay.blockID], 1, 0));
 		}
 
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 11), new Object[]{Block.flower});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 1), new Object[]{Block.rose});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 3, 15), new Object[]{Item.bone});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 9), new Object[]{new ItemStack(Item.dye, 1, 1), new ItemStack(Item.dye, 1, 15)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 14), new Object[]{new ItemStack(Item.dye, 1, 1), new ItemStack(Item.dye, 1, 11)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 10), new Object[]{new ItemStack(Item.dye, 1, 2), new ItemStack(Item.dye, 1, 15)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 8), new Object[]{new ItemStack(Item.dye, 1, 0), new ItemStack(Item.dye, 1, 15)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 7), new Object[]{new ItemStack(Item.dye, 1, 8), new ItemStack(Item.dye, 1, 15)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 3, 7), new Object[]{new ItemStack(Item.dye, 1, 0), new ItemStack(Item.dye, 1, 15), new ItemStack(Item.dye, 1, 15)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 12), new Object[]{new ItemStack(Item.dye, 1, 4), new ItemStack(Item.dye, 1, 15)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 6), new Object[]{new ItemStack(Item.dye, 1, 4), new ItemStack(Item.dye, 1, 2)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 5), new Object[]{new ItemStack(Item.dye, 1, 4), new ItemStack(Item.dye, 1, 1)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 13), new Object[]{new ItemStack(Item.dye, 1, 5), new ItemStack(Item.dye, 1, 9)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 3, 13), new Object[]{new ItemStack(Item.dye, 1, 4), new ItemStack(Item.dye, 1, 1), new ItemStack(Item.dye, 1, 9)});
-		var1.addShapelessRecipe(new ItemStack(Item.dye, 4, 13), new Object[]{new ItemStack(Item.dye, 1, 4), new ItemStack(Item.dye, 1, 1), new ItemStack(Item.dye, 1, 1), new ItemStack(Item.dye, 1, 15)});
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 4), Block.flower);
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 14), Block.rose);
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 3, 0), Item.bone);
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 6), new ItemStack(Item.dye, 1, 14), new ItemStack(Item.dye, 1, 0));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 1), new ItemStack(Item.dye, 1, 14), new ItemStack(Item.dye, 1, 4));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 5), new ItemStack(Item.dye, 1, 13), new ItemStack(Item.dye, 1, 0));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 7), new ItemStack(Item.dye, 1, 15), new ItemStack(Item.dye, 1, 0));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 8), new ItemStack(Item.dye, 1, 7), new ItemStack(Item.dye, 1, 0));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 3, 8), new ItemStack(Item.dye, 1, 15), new ItemStack(Item.dye, 1, 0), new ItemStack(Item.dye, 1, 0));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 3), new ItemStack(Item.dye, 1, 11), new ItemStack(Item.dye, 1, 0));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 9), new ItemStack(Item.dye, 1, 11), new ItemStack(Item.dye, 1, 13));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 10), new ItemStack(Item.dye, 1, 11), new ItemStack(Item.dye, 1, 14));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 2, 2), new ItemStack(Item.dye, 1, 10), new ItemStack(Item.dye, 1, 6));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 3, 2), new ItemStack(Item.dye, 1, 11), new ItemStack(Item.dye, 1, 14), new ItemStack(Item.dye, 1, 6));
+		var1.addShapelessRecipe(new ItemStack(Item.dye, 4, 2), new ItemStack(Item.dye, 1, 11), new ItemStack(Item.dye, 1, 14), new ItemStack(Item.dye, 1, 14), new ItemStack(Item.dye, 1, 0));
 	}
 }
--- net/minecraft/client/controller/ClientPlayerController.java
+++ net/minecraft/client/controller/ClientPlayerController.java
@@ -2,6 +2,7 @@
 
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.player.ClientNetPlayerEntity;
+import net.minecraft.client.sound.SoundManager;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.item.ItemStack;
@@ -94,7 +95,7 @@
 					Block var6 = Block.blocksList[var5];
 					this.curBlockDamageMP += var6.blockStrength(this.mc.thePlayer);
 					if(this.field_9441_h % 4.0F == 0.0F && var6 != null) {
-						this.mc.sndManager.playSound(var6.stepSound.baseStepSoundDir(), (float)var1 + 0.5F, (float)var2 + 0.5F, (float)var3 + 0.5F, (var6.stepSound.getVolume() + 1.0F) / 8.0F, var6.stepSound.getPitch() * 0.5F);
+						this.mc.sndManager.playSound(var6.stepSound.baseSteppySoundDir(), (float)var1 + 0.5F, (float)var2 + 0.5F, (float)var3 + 0.5F, (var6.stepSound.getVolume() + 1.0F) / 8.0F, var6.stepSound.getPitch() * 0.5F);
 					}
 
 					++this.field_9441_h;
@@ -105,7 +106,7 @@
 						this.curBlockDamageMP = 0.0F;
 						this.prevBlockDamageMP = 0.0F;
 						this.field_9441_h = 0.0F;
-						this.blockHitDelay = 5;
+//						this.blockHitDelay = 5;
 					}
 				} else {
 					this.clickBlock(var1, var2, var3, var4);
@@ -138,7 +139,7 @@
 	public void updateController() {
 		this.syncCurrentPlayItem();
 		this.prevBlockDamageMP = this.curBlockDamageMP;
-		this.mc.sndManager.playRandomMusicIfReady();
+		this.mc.sndManager.playRandomMusicIfReady(SoundManager.MusicType.GAME);
 	}
 
 	private void syncCurrentPlayItem() {
--- argo/J_SajParser.java
+++ /dev/null
@@ -1,417 +1,0 @@
-package argo;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.util.Arrays;
-
-public final class J_SajParser {
-	public void func_27463_a(Reader var1, J_JsonListener var2) throws J_InvalidSyntaxException, IOException {
-		J_PositionTrackingPushbackReader var3 = new J_PositionTrackingPushbackReader(var1);
-		char var4 = (char)var3.func_27333_c();
-		switch(var4) {
-		case '[':
-			var3.func_27334_a(var4);
-			var2.func_27195_b();
-			this.func_27455_a(var3, var2);
-			break;
-		case '{':
-			var3.func_27334_a(var4);
-			var2.func_27195_b();
-			this.func_27453_b(var3, var2);
-			break;
-		default:
-			throw new J_InvalidSyntaxException("Expected either [ or { but got [" + var4 + "].", var3);
-		}
-
-		int var5 = this.func_27448_l(var3);
-		if(var5 != -1) {
-			throw new J_InvalidSyntaxException("Got unexpected trailing character [" + (char)var5 + "].", var3);
-		} else {
-			var2.func_27204_c();
-		}
-	}
-
-	private void func_27455_a(J_PositionTrackingPushbackReader var1, J_JsonListener var2) throws J_InvalidSyntaxException, IOException {
-		char var3 = (char)this.func_27448_l(var1);
-		if(var3 != 91) {
-			throw new J_InvalidSyntaxException("Expected object to start with [ but got [" + var3 + "].", var1);
-		} else {
-			var2.func_27200_d();
-			char var4 = (char)this.func_27448_l(var1);
-			var1.func_27334_a(var4);
-			if(var4 != 93) {
-				this.func_27464_d(var1, var2);
-			}
-
-			boolean var5 = false;
-
-			while(!var5) {
-				char var6 = (char)this.func_27448_l(var1);
-				switch(var6) {
-				case ',':
-					this.func_27464_d(var1, var2);
-					break;
-				case ']':
-					var5 = true;
-					break;
-				default:
-					throw new J_InvalidSyntaxException("Expected either , or ] but got [" + var6 + "].", var1);
-				}
-			}
-
-			var2.func_27197_e();
-		}
-	}
-
-	private void func_27453_b(J_PositionTrackingPushbackReader var1, J_JsonListener var2) throws J_InvalidSyntaxException, IOException {
-		char var3 = (char)this.func_27448_l(var1);
-		if(var3 != 123) {
-			throw new J_InvalidSyntaxException("Expected object to start with { but got [" + var3 + "].", var1);
-		} else {
-			var2.func_27194_f();
-			char var4 = (char)this.func_27448_l(var1);
-			var1.func_27334_a(var4);
-			if(var4 != 125) {
-				this.func_27449_c(var1, var2);
-			}
-
-			boolean var5 = false;
-
-			while(!var5) {
-				char var6 = (char)this.func_27448_l(var1);
-				switch(var6) {
-				case ',':
-					this.func_27449_c(var1, var2);
-					break;
-				case '}':
-					var5 = true;
-					break;
-				default:
-					throw new J_InvalidSyntaxException("Expected either , or } but got [" + var6 + "].", var1);
-				}
-			}
-
-			var2.func_27203_g();
-		}
-	}
-
-	private void func_27449_c(J_PositionTrackingPushbackReader var1, J_JsonListener var2) throws J_InvalidSyntaxException, IOException {
-		char var3 = (char)this.func_27448_l(var1);
-		if(34 != var3) {
-			throw new J_InvalidSyntaxException("Expected object identifier to begin with [\"] but got [" + var3 + "].", var1);
-		} else {
-			var1.func_27334_a(var3);
-			var2.func_27205_a(this.func_27452_i(var1));
-			char var4 = (char)this.func_27448_l(var1);
-			if(var4 != 58) {
-				throw new J_InvalidSyntaxException("Expected object identifier to be followed by : but got [" + var4 + "].", var1);
-			} else {
-				this.func_27464_d(var1, var2);
-				var2.func_27199_h();
-			}
-		}
-	}
-
-	private void func_27464_d(J_PositionTrackingPushbackReader var1, J_JsonListener var2) throws J_InvalidSyntaxException, IOException {
-		char var3 = (char)this.func_27448_l(var1);
-		switch(var3) {
-		case '\"':
-			var1.func_27334_a(var3);
-			var2.func_27198_c(this.func_27452_i(var1));
-			break;
-		case '-':
-		case '0':
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		case '8':
-		case '9':
-			var1.func_27334_a(var3);
-			var2.func_27201_b(this.func_27459_a(var1));
-			break;
-		case '[':
-			var1.func_27334_a(var3);
-			this.func_27455_a(var1, var2);
-			break;
-		case 'f':
-			char[] var6 = new char[4];
-			int var7 = var1.func_27336_b(var6);
-			if(var7 != 4 || var6[0] != 97 || var6[1] != 108 || var6[2] != 115 || var6[3] != 101) {
-				var1.func_27335_a(var6);
-				throw new J_InvalidSyntaxException("Expected \'f\' to be followed by [[a, l, s, e]], but got [" + Arrays.toString(var6) + "].", var1);
-			}
-
-			var2.func_27193_j();
-			break;
-		case 'n':
-			char[] var8 = new char[3];
-			int var9 = var1.func_27336_b(var8);
-			if(var9 != 3 || var8[0] != 117 || var8[1] != 108 || var8[2] != 108) {
-				var1.func_27335_a(var8);
-				throw new J_InvalidSyntaxException("Expected \'n\' to be followed by [[u, l, l]], but got [" + Arrays.toString(var8) + "].", var1);
-			}
-
-			var2.func_27202_k();
-			break;
-		case 't':
-			char[] var4 = new char[3];
-			int var5 = var1.func_27336_b(var4);
-			if(var5 != 3 || var4[0] != 114 || var4[1] != 117 || var4[2] != 101) {
-				var1.func_27335_a(var4);
-				throw new J_InvalidSyntaxException("Expected \'t\' to be followed by [[r, u, e]], but got [" + Arrays.toString(var4) + "].", var1);
-			}
-
-			var2.func_27196_i();
-			break;
-		case '{':
-			var1.func_27334_a(var3);
-			this.func_27453_b(var1, var2);
-			break;
-		default:
-			throw new J_InvalidSyntaxException("Invalid character at start of value [" + var3 + "].", var1);
-		}
-
-	}
-
-	private String func_27459_a(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		StringBuilder var2 = new StringBuilder();
-		char var3 = (char)var1.func_27333_c();
-		if(45 == var3) {
-			var2.append('-');
-		} else {
-			var1.func_27334_a(var3);
-		}
-
-		var2.append(this.func_27451_b(var1));
-		return var2.toString();
-	}
-
-	private String func_27451_b(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		StringBuilder var2 = new StringBuilder();
-		char var3 = (char)var1.func_27333_c();
-		if(48 == var3) {
-			var2.append('0');
-			var2.append(this.func_27462_f(var1));
-			var2.append(this.func_27454_g(var1));
-		} else {
-			var1.func_27334_a(var3);
-			var2.append(this.func_27460_c(var1));
-			var2.append(this.func_27456_e(var1));
-			var2.append(this.func_27462_f(var1));
-			var2.append(this.func_27454_g(var1));
-		}
-
-		return var2.toString();
-	}
-
-	private char func_27460_c(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		char var3 = (char)var1.func_27333_c();
-		switch(var3) {
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		case '8':
-		case '9':
-			return var3;
-		default:
-			throw new J_InvalidSyntaxException("Expected a digit 1 - 9 but got [" + var3 + "].", var1);
-		}
-	}
-
-	private char func_27458_d(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		char var3 = (char)var1.func_27333_c();
-		switch(var3) {
-		case '0':
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		case '8':
-		case '9':
-			return var3;
-		default:
-			throw new J_InvalidSyntaxException("Expected a digit 1 - 9 but got [" + var3 + "].", var1);
-		}
-	}
-
-	private String func_27456_e(J_PositionTrackingPushbackReader var1) throws IOException {
-		StringBuilder var2 = new StringBuilder();
-		boolean var3 = false;
-
-		while(!var3) {
-			char var4 = (char)var1.func_27333_c();
-			switch(var4) {
-			case '0':
-			case '1':
-			case '2':
-			case '3':
-			case '4':
-			case '5':
-			case '6':
-			case '7':
-			case '8':
-			case '9':
-				var2.append(var4);
-				break;
-			default:
-				var3 = true;
-				var1.func_27334_a(var4);
-			}
-		}
-
-		return var2.toString();
-	}
-
-	private String func_27462_f(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		StringBuilder var2 = new StringBuilder();
-		char var3 = (char)var1.func_27333_c();
-		if(var3 == 46) {
-			var2.append('.');
-			var2.append(this.func_27458_d(var1));
-			var2.append(this.func_27456_e(var1));
-		} else {
-			var1.func_27334_a(var3);
-		}
-
-		return var2.toString();
-	}
-
-	private String func_27454_g(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		StringBuilder var2 = new StringBuilder();
-		char var3 = (char)var1.func_27333_c();
-		if(var3 != 46 && var3 != 69) {
-			var1.func_27334_a(var3);
-		} else {
-			var2.append('E');
-			var2.append(this.func_27461_h(var1));
-			var2.append(this.func_27458_d(var1));
-			var2.append(this.func_27456_e(var1));
-		}
-
-		return var2.toString();
-	}
-
-	private String func_27461_h(J_PositionTrackingPushbackReader var1) throws IOException {
-		StringBuilder var2 = new StringBuilder();
-		char var3 = (char)var1.func_27333_c();
-		if(var3 != 43 && var3 != 45) {
-			var1.func_27334_a(var3);
-		} else {
-			var2.append(var3);
-		}
-
-		return var2.toString();
-	}
-
-	private String func_27452_i(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		StringBuilder var2 = new StringBuilder();
-		char var3 = (char)var1.func_27333_c();
-		if(34 != var3) {
-			throw new J_InvalidSyntaxException("Expected [\"] but got [" + var3 + "].", var1);
-		} else {
-			boolean var4 = false;
-
-			while(!var4) {
-				char var5 = (char)var1.func_27333_c();
-				switch(var5) {
-				case '\"':
-					var4 = true;
-					break;
-				case '\\':
-					char var6 = this.func_27457_j(var1);
-					var2.append(var6);
-					break;
-				default:
-					var2.append(var5);
-				}
-			}
-
-			return var2.toString();
-		}
-	}
-
-	private char func_27457_j(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		char var3 = (char)var1.func_27333_c();
-		char var2;
-		switch(var3) {
-		case '\"':
-			var2 = 34;
-			break;
-		case '/':
-			var2 = 47;
-			break;
-		case '\\':
-			var2 = 92;
-			break;
-		case 'b':
-			var2 = 8;
-			break;
-		case 'f':
-			var2 = 12;
-			break;
-		case 'n':
-			var2 = 10;
-			break;
-		case 'r':
-			var2 = 13;
-			break;
-		case 't':
-			var2 = 9;
-			break;
-		case 'u':
-			var2 = (char)this.func_27450_k(var1);
-			break;
-		default:
-			throw new J_InvalidSyntaxException("Unrecognised escape character [" + var3 + "].", var1);
-		}
-
-		return var2;
-	}
-
-	private int func_27450_k(J_PositionTrackingPushbackReader var1) throws J_InvalidSyntaxException, IOException {
-		char[] var2 = new char[4];
-		int var3 = var1.func_27336_b(var2);
-		if(var3 != 4) {
-			throw new J_InvalidSyntaxException("Expected a 4 digit hexidecimal number but got only [" + var3 + "], namely [" + String.valueOf(var2, 0, var3) + "].", var1);
-		} else {
-			try {
-				int var4 = Integer.parseInt(String.valueOf(var2), 16);
-				return var4;
-			} catch (NumberFormatException var6) {
-				var1.func_27335_a(var2);
-				throw new J_InvalidSyntaxException("Unable to parse [" + String.valueOf(var2) + "] as a hexidecimal number.", var6, var1);
-			}
-		}
-	}
-
-	private int func_27448_l(J_PositionTrackingPushbackReader var1) throws IOException {
-		boolean var3 = false;
-
-		int var2;
-		do {
-			var2 = var1.func_27333_c();
-			switch(var2) {
-			case 9:
-			case 10:
-			case 13:
-			case 32:
-				break;
-			default:
-				var3 = true;
-			}
-		} while(!var3);
-
-		return var2;
-	}
-}
--- net/minecraft/network/packet/Packet53BlockChange.java
+++ net/minecraft/network/packet/Packet53BlockChange.java
@@ -19,7 +19,7 @@
 
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.xPosition = var1.readInt();
-		this.yPosition = var1.read();
+		this.yPosition = var1.readInt();
 		this.zPosition = var1.readInt();
 		this.type = var1.read();
 		this.metadata = var1.read();
@@ -27,7 +27,7 @@
 
 	public void writePacketData(DataOutputStream var1) throws IOException {
 		var1.writeInt(this.xPosition);
-		var1.write(this.yPosition);
+		var1.writeInt(this.yPosition);
 		var1.writeInt(this.zPosition);
 		var1.write(this.type);
 		var1.write(this.metadata);
@@ -38,7 +38,7 @@
 	}
 
 	public int getPacketSize() {
-		return 11;
+		return 14;
 	}
 
 	public Packet53BlockChange(int var1, int var2, int var3, World var4) {
--- net/minecraft/game/world/block/RedstoneRepeaterBlock.java
+++ net/minecraft/game/world/block/RedstoneRepeaterBlock.java
@@ -10,12 +10,18 @@
 import net.minecraft.util.MathHelper;
 
 public class RedstoneRepeaterBlock extends Block {
+	private static final int TEX_OFF = TerrainLayout.texCoord("redstone_repeater_off");
+	private static final int TEX_ON = TerrainLayout.texCoord("redstone_repeater_on");
+	private static final int TEX_TORCH_OFF = TerrainLayout.texCoord("redstone_torch_off");
+	private static final int TEX_TORCH_ON = TerrainLayout.texCoord("redstone_torch_on");
+	private static final int TEX_BOTTOM = TerrainLayout.texCoord("smooth_stone");
+
 	public static final double[] tickLengths = new double[]{-0.0625D, 1.0D / 16.0D, 0.1875D, 0.3125D};
 	private static final int[] tickInt = new int[]{1, 2, 3, 4};
 	private final boolean isRepeaterPowered;
 
 	protected RedstoneRepeaterBlock(int var1, boolean var2) {
-		super(var1, 6, Material.circuits);
+		super(var1, TEX_OFF, Material.circuits);
 		this.isRepeaterPowered = var2;
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 2.0F / 16.0F, 1.0F);
 	}
@@ -48,7 +54,7 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return var1 == 0 ? (this.isRepeaterPowered ? 99 : 115) : (var1 == 1 ? (this.isRepeaterPowered ? 147 : 131) : 5);
+		return var1 == 0 ? (this.isRepeaterPowered ? TEX_TORCH_ON : TEX_TORCH_OFF) : var1 == 1 ? (this.isRepeaterPowered ? TEX_ON : TEX_OFF) : TEX_BOTTOM;
 	}
 
 	public boolean shouldSideBeRendered(BlockAccess var1, int var2, int var3, int var4, int var5) {
--- /dev/null
+++ net/minecraft/game/world/terrain/NoiseSettings.java
@@ -1,0 +1,216 @@
+package net.minecraft.game.world.terrain;
+
+import net.minecraft.util.MathHelper;
+
+import java.util.function.ToDoubleFunction;
+
+public class NoiseSettings {
+	private final double selectorThreshold;
+	private final double selectorOffset;
+	private final double noiseStretchMin ;
+	private final double noiseStretchMax ;
+	private final double noiseUnderDampMin;
+	private final double noiseUnderDampMax;
+	private final double heightOffsetMin;
+	private final double heightOffsetMax;
+
+	private NoiseSettings(Builder builder) {
+		this.selectorThreshold = builder.selectorThreshold;
+		this.selectorOffset = builder.selectorOffset;
+		this.noiseStretchMin = builder.noiseStretchMin;
+		this.noiseStretchMax = builder.noiseStretchMax;
+		this.noiseUnderDampMin = builder.noiseUnderDampMin;
+		this.noiseUnderDampMax = builder.noiseUnderDampMax;
+		this.heightOffsetMin = builder.heightOffsetMin;
+		this.heightOffsetMax = builder.heightOffsetMax;
+	}
+
+	public NoiseSettings(NoiseSettings a, NoiseSettings b, double t) {
+		this.selectorThreshold = MathHelper.lerp(a.selectorThreshold, b.selectorThreshold, t);
+		this.selectorOffset = MathHelper.lerp(a.selectorOffset, b.selectorOffset, t);
+		this.noiseStretchMin = MathHelper.lerp(a.noiseStretchMin, b.noiseStretchMin, t);
+		this.noiseStretchMax = MathHelper.lerp(a.noiseStretchMax, b.noiseStretchMax, t);
+		this.noiseUnderDampMin = MathHelper.lerp(a.noiseUnderDampMin, b.noiseUnderDampMin, t);
+		this.noiseUnderDampMax = MathHelper.lerp(a.noiseUnderDampMax, b.noiseUnderDampMax, t);
+		this.heightOffsetMin = MathHelper.lerp(a.heightOffsetMin, b.heightOffsetMin, t);
+		this.heightOffsetMax = MathHelper.lerp(a.heightOffsetMax, b.heightOffsetMax, t);
+	}
+
+	// I would've created three noise settings instances with three 1D lerps
+	// but that'd be a waste of memory so there's this monstrosity instead.
+	//
+	// Valhalla when? 🥺👉👈
+	//
+	// Wait why are the hands a different color from
+	// the face on Windows? Mildly irritating, but whatever.
+	public NoiseSettings(NoiseSettings n00, NoiseSettings n01, NoiseSettings n10, NoiseSettings n11, double t0, double t1) {
+		this.selectorThreshold = MathHelper.lerp(n00.selectorThreshold, n01.selectorThreshold, n10.selectorThreshold, n11.selectorThreshold, t0, t1);
+		this.selectorOffset = MathHelper.lerp(n00.selectorOffset, n01.selectorOffset, n10.selectorOffset, n11.selectorOffset, t0, t1);
+		this.noiseStretchMin = MathHelper.lerp(n00.noiseStretchMin, n01.noiseStretchMin, n10.noiseStretchMin, n11.noiseStretchMin, t0, t1);
+		this.noiseStretchMax = MathHelper.lerp(n00.noiseStretchMax, n01.noiseStretchMax, n10.noiseStretchMax, n11.noiseStretchMax, t0, t1);
+		this.noiseUnderDampMin = MathHelper.lerp(n00.noiseUnderDampMin, n01.noiseUnderDampMin, n10.noiseUnderDampMin, n11.noiseUnderDampMin, t0, t1);
+		this.noiseUnderDampMax = MathHelper.lerp(n00.noiseUnderDampMax, n01.noiseUnderDampMax, n10.noiseUnderDampMax, n11.noiseUnderDampMax, t0, t1);
+		this.heightOffsetMin = MathHelper.lerp(n00.heightOffsetMin, n01.heightOffsetMin, n10.heightOffsetMin, n11.heightOffsetMin, t0, t1);
+		this.heightOffsetMax = MathHelper.lerp(n00.heightOffsetMax, n01.heightOffsetMax, n10.heightOffsetMax, n11.heightOffsetMax, t0, t1);
+	}
+
+	public NoiseSettings(NoiseSettings... samples) {
+		this.selectorThreshold = mean(samples, NoiseSettings::selectorThreshold);
+		this.selectorOffset = mean(samples, NoiseSettings::selectorOffset);
+		this.noiseStretchMin = mean(samples, NoiseSettings::noiseStretchMin);
+		this.noiseStretchMax = mean(samples, NoiseSettings::noiseStretchMax);
+		this.noiseUnderDampMin = mean(samples, NoiseSettings::noiseUnderDampMin);
+		this.noiseUnderDampMax = mean(samples, NoiseSettings::noiseUnderDampMax);
+		this.heightOffsetMin = mean(samples, NoiseSettings::heightOffsetMin);
+		this.heightOffsetMax = mean(samples, NoiseSettings::heightOffsetMax);
+	}
+
+	private static double mean(NoiseSettings[] samples, ToDoubleFunction<NoiseSettings> property) {
+		double sum = 0.0D;
+		int amount = 0;
+		for (NoiseSettings sample : samples) {
+			if (sample != null) {
+				sum += property.applyAsDouble(sample);
+				amount++;
+			}
+		}
+		return sum / amount;
+	}
+
+	public double selectorThreshold() {
+		return selectorThreshold;
+	}
+
+	public double selectorOffset() {
+		return selectorOffset;
+	}
+
+	public double noiseStretchMin() {
+		return noiseStretchMin;
+	}
+
+	public double noiseStretchMax() {
+		return noiseStretchMax;
+	}
+
+	public double noiseUnderDampMin() {
+		return noiseUnderDampMin;
+	}
+
+	public double noiseUnderDampMax() {
+		return noiseUnderDampMax;
+	}
+
+	public double heightOffsetMin() {
+		return heightOffsetMin;
+	}
+
+	public double heightOffsetMax() {
+		return heightOffsetMax;
+	}
+
+	public static final class Builder {
+		private double selectorThreshold = 0.1D;
+		private double selectorOffset = 0.0D;
+		private double noiseStretchMin = 20.0D;
+		private double noiseStretchMax = 30.0D;
+		private double noiseUnderDampMin = 1.5D;
+		private double noiseUnderDampMax = 1.5D;
+		private double heightOffsetMin = 8.0D;
+		private double heightOffsetMax = 8.0D;
+
+		public Builder() {
+		}
+
+		public Builder(NoiseSettings noiseSettings) {
+			this.selectorThreshold = noiseSettings.selectorThreshold;
+			this.selectorOffset = noiseSettings.selectorOffset;
+			this.noiseStretchMin = noiseSettings.noiseStretchMin;
+			this.noiseStretchMax = noiseSettings.noiseStretchMax;
+			this.noiseUnderDampMin = noiseSettings.noiseUnderDampMin;
+			this.noiseUnderDampMax = noiseSettings.noiseUnderDampMax;
+			this.heightOffsetMin = noiseSettings.heightOffsetMin;
+			this.heightOffsetMax = noiseSettings.heightOffsetMax;
+		}
+
+		public Builder selectorThreshold(double selectorThreshold) {
+			this.selectorThreshold = selectorThreshold;
+			return this;
+		}
+
+		public Builder selectorOffset(double selectorOffset) {
+			this.selectorOffset = selectorOffset;
+			return this;
+		}
+
+		public Builder noiseStretch(double noiseStretch) {
+			this.noiseStretchMin = noiseStretch;
+			this.noiseStretchMax = noiseStretch;
+			return this;
+		}
+
+		public Builder noiseStretch(double min, double max) {
+			this.noiseStretchMin = min;
+			this.noiseStretchMax = max;
+			return this;
+		}
+
+		public Builder noiseStretchMin(double noiseStretchMin) {
+			this.noiseStretchMin = noiseStretchMin;
+			return this;
+		}
+
+		public Builder noiseStretchMax(double noiseStretchMax) {
+			this.noiseStretchMax = noiseStretchMax;
+			return this;
+		}
+
+		public Builder noiseUnderDamp(double noiseUnderDamp) {
+			this.noiseUnderDampMin = noiseUnderDamp;
+			this.noiseUnderDampMax = noiseUnderDamp;
+			return this;
+		}
+
+		public Builder noiseUnderDamp(double min, double max) {
+			this.noiseUnderDampMin = min;
+			this.noiseUnderDampMax = max;
+			return this;
+		}
+
+		public Builder noiseUnderDampMin(double noiseUnderDampMin) {
+			this.noiseUnderDampMin = noiseUnderDampMin;
+			return this;
+		}
+
+		public Builder noiseUnderDampMax(double noiseUnderDampMax) {
+			this.noiseUnderDampMax = noiseUnderDampMax;
+			return this;
+		}
+
+		public Builder heightOffset(double heightOffset) {
+			this.heightOffsetMin = heightOffset;
+			this.heightOffsetMax = heightOffset;
+			return this;
+		}
+
+		public Builder heightOffset(double min, double max) {
+			this.heightOffsetMin = min;
+			this.heightOffsetMax = max;
+			return this;
+		}
+
+		public Builder heightOffsetMin(double heightOffsetMin) {
+			this.heightOffsetMin = heightOffsetMin;
+			return this;
+		}
+
+		public Builder heightOffsetMax(double heightOffsetMax) {
+			this.heightOffsetMax = heightOffsetMax;
+			return this;
+		}
+
+		public NoiseSettings build() {
+			return new NoiseSettings(this);
+		}
+	}
+}
--- net/minecraft/network/ThreadCloseConnection.java
+++ net/minecraft/network/ThreadCloseConnection.java
@@ -12,7 +12,7 @@
 			Thread.sleep(2000L);
 			if(NetworkManager.isRunning(this.netManager)) {
 				NetworkManager.getWriteThread(this.netManager).interrupt();
-				this.netManager.networkShutdown("disconnect.closed", new Object[0]);
+				this.netManager.networkShutdown("disconnect.closed");
 			}
 		} catch (Exception var2) {
 			var2.printStackTrace();
--- net/minecraft/util/StringTranslate.java
+++ net/minecraft/util/StringTranslate.java
@@ -33,4 +33,21 @@
 	public String translateNamedKey(String var1) {
 		return this.translateTable.getProperty(var1 + ".name", "");
 	}
+
+	public static String i18n(String var1) {
+		return instance.translateKey(var1);
+	}
+
+	public static String i18n(String key, String alt) {
+		return instance.translateTable.getProperty(key, alt);
+	}
+
+	public static String i18nf(String var1, Object... var2) {
+		return instance.translateKeyFormat(var1, var2);
+	}
+
+	public static String formatFloat(float var1) {
+		if (var1 % 1.0F == 0.0F) return String.valueOf((int)var1);
+		return String.valueOf((int)(var1 * 100.0F) / 100.0F);
+	}
 }
--- net/minecraft/client/gui/WorldSlotGui.java
+++ net/minecraft/client/gui/WorldSlotGui.java
@@ -6,6 +6,8 @@
 import net.minecraft.game.world.save.SaveFormatComparator;
 import net.minecraft.util.MathHelper;
 
+import static net.minecraft.util.StringTranslate.i18n;
+
 class WorldSlotGui extends GuiSlot {
 	final SelectWorldScreen parentWorldGui;
 
@@ -38,8 +40,8 @@
 		return SelectWorldScreen.getSize(this.parentWorldGui).size() * 36;
 	}
 
-	protected void drawBackground() {
-		this.parentWorldGui.drawDefaultBackground();
+	protected void drawBackground(float var3) {
+		this.parentWorldGui.drawDefaultBackground(var3);
 	}
 
 	protected void drawSlot(int var1, int var2, int var3, int var4, Tessellator var5) {
@@ -53,7 +55,7 @@
 		var8 = var8 + " (" + SelectWorldScreen.getDateFormatter(this.parentWorldGui).format(new Date(var6.func_22163_e()));
 		long var9 = var6.func_22159_c();
 		var8 = var8 + ", " + (float)(var9 / 1024L * 100L / 1024L) / 100.0F + " MB)";
-		String var11 = "";
+		String var11 = i18n("selectWorld.gameMode.format").replace("$", i18n("selectWorld.gameMode." + (var6.isCreative() ? "creative" : "survival")));
 		if(var6.func_22161_d()) {
 			var11 = SelectWorldScreen.func_22088_h(this.parentWorldGui) + " " + var11;
 		}
--- argo/J_JsonElementNodeSelector.java
+++ /dev/null
@@ -1,35 +1,0 @@
-package argo;
-
-import java.util.List;
-
-final class J_JsonElementNodeSelector extends J_LeafFunctor {
-	final int field_27069_a;
-
-	J_JsonElementNodeSelector(int var1) {
-		this.field_27069_a = var1;
-	}
-
-	public boolean func_27067_a(List var1) {
-		return var1.size() > this.field_27069_a;
-	}
-
-	public String func_27060_a() {
-		return Integer.toString(this.field_27069_a);
-	}
-
-	public J_JsonNode func_27068_b(List var1) {
-		return (J_JsonNode)var1.get(this.field_27069_a);
-	}
-
-	public String toString() {
-		return "an element at index [" + this.field_27069_a + "]";
-	}
-
-	public Object func_27063_c(Object var1) {
-		return this.func_27068_b((List)var1);
-	}
-
-	public boolean func_27058_a(Object var1) {
-		return this.func_27067_a((List)var1);
-	}
-}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/SmoothWorldRenderer.java
@@ -1,0 +1,5 @@
+package net.mine_diver.smoothbeta.client.render;
+
+public interface SmoothWorldRenderer {
+    VboPool smoothbeta_getTerrainVboPool();
+}
--- /dev/null
+++ net/minecraft/client/gui/CreativeMenu.java
@@ -1,0 +1,199 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.gui.component.GuiButton;
+import net.minecraft.client.gui.component.GuiSliderGeneric;
+import net.minecraft.client.gui.component.GuiTransparentButton;
+import net.minecraft.client.gui.container.ContainerScreen;
+import net.minecraft.game.entity.player.InventoryPlayer;
+import net.minecraft.game.item.ContainerCreative;
+import net.minecraft.game.item.InventoryReadonly;
+import org.lwjgl.opengl.GL11;
+
+import net.minecraft.client.Minecraft;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.Map;
+
+public class CreativeMenu extends ContainerScreen {
+	protected String title = "Creative";
+	protected InventoryReadonly inventory;
+	protected int row = 0;
+	private int maxRow;
+	private GuiSliderGeneric rowSlider;
+
+	public CreativeMenu(InventoryPlayer inv, Minecraft minecraft) {
+		super(new ContainerCreative(inv, minecraft.gameSettings.creativeDebug
+				? InventoryReadonly.generateCreativeInventory(true)
+				: InventoryReadonly.getCreativeInventory()));
+		this.xSize = 176;
+		this.ySize = 190;
+		this.mc = minecraft;
+
+		this.inventory = ((ContainerCreative)this.inventorySlots).inventory;
+		this.maxRow = this.inventory.getSize() / 8 - 7;
+		this.setupItems();
+	}
+
+	public void initGui() {
+		this.rowSlider = null;
+		this.setupItems();
+		this.setupControls();
+
+		if (Minecraft.DEBUG_MODE) {
+			this.controlList.add(new GuiButton(100, -150, -20, 150, 20,
+											   (this.mc.gameSettings.creativeDebug ? "Disable " : "Enable ") + "Debug ;)")
+					.alignedAt(1.0F, 1.0F));
+		}
+		super.initGui();
+		this.initialized = false;
+	}
+
+	protected void drawGuiContainerBackgroundLayer(float var1) {
+		int bg = this.mc.textureRegistry.getTexture("/gui/creative.png");
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		this.mc.textureRegistry.bindTexture(bg);
+		int posX = (this.width - this.xSize) / 2;
+		int posY = (this.height - this.ySize) / 2;
+		this.drawTexturedRect(posX, posY, 0, 0, this.xSize, this.ySize);
+
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/gui/creative.png"));
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		for (int i = 1; i < 9; i++) {
+			if (this.inventory.getLabel(i + row) != null) {
+				this.drawTexturedRect(posX + 7, posY + i * 18 - 1, 0, 238, 144, 18);
+			}
+		}
+	}
+
+	protected void drawGuiContainerForegroundLayer() {
+		this.fontRenderer.drawString(this.mc.gameSettings.creativeDebug ? "Cheats" : this.title, 8, 6, 4210752);
+		for (int i = 1; i < 9; i++) {
+			String label = this.inventory.getLabel(i + row);
+			if (label != null) {
+				this.fontRenderer.drawStringWithShadow(label, 12, i * 18 + 4, 0xFFFFFF);
+			}
+		}
+	}
+
+	protected void setupItems() {
+		this.inventory.pickOne = this.mc.thePlayer != null && this.mc.thePlayer.creative;
+		((ContainerCreative)this.inventorySlots).setupItems(this.row);
+	}
+
+	private void setupControls() {
+		int posX = (this.width - this.xSize) / 2 + 151;
+		int posY = (this.height - this.ySize) / 2 + 17;
+
+		if (this.mc.gameSettings.creativeDebug) {
+			this.controlList.add(new GuiButton(101, posX + 18, posY + 81, 18, 18, "FB"));
+			this.controlList.add(new GuiButton(102, posX + 18, posY + 99, 18, 18, "NC"));
+			this.controlList.add(new GuiButton(103, posX + 38, posY + 81, 64, 18, "Day"));
+			this.controlList.add(new GuiButton(104, posX + 38, posY + 99, 64, 18, "Night"));
+			this.controlList.add(new GuiButton(105, posX + 38, posY + 117, 64, 18, "Sunset"));
+		}
+
+		this.rowSlider = new GuiSliderGeneric(4, (this.width - this.xSize) / 2 + 151, (this.height - this.ySize) / 2 + 17, 18, 144, "Page", 0.0F, this.maxRow);
+		this.rowSlider.round = true;
+		this.rowSlider.vertical = true;
+		this.rowSlider.displayString = this.rowSlider.getDisplayString();
+		this.controlList.add(this.rowSlider);
+
+		if (this.inventory.labels != null) {
+			int y = posY;
+			for (Iterator<Map.Entry<Integer, String>> it = this.inventory.labels
+					.entrySet()
+					.stream()
+					.sorted(Comparator.comparingInt(Map.Entry::getKey))
+					.iterator(); it.hasNext(); ) {
+				Map.Entry<Integer, String> label = it.next();
+				this.controlList.add(new GuiTransparentButton(200 + label.getKey(), 8, y, (this.width - this.xSize) / 2, 12, label.getValue()));
+				y += 12;
+			}
+		}
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		switch (var1.id) {
+			case 0:
+				this.row = Math.max(this.row - 4, 0);
+				break;
+
+			case 1:
+				this.row = Math.max(this.row - 1, 0);
+				break;
+
+			case 2:
+				this.row = Math.min(this.row + 1, this.maxRow);
+				break;
+
+			case 3:
+				this.row = Math.min(this.row + 4, this.maxRow);
+				break;
+
+			case 100:
+				this.mc.gameSettings.creativeDebug = !this.mc.gameSettings.creativeDebug;
+
+				this.controlList.clear();
+				this.controlList.add(var1);
+				var1.displayString = (this.mc.gameSettings.creativeDebug ? "Disable " : "Enable ") + "Debug ;)";
+
+				((ContainerCreative)this.inventorySlots).inventory =
+						this.inventory = this.mc.gameSettings.creativeDebug
+								? InventoryReadonly.generateCreativeInventory(true)
+								: InventoryReadonly.getCreativeInventory();
+				this.maxRow = this.inventory.getSize() / 8 - 7;
+				this.row = 0;
+
+				this.setupItems();
+				this.setupControls();
+				break;
+
+			case 101:
+//				this.mc.worldRenderer.toggleFullbright();
+				break;
+
+			case 102:
+				this.mc.thePlayer.noClip = !this.mc.thePlayer.noClip;
+//				this.mc.thePlayer.flying = this.mc.thePlayer.noClip;
+				break;
+
+			case 103:
+				this.mc.theWorld.setWorldTime(1000);
+				break;
+
+			case 104:
+				this.mc.theWorld.setWorldTime(14000);
+				break;
+
+			case 105:
+				this.mc.theWorld.setWorldTime(12000);
+				break;
+		}
+
+		if (var1.id >= 200) {
+			this.row = var1.id - 201;
+			if (this.row > this.maxRow) {
+				this.row = this.maxRow;
+			}
+		}
+
+		setupItems();
+		if (var1.id != 4) {
+			this.rowSlider.sliderValue = row / rowSlider.multiplier;
+			this.rowSlider.displayString = this.rowSlider.getDisplayString();
+		}
+	}
+
+	public void updateScreen() {
+		int oldRow = this.row;
+		this.row = (int) this.rowSlider.getValue();
+		if (this.row != oldRow) {
+			setupItems();
+		}
+	}
+
+	protected void mouseScrolled(int delta) {
+		this.rowSlider.mouseScrolled(delta);
+	}
+}
--- net/minecraft/game/world/Explosion.java
+++ net/minecraft/game/world/Explosion.java
@@ -111,8 +111,7 @@
 		}
 
 		this.explosionSize = var1;
-		ArrayList var32 = new ArrayList();
-		var32.addAll(this.destroyedBlockPositions);
+		ArrayList var32 = new ArrayList(this.destroyedBlockPositions);
 		if(this.isFlaming) {
 			for(int var34 = var32.size() - 1; var34 >= 0; --var34) {
 				ChunkPosition var35 = (ChunkPosition)var32.get(var34);
@@ -131,8 +130,7 @@
 
 	public void doExplosionB(boolean var1) {
 		this.worldObj.playSoundEffect(this.explosionX, this.explosionY, this.explosionZ, "random.explode", 4.0F, (1.0F + (this.worldObj.rand.nextFloat() - this.worldObj.rand.nextFloat()) * 0.2F) * 0.7F);
-		ArrayList var2 = new ArrayList();
-		var2.addAll(this.destroyedBlockPositions);
+		ArrayList var2 = new ArrayList(this.destroyedBlockPositions);
 
 		for(int var3 = var2.size() - 1; var3 >= 0; --var3) {
 			ChunkPosition var4 = (ChunkPosition)var2.get(var3);
@@ -248,8 +246,7 @@
 		}
 
 		this.explosionSize = var1;
-		ArrayList var32 = new ArrayList();
-		var32.addAll(this.destroyedBlockPositions);
+		ArrayList var32 = new ArrayList(this.destroyedBlockPositions);
 		if(this.isFlaming) {
 			for(int var34 = var32.size() - 1; var34 >= 0; --var34) {
 				ChunkPosition var35 = (ChunkPosition)var32.get(var34);
@@ -268,8 +265,7 @@
 
 	public void doEffects(boolean var1) {
 		this.worldObj.playSoundEffect(this.explosionX, this.explosionY, this.explosionZ, "random.explode", 4.0F, (1.0F + (this.worldObj.rand.nextFloat() - this.worldObj.rand.nextFloat()) * 0.2F) * 0.7F);
-		ArrayList var2 = new ArrayList();
-		var2.addAll(this.destroyedBlockPositions);
+		ArrayList var2 = new ArrayList(this.destroyedBlockPositions);
 
 		for(int var3 = var2.size() - 1; var3 >= 0; --var3) {
 			ChunkPosition var4 = (ChunkPosition)var2.get(var3);
--- net/minecraft/client/gui/IngameMenuScreen.java
+++ net/minecraft/client/gui/IngameMenuScreen.java
@@ -15,15 +15,15 @@
 		this.updateCounter2 = 0;
 		this.controlList.clear();
 		byte var1 = -16;
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 120 + var1, "Save and quit to title"));
+		this.controlList.add(new GuiButton(1, -100, 104, "Save and quit to title").alignedAt(0.5F, 0.25F));
 		if(this.mc.isMultiplayerWorld()) {
 			((GuiButton)this.controlList.get(0)).displayString = "Disconnect";
 		}
 
-		this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 24 + var1, "Back to game"));
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 96 + var1, "Options..."));
-		this.controlList.add(new GuiButton(5, this.width / 2 - 100, this.height / 4 + 48 + var1, 98, 20, StatCollector.translateToLocal("gui.achievements")));
-		this.controlList.add(new GuiButton(6, this.width / 2 + 2, this.height / 4 + 48 + var1, 98, 20, StatCollector.translateToLocal("gui.stats")));
+		this.controlList.add(new GuiButton(4, -100, 8, "Back to game").alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(0, -100, 80, "Options...").alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(5, -100, 32, 98, 20, StatCollector.translateToLocal("gui.achievements")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(6, 2, 32, 98, 20, StatCollector.translateToLocal("gui.stats")).alignedAt(0.5F, 0.25F));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -62,7 +62,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		boolean var4 = !this.mc.theWorld.saveLevelButMoreComplicated(this.updateCounter2++);
 		if(var4 || this.updateCounter < 20) {
 			float var5 = ((float)(this.updateCounter % 10) + var3) / 10.0F;
--- /dev/null
+++ net/minecraft/game/world/biome/SavannaBiome.java
@@ -1,0 +1,55 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.feature.Feature;
+import net.minecraft.game.world.terrain.feature.MahoganyTreeFeature;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+
+import java.util.Random;
+
+public class SavannaBiome extends Biome {
+	private PerlinNoiseOctaves mudNoise;
+
+	public SavannaBiome(int i) {
+		super(i);
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(15.0D, 25.0D)
+				.heightOffset(0.0D, 8.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings()
+				.selectorThreshold(0.0D)
+				.heightOffset(50.0D, 5.0D);
+	}
+
+	protected void initializeNoise(Random random) {
+		this.mudNoise = new PerlinNoiseOctaves(random, 3);
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return Math.max(treeBonus + treeNoise * 2 / 3, 1);
+	}
+
+	public Feature getRandomTreeFeature(Random var1) {
+		return new MahoganyTreeFeature();
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		super.buildSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+
+		int wx = chunk.xPosition * 16 + x;
+		int wz = chunk.zPosition * 16 + z;
+
+		double mudValue = this.mudNoise.generateNoiseNormalized2D(wx * 0.08D, wz * 0.08D);
+		if (mudValue > 0.4D + random.nextDouble() * 0.15D) {
+			chunk.setBlockRaw(x, surfaceHeight, z, 0);
+			chunk.setBlockRaw(x, surfaceHeight - 1, z, Block.mud.blockID);
+		}
+	}
+}
--- net/minecraft/game/item/ToolItem.java
+++ net/minecraft/game/item/ToolItem.java
@@ -3,31 +3,34 @@
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.world.block.Block;
+import net.minecraft.util.StringTranslate;
+
+import java.util.List;
+
+import static net.minecraft.util.StringTranslate.i18nf;
 
 public class ToolItem extends Item {
-	private Block[] blocksEffectiveAgainst;
+	private ToolType toolType;
 	private float efficiencyOnProperMaterial = 4.0F;
 	private int damageVsEntity;
-	protected ToolMaterial toolMaterial;
-
-	protected ToolItem(int var1, int var2, ToolMaterial var3, Block[] var4) {
+	protected final int harvestLevel;
+
+	protected ToolItem(int var1, int var2, ToolMaterial var3, ToolType var4) {
+		this(var1, var2 + var3.getDamageVsEntity(), var3.getMaxUses(), var3.getEfficiencyOnProperMaterial(), var3.getHarvestLevel(), var4);
+	}
+
+	protected ToolItem(int var1, int damage, int maxUses, float efficiency, int harvestLevel, ToolType var4) {
 		super(var1);
-		this.toolMaterial = var3;
-		this.blocksEffectiveAgainst = var4;
+		this.harvestLevel = harvestLevel;
+		this.toolType = var4;
 		this.maxStackSize = 1;
-		this.setMaxDamage(var3.getMaxUses());
-		this.efficiencyOnProperMaterial = var3.getEfficiencyOnProperMaterial();
-		this.damageVsEntity = var2 + var3.getDamageVsEntity();
+		this.setMaxDamage(maxUses);
+		this.efficiencyOnProperMaterial = efficiency;
+		this.damageVsEntity = damage;
 	}
 
 	public float getStrengthAgainstBlock(ItemStack var1, Block var2) {
-		for(int var3 = 0; var3 < this.blocksEffectiveAgainst.length; ++var3) {
-			if(this.blocksEffectiveAgainst[var3] == var2) {
-				return this.efficiencyOnProperMaterial;
-			}
-		}
-
-		return 1.0F;
+		return var2.effectiveTool == this.toolType ? this.efficiencyOnProperMaterial : 1.0F;
 	}
 
 	public boolean hitEntity(ItemStack var1, LivingEntity var2, LivingEntity var3) {
@@ -46,5 +49,17 @@
 
 	public boolean hasToolGrip() {
 		return true;
+	}
+
+	public boolean canHarvestBlock(Block var1) {
+		return var1.effectiveTool == this.toolType && var1.harvestLevel <= this.harvestLevel;
+	}
+
+	public void buildTooltipFromStack(ItemStack var1, List<String> tooltip) {
+		super.buildTooltipFromStack(var1, tooltip);
+		tooltip.add(i18nf("tooltip.efficiency", StringTranslate.formatFloat(this.efficiencyOnProperMaterial)));
+		if (this.damageVsEntity > 1) {
+			tooltip.add(i18nf("tooltip.damage", this.damageVsEntity));
+		}
 	}
 }
--- net/minecraft/client/gui/ErrorScreen.java
+++ net/minecraft/client/gui/ErrorScreen.java
@@ -19,7 +19,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, "Out of memory!", this.width / 2, this.height / 4 - 60 + 20, 16777215);
 		this.drawString(this.fontRenderer, "Minecraft has run out of memory.", this.width / 2 - 140, this.height / 4 - 60 + 60 + 0, 10526880);
 		this.drawString(this.fontRenderer, "This could be caused by a bug in the game or by the", this.width / 2 - 140, this.height / 4 - 60 + 60 + 18, 10526880);
--- net/minecraft/game/entity/monster/SlimeEntity.java
+++ net/minecraft/game/entity/monster/SlimeEntity.java
@@ -3,7 +3,6 @@
 import com.mojang.nbt.CompoundTag;
 import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
-import net.minecraft.game.item.Item;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.util.MathHelper;
@@ -24,11 +23,11 @@
 
 	protected void entityInit() {
 		super.entityInit();
-		this.properties.addProperty(16, new Byte((byte)1));
+		this.properties.addProperty(16, (byte) 1);
 	}
 
 	public void setSlimeSize(int var1) {
-		this.properties.updateProperty(16, new Byte((byte)var1));
+		this.properties.updateProperty(16, (byte) var1);
 		this.setSize(0.6F * (float)var1, 0.6F * (float)var1);
 		this.health = var1 * var1;
 		this.setPosition(this.posX, this.posY, this.posZ);
@@ -105,7 +104,7 @@
 
 	public void setEntityDead() {
 		int var1 = this.getSlimeSize();
-		if(!this.worldObj.remoteWorld && var1 > 1 && this.health == 0) {
+		if(!this.worldObj.remoteWorld && var1 > 1 && this.health <= 0) {
 			for(int var2 = 0; var2 < 4; ++var2) {
 				float var3 = ((float)(var2 % 2) - 0.5F) * (float)var1 / 4.0F;
 				float var4 = ((float)(var2 / 2) - 0.5F) * (float)var1 / 4.0F;
@@ -133,10 +132,6 @@
 
 	protected String getDeathSound() {
 		return "mob.slime";
-	}
-
-	protected int getDropItemId() {
-		return this.getSlimeSize() == 1 ? Item.slimeBall.itemID : 0;
 	}
 
 	public boolean getCanSpawnHere() {
--- argo/J_JsonTrueNodeBuilder.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package argo;
-
-final class J_JsonTrueNodeBuilder implements J_JsonNodeBuilder {
-	public J_JsonNode func_27234_b() {
-		return J_JsonNodeFactories.func_27313_b();
-	}
-}
--- /dev/null
+++ net/minecraft/game/world/biome/CachedBiomeRegion.java
@@ -1,0 +1,41 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.util.Array2D;
+import net.minecraft.util.IntArray2D;
+
+public class CachedBiomeRegion {
+	public final Array2D<Biome> biomes = new Array2D<>(Biome[]::new, 16, 16);
+	public final IntArray2D ocean = new IntArray2D(16, 16);
+	public final IntArray2D edge = new IntArray2D(16, 16);
+	public final IntArray2D[] colors = new IntArray2D[3];
+
+	public CachedBiomeRegion(BiomeSource biomeSource, int x, int z) {
+		biomeSource.loadBlockGeneratorData(this.biomes.getArray(), x << 4, z << 4, 16, 16);
+		biomeSource.loadOceanData(this.ocean.getArray(), x << 4, z << 4, 16, 16);
+		biomeSource.loadEdgeData(this.edge.getArray(), x << 4, z << 4, 16, 16);
+		if (biomeSource instanceof ClimaticBiomeSource) {
+			((ClimaticBiomeSource) biomeSource).blockGeneratorData = this.biomes.getArray();
+		}
+
+		for (BiomeColorType colorType : BiomeColorType.values()) {
+			this.colors[colorType.ordinal()] = new IntArray2D(16, 16);
+			biomeSource.loadColorData(this.colors[colorType.ordinal()].getArray(), x << 4, z << 4, 16, 16, colorType);
+		}
+	}
+
+	public Biome getBiome(int x, int z) {
+		return this.biomes.get(x, z);
+	}
+
+	public int getEdge(int x, int z) {
+		return this.edge.get(x, z);
+	}
+
+	public int getOcean(int x, int z) {
+		return this.ocean.get(x, z);
+	}
+
+	public int getColor(int x, int z, BiomeColorType type) {
+		return this.colors[type.ordinal()].get(x, z);
+	}
+}
--- net/minecraft/server/world/WorldServerMulti.java
+++ net/minecraft/server/world/WorldServerMulti.java
@@ -1,11 +1,12 @@
 package net.minecraft.server.world;
 
+import net.minecraft.game.world.NewWorldInfo;
 import net.minecraft.game.world.save.SaveHandler;
 import net.minecraft.server.MinecraftServer;
 
 public class WorldServerMulti extends WorldServer {
-	public WorldServerMulti(MinecraftServer var1, SaveHandler var2, String var3, int var4, long var5, WorldServer var7) {
-		super(var1, var2, var3, var4, var5);
+	public WorldServerMulti(MinecraftServer var1, SaveHandler var2, int var4, NewWorldInfo var3, WorldServer var7) {
+		super(var1, var2, var4, var3);
 		this.mapStorage = var7.mapStorage;
 	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerInitEdge.java
@@ -1,0 +1,18 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.IntArray2D;
+
+public class LayerInitEdge extends Layer {
+	public LayerInitEdge(long seed, Layer parent) {
+		super(seed, parent);
+	}
+
+	public LayerInitEdge(Layer parent) {
+		super(0L, parent);
+	}
+
+	protected IntArray2D getData(int x, int z, int width, int length) {
+		return forEachWithNeighbors(x, z, width, length, (i, ox, oz, neighbors) ->
+				allNeighborsEqual(neighbors, i) ? 0 : 1);
+	}
+}
--- net/minecraft/game/item/recipe/RecipesArmor.java
+++ net/minecraft/game/item/recipe/RecipesArmor.java
@@ -14,7 +14,7 @@
 
 			for(int var4 = 0; var4 < this.recipeItems.length - 1; ++var4) {
 				Item var5 = (Item)this.recipeItems[var4 + 1][var2];
-				var1.addRecipe(new ItemStack(var5), new Object[]{this.recipePatterns[var4], Character.valueOf('X'), var3});
+				var1.addRecipe(new ItemStack(var5), this.recipePatterns[var4], 'X', var3);
 			}
 		}
 
--- net/minecraft/client/render/texture/TextureWatchFX.java
+++ net/minecraft/client/render/texture/TextureWatchFX.java
@@ -20,8 +20,8 @@
 
 		try {
 			BufferedImage var2 = ImageIO.read(Minecraft.class.getResource("/gui/items.png"));
-			int var3 = this.iconIndex % 16 * 16;
-			int var4 = this.iconIndex / 16 * 16;
+			int var3 = this.iconIndex % 32 * 16;
+			int var4 = this.iconIndex / 32 * 16;
 			var2.getRGB(var3, var4, 16, 16, this.watchIconImageData, 0, 16);
 			var2 = ImageIO.read(Minecraft.class.getResource("/misc/dial.png"));
 			var2.getRGB(0, 0, 16, 16, this.dialImageData, 0, 16);
--- net/minecraft/client/gui/ConnectingScreen.java
+++ net/minecraft/client/gui/ConnectingScreen.java
@@ -29,7 +29,7 @@
 	public void initGui() {
 		StringTranslate var1 = StringTranslate.getInstance();
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 120 + 12, var1.translateKey("gui.cancel")));
+		this.controlList.add(new GuiButton(0, -100, 132, var1.translateKey("gui.cancel")).alignedAt(0.5F, 0.25F));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -45,7 +45,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		StringTranslate var4 = StringTranslate.getInstance();
 		if(this.clientHandler == null) {
 			this.drawCenteredString(this.fontRenderer, var4.translateKey("connect.connecting"), this.width / 2, this.height / 2 - 50, 16777215);
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/VertexFormats.java
@@ -1,0 +1,25 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public class VertexFormats {
+	public static final VertexFormatElement POSITION_ELEMENT = new VertexFormatElement(0, VertexFormatElement.ComponentType.FLOAT, VertexFormatElement.Type.POSITION, 3);
+	public static final VertexFormatElement COLOR_ELEMENT = new VertexFormatElement(0, VertexFormatElement.ComponentType.UBYTE, VertexFormatElement.Type.COLOR, 4);
+	public static final VertexFormatElement TEXTURE_0_ELEMENT = new VertexFormatElement(0, VertexFormatElement.ComponentType.FLOAT, VertexFormatElement.Type.UV, 2);
+	public static final VertexFormatElement NORMAL_ELEMENT = new VertexFormatElement(0, VertexFormatElement.ComponentType.BYTE, VertexFormatElement.Type.NORMAL, 3);
+	public static final VertexFormatElement PADDING_ELEMENT = new VertexFormatElement(0, VertexFormatElement.ComponentType.BYTE, VertexFormatElement.Type.PADDING, 1);
+	public static final VertexFormat POSITION_TEXTURE_COLOR_NORMAL = new VertexFormat(getTexColNormFormat());
+
+	private static Map<String, VertexFormatElement> getTexColNormFormat() {
+		Map<String, VertexFormatElement> map = new LinkedHashMap<>();
+		map.put("Position", POSITION_ELEMENT);
+		map.put("UV0", TEXTURE_0_ELEMENT);
+		map.put("Color", COLOR_ELEMENT);
+		map.put("Normal", NORMAL_ELEMENT);
+		map.put("Padding", PADDING_ELEMENT);
+		return Collections.unmodifiableMap(map);
+	}
+
+}
--- /dev/null
+++ net/minecraft/game/world/biome/MapleForestBiome.java
@@ -1,0 +1,81 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.feature.BigTreeFeature;
+import net.minecraft.game.world.terrain.feature.Feature;
+
+import java.util.Random;
+
+public class MapleForestBiome extends Biome {
+	private final NoiseSettings bloomingEdgeNoiseSettings = this.buildEdgeNoiseSettings().build();
+	private final boolean blooming;
+
+	protected MapleForestBiome(int id) {
+		this(id, false);
+	}
+
+	protected MapleForestBiome(int id, boolean blooming) {
+		super(id);
+		this.blooming = blooming;
+		this.rebuildNoiseSettings();
+	}
+
+	protected Biome enableSnow() {
+		super.enableSnow();
+		this.rebuildNoiseSettings();
+		return this;
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		if (this.blooming) {
+			double hoOff = this.getEnableSnow() ? 10.0D : 20.0D;
+			return super.buildNoiseSettings()
+					.noiseStretch(20.0D)
+					.heightOffset(hoOff, hoOff + 10.0D)
+					.selectorOffset(-0.25D);
+		}
+
+		return super.buildNoiseSettings()
+				.noiseStretch(80.0D)
+				.heightOffset(20.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		if (this.blooming) {
+			double hoOff = this.getEnableSnow() ? 10.0D : 50.0D;
+			return this.buildNoiseSettings()
+					.noiseStretch(30.0D)
+					.heightOffset(hoOff, hoOff + 10);
+		}
+
+		return this.buildNoiseSettings()
+				.noiseStretch(120.0D)
+				.heightOffset(30.0D);
+	}
+
+	protected NoiseSettings.Builder buildEdgeNoiseSettings() {
+		return this.buildNoiseSettings()
+				.heightOffset(5.0D, 10.0D);
+	}
+
+	public NoiseSettings getNoiseSettings(int x, int z, double boost, double ocean, double edge) {
+		NoiseSettings noiseSettings = super.getNoiseSettings(x, z, boost, ocean, edge);
+		if (this.blooming) noiseSettings = new NoiseSettings(this.bloomingEdgeNoiseSettings, noiseSettings, Math.min(edge * 2.0D, 1.0D));
+		return noiseSettings;
+	}
+
+	public Feature getRandomTreeFeature(Random var1) {
+		return var1.nextInt(3) != 0 || this.blooming ? new BigTreeFeature(2, this.blooming ? 66 : 2) : super.getRandomTreeFeature(var1);
+	}
+
+	public Feature modifyGrownTree(Feature var1, Random var2) {
+		if (this.blooming && var1 instanceof BigTreeFeature && ((BigTreeFeature) var1).getLeavesMetadata() < 64) {
+			var1 = new BigTreeFeature(2, ((BigTreeFeature) var1).getLeavesMetadata() + 64);
+		}
+		return super.modifyGrownTree(var1, var2);
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return this.blooming ? treeBonus + treeNoise + (this.getEnableSnow() ? 2 : 4) : 10;
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/Layer.java
@@ -1,0 +1,247 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.BiomeColorType;
+import net.minecraft.util.IntArray2D;
+
+import java.util.function.IntUnaryOperator;
+import java.util.function.UnaryOperator;
+
+public abstract class Layer {
+	private long worldSeed;
+	private long chunkSeed;
+	private long baseSeed;
+	public final long seed;
+	protected Layer parent;
+
+	private int lastQueryX;
+	private int lastQueryZ;
+	private int lastQueryWidth;
+	private int lastQueryLength;
+	private IntArray2D lastQueryData;
+
+	public static Layer[] getLayerArray(long seed) {
+		return getLayerArray(null, seed);
+	}
+
+	public static Layer[] getLayerArray(World world) {
+		return getLayerArray(world, world.getRandomSeed());
+	}
+
+	private static Layer[] getLayerArray(World world, long seed) {
+		final int colorSpread = 4;
+		final int edgeDistance = 5;
+
+		Layer land = new LayerLand(100);
+		Layer biomes = new LayerClimaticBiomes(200);
+		biomes = new LayerVoronoiZoom(500, biomes);
+		biomes = new LayerApplyVariants(3000, biomes, 0);
+		biomes = new LayerApplyVariants(3001, biomes, 1);
+
+		for (int i = 0; i < 3; i++) {
+			biomes = new LayerZoom(1000 + i, biomes);
+			biomes = new LayerSmooth(2000 + i, biomes);
+			if (i == 0) biomes = new LayerApplyVariants(3002 + i, biomes, i + 2);
+		}
+
+		Layer edge = new LayerInitEdge(biomes);
+		edge = stack(edge, LayerEdge::new, edgeDistance - 1);
+		edge = new LayerFillEdge(edge, edgeDistance);
+
+		Layer grassColor = new LayerGetColor(biomes, world, colorSpread, BiomeColorType.GRASS);
+		Layer foliageColor = new LayerGetColor(biomes, world, colorSpread, BiomeColorType.FOLIAGE);
+		Layer skyColor = new LayerGetColor(biomes, world, colorSpread, BiomeColorType.SKY);
+
+		for (int i = 0; i < colorSpread; i++) {
+			biomes = new LayerZoom(1100 + i, biomes);
+			biomes = new LayerSmooth(2100 + i, biomes);
+			edge = new LayerSmoothZoom(3100 + i, edge);
+		}
+
+		grassColor = stack(grassColor, LayerSmoothZoomRGB::new, 5000 + colorSpread, colorSpread);
+		foliageColor = stack(foliageColor, LayerSmoothZoomRGB::new, 5000 + colorSpread, colorSpread);
+		skyColor = stack(skyColor, LayerSmoothZoomRGB::new, 5000 + colorSpread, colorSpread);
+
+		biomes = new LayerApplyBiomesToLand(biomes, land);
+
+		Layer[] layers = new Layer[] { biomes, land, edge, grassColor, foliageColor, skyColor };
+		for (Layer layer : layers) {
+			layer.setWorldSeed(seed);
+		}
+		return layers;
+	}
+
+	public Layer(long seed) {
+		this.seed = seed;
+		this.baseSeed = seed;
+		this.baseSeed *= this.baseSeed * 6364136223846793005L + 1442695040888963407L;
+		this.baseSeed += seed;
+		this.baseSeed *= this.baseSeed * 6364136223846793005L + 1442695040888963407L;
+		this.baseSeed += seed;
+		this.baseSeed *= this.baseSeed * 6364136223846793005L + 1442695040888963407L;
+		this.baseSeed += seed;
+	}
+
+	public Layer(long seed, Layer parent) {
+		this(seed);
+		this.parent = parent;
+	}
+
+	public static Layer stack(Layer baseLayer, UnaryOperator<Layer> constructor, int count) {
+		return stack(baseLayer, (s, p) -> constructor.apply(p), 0, count);
+	}
+
+	public static Layer stack(Layer baseLayer, LayerConstructor constructor, long seed, int count) {
+		for (int i = 0; i < count; i++) {
+			baseLayer = constructor.create(seed + i, baseLayer);
+		}
+		return baseLayer;
+	}
+
+	public void setWorldSeed(long seed) {
+		this.worldSeed = seed;
+		if(this.parent != null) {
+			this.parent.setWorldSeed(seed);
+		}
+
+		this.worldSeed *= this.worldSeed * 6364136223846793005L + 1442695040888963407L;
+		this.worldSeed += this.baseSeed;
+		this.worldSeed *= this.worldSeed * 6364136223846793005L + 1442695040888963407L;
+		this.worldSeed += this.baseSeed;
+		this.worldSeed *= this.worldSeed * 6364136223846793005L + 1442695040888963407L;
+		this.worldSeed += this.baseSeed;
+	}
+
+	public void setChunkSeed(long x, long z) {
+		this.chunkSeed = this.worldSeed;
+		this.chunkSeed *= this.chunkSeed * 6364136223846793005L + 1442695040888963407L;
+		this.chunkSeed += x;
+		this.chunkSeed *= this.chunkSeed * 6364136223846793005L + 1442695040888963407L;
+		this.chunkSeed += z;
+		this.chunkSeed *= this.chunkSeed * 6364136223846793005L + 1442695040888963407L;
+		this.chunkSeed += x;
+		this.chunkSeed *= this.chunkSeed * 6364136223846793005L + 1442695040888963407L;
+		this.chunkSeed += z;
+	}
+
+	protected long getWorldSeed() {
+		return this.worldSeed;
+	}
+
+	protected int nextInt(int bound) {
+		int var2 = (int)((this.chunkSeed >> 24) % (long)bound);
+		if(var2 < 0) {
+			var2 += bound;
+		}
+
+		this.chunkSeed *= this.chunkSeed * 6364136223846793005L + 1442695040888963407L;
+		this.chunkSeed += this.worldSeed;
+		return var2;
+	}
+
+	protected abstract IntArray2D getData(int x, int z, int width, int length);
+
+	public IntArray2D getCachedData(int x, int z, int width, int length) {
+		if (this.lastQueryX == x && this.lastQueryZ == z
+				&& this.lastQueryWidth == width && this.lastQueryLength == length
+				&& this.lastQueryData != null) {
+			return this.lastQueryData;
+		}
+
+		this.lastQueryX = x;
+		this.lastQueryZ = z;
+		this.lastQueryWidth = width;
+		this.lastQueryLength = length;
+		this.lastQueryData = this.getData(x, z, width, length);
+		return this.lastQueryData;
+	}
+
+	protected IntArray2D forEach(int x, int z, int width, int length, IntUnaryOperator operator) {
+		return forEach(x, z, width, length, (i, ox, oz) -> operator.applyAsInt(i));
+	}
+
+	protected IntArray2D forEach(int x, int z, int width, int length, LayerOperator operator) {
+		IntArray2D input = this.parent != null ? this.parent.getCachedData(x, z, width, length) : null;
+		IntArray2D output = new IntArray2D(width, length);
+
+		for (int xx = 0; xx < width; xx++) {
+			for (int zz = 0; zz < length; zz++) {
+				this.setChunkSeed(xx + x, zz + z);
+				output.set(xx, zz, operator.apply(input != null ? input.get(xx, zz) : 0, xx, zz));
+			}
+		}
+
+		return output;
+	}
+
+	protected IntArray2D forEachWithNeighbors(int x, int z, int width, int length, NeighborLayerOperator operator) {
+		return forEachWithNeighbors(x, z, width, length, true, false, operator);
+	}
+
+	protected IntArray2D forEachWithNeighbors(int x, int z, int width, int length, boolean side, boolean diagonal, NeighborLayerOperator operator) {
+		if (!side && !diagonal) throw new IllegalArgumentException("Pick a direction! You gotta do it!");
+
+		int inX = x - 1;
+		int inZ = z - 1;
+		int inWidth = width + 2;
+		int inLength = length + 2;
+
+		IntArray2D input = this.parent != null ? this.parent.getCachedData(inX, inZ, inWidth, inLength) : null;
+		IntArray2D output = new IntArray2D(width, length);
+		int[] neighbors = new int[side && diagonal ? 8 : 4];
+
+		for (int xx = 0; xx < width; xx++) {
+			for (int zz = 0; zz < length; zz++) {
+				int inputPoint = 0;
+				if (input != null) {
+					inputPoint = input.get(xx + 1, zz + 1);
+					if (diagonal) {
+						neighbors[0] = input.get(xx, zz);
+						neighbors[1] = input.get(xx + 2, zz);
+						neighbors[2] = input.get(xx, (zz + 2));
+						neighbors[3] = input.get(xx + 2, (zz + 2));
+						if (side) {
+							neighbors[4] = input.get(xx, (zz + 1));
+							neighbors[5] = input.get(xx + 2, (zz + 1));
+							neighbors[6] = input.get(xx + 1, zz);
+							neighbors[7] = input.get(xx + 1, (zz + 2));
+						}
+					} else {
+						neighbors[0] = input.get(xx, (zz + 1));
+						neighbors[1] = input.get(xx + 2, (zz + 1));
+						neighbors[2] = input.get(xx + 1, zz);
+						neighbors[3] = input.get(xx + 1, (zz + 2));
+					}
+				}
+
+				this.setChunkSeed(xx + x, zz + z);
+				output.set(xx, zz, operator.apply(inputPoint, xx + x, zz + z, neighbors));
+			}
+		}
+
+		return output;
+	}
+
+	protected static boolean allNeighborsEqual(int[] neighbors, int i) {
+		return neighbors[0] == i && neighbors[1] == i && neighbors[2] == i && neighbors[3] == i;
+	}
+
+	protected static boolean neighborsContain(int[] neighbors, int i) {
+		return neighbors[0] == i || neighbors[1] == i || neighbors[2] == i || neighbors[3] == i;
+	}
+
+	@FunctionalInterface
+	public interface LayerOperator {
+		int apply(int i, int ox, int oz);
+	}
+
+	@FunctionalInterface
+	public interface NeighborLayerOperator {
+		int apply(int i, int ox, int oz, int... neighbors);
+	}
+
+	@FunctionalInterface
+	public interface LayerConstructor {
+		Layer create(long seed, Layer parent);
+	}
+}
--- net/minecraft/client/gui/AchievementOverlayGui.java
+++ net/minecraft/client/gui/AchievementOverlayGui.java
@@ -61,21 +61,6 @@
 	}
 
 	public void updateAchievementWindow() {
-		if(Minecraft.hasPaidCheckTime > 0L) {
-			GL11.glDisable(GL11.GL_DEPTH_TEST);
-			GL11.glDepthMask(false);
-			RenderHelper.disableStandardItemLighting();
-			this.updateAchievementWindowScale();
-			String var1 = "Minecraft Beta 1.7.3   Unlicensed Copy :(";
-			String var2 = "(Or logged in from another location)";
-			String var3 = "Purchase at minecraft.net";
-			this.theGame.fontRenderer.drawStringWithShadow(var1, 2, 2, 16777215);
-			this.theGame.fontRenderer.drawStringWithShadow(var2, 2, 11, 16777215);
-			this.theGame.fontRenderer.drawStringWithShadow(var3, 2, 20, 16777215);
-			GL11.glDepthMask(true);
-			GL11.glEnable(GL11.GL_DEPTH_TEST);
-		}
-
 		if(this.theAchievement != null && this.field_25083_f != 0L) {
 			double var8 = (double)(System.currentTimeMillis() - this.field_25083_f) / 3000.0D;
 			if(this.field_27103_i || this.field_27103_i || var8 >= 0.0D && var8 <= 1.0D) {
--- argo/J_JsonNumberNodeBuilder.java
+++ /dev/null
@@ -1,13 +1,0 @@
-package argo;
-
-final class J_JsonNumberNodeBuilder implements J_JsonNodeBuilder {
-	private final J_JsonNode field_27239_a;
-
-	J_JsonNumberNodeBuilder(String var1) {
-		this.field_27239_a = J_JsonNodeFactories.func_27311_b(var1);
-	}
-
-	public J_JsonNode func_27234_b() {
-		return this.field_27239_a;
-	}
-}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/Uniform.java
@@ -1,0 +1,17 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import org.lwjgl.util.vector.Vector3f;
+
+public class Uniform {
+	public void set(float value1, float value2, float value3) {}
+
+	public void setForDataType(float value1, float value2, float value3, float value4) {}
+
+	public void setForDataType(int value1, int value2, int value3, int value4) {}
+
+	public void set(int value) {}
+
+	public void set(float[] values) {}
+
+	public void set(Vector3f vector) {}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerZoom.java
@@ -1,0 +1,44 @@
+package net.minecraft.game.world.biome.layers;
+
+public class LayerZoom extends LayerZoomBase {
+	public LayerZoom(long seed, Layer parent) {
+		super(seed, parent);
+	}
+
+	protected int interpolate(int a, int b) {
+		return nextInt(2) == 0 ? a : b;
+	}
+
+	protected int interpolate(int a, int b, int c, int d) {
+		if(b == c && c == d) {
+			return b;
+		} else if(a == b && a == c) {
+			return a;
+		} else if(a == b && a == d) {
+			return a;
+		} else if(a == c && a == d) {
+			return a;
+		} else if(a == b && c != d) {
+			return a;
+		} else if(a == c && b != d) {
+			return a;
+		} else if(a == d && b != c) {
+			return a;
+		} else if(b == c && a != d) {
+			return b;
+		} else if(b == d && a != c) {
+			return b;
+		} else if(c == d && a != b) {
+			return c;
+		} else {
+			int choice = this.nextInt(4);
+			switch (choice) {
+				case 0: return a;
+				case 1: return b;
+				case 2: return c;
+				case 3: return d;
+				default: throw new IllegalStateException("Unexpected value: " + choice);
+			}
+		}
+	}
+}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/GlUniform.java
@@ -1,0 +1,189 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import net.minecraft.client.render.GLAllocation;
+import org.lwjgl.opengl.GL20;
+import org.lwjgl.util.vector.Vector3f;
+
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+public class GlUniform extends Uniform implements AutoCloseable {
+	public static final int INT1 = 0;
+	public static final int INT2 = 1;
+	public static final int INT3 = 2;
+	public static final int INT4 = 3;
+	public static final int FLOAT1 = 4;
+	public static final int FLOAT2 = 5;
+	public static final int FLOAT3 = 6;
+	public static final int FLOAT4 = 7;
+	public static final int MAT2X2 = 8;
+	public static final int MAT3X3 = 9;
+	public static final int MAT4X4 = 10;
+	private static final boolean TRANSPOSE = false;
+	private int location;
+	private final int count;
+	private final int dataType;
+	private final IntBuffer intData;
+	private final FloatBuffer floatData;
+	private final String name;
+
+	public GlUniform(String name, int dataType, int count) {
+		this.name = name;
+		this.count = count;
+		this.dataType = dataType;
+		if (dataType <= INT4) {
+			this.intData = GLAllocation.createDirectIntBuffer(count);
+			this.floatData = null;
+		} else {
+			this.intData = null;
+			this.floatData = GLAllocation.createDirectFloatBuffer(count);
+		}
+
+		this.location = -1;
+		this.markStateDirty();
+	}
+
+	public static int getUniformLocation(int program, CharSequence name) {
+		return GL20.glGetUniformLocation(program, name);
+	}
+
+	public static void uniform1(int location, int value) {
+		GL20.glUniform1i(location, value);
+	}
+
+	public static void bindAttribLocation(int program, int index, CharSequence name) {
+		GL20.glBindAttribLocation(program, index, name);
+	}
+
+	public void close() {}
+
+	private void markStateDirty() {}
+
+	public static int getTypeIndex(String typeName) {
+		int i = -1;
+		if ("int".equals(typeName)) i = INT1;
+		else if ("float".equals(typeName)) i = FLOAT1;
+		else if (typeName.startsWith("matrix")) if (typeName.endsWith("2x2")) i = MAT2X2;
+		else if (typeName.endsWith("3x3")) i = MAT3X3;
+		else if (typeName.endsWith("4x4")) i = MAT4X4;
+
+		return i;
+	}
+
+	public void setLocation(int location) {
+		this.location = location;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public final void set(float value1, float value2, float value3) {
+		this.floatData.position(0);
+		this.floatData.put(0, value1);
+		this.floatData.put(1, value2);
+		this.floatData.put(2, value3);
+		this.markStateDirty();
+	}
+
+	public final void set(Vector3f vector) {
+		this.floatData.position(0);
+		this.floatData.put(0, vector.getX());
+		this.floatData.put(1, vector.getY());
+		this.floatData.put(2, vector.getZ());
+		this.markStateDirty();
+	}
+
+	public final void setForDataType(float value1, float value2, float value3, float value4) {
+		this.floatData.position(0);
+		if (this.dataType >= FLOAT1) this.floatData.put(0, value1);
+
+		if (this.dataType >= FLOAT2) this.floatData.put(1, value2);
+
+		if (this.dataType >= FLOAT3) this.floatData.put(2, value3);
+
+		if (this.dataType >= FLOAT4) this.floatData.put(3, value4);
+
+		this.markStateDirty();
+	}
+
+	public final void setForDataType(int value1, int value2, int value3, int value4) {
+		this.intData.position(0);
+		if (this.dataType >= INT1) this.intData.put(0, value1);
+
+		if (this.dataType >= INT2) this.intData.put(1, value2);
+
+		if (this.dataType >= INT3) this.intData.put(2, value3);
+
+		if (this.dataType >= INT4) this.intData.put(3, value4);
+
+		this.markStateDirty();
+	}
+
+	public final void set(int value) {
+		this.intData.position(0);
+		this.intData.put(0, value);
+		this.markStateDirty();
+	}
+
+	public final void set(float[] values) {
+		if (values.length < this.count)
+			System.err.printf("Uniform.set called with a too-small value array (expected %s, got %s). Ignoring.%n", this.count, values.length);
+		else {
+			this.floatData.position(0);
+			this.floatData.put(values);
+			this.floatData.position(0);
+			this.markStateDirty();
+		}
+	}
+
+	public final void set(FloatBuffer matrix) {
+		floatData.position(0);
+		floatData.put(matrix);
+		markStateDirty();
+	}
+
+	public void upload() {
+		if (this.dataType <= INT4) this.uploadInts();
+		else if (this.dataType <= FLOAT4) this.uploadFloats();
+		else {
+			if (this.dataType > MAT4X4) {
+				System.err.printf("Uniform.upload called, but type value (%s) is not a valid type. Ignoring.%n", this.dataType);
+				return;
+			}
+
+			this.uploadMatrix();
+		}
+	}
+
+	private void uploadInts() {
+		this.intData.rewind();
+		switch (this.dataType) {
+			case INT1: GL20.glUniform1(this.location, this.intData); break;
+			case INT2: GL20.glUniform2(this.location, this.intData); break;
+			case INT3: GL20.glUniform3(this.location, this.intData); break;
+			case INT4: GL20.glUniform4(this.location, this.intData); break;
+			default: System.err.printf("Uniform.upload called, but count value (%s) is  not in the range of 1 to 4. Ignoring.%n", this.count); break;
+		}
+	}
+
+	private void uploadFloats() {
+		this.floatData.rewind();
+		switch (this.dataType) {
+			case FLOAT1: GL20.glUniform1(this.location, this.floatData); break;
+			case FLOAT2: GL20.glUniform2(this.location, this.floatData); break;
+			case FLOAT3: GL20.glUniform3(this.location, this.floatData); break;
+			case FLOAT4: GL20.glUniform4(this.location, this.floatData); break;
+			default: System.err.printf("Uniform.upload called, but count value (%s) is not in the range of 1 to 4. Ignoring.%n", this.count); break;
+		}
+	}
+
+	private void uploadMatrix() {
+		this.floatData.clear();
+		switch (this.dataType) {
+			case MAT2X2: GL20.glUniformMatrix2(this.location, TRANSPOSE, this.floatData); break;
+			case MAT3X3: GL20.glUniformMatrix3(this.location, TRANSPOSE, this.floatData); break;
+			case MAT4X4: GL20.glUniformMatrix4(this.location, TRANSPOSE, this.floatData); break;
+		}
+	}
+}
--- net/minecraft/game/world/block/BaseLeavesBlock.java
+++ net/minecraft/game/world/block/BaseLeavesBlock.java
@@ -4,11 +4,10 @@
 import net.minecraft.game.world.material.Material;
 
 public class BaseLeavesBlock extends Block {
-	protected boolean fancyGraphics;
+	protected int graphicsLevel;
 
-	protected BaseLeavesBlock(int var1, int var2, Material var3, boolean var4) {
+	protected BaseLeavesBlock(int var1, int var2, Material var3) {
 		super(var1, var2, var3);
-		this.fancyGraphics = var4;
 	}
 
 	public boolean isOpaqueCube() {
@@ -17,6 +16,7 @@
 
 	public boolean shouldSideBeRendered(BlockAccess var1, int var2, int var3, int var4, int var5) {
 		int var6 = var1.getBlockId(var2, var3, var4);
-		return !this.fancyGraphics && var6 == this.blockID ? false : super.shouldSideBeRendered(var1, var2, var3, var4, var5);
+		return (this.graphicsLevel <= 0 || (var1.getBlockIntProperty(var2, var3, var4, LeavesBlock.TYPE) == 4 && var5 < 2))
+				&& var6 == this.blockID ? false : super.shouldSideBeRendered(var1, var2, var3, var4, var5);
 	}
 }
--- net/minecraft/client/render/TextureRegistry.java
+++ net/minecraft/client/render/TextureRegistry.java
@@ -14,6 +14,12 @@
 import java.util.List;
 import java.util.Map;
 import javax.imageio.ImageIO;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import net.minecraft.client.GameSettings;
 import net.minecraft.client.ImageBuffer;
 import net.minecraft.client.render.texture.TextureFX;
@@ -23,11 +29,11 @@
 
 public class TextureRegistry {
 	public static boolean useMipmaps = false;
-	private HashMap textureMap = new HashMap();
+	private Object2IntMap<String> textureMap = new Object2IntOpenHashMap<>();
 	private HashMap field_28151_c = new HashMap();
-	private HashMap textureNameToImageMap = new HashMap();
+	private Int2ObjectMap<BufferedImage> textureNameToImageMap = new Int2ObjectOpenHashMap<>();
 	private IntBuffer singleIntBuffer = GLAllocation.createDirectIntBuffer(1);
-	private ByteBuffer imageData = GLAllocation.createDirectByteBuffer(1048576);
+	private ByteBuffer imageData = GLAllocation.createDirectByteBuffer(8388608);
 	private List textureList = new ArrayList();
 	private Map urlToImageDataMap = new HashMap();
 	private GameSettings options;
@@ -102,9 +108,9 @@
 
 	public int getTexture(String var1) {
 		TexturePackBase var2 = this.texturePack.selectedTexturePack;
-		Integer var3 = (Integer)this.textureMap.get(var1);
-		if(var3 != null) {
-			return var3.intValue();
+		int var3 = this.textureMap.getInt(var1);
+		if(var3 != 0) {
+			return var3;
 		} else {
 			try {
 				this.singleIntBuffer.clear();
@@ -129,14 +135,14 @@
 					}
 				}
 
-				this.textureMap.put(var1, Integer.valueOf(var6));
+				this.textureMap.put(var1, var6);
 				return var6;
 			} catch (IOException var5) {
 				var5.printStackTrace();
 				GLAllocation.generateTextureNames(this.singleIntBuffer);
 				int var4 = this.singleIntBuffer.get(0);
 				this.setupTexture(this.missingTextureImage, var4);
-				this.textureMap.put(var1, Integer.valueOf(var4));
+				this.textureMap.put(var1, var4);
 				return var4;
 			}
 		}
@@ -160,7 +166,7 @@
 		GLAllocation.generateTextureNames(this.singleIntBuffer);
 		int var2 = this.singleIntBuffer.get(0);
 		this.setupTexture(var1, var2);
-		this.textureNameToImageMap.put(Integer.valueOf(var2), var1);
+		this.textureNameToImageMap.put(var2, var1);
 		return var2;
 	}
 
@@ -300,7 +306,7 @@
 	}
 
 	public void deleteTexture(int var1) {
-		this.textureNameToImageMap.remove(Integer.valueOf(var1));
+		this.textureNameToImageMap.remove(var1);
 		this.singleIntBuffer.clear();
 		this.singleIntBuffer.put(var1);
 		this.singleIntBuffer.flip();
@@ -377,7 +383,7 @@
 
 			for(var3 = 0; var3 < var2.tileSize; ++var3) {
 				for(var4 = 0; var4 < var2.tileSize; ++var4) {
-					GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, 0, var2.iconIndex % 16 * 16 + var3 * 16, var2.iconIndex / 16 * 16 + var4 * 16, 16, 16, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
+					GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, 0, var2.iconIndex % 32 * 16 + var3 * 16, var2.iconIndex / 32 * 16 + var4 * 16, 16, 16, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
 					if(useMipmaps) {
 						for(var5 = 1; var5 <= 4; ++var5) {
 							var6 = 16 >> var5 - 1;
@@ -463,21 +469,21 @@
 
 	public void refreshTextures() {
 		TexturePackBase var1 = this.texturePack.selectedTexturePack;
-		Iterator var2 = this.textureNameToImageMap.keySet().iterator();
+		IntIterator var2i = this.textureNameToImageMap.keySet().iterator();
 
 		BufferedImage var4;
-		while(var2.hasNext()) {
-			int var3 = ((Integer)var2.next()).intValue();
-			var4 = (BufferedImage)this.textureNameToImageMap.get(Integer.valueOf(var3));
+		while(var2i.hasNext()) {
+			int var3 = var2i.nextInt();
+			var4 = this.textureNameToImageMap.get(var3);
 			this.setupTexture(var4, var3);
 		}
 
 		ThreadDownloadImageData var8;
-		for(var2 = this.urlToImageDataMap.values().iterator(); var2.hasNext(); var8.textureSetupComplete = false) {
+		for(Iterator var2 = this.urlToImageDataMap.values().iterator(); var2.hasNext(); var8.textureSetupComplete = false) {
 			var8 = (ThreadDownloadImageData)var2.next();
 		}
 
-		var2 = this.textureMap.keySet().iterator();
+		Iterator var2 = this.textureMap.keySet().iterator();
 
 		String var9;
 		while(var2.hasNext()) {
@@ -496,7 +502,7 @@
 					var4 = this.readTextureImage(var1.getResourceAsStream(var9));
 				}
 
-				int var5 = ((Integer)this.textureMap.get(var9)).intValue();
+				int var5 = this.textureMap.getInt(var9);
 				this.setupTexture(var4, var5);
 				this.blurTexture = false;
 				this.clampTexture = false;
--- net/minecraft/client/render/RenderBlocks.java
+++ net/minecraft/client/render/RenderBlocks.java
@@ -4,20 +4,14 @@
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
-import net.minecraft.game.world.block.BedBlock;
-import net.minecraft.game.world.block.Block;
-import net.minecraft.game.world.block.DoorBlock;
-import net.minecraft.game.world.block.LiquidBlock;
-import net.minecraft.game.world.block.ModelBed;
-import net.minecraft.game.world.block.PistonBaseBlock;
-import net.minecraft.game.world.block.PistonExtensionBlock;
-import net.minecraft.game.world.block.RailBlock;
-import net.minecraft.game.world.block.RedstoneRepeaterBlock;
-import net.minecraft.game.world.block.RedstoneWireBlock;
+import net.minecraft.game.world.block.*;
 import net.minecraft.game.world.material.Material;
+import net.minecraft.game.world.terrain.noise.PerlinNoise;
 import net.minecraft.util.MathHelper;
 import org.lwjgl.opengl.GL11;
 
+import java.util.Random;
+
 public class RenderBlocks {
 	private BlockAccess blockAccess;
 	private int overrideBlockTexture = -1;
@@ -85,6 +79,15 @@
 	private boolean field_22357_ad;
 	private boolean field_22355_ae;
 
+	private static final PerlinNoise[] perlinNoise = new PerlinNoise[4];
+
+	static {
+		Random random = new Random();
+		for (int i = 0; i < 4; i++) {
+			perlinNoise[i] = new PerlinNoise(random);
+		}
+	}
+
 	public RenderBlocks(BlockAccess var1) {
 		this.blockAccess = var1;
 	}
@@ -107,14 +110,32 @@
 	public boolean renderBlockByRenderType(Block var1, int var2, int var3, int var4) {
 		int var5 = var1.getRenderType();
 		var1.setBlockBoundsBasedOnState(this.blockAccess, var2, var3, var4);
-		return var5 == 0 ? this.renderStandardBlock(var1, var2, var3, var4) : (var5 == 4 ? this.renderBlockFluids(var1, var2, var3, var4) : (var5 == 13 ? this.renderBlockCactus(var1, var2, var3, var4) : (var5 == 1 ? this.renderBlockReed(var1, var2, var3, var4) : (var5 == 6 ? this.renderBlockCrops(var1, var2, var3, var4) : (var5 == 2 ? this.renderBlockTorch(var1, var2, var3, var4) : (var5 == 3 ? this.renderBlockFire(var1, var2, var3, var4) : (var5 == 5 ? this.renderBlockRedstoneWire(var1, var2, var3, var4) : (var5 == 8 ? this.renderBlockLadder(var1, var2, var3, var4) : (var5 == 7 ? this.renderBlockDoor(var1, var2, var3, var4) : (var5 == 9 ? this.renderBlockMinecartTrack((RailBlock)var1, var2, var3, var4) : (var5 == 10 ? this.renderBlockStairs(var1, var2, var3, var4) : (var5 == 11 ? this.renderBlockFence(var1, var2, var3, var4) : (var5 == 12 ? this.renderBlockLever(var1, var2, var3, var4) : (var5 == 14 ? this.renderBlockBed(var1, var2, var3, var4) : (var5 == 15 ? this.renderBlockRepeater(var1, var2, var3, var4) : (var5 == 16 ? this.func_31074_b(var1, var2, var3, var4, false) : (var5 == 17 ? this.func_31080_c(var1, var2, var3, var4, true) : false)))))))))))))))));
+		return var5 == 0 ? this.renderStandardBlock(var1, var2, var3, var4)
+				: var5 == 1 ? this.renderBlockReed(var1, var2, var3, var4)
+				: var5 == 2 ? this.renderBlockTorch(var1, var2, var3, var4)
+				: var5 == 3 ? this.renderBlockFire(var1, var2, var3, var4)
+				: var5 == 4 ? this.renderBlockFluids(var1, var2, var3, var4)
+				: var5 == 5 ? this.renderBlockRedstoneWire(var1, var2, var3, var4)
+				: var5 == 6 ? this.renderBlockCrops(var1, var2, var3, var4)
+				: var5 == 7 ? this.renderBlockGrass(var1, var2, var3, var4)
+				: var5 == 8 ? this.renderBlockLadder(var1, var2, var3, var4)
+				: var5 == 9 ? this.renderBlockMinecartTrack((RailBlock)var1, var2, var3, var4)
+				: var5 == 10 ? this.renderBlockStairs(var1, var2, var3, var4)
+				: var5 == 11 ? this.renderBlockFence(var1, var2, var3, var4)
+				: var5 == 12 ? this.renderBlockLever(var1, var2, var3, var4)
+				: var5 == 13 ? this.renderBlockCactus(var1, var2, var3, var4)
+				: var5 == 14 ? this.renderBlockBed(var1, var2, var3, var4)
+				: var5 == 15 ? this.renderBlockRepeater(var1, var2, var3, var4)
+				: var5 == 16 ? this.func_31074_b(var1, var2, var3, var4, false)
+				: var5 == 17 ? this.func_31080_c(var1, var2, var3, var4, true)
+				: false;
 	}
 
 	private boolean renderBlockBed(Block var1, int var2, int var3, int var4) {
 		Tessellator var5 = Tessellator.instance;
 		int var6 = this.blockAccess.getBlockMetadata(var2, var3, var4);
-		int var7 = BedBlock.getDirectionFromMetadata(var6);
-		boolean var8 = BedBlock.isBlockFootOfBed(var6);
+		int var7 = var1.properties.getInt(var6, BedBlock.DIRECTION);
+		boolean var8 = var1.properties.getBoolean(var6, BedBlock.IS_HEAD);
 		float var9 = 0.5F;
 		float var10 = 1.0F;
 		float var11 = 0.8F;
@@ -122,12 +143,12 @@
 		float var25 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var9 * var25, var9 * var25, var9 * var25);
 		int var26 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0);
-		int var27 = (var26 & 15) << 4;
-		int var28 = var26 & 240;
-		double var29 = (double)((float)var27 / 256.0F);
-		double var31 = ((double)(var27 + 16) - 0.01D) / 256.0D;
-		double var33 = (double)((float)var28 / 256.0F);
-		double var35 = ((double)(var28 + 16) - 0.01D) / 256.0D;
+		int var27 = (var26 & 31) << 4;
+		int var28 = (var26 & 992) >> 1;
+		double var29 = (double)((float)var27 / 512.0F);
+		double var31 = ((double)(var27 + 16) - 0.01D) / 512.0D;
+		double var33 = (double)((float)var28 / 512.0F);
+		double var35 = ((double)(var28 + 16) - 0.01D) / 512.0D;
 		double var37 = (double)var2 + var1.minX;
 		double var39 = (double)var2 + var1.maxX;
 		double var41 = (double)var3 + var1.minY + 0.1875D;
@@ -140,12 +161,12 @@
 		float var64 = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
 		var5.setColorOpaque_F(var10 * var64, var10 * var64, var10 * var64);
 		var27 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1);
-		var28 = (var27 & 15) << 4;
-		int var67 = var27 & 240;
-		double var30 = (double)((float)var28 / 256.0F);
-		double var32 = ((double)(var28 + 16) - 0.01D) / 256.0D;
-		double var34 = (double)((float)var67 / 256.0F);
-		double var36 = ((double)(var67 + 16) - 0.01D) / 256.0D;
+		var28 = (var27 & 31) << 4;
+		int var67 = (var27 & 992) >> 1;
+		double var30 = (double)((float)var28 / 512.0F);
+		double var32 = ((double)(var28 + 16) - 0.01D) / 512.0D;
+		double var34 = (double)((float)var67 / 512.0F);
+		double var36 = ((double)(var67 + 16) - 0.01D) / 512.0D;
 		double var38 = var30;
 		double var40 = var32;
 		double var42 = var34;
@@ -317,12 +338,12 @@
 		this.renderTorchAtAngle(var1, (double)var2 + var12, (double)var3 + var10, (double)var4 + var14, 0.0D, 0.0D);
 		this.renderTorchAtAngle(var1, (double)var2 + var16, (double)var3 + var10, (double)var4 + var18, 0.0D, 0.0D);
 		int var20 = var1.getBlockTextureFromSide(1);
-		int var21 = (var20 & 15) << 4;
-		int var22 = var20 & 240;
-		double var23 = (double)((float)var21 / 256.0F);
-		double var25 = (double)(((float)var21 + 15.99F) / 256.0F);
-		double var27 = (double)((float)var22 / 256.0F);
-		double var29 = (double)(((float)var22 + 15.99F) / 256.0F);
+		int var21 = (var20 & 31) << 4;
+		int var22 = (var20 & 992) >> 1;
+		double var23 = (double)((float)var21 / 512.0F);
+		double var25 = (double)(((float)var21 + 15.99F) / 512.0F);
+		double var27 = (double)((float)var22 / 512.0F);
+		double var29 = (double)(((float)var22 + 15.99F) / 512.0F);
 		float var31 = 2.0F / 16.0F;
 		float var32 = (float)(var2 + 1);
 		float var33 = (float)(var2 + 1);
@@ -378,7 +399,7 @@
 	private boolean func_31074_b(Block var1, int var2, int var3, int var4, boolean var5) {
 		int var6 = this.blockAccess.getBlockMetadata(var2, var3, var4);
 		boolean var7 = var5 || (var6 & 8) != 0;
-		int var8 = PistonBaseBlock.getOrientation(var6);
+		int var8 = PistonBaseBlock.getOrientation(var6).ordinal();
 		if(var7) {
 			switch(var8) {
 			case 0:
@@ -472,18 +493,18 @@
 	}
 
 	private void func_31076_a(double var1, double var3, double var5, double var7, double var9, double var11, float var13, double var14) {
-		int var16 = 108;
+		int var16 = PistonBaseBlock.TEX_SIDE;
 		if(this.overrideBlockTexture >= 0) {
 			var16 = this.overrideBlockTexture;
 		}
 
-		int var17 = (var16 & 15) << 4;
-		int var18 = var16 & 240;
+		int var17 = (var16 & 31) << 4;
+		int var18 = (var16 & 992) >> 1;
 		Tessellator var19 = Tessellator.instance;
-		double var20 = (double)((float)(var17 + 0) / 256.0F);
-		double var22 = (double)((float)(var18 + 0) / 256.0F);
-		double var24 = ((double)var17 + var14 - 0.01D) / 256.0D;
-		double var26 = ((double)((float)var18 + 4.0F) - 0.01D) / 256.0D;
+		double var20 = (double)((float)(var17 + 0) / 512.0F);
+		double var22 = (double)((float)(var18 + 0) / 512.0F);
+		double var24 = ((double)var17 + var14 - 0.01D) / 512.0D;
+		double var26 = ((double)((float)var18 + 4.0F) - 0.01D) / 512.0D;
 		var19.setColorOpaque_F(var13, var13, var13);
 		var19.addVertexWithUV(var1, var7, var9, var24, var22);
 		var19.addVertexWithUV(var1, var5, var9, var20, var22);
@@ -492,18 +513,18 @@
 	}
 
 	private void func_31081_b(double var1, double var3, double var5, double var7, double var9, double var11, float var13, double var14) {
-		int var16 = 108;
+		int var16 = PistonBaseBlock.TEX_SIDE;
 		if(this.overrideBlockTexture >= 0) {
 			var16 = this.overrideBlockTexture;
 		}
 
-		int var17 = (var16 & 15) << 4;
-		int var18 = var16 & 240;
+		int var17 = (var16 & 31) << 4;
+		int var18 = (var16 & 992) >> 1;
 		Tessellator var19 = Tessellator.instance;
-		double var20 = (double)((float)(var17 + 0) / 256.0F);
-		double var22 = (double)((float)(var18 + 0) / 256.0F);
-		double var24 = ((double)var17 + var14 - 0.01D) / 256.0D;
-		double var26 = ((double)((float)var18 + 4.0F) - 0.01D) / 256.0D;
+		double var20 = (double)((float)(var17 + 0) / 512.0F);
+		double var22 = (double)((float)(var18 + 0) / 512.0F);
+		double var24 = ((double)var17 + var14 - 0.01D) / 512.0D;
+		double var26 = ((double)((float)var18 + 4.0F) - 0.01D) / 512.0D;
 		var19.setColorOpaque_F(var13, var13, var13);
 		var19.addVertexWithUV(var1, var5, var11, var24, var22);
 		var19.addVertexWithUV(var1, var5, var9, var20, var22);
@@ -512,18 +533,18 @@
 	}
 
 	private void func_31077_c(double var1, double var3, double var5, double var7, double var9, double var11, float var13, double var14) {
-		int var16 = 108;
+		int var16 = PistonBaseBlock.TEX_SIDE;
 		if(this.overrideBlockTexture >= 0) {
 			var16 = this.overrideBlockTexture;
 		}
 
-		int var17 = (var16 & 15) << 4;
-		int var18 = var16 & 240;
+		int var17 = (var16 & 31) << 4;
+		int var18 = (var16 & 992) >> 1;
 		Tessellator var19 = Tessellator.instance;
-		double var20 = (double)((float)(var17 + 0) / 256.0F);
-		double var22 = (double)((float)(var18 + 0) / 256.0F);
-		double var24 = ((double)var17 + var14 - 0.01D) / 256.0D;
-		double var26 = ((double)((float)var18 + 4.0F) - 0.01D) / 256.0D;
+		double var20 = (double)((float)(var17 + 0) / 512.0F);
+		double var22 = (double)((float)(var18 + 0) / 512.0F);
+		double var24 = ((double)var17 + var14 - 0.01D) / 512.0D;
+		double var26 = ((double)((float)var18 + 4.0F) - 0.01D) / 512.0D;
 		var19.setColorOpaque_F(var13, var13, var13);
 		var19.addVertexWithUV(var3, var5, var9, var24, var22);
 		var19.addVertexWithUV(var1, var5, var9, var20, var22);
@@ -664,12 +685,12 @@
 			var14 = this.overrideBlockTexture;
 		}
 
-		int var15 = (var14 & 15) << 4;
-		int var16 = var14 & 240;
-		float var17 = (float)var15 / 256.0F;
-		float var18 = ((float)var15 + 15.99F) / 256.0F;
-		float var19 = (float)var16 / 256.0F;
-		float var20 = ((float)var16 + 15.99F) / 256.0F;
+		int var15 = (var14 & 31) << 4;
+		int var16 = (var14 & 992) >> 1;
+		float var17 = (float)var15 / 512.0F;
+		float var18 = ((float)var15 + 15.99F) / 512.0F;
+		float var19 = (float)var16 / 512.0F;
+		float var20 = ((float)var16 + 15.99F) / 512.0F;
 		Vec3D[] var21 = new Vec3D[8];
 		float var22 = 1.0F / 16.0F;
 		float var23 = 1.0F / 16.0F;
@@ -685,10 +706,10 @@
 
 		for(int var25 = 0; var25 < 8; ++var25) {
 			if(var7) {
-				var21[var25].zCoord -= 1.0D / 16.0D;
+				var21[var25].zCoord -= 1.0D / 32.0D;
 				var21[var25].rotateAroundX((float)Math.PI * 2.0F / 9.0F);
 			} else {
-				var21[var25].zCoord += 1.0D / 16.0D;
+				var21[var25].zCoord += 1.0D / 32.0D;
 				var21[var25].rotateAroundX(-((float)Math.PI * 2.0F / 9.0F));
 			}
 
@@ -732,15 +753,15 @@
 
 		for(int var29 = 0; var29 < 6; ++var29) {
 			if(var29 == 0) {
-				var17 = (float)(var15 + 7) / 256.0F;
-				var18 = ((float)(var15 + 9) - 0.01F) / 256.0F;
-				var19 = (float)(var16 + 6) / 256.0F;
-				var20 = ((float)(var16 + 8) - 0.01F) / 256.0F;
+				var17 = (float)(var15 + 7) / 512.0F;
+				var18 = ((float)(var15 + 9) - 0.01F) / 512.0F;
+				var19 = (float)(var16 + 6) / 512.0F;
+				var20 = ((float)(var16 + 8) - 0.01F) / 512.0F;
 			} else if(var29 == 2) {
-				var17 = (float)(var15 + 7) / 256.0F;
-				var18 = ((float)(var15 + 9) - 0.01F) / 256.0F;
-				var19 = (float)(var16 + 6) / 256.0F;
-				var20 = ((float)(var16 + 16) - 0.01F) / 256.0F;
+				var17 = (float)(var15 + 7) / 512.0F;
+				var18 = ((float)(var15 + 9) - 0.01F) / 512.0F;
+				var19 = (float)(var16 + 6) / 512.0F;
+				var20 = ((float)(var16 + 16) - 0.01F) / 512.0F;
 			}
 
 			if(var29 == 0) {
@@ -793,12 +814,12 @@
 
 		float var7 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var7, var7, var7);
-		int var8 = (var6 & 15) << 4;
-		int var9 = var6 & 240;
-		double var10 = (double)((float)var8 / 256.0F);
-		double var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-		double var14 = (double)((float)var9 / 256.0F);
-		double var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+		int var8 = (var6 & 31) << 4;
+		int var9 = (var6 & 992) >> 1;
+		double var10 = (double)((float)var8 / 512.0F);
+		double var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+		double var14 = (double)((float)var9 / 512.0F);
+		double var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 		float var18 = 1.4F;
 		double var21;
 		double var23;
@@ -811,10 +832,10 @@
 			float var37 = 0.2F;
 			float var20 = 1.0F / 16.0F;
 			if((var2 + var3 + var4 & 1) == 1) {
-				var10 = (double)((float)var8 / 256.0F);
-				var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-				var14 = (double)((float)(var9 + 16) / 256.0F);
-				var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+				var10 = (double)((float)var8 / 512.0F);
+				var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+				var14 = (double)((float)(var9 + 16) / 512.0F);
+				var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 			}
 
 			if((var2 / 2 + var3 / 2 + var4 / 2 & 1) == 1) {
@@ -876,10 +897,10 @@
 				var31 = (double)var2 + 0.5D + 0.5D;
 				var33 = (double)var4 + 0.5D - 0.5D;
 				double var35 = (double)var4 + 0.5D + 0.5D;
-				var10 = (double)((float)var8 / 256.0F);
-				var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-				var14 = (double)((float)var9 / 256.0F);
-				var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+				var10 = (double)((float)var8 / 512.0F);
+				var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+				var14 = (double)((float)var9 / 512.0F);
+				var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 				++var3;
 				var18 = -0.2F;
 				if((var2 + var3 + var4 & 1) == 0) {
@@ -887,10 +908,10 @@
 					var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 0), var12, var16);
 					var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 1), var10, var16);
 					var5.addVertexWithUV(var29, (double)((float)var3 + var18), (double)(var4 + 1), var10, var14);
-					var10 = (double)((float)var8 / 256.0F);
-					var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-					var14 = (double)((float)(var9 + 16) / 256.0F);
-					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+					var10 = (double)((float)var8 / 512.0F);
+					var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+					var14 = (double)((float)(var9 + 16) / 512.0F);
+					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 					var5.addVertexWithUV(var31, (double)((float)var3 + var18), (double)(var4 + 1), var12, var14);
 					var5.addVertexWithUV(var23, (double)(var3 + 0), (double)(var4 + 1), var12, var16);
 					var5.addVertexWithUV(var23, (double)(var3 + 0), (double)(var4 + 0), var10, var16);
@@ -900,10 +921,10 @@
 					var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var27, var12, var16);
 					var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var27, var10, var16);
 					var5.addVertexWithUV((double)(var2 + 1), (double)((float)var3 + var18), var35, var10, var14);
-					var10 = (double)((float)var8 / 256.0F);
-					var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-					var14 = (double)((float)(var9 + 16) / 256.0F);
-					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+					var10 = (double)((float)var8 / 512.0F);
+					var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+					var14 = (double)((float)(var9 + 16) / 512.0F);
+					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 					var5.addVertexWithUV((double)(var2 + 1), (double)((float)var3 + var18), var33, var12, var14);
 					var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var25, var12, var16);
 					var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var25, var10, var16);
@@ -927,10 +948,10 @@
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 0), var12, var16);
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 1), var10, var16);
 			var5.addVertexWithUV(var29, (double)((float)var3 + var18), (double)(var4 + 1), var10, var14);
-			var10 = (double)((float)var8 / 256.0F);
-			var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-			var14 = (double)((float)(var9 + 16) / 256.0F);
-			var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+			var10 = (double)((float)var8 / 512.0F);
+			var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+			var14 = (double)((float)(var9 + 16) / 512.0F);
+			var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 			var5.addVertexWithUV((double)(var2 + 1), (double)((float)var3 + var18), var33, var12, var14);
 			var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var25, var12, var16);
 			var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var25, var10, var16);
@@ -955,10 +976,10 @@
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 1), var10, var16);
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 0), var12, var16);
 			var5.addVertexWithUV(var29, (double)((float)var3 + var18), (double)(var4 + 0), var12, var14);
-			var10 = (double)((float)var8 / 256.0F);
-			var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-			var14 = (double)((float)var9 / 256.0F);
-			var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+			var10 = (double)((float)var8 / 512.0F);
+			var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+			var14 = (double)((float)var9 / 512.0F);
+			var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 			var5.addVertexWithUV((double)(var2 + 0), (double)((float)var3 + var18), var33, var10, var14);
 			var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var25, var10, var16);
 			var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var25, var12, var16);
@@ -975,7 +996,7 @@
 	public boolean renderBlockRedstoneWire(Block var1, int var2, int var3, int var4) {
 		Tessellator var5 = Tessellator.instance;
 		int var6 = this.blockAccess.getBlockMetadata(var2, var3, var4);
-		int var7 = var1.getBlockTextureFromSideAndMetadata(1, var6);
+		int var7 = var1.getBlockTextureFromSideAndMetadata(0, var6);
 		if(this.overrideBlockTexture >= 0) {
 			var7 = this.overrideBlockTexture;
 		}
@@ -998,12 +1019,12 @@
 		}
 
 		var5.setColorOpaque_F(var8 * var10, var8 * var11, var8 * var12);
-		int var13 = (var7 & 15) << 4;
-		int var14 = var7 & 240;
-		double var15 = (double)((float)var13 / 256.0F);
-		double var17 = (double)(((float)var13 + 15.99F) / 256.0F);
-		double var19 = (double)((float)var14 / 256.0F);
-		double var21 = (double)(((float)var14 + 15.99F) / 256.0F);
+		int var13 = (var7 & 31) << 4;
+		int var14 = (var7 & 992) >> 1;
+		double var15 = (double)((float)var13 / 512.0F);
+		double var17 = (double)(((float)var13 + 15.99F) / 512.0F);
+		double var19 = (double)((float)var14 / 512.0F);
+		double var21 = (double)(((float)var14 + 15.99F) / 512.0F);
 		boolean var26 = RedstoneWireBlock.isPowerProviderOrWire(this.blockAccess, var2 - 1, var3, var4, 1) || !this.blockAccess.isBlockNormalCube(var2 - 1, var3, var4) && RedstoneWireBlock.isPowerProviderOrWire(this.blockAccess, var2 - 1, var3 - 1, var4, -1);
 		boolean var27 = RedstoneWireBlock.isPowerProviderOrWire(this.blockAccess, var2 + 1, var3, var4, 3) || !this.blockAccess.isBlockNormalCube(var2 + 1, var3, var4) && RedstoneWireBlock.isPowerProviderOrWire(this.blockAccess, var2 + 1, var3 - 1, var4, -1);
 		boolean var28 = RedstoneWireBlock.isPowerProviderOrWire(this.blockAccess, var2, var3, var4 - 1, 2) || !this.blockAccess.isBlockNormalCube(var2, var3, var4 - 1) && RedstoneWireBlock.isPowerProviderOrWire(this.blockAccess, var2, var3 - 1, var4 - 1, -1);
@@ -1040,10 +1061,14 @@
 		}
 
 		if(var35 != 0) {
-			var15 = (double)((float)(var13 + 16) / 256.0F);
-			var17 = (double)(((float)(var13 + 16) + 15.99F) / 256.0F);
-			var19 = (double)((float)var14 / 256.0F);
-			var21 = (double)(((float)var14 + 15.99F) / 256.0F);
+			var7 = var1.getBlockTextureFromSideAndMetadata(1, var6);
+			var13 = (var7 & 31) << 4;
+			var14 = (var7 & 992) >> 1;
+
+			var15 = (double)((float)var13 / 512.0F);
+			var17 = (double)(((float)var13 + 15.99F) / 512.0F);
+			var19 = (double)((float)var14 / 512.0F);
+			var21 = (double)(((float)var14 + 15.99F) / 512.0F);
 		}
 
 		if(var35 == 0) {
@@ -1053,7 +1078,7 @@
 				}
 
 				if(!var26) {
-					var15 += 1.25D / 64.0D;
+					var15 += 1.25D / 128.0D;
 				}
 
 				if(!var27) {
@@ -1061,7 +1086,7 @@
 				}
 
 				if(!var27) {
-					var17 -= 1.25D / 64.0D;
+					var17 -= 1.25D / 128.0D;
 				}
 
 				if(!var28) {
@@ -1069,7 +1094,7 @@
 				}
 
 				if(!var28) {
-					var19 += 1.25D / 64.0D;
+					var19 += 1.25D / 128.0D;
 				}
 
 				if(!var29) {
@@ -1077,96 +1102,72 @@
 				}
 
 				if(!var29) {
-					var21 -= 1.25D / 64.0D;
+					var21 -= 1.25D / 128.0D;
 				}
 			}
 
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var34, var17, var21);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var33, var17, var19);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var33, var15, var19);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var34, var15, var21);
+			var5.addVertexWithUV((double)var32, (double)((float)var3 + 1.0F / 64.0F), (double)var34, var17, var21);
+			var5.addVertexWithUV((double)var32, (double)((float)var3 + 1.0F / 64.0F), (double)var33, var17, var19);
+			var5.addVertexWithUV((double)var31, (double)((float)var3 + 1.0F / 64.0F), (double)var33, var15, var19);
+			var5.addVertexWithUV((double)var31, (double)((float)var3 + 1.0F / 64.0F), (double)var34, var15, var21);
 			var5.setColorOpaque_F(var8, var8, var8);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var34, var17, var21 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var33, var17, var19 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var33, var15, var19 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var34, var15, var21 + 1.0D / 16.0D);
 		} else if(var35 == 1) {
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var34, var17, var21);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var33, var17, var19);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var33, var15, var19);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var34, var15, var21);
+			var5.addVertexWithUV((double)var32, (double)((float)var3 + 1.0F / 64.0F), (double)var34, var17, var21);
+			var5.addVertexWithUV((double)var32, (double)((float)var3 + 1.0F / 64.0F), (double)var33, var17, var19);
+			var5.addVertexWithUV((double)var31, (double)((float)var3 + 1.0F / 64.0F), (double)var33, var15, var19);
+			var5.addVertexWithUV((double)var31, (double)((float)var3 + 1.0F / 64.0F), (double)var34, var15, var21);
 			var5.setColorOpaque_F(var8, var8, var8);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var34, var17, var21 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var33, var17, var19 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var33, var15, var19 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var34, var15, var21 + 1.0D / 16.0D);
 		} else if(var35 == 2) {
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var34, var17, var21);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var33, var15, var21);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var33, var15, var19);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var34, var17, var19);
+			var5.addVertexWithUV((double)var32, (double)((float)var3 + 1.0F / 64.0F), (double)var34, var17, var21);
+			var5.addVertexWithUV((double)var32, (double)((float)var3 + 1.0F / 64.0F), (double)var33, var15, var21);
+			var5.addVertexWithUV((double)var31, (double)((float)var3 + 1.0F / 64.0F), (double)var33, var15, var19);
+			var5.addVertexWithUV((double)var31, (double)((float)var3 + 1.0F / 64.0F), (double)var34, var17, var19);
 			var5.setColorOpaque_F(var8, var8, var8);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var34, var17, var21 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var32, (double)((float)var3 + 0.015625F), (double)var33, var15, var21 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var33, var15, var19 + 1.0D / 16.0D);
-			var5.addVertexWithUV((double)var31, (double)((float)var3 + 0.015625F), (double)var34, var17, var19 + 1.0D / 16.0D);
 		}
 
 		if(!this.blockAccess.isBlockNormalCube(var2, var3 + 1, var4)) {
-			var15 = (double)((float)(var13 + 16) / 256.0F);
-			var17 = (double)(((float)(var13 + 16) + 15.99F) / 256.0F);
-			var19 = (double)((float)var14 / 256.0F);
-			var21 = (double)(((float)var14 + 15.99F) / 256.0F);
+			var7 = var1.getBlockTextureFromSideAndMetadata(1, var6);
+			var13 = (var7 & 31) << 4;
+			var14 = (var7 & 992) >> 1;
+
+			var15 = (double)((float)var13 / 512.0F);
+			var17 = (double)(((float)var13 + 15.99F) / 512.0F);
+			var19 = (double)((float)var14 / 512.0F);
+			var21 = (double)(((float)var14 + 15.99F) / 512.0F);
 			if(this.blockAccess.isBlockNormalCube(var2 - 1, var3, var4) && this.blockAccess.getBlockId(var2 - 1, var3 + 1, var4) == Block.redstoneWire.blockID) {
 				var5.setColorOpaque_F(var8 * var10, var8 * var11, var8 * var12);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 1), var17, var19);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)(var3 + 0), (double)(var4 + 1), var15, var19);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)(var3 + 0), (double)(var4 + 0), var15, var21);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 0), var17, var21);
+				var5.addVertexWithUV((double)((float)var2 + 1.0F / 64.0F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 1), var17, var19);
+				var5.addVertexWithUV((double)((float)var2 + 1.0F / 64.0F), (double)(var3 + 0), (double)(var4 + 1), var15, var19);
+				var5.addVertexWithUV((double)((float)var2 + 1.0F / 64.0F), (double)(var3 + 0), (double)(var4 + 0), var15, var21);
+				var5.addVertexWithUV((double)((float)var2 + 1.0F / 64.0F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 0), var17, var21);
 				var5.setColorOpaque_F(var8, var8, var8);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 1), var17, var19 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)(var3 + 0), (double)(var4 + 1), var15, var19 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)(var3 + 0), (double)(var4 + 0), var15, var21 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)((float)var2 + 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 0), var17, var21 + 1.0D / 16.0D);
 			}
 
 			if(this.blockAccess.isBlockNormalCube(var2 + 1, var3, var4) && this.blockAccess.getBlockId(var2 + 1, var3 + 1, var4) == Block.redstoneWire.blockID) {
 				var5.setColorOpaque_F(var8 * var10, var8 * var11, var8 * var12);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)(var3 + 0), (double)(var4 + 1), var15, var21);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 1), var17, var21);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 0), var17, var19);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)(var3 + 0), (double)(var4 + 0), var15, var19);
+				var5.addVertexWithUV((double)((float)(var2 + 1) - 1.0F / 64.0F), (double)(var3 + 0), (double)(var4 + 1), var15, var21);
+				var5.addVertexWithUV((double)((float)(var2 + 1) - 1.0F / 64.0F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 1), var17, var21);
+				var5.addVertexWithUV((double)((float)(var2 + 1) - 1.0F / 64.0F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 0), var17, var19);
+				var5.addVertexWithUV((double)((float)(var2 + 1) - 1.0F / 64.0F), (double)(var3 + 0), (double)(var4 + 0), var15, var19);
 				var5.setColorOpaque_F(var8, var8, var8);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)(var3 + 0), (double)(var4 + 1), var15, var21 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 1), var17, var21 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)(var4 + 0), var17, var19 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)((float)(var2 + 1) - 0.015625F), (double)(var3 + 0), (double)(var4 + 0), var15, var19 + 1.0D / 16.0D);
 			}
 
 			if(this.blockAccess.isBlockNormalCube(var2, var3, var4 - 1) && this.blockAccess.getBlockId(var2, var3 + 1, var4 - 1) == Block.redstoneWire.blockID) {
 				var5.setColorOpaque_F(var8 * var10, var8 * var11, var8 * var12);
-				var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), (double)((float)var4 + 0.015625F), var15, var21);
-				var5.addVertexWithUV((double)(var2 + 1), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)var4 + 0.015625F), var17, var21);
-				var5.addVertexWithUV((double)(var2 + 0), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)var4 + 0.015625F), var17, var19);
-				var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), (double)((float)var4 + 0.015625F), var15, var19);
+				var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), (double)((float)var4 + 1.0F / 64.0F), var15, var21);
+				var5.addVertexWithUV((double)(var2 + 1), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)var4 + 1.0F / 64.0F), var17, var21);
+				var5.addVertexWithUV((double)(var2 + 0), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)var4 + 1.0F / 64.0F), var17, var19);
+				var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), (double)((float)var4 + 1.0F / 64.0F), var15, var19);
 				var5.setColorOpaque_F(var8, var8, var8);
-				var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), (double)((float)var4 + 0.015625F), var15, var21 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)(var2 + 1), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)var4 + 0.015625F), var17, var21 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)(var2 + 0), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)var4 + 0.015625F), var17, var19 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), (double)((float)var4 + 0.015625F), var15, var19 + 1.0D / 16.0D);
 			}
 
 			if(this.blockAccess.isBlockNormalCube(var2, var3, var4 + 1) && this.blockAccess.getBlockId(var2, var3 + 1, var4 + 1) == Block.redstoneWire.blockID) {
 				var5.setColorOpaque_F(var8 * var10, var8 * var11, var8 * var12);
-				var5.addVertexWithUV((double)(var2 + 1), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)(var4 + 1) - 0.015625F), var17, var19);
-				var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), (double)((float)(var4 + 1) - 0.015625F), var15, var19);
-				var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), (double)((float)(var4 + 1) - 0.015625F), var15, var21);
-				var5.addVertexWithUV((double)(var2 + 0), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)(var4 + 1) - 0.015625F), var17, var21);
+				var5.addVertexWithUV((double)(var2 + 1), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)(var4 + 1) - 1.0F / 64.0F), var17, var19);
+				var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), (double)((float)(var4 + 1) - 1.0F / 64.0F), var15, var19);
+				var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), (double)((float)(var4 + 1) - 1.0F / 64.0F), var15, var21);
+				var5.addVertexWithUV((double)(var2 + 0), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)(var4 + 1) - 1.0F / 64.0F), var17, var21);
 				var5.setColorOpaque_F(var8, var8, var8);
-				var5.addVertexWithUV((double)(var2 + 1), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)(var4 + 1) - 0.015625F), var17, var19 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), (double)((float)(var4 + 1) - 0.015625F), var15, var19 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), (double)((float)(var4 + 1) - 0.015625F), var15, var21 + 1.0D / 16.0D);
-				var5.addVertexWithUV((double)(var2 + 0), (double)((float)(var3 + 1) + 7.0F / 320.0F), (double)((float)(var4 + 1) - 0.015625F), var17, var21 + 1.0D / 16.0D);
 			}
 		}
 
@@ -1187,12 +1188,12 @@
 
 		float var8 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var8, var8, var8);
-		int var9 = (var7 & 15) << 4;
-		int var10 = var7 & 240;
-		double var11 = (double)((float)var9 / 256.0F);
-		double var13 = (double)(((float)var9 + 15.99F) / 256.0F);
-		double var15 = (double)((float)var10 / 256.0F);
-		double var17 = (double)(((float)var10 + 15.99F) / 256.0F);
+		int var9 = (var7 & 31) << 4;
+		int var10 = (var7 & 992) >> 1;
+		double var11 = (double)((float)var9 / 512.0F);
+		double var13 = (double)(((float)var9 + 15.99F) / 512.0F);
+		double var15 = (double)((float)var10 / 512.0F);
+		double var17 = (double)(((float)var10 + 15.99F) / 512.0F);
 		float var19 = 1.0F / 16.0F;
 		float var20 = (float)(var2 + 1);
 		float var21 = (float)(var2 + 1);
@@ -1267,12 +1268,12 @@
 
 		float var7 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var7, var7, var7);
-		int var8 = (var6 & 15) << 4;
-		int var9 = var6 & 240;
-		double var10 = (double)((float)var8 / 256.0F);
-		double var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-		double var14 = (double)((float)var9 / 256.0F);
-		double var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+		int var8 = (var6 & 31) << 4;
+		int var9 = (var6 & 992) >> 1;
+		double var10 = (double)((float)var8 / 512.0F);
+		double var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+		double var14 = (double)((float)var9 / 512.0F);
+		double var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 		int var18 = this.blockAccess.getBlockMetadata(var2, var3, var4);
 		float var19 = 0.0F;
 		float var20 = 0.05F;
@@ -1331,7 +1332,7 @@
 			long var17 = (long)(var2 * 3129871) ^ (long)var4 * 116129781L ^ (long)var3;
 			var17 = var17 * var17 * 42317861L + var17 * 11L;
 			var19 += ((double)((float)(var17 >> 16 & 15L) / 15.0F) - 0.5D) * 0.5D;
-			var20 += ((double)((float)(var17 >> 20 & 15L) / 15.0F) - 1.0D) * 0.2D;
+			var20 += ((double)((float)(var17 >> 20 & 15L) / 15.0F) - 1.0D) / 3.0D;
 			var15 += ((double)((float)(var17 >> 24 & 15L) / 15.0F) - 0.5D) * 0.5D;
 		}
 
@@ -1354,15 +1355,15 @@
 			var13 = this.overrideBlockTexture;
 		}
 
-		int var14 = (var13 & 15) << 4;
-		int var15 = var13 & 240;
-		float var16 = (float)var14 / 256.0F;
-		float var17 = ((float)var14 + 15.99F) / 256.0F;
-		float var18 = (float)var15 / 256.0F;
-		float var19 = ((float)var15 + 15.99F) / 256.0F;
+		int var14 = (var13 & 31) << 4;
+		int var15 = (var13 & 992) >> 1;
+		float var16 = (float)var14 / 512.0F;
+		float var17 = ((float)var14 + 15.99F) / 512.0F;
+		float var18 = (float)var15 / 512.0F;
+		float var19 = ((float)var15 + 15.99F) / 512.0F;
 		double var20 = (double)var16 + 1.75D / 64.0D;
-		double var22 = (double)var18 + 6.0D / 256.0D;
-		double var24 = (double)var16 + 9.0D / 256.0D;
+		double var22 = (double)var18 + 6.0D / 512.0D;
+		double var24 = (double)var16 + 9.0D / 512.0D;
 		double var26 = (double)var18 + 1.0D / 32.0D;
 		var2 += 0.5D;
 		var6 += 0.5D;
@@ -1401,12 +1402,12 @@
 			var10 = this.overrideBlockTexture;
 		}
 
-		int var11 = (var10 & 15) << 4;
-		int var12 = var10 & 240;
-		double var13 = (double)((float)var11 / 256.0F);
-		double var15 = (double)(((float)var11 + 15.99F) / 256.0F);
-		double var17 = (double)((float)var12 / 256.0F);
-		double var19 = (double)(((float)var12 + 15.99F) / 256.0F);
+		int var11 = (var10 & 31) << 4;
+		int var12 = (var10 & 992) >> 1;
+		double var13 = (double)((float)var11 / 512.0F);
+		double var15 = (double)(((float)var11 + 15.99F) / 512.0F);
+		double var17 = (double)((float)var12 / 512.0F);
+		double var19 = (double)(((float)var12 + 15.99F) / 512.0F);
 		double var21 = var3 + 0.5D - (double)0.45F;
 		double var23 = var3 + 0.5D + (double)0.45F;
 		double var25 = var7 + 0.5D - (double)0.45F;
@@ -1436,12 +1437,12 @@
 			var10 = this.overrideBlockTexture;
 		}
 
-		int var11 = (var10 & 15) << 4;
-		int var12 = var10 & 240;
-		double var13 = (double)((float)var11 / 256.0F);
-		double var15 = (double)(((float)var11 + 15.99F) / 256.0F);
-		double var17 = (double)((float)var12 / 256.0F);
-		double var19 = (double)(((float)var12 + 15.99F) / 256.0F);
+		int var11 = (var10 & 31) << 4;
+		int var12 = (var10 & 992) >> 1;
+		double var13 = (double)((float)var11 / 512.0F);
+		double var15 = (double)(((float)var11 + 15.99F) / 512.0F);
+		double var17 = (double)((float)var12 / 512.0F);
+		double var19 = (double)(((float)var12 + 15.99F) / 512.0F);
 		double var21 = var3 + 0.5D - 0.25D;
 		double var23 = var3 + 0.5D + 0.25D;
 		double var25 = var7 + 0.5D - 0.5D;
@@ -1522,19 +1523,19 @@
 					var28 = var1.getBlockTextureFromSideAndMetadata(2, var23);
 				}
 
-				int var30 = (var28 & 15) << 4;
-				var31 = var28 & 240;
-				double var32 = ((double)var30 + 8.0D) / 256.0D;
-				double var34 = ((double)var31 + 8.0D) / 256.0D;
+				int var30 = (var28 & 31) << 4;
+				var31 = (var28 & 992) >> 1;
+				double var32 = ((double)var30 + 8.0D) / 512.0D;
+				double var34 = ((double)var31 + 8.0D) / 512.0D;
 				if(var29 < -999.0F) {
 					var29 = 0.0F;
 				} else {
-					var32 = (double)((float)(var30 + 16) / 256.0F);
-					var34 = (double)((float)(var31 + 16) / 256.0F);
+					var32 = (double)((float)(var30 + 16) / 512.0F);
+					var34 = (double)((float)(var31 + 16) / 512.0F);
 				}
 
-				var36 = MathHelper.sin(var29) * 8.0F / 256.0F;
-				var37 = MathHelper.cos(var29) * 8.0F / 256.0F;
+				var36 = MathHelper.sin(var29) * 8.0F / 512.0F;
+				var37 = MathHelper.cos(var29) * 8.0F / 512.0F;
 				var38 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
 				var5.setColorOpaque_F(var15 * var38 * var7, var15 * var38 * var8, var15 * var38 * var9);
 				var5.addVertexWithUV((double)(var2 + 0), (double)((float)var3 + var24), (double)(var4 + 0), var32 - (double)var37 - (double)var36, var34 - (double)var37 + (double)var36);
@@ -1570,8 +1571,8 @@
 				}
 
 				int var54 = var1.getBlockTextureFromSideAndMetadata(var28 + 2, var23);
-				int var33 = (var54 & 15) << 4;
-				int var55 = var54 & 240;
+				int var33 = (var54 & 31) << 4;
+				int var55 = (var54 & 992) >> 1;
 				if(this.renderAllFaces || var12[var28]) {
 					float var35;
 					float var39;
@@ -1607,11 +1608,11 @@
 					}
 
 					var13 = true;
-					double var41 = (double)((float)(var33 + 0) / 256.0F);
-					double var43 = ((double)(var33 + 16) - 0.01D) / 256.0D;
-					double var45 = (double)(((float)var55 + (1.0F - var35) * 16.0F) / 256.0F);
-					double var47 = (double)(((float)var55 + (1.0F - var36) * 16.0F) / 256.0F);
-					double var49 = ((double)(var55 + 16) - 0.01D) / 256.0D;
+					double var41 = (double)((float)(var33 + 0) / 512.0F);
+					double var43 = ((double)(var33 + 16) - 0.01D) / 512.0D;
+					double var45 = (double)(((float)var55 + (1.0F - var35) * 16.0F) / 512.0F);
+					double var47 = (double)(((float)var55 + (1.0F - var36) * 16.0F) / 512.0F);
+					double var49 = ((double)(var55 + 16) - 0.01D) / 512.0D;
 					float var51 = var1.getBlockBrightness(this.blockAccess, var53, var3, var31);
 					if(var28 < 2) {
 						var51 *= var16;
@@ -1767,7 +1768,7 @@
 		this.field_22339_T = Block.canBlockGrass[this.blockAccess.getBlockId(var2, var3 + 1, var4 - 1)];
 		this.field_22355_ae = Block.canBlockGrass[this.blockAccess.getBlockId(var2, var3 - 1, var4 + 1)];
 		this.field_22361_ab = Block.canBlockGrass[this.blockAccess.getBlockId(var2, var3 - 1, var4 - 1)];
-		if(var1.textureIndex == 3) {
+		if(var1.textureIndex == GrassBlock.TEX_SIDE) {
 			var18 = false;
 			var17 = var18;
 			var16 = var18;
@@ -1841,7 +1842,23 @@
 			this.colorRedTopRight *= var12;
 			this.colorGreenTopRight *= var12;
 			this.colorBlueTopRight *= var12;
-			this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
+
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderBottomFace(var1, var2, var3, var4, subTexture);
+						this.colorRedTopLeft = this.colorGreenTopLeft = this.colorBlueTopLeft = 0.5F * var9;
+						this.colorRedBottomLeft = this.colorGreenBottomLeft = this.colorBlueBottomLeft = 0.5F * var10;
+						this.colorRedBottomRight = this.colorGreenBottomRight = this.colorBlueBottomRight = 0.5F * var11;
+						this.colorRedTopRight = this.colorGreenTopRight = this.colorBlueTopRight = 0.5F * var12;
+					}
+				}
+			} else {
+				this.renderBottomFace(var1, var2, var3, var4, texture);
+			}
+
 			var8 = true;
 		}
 
@@ -1903,7 +1920,23 @@
 			this.colorRedTopRight *= var12;
 			this.colorGreenTopRight *= var12;
 			this.colorBlueTopRight *= var12;
-			this.renderTopFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
+
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderTopFace(var1, var2, var3, var4, subTexture);
+						this.colorRedTopLeft = this.colorGreenTopLeft = this.colorBlueTopLeft = var9;
+						this.colorRedBottomLeft = this.colorGreenBottomLeft = this.colorBlueBottomLeft = var10;
+						this.colorRedBottomRight = this.colorGreenBottomRight = this.colorBlueBottomRight = var11;
+						this.colorRedTopRight = this.colorGreenTopRight = this.colorBlueTopRight = var12;
+					}
+				}
+			} else {
+				this.renderTopFace(var1, var2, var3, var4, texture);
+			}
+
 			var8 = true;
 		}
 
@@ -1966,9 +1999,24 @@
 			this.colorRedTopRight *= var12;
 			this.colorGreenTopRight *= var12;
 			this.colorBlueTopRight *= var12;
-			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2);
-			this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, var19);
-			if(fancyGrass && var19 == 3 && this.overrideBlockTexture < 0) {
+
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderEastFace(var1, var2, var3, var4, subTexture);
+						this.colorRedTopLeft = this.colorGreenTopLeft = this.colorBlueTopLeft = 0.8F * var9;
+						this.colorRedBottomLeft = this.colorGreenBottomLeft = this.colorBlueBottomLeft = 0.8F * var10;
+						this.colorRedBottomRight = this.colorGreenBottomRight = this.colorBlueBottomRight = 0.8F * var11;
+						this.colorRedTopRight = this.colorGreenTopRight = this.colorBlueTopRight = 0.8F * var12;
+					}
+				}
+			} else {
+				this.renderEastFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				this.colorRedTopLeft *= var5;
 				this.colorRedBottomLeft *= var5;
 				this.colorRedBottomRight *= var5;
@@ -1981,7 +2029,7 @@
 				this.colorBlueBottomLeft *= var7;
 				this.colorBlueBottomRight *= var7;
 				this.colorBlueTopRight *= var7;
-				this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var8 = true;
@@ -2045,9 +2093,24 @@
 			this.colorRedTopRight *= var12;
 			this.colorGreenTopRight *= var12;
 			this.colorBlueTopRight *= var12;
-			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3);
-			this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3));
-			if(fancyGrass && var19 == 3 && this.overrideBlockTexture < 0) {
+
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderWestFace(var1, var2, var3, var4, subTexture);
+						this.colorRedTopLeft = this.colorGreenTopLeft = this.colorBlueTopLeft = 0.8F * var9;
+						this.colorRedBottomLeft = this.colorGreenBottomLeft = this.colorBlueBottomLeft = 0.8F * var10;
+						this.colorRedBottomRight = this.colorGreenBottomRight = this.colorBlueBottomRight = 0.8F * var11;
+						this.colorRedTopRight = this.colorGreenTopRight = this.colorBlueTopRight = 0.8F * var12;
+					}
+				}
+			} else {
+				this.renderWestFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				this.colorRedTopLeft *= var5;
 				this.colorRedBottomLeft *= var5;
 				this.colorRedBottomRight *= var5;
@@ -2060,7 +2123,7 @@
 				this.colorBlueBottomLeft *= var7;
 				this.colorBlueBottomRight *= var7;
 				this.colorBlueTopRight *= var7;
-				this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var8 = true;
@@ -2124,9 +2187,24 @@
 			this.colorRedTopRight *= var12;
 			this.colorGreenTopRight *= var12;
 			this.colorBlueTopRight *= var12;
-			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4);
-			this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, var19);
-			if(fancyGrass && var19 == 3 && this.overrideBlockTexture < 0) {
+
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderNorthFace(var1, var2, var3, var4, subTexture);
+						this.colorRedTopLeft = this.colorGreenTopLeft = this.colorBlueTopLeft = 0.6F * var9;
+						this.colorRedBottomLeft = this.colorGreenBottomLeft = this.colorBlueBottomLeft = 0.6F * var10;
+						this.colorRedBottomRight = this.colorGreenBottomRight = this.colorBlueBottomRight = 0.6F * var11;
+						this.colorRedTopRight = this.colorGreenTopRight = this.colorBlueTopRight = 0.6F * var12;
+					}
+				}
+			} else {
+				this.renderNorthFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				this.colorRedTopLeft *= var5;
 				this.colorRedBottomLeft *= var5;
 				this.colorRedBottomRight *= var5;
@@ -2139,7 +2217,7 @@
 				this.colorBlueBottomLeft *= var7;
 				this.colorBlueBottomRight *= var7;
 				this.colorBlueTopRight *= var7;
-				this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var8 = true;
@@ -2203,9 +2281,24 @@
 			this.colorRedTopRight *= var12;
 			this.colorGreenTopRight *= var12;
 			this.colorBlueTopRight *= var12;
-			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5);
-			this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, var19);
-			if(fancyGrass && var19 == 3 && this.overrideBlockTexture < 0) {
+
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderSouthFace(var1, var2, var3, var4, subTexture);
+						this.colorRedTopLeft = this.colorGreenTopLeft = this.colorBlueTopLeft = 0.6F * var9;
+						this.colorRedBottomLeft = this.colorGreenBottomLeft = this.colorBlueBottomLeft = 0.6F * var10;
+						this.colorRedBottomRight = this.colorGreenBottomRight = this.colorBlueBottomRight = 0.6F * var11;
+						this.colorRedTopRight = this.colorGreenTopRight = this.colorBlueTopRight = 0.6F * var12;
+					}
+				}
+			} else {
+				this.renderSouthFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				this.colorRedTopLeft *= var5;
 				this.colorRedBottomLeft *= var5;
 				this.colorRedBottomRight *= var5;
@@ -2218,7 +2311,7 @@
 				this.colorBlueBottomLeft *= var7;
 				this.colorBlueBottomRight *= var7;
 				this.colorBlueTopRight *= var7;
-				this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var8 = true;
@@ -2265,7 +2358,18 @@
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 - 1, var4, 0)) {
 			var27 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
 			var8.setColorOpaque_F(var17 * var27, var20 * var27, var23 * var27);
-			this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderBottomFace(var1, var2, var3, var4, subTexture);
+						var8.setColorOpaque_F(var10 * var27, var10 * var27, var10 * var27);
+					}
+				}
+			} else {
+				this.renderBottomFace(var1, var2, var3, var4, texture);
+			}
 			var9 = true;
 		}
 
@@ -2276,7 +2380,18 @@
 			}
 
 			var8.setColorOpaque_F(var14 * var27, var15 * var27, var16 * var27);
-			this.renderTopFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderTopFace(var1, var2, var3, var4, subTexture);
+						var8.setColorOpaque_F(var11 * var27, var11 * var27, var11 * var27);
+					}
+				}
+			} else {
+				this.renderTopFace(var1, var2, var3, var4, texture);
+			}
 			var9 = true;
 		}
 
@@ -2288,11 +2403,22 @@
 			}
 
 			var8.setColorOpaque_F(var18 * var27, var21 * var27, var24 * var27);
-			var28 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2);
-			this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, var28);
-			if(fancyGrass && var28 == 3 && this.overrideBlockTexture < 0) {
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderEastFace(var1, var2, var3, var4, subTexture);
+						var8.setColorOpaque_F(var12 * var27, var12 * var27, var12 * var27);
+					}
+				}
+			} else {
+				this.renderEastFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				var8.setColorOpaque_F(var18 * var27 * var5, var21 * var27 * var6, var24 * var27 * var7);
-				this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var9 = true;
@@ -2305,11 +2431,22 @@
 			}
 
 			var8.setColorOpaque_F(var18 * var27, var21 * var27, var24 * var27);
-			var28 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3);
-			this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, var28);
-			if(fancyGrass && var28 == 3 && this.overrideBlockTexture < 0) {
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderWestFace(var1, var2, var3, var4, subTexture);
+						var8.setColorOpaque_F(var12 * var27, var12 * var27, var12 * var27);
+					}
+				}
+			} else {
+				this.renderWestFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				var8.setColorOpaque_F(var18 * var27 * var5, var21 * var27 * var6, var24 * var27 * var7);
-				this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var9 = true;
@@ -2322,11 +2459,22 @@
 			}
 
 			var8.setColorOpaque_F(var19 * var27, var22 * var27, var25 * var27);
-			var28 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4);
-			this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, var28);
-			if(fancyGrass && var28 == 3 && this.overrideBlockTexture < 0) {
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderNorthFace(var1, var2, var3, var4, subTexture);
+						var8.setColorOpaque_F(var13 * var27, var13 * var27, var13 * var27);
+					}
+				}
+			} else {
+				this.renderNorthFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				var8.setColorOpaque_F(var19 * var27 * var5, var22 * var27 * var6, var25 * var27 * var7);
-				this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var9 = true;
@@ -2339,11 +2487,22 @@
 			}
 
 			var8.setColorOpaque_F(var19 * var27, var22 * var27, var25 * var27);
-			var28 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5);
-			this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, var28);
-			if(fancyGrass && var28 == 3 && this.overrideBlockTexture < 0) {
+			int texture = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						this.renderSouthFace(var1, var2, var3, var4, subTexture);
+						var8.setColorOpaque_F(var13 * var27, var13 * var27, var13 * var27);
+					}
+				}
+			} else {
+				this.renderSouthFace(var1, var2, var3, var4, texture);
+			}
+
+			if(fancyGrass && texture == GrassBlock.TEX_SIDE && this.overrideBlockTexture < 0) {
 				var8.setColorOpaque_F(var19 * var27 * var5, var22 * var27 * var6, var25 * var27 * var7);
-				this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, 38);
+				this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, GrassBlock.TEX_SIDE_TINTED);
 			}
 
 			var9 = true;
@@ -2528,148 +2687,13 @@
 	}
 
 	public boolean renderBlockStairs(Block var1, int var2, int var3, int var4) {
-		boolean var5 = false;
-		int var6 = this.blockAccess.getBlockMetadata(var2, var3, var4);
-		if(var6 == 0) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 0.5F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var5 = true;
-		} else if(var6 == 1) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 1.0F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var5 = true;
-		} else if(var6 == 2) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 0.5F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 1.0F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var5 = true;
-		} else if(var6 == 3) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 0.5F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 0.5F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var5 = true;
-		}
-
+		((StairsBlock)var1).doShape(this.blockAccess, var2, var3, var4, () -> this.renderStandardBlock(var1, var2, var3, var4));
 		var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-		return var5;
+		return true;
 	}
 
 	public boolean renderBlockDoor(Block var1, int var2, int var3, int var4) {
-		Tessellator var5 = Tessellator.instance;
-		DoorBlock var6 = (DoorBlock)var1;
-		boolean var7 = false;
-		float var8 = 0.5F;
-		float var9 = 1.0F;
-		float var10 = 0.8F;
-		float var11 = 0.6F;
-		float var12 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
-		float var13 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
-		if(var6.minY > 0.0D) {
-			var13 = var12;
-		}
-
-		if(Block.lightValue[var1.blockID] > 0) {
-			var13 = 1.0F;
-		}
-
-		var5.setColorOpaque_F(var8 * var13, var8 * var13, var8 * var13);
-		this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
-		var7 = true;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
-		if(var6.maxY < 1.0D) {
-			var13 = var12;
-		}
-
-		if(Block.lightValue[var1.blockID] > 0) {
-			var13 = 1.0F;
-		}
-
-		var5.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
-		this.renderTopFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
-		var7 = true;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 - 1);
-		if(var6.minZ > 0.0D) {
-			var13 = var12;
-		}
-
-		if(Block.lightValue[var1.blockID] > 0) {
-			var13 = 1.0F;
-		}
-
-		var5.setColorOpaque_F(var10 * var13, var10 * var13, var10 * var13);
-		int var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2);
-		if(var14 < 0) {
-			this.flipTexture = true;
-			var14 = -var14;
-		}
-
-		this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, var14);
-		var7 = true;
-		this.flipTexture = false;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 + 1);
-		if(var6.maxZ < 1.0D) {
-			var13 = var12;
-		}
-
-		if(Block.lightValue[var1.blockID] > 0) {
-			var13 = 1.0F;
-		}
-
-		var5.setColorOpaque_F(var10 * var13, var10 * var13, var10 * var13);
-		var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3);
-		if(var14 < 0) {
-			this.flipTexture = true;
-			var14 = -var14;
-		}
-
-		this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, var14);
-		var7 = true;
-		this.flipTexture = false;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2 - 1, var3, var4);
-		if(var6.minX > 0.0D) {
-			var13 = var12;
-		}
-
-		if(Block.lightValue[var1.blockID] > 0) {
-			var13 = 1.0F;
-		}
-
-		var5.setColorOpaque_F(var11 * var13, var11 * var13, var11 * var13);
-		var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4);
-		if(var14 < 0) {
-			this.flipTexture = true;
-			var14 = -var14;
-		}
-
-		this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, var14);
-		var7 = true;
-		this.flipTexture = false;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2 + 1, var3, var4);
-		if(var6.maxX < 1.0D) {
-			var13 = var12;
-		}
-
-		if(Block.lightValue[var1.blockID] > 0) {
-			var13 = 1.0F;
-		}
-
-		var5.setColorOpaque_F(var11 * var13, var11 * var13, var11 * var13);
-		var14 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5);
-		if(var14 < 0) {
-			this.flipTexture = true;
-			var14 = -var14;
-		}
-
-		this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, var14);
-		var7 = true;
-		this.flipTexture = false;
-		return var7;
+		return false;
 	}
 
 	public void renderBottomFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -2678,20 +2702,25 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minZ * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
+		if(var8 < 0) {
+			this.flipTexture = true;
+			var8 = -var8;
+		}
+
+		int var10 = (var8 & 31) << 4;
+		int var11 = (var8 & 992) >> 1;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
+		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
 		}
 
 		double var20 = var14;
@@ -2699,10 +2728,10 @@
 		double var24 = var16;
 		double var26 = var18;
 		if(this.field_31082_l == 2) {
-			var12 = ((double)var10 + var1.minZ * 16.0D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 256.0D;
-			var14 = ((double)var10 + var1.maxZ * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 256.0D;
+			var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
 			var24 = var16;
 			var26 = var18;
 			var20 = var12;
@@ -2710,10 +2739,10 @@
 			var16 = var18;
 			var18 = var24;
 		} else if(this.field_31082_l == 1) {
-			var12 = ((double)(var10 + 16) - var1.maxZ * 16.0D) / 256.0D;
-			var16 = ((double)var11 + var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.maxX * 16.0D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.maxZ * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var12 = var14;
@@ -2721,10 +2750,10 @@
 			var24 = var18;
 			var26 = var16;
 		} else if(this.field_31082_l == 3) {
-			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D - 0.01D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var24 = var16;
@@ -2752,6 +2781,7 @@
 			var9.addVertexWithUV(var30, var32, var36, var14, var18);
 		}
 
+		this.flipTexture = false;
 	}
 
 	public void renderTopFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -2760,20 +2790,25 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minZ * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
+		if(var8 < 0) {
+			this.flipTexture = true;
+			var8 = -var8;
+		}
+
+		int var10 = (var8 & 31) << 4;
+		int var11 = (var8 & 992) >> 1;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
+		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
 		}
 
 		double var20 = var14;
@@ -2781,10 +2816,10 @@
 		double var24 = var16;
 		double var26 = var18;
 		if(this.field_31083_k == 1) {
-			var12 = ((double)var10 + var1.minZ * 16.0D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 256.0D;
-			var14 = ((double)var10 + var1.maxZ * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 256.0D;
+			var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
 			var24 = var16;
 			var26 = var18;
 			var20 = var12;
@@ -2792,10 +2827,10 @@
 			var16 = var18;
 			var18 = var24;
 		} else if(this.field_31083_k == 2) {
-			var12 = ((double)(var10 + 16) - var1.maxZ * 16.0D) / 256.0D;
-			var16 = ((double)var11 + var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.maxX * 16.0D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.maxZ * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var12 = var14;
@@ -2803,10 +2838,10 @@
 			var24 = var18;
 			var26 = var16;
 		} else if(this.field_31083_k == 3) {
-			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D - 0.01D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var24 = var16;
@@ -2834,6 +2869,7 @@
 			var9.addVertexWithUV(var28, var32, var36, var22, var26);
 		}
 
+		this.flipTexture = false;
 	}
 
 	public void renderEastFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -2842,12 +2878,17 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 256.0D;
-		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 256.0D;
+		if(var8 < 0) {
+			this.flipTexture = true;
+			var8 = -var8;
+		}
+
+		int var10 = (var8 & 31) << 4;
+		int var11 = (var8 & 992) >> 1;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -2856,13 +2897,13 @@
 		}
 
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
 		}
 
 		var20 = var14;
@@ -2870,10 +2911,10 @@
 		double var24 = var16;
 		double var26 = var18;
 		if(this.field_31087_g == 2) {
-			var12 = ((double)var10 + var1.minY * 16.0D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)var10 + var1.maxY * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 256.0D;
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
 			var24 = var16;
 			var26 = var18;
 			var20 = var12;
@@ -2881,10 +2922,10 @@
 			var16 = var18;
 			var18 = var24;
 		} else if(this.field_31087_g == 1) {
-			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 256.0D;
-			var16 = ((double)var11 + var1.maxX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.minX * 16.0D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var12 = var14;
@@ -2892,10 +2933,10 @@
 			var24 = var18;
 			var26 = var16;
 		} else if(this.field_31087_g == 3) {
-			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 256.0D;
-			var16 = ((double)var11 + var1.maxY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var24 = var16;
@@ -2923,6 +2964,7 @@
 			var9.addVertexWithUV(var28, var32, var36, var14, var18);
 		}
 
+		this.flipTexture = false;
 	}
 
 	public void renderWestFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -2931,12 +2973,17 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 256.0D;
-		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 256.0D;
+		if(var8 < 0) {
+			this.flipTexture = true;
+			var8 = -var8;
+		}
+
+		int var10 = (var8 & 31) << 4;
+		int var11 = (var8 & 992) >> 1;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -2945,13 +2992,13 @@
 		}
 
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
 		}
 
 		var20 = var14;
@@ -2959,10 +3006,10 @@
 		double var24 = var16;
 		double var26 = var18;
 		if(this.field_31086_h == 1) {
-			var12 = ((double)var10 + var1.minY * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)var10 + var1.maxY * 16.0D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 256.0D;
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
 			var24 = var16;
 			var26 = var18;
 			var20 = var12;
@@ -2970,10 +3017,10 @@
 			var16 = var18;
 			var18 = var24;
 		} else if(this.field_31086_h == 2) {
-			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 256.0D;
-			var16 = ((double)var11 + var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.maxX * 16.0D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var12 = var14;
@@ -2981,10 +3028,10 @@
 			var24 = var18;
 			var26 = var16;
 		} else if(this.field_31086_h == 3) {
-			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 256.0D;
-			var16 = ((double)var11 + var1.maxY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var24 = var16;
@@ -3012,6 +3059,7 @@
 			var9.addVertexWithUV(var30, var34, var36, var20, var24);
 		}
 
+		this.flipTexture = false;
 	}
 
 	public void renderNorthFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -3020,12 +3068,17 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minZ * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 256.0D;
-		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 256.0D;
+		if(var8 < 0) {
+			this.flipTexture = true;
+			var8 = -var8;
+		}
+
+		int var10 = (var8 & 31) << 4;
+		int var11 = (var8 & 992) >> 1;
+		double var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -3034,13 +3087,13 @@
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
 		}
 
 		var20 = var14;
@@ -3048,10 +3101,10 @@
 		double var24 = var16;
 		double var26 = var18;
 		if(this.field_31084_j == 1) {
-			var12 = ((double)var10 + var1.minY * 16.0D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.maxZ * 16.0D) / 256.0D;
-			var14 = ((double)var10 + var1.maxY * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 256.0D;
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxZ * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
 			var24 = var16;
 			var26 = var18;
 			var20 = var12;
@@ -3059,10 +3112,10 @@
 			var16 = var18;
 			var18 = var24;
 		} else if(this.field_31084_j == 2) {
-			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 256.0D;
-			var16 = ((double)var11 + var1.minZ * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.maxZ * 16.0D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxZ * 16.0D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var12 = var14;
@@ -3070,10 +3123,10 @@
 			var24 = var18;
 			var26 = var16;
 		} else if(this.field_31084_j == 3) {
-			var12 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.maxZ * 16.0D - 0.01D) / 256.0D;
-			var16 = ((double)var11 + var1.maxY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var24 = var16;
@@ -3101,6 +3154,7 @@
 			var9.addVertexWithUV(var28, var30, var36, var14, var18);
 		}
 
+		this.flipTexture = false;
 	}
 
 	public void renderSouthFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -3109,12 +3163,17 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minZ * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 256.0D;
-		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 256.0D;
+		if(var8 < 0) {
+			this.flipTexture = true;
+			var8 = -var8;
+		}
+
+		int var10 = (var8 & 31) << 4;
+		int var11 = (var8 & 992) >> 1;
+		double var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -3123,13 +3182,13 @@
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
 		}
 
 		var20 = var14;
@@ -3137,10 +3196,10 @@
 		double var24 = var16;
 		double var26 = var18;
 		if(this.field_31085_i == 2) {
-			var12 = ((double)var10 + var1.minY * 16.0D) / 256.0D;
-			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 256.0D;
-			var14 = ((double)var10 + var1.maxY * 16.0D) / 256.0D;
-			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D) / 256.0D;
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D) / 512.0D;
 			var24 = var16;
 			var26 = var18;
 			var20 = var12;
@@ -3148,10 +3207,10 @@
 			var16 = var18;
 			var18 = var24;
 		} else if(this.field_31085_i == 1) {
-			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 256.0D;
-			var16 = ((double)var11 + var1.maxZ * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.minZ * 16.0D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.maxZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var12 = var14;
@@ -3159,10 +3218,10 @@
 			var24 = var18;
 			var26 = var16;
 		} else if(this.field_31085_i == 3) {
-			var12 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 256.0D;
-			var14 = ((double)(var10 + 16) - var1.maxZ * 16.0D - 0.01D) / 256.0D;
-			var16 = ((double)var11 + var1.maxY * 16.0D) / 256.0D;
-			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 256.0D;
+			var12 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
 			var20 = var14;
 			var22 = var12;
 			var24 = var16;
@@ -3190,6 +3249,32 @@
 			var9.addVertexWithUV(var28, var32, var36, var12, var16);
 		}
 
+		this.flipTexture = false;
+	}
+
+	public boolean renderBlockGrass(Block var1, int var2, int var3, int var4) {
+		this.renderStandardBlock(var1, var2, var3, var4);
+		if (Minecraft.isFabulousGraphicsEnabled()) {
+			Block blockAbove = this.blockAccess.getBlock(var2, var3 + 1, var4);
+
+			if (perlinNoise[0].generateNoise3D(var2 * 0.25D, var3 * 0.25D, var4 * 0.25D) > -0.5D
+					&& (blockAbove == null
+					|| (!blockAbove.renderAsNormalBlock() && blockAbove.getRenderType() > 1))) {
+				Tessellator var5 = Tessellator.instance;
+				float light = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
+				int color = var1.getColorMultiplier(this.blockAccess, var2, var3, var4);
+				float r = (color >> 16 & 255) / 255.0F;
+				float g = (color >> 8 & 255) / 255.0F;
+				float b = (color & 255) / 255.0F;
+
+				var5.setColorOpaque_F(r * light, g * light, b * light);
+				this.renderCrossedSquares(var1, -1,
+						var2 + perlinNoise[1].generateNoise3D(var2, var3, var4) * 0.2D,
+						var3 + 0.25D + perlinNoise[2].generateNoise3D(var2, var3, var4) * 0.5D,
+						var4 + perlinNoise[3].generateNoise3D(var2, var3, var4) * 0.2D);
+			}
+		}
+		return true;
 	}
 
 	public void renderBlockOnInventory(Block var1, int var2, float var3) {
@@ -3197,16 +3282,22 @@
 		int var5;
 		float var6;
 		float var7;
+		float r = 1.0F;
+		float g = 1.0F;
+		float b = 1.0F;
 		if(this.field_31088_b) {
 			var5 = var1.getInventoryColor(var2);
 			var6 = (float)(var5 >> 16 & 255) / 255.0F;
 			var7 = (float)(var5 >> 8 & 255) / 255.0F;
 			float var8 = (float)(var5 & 255) / 255.0F;
 			GL11.glColor4f(var6 * var3, var7 * var3, var8 * var3, 1.0F);
+			r = var6;
+			g = var7;
+			b = var8;
 		}
 
 		var5 = var1.getRenderType();
-		if(var5 != 0 && var5 != 16) {
+		if(var5 != 0 && var5 != 7 && var5 != 16) {
 			if(var5 == 1) {
 				var4.startDrawingQuads();
 				var4.setNormal(0.0F, -1.0F, 0.0F);
@@ -3218,34 +3309,34 @@
 				var6 = 1.0F / 16.0F;
 				var4.startDrawingQuads();
 				var4.setNormal(0.0F, -1.0F, 0.0F);
-				this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+				this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, var2));
 				var4.draw();
 				var4.startDrawingQuads();
 				var4.setNormal(0.0F, 1.0F, 0.0F);
-				this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+				this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, var2));
 				var4.draw();
 				var4.startDrawingQuads();
 				var4.setNormal(0.0F, 0.0F, -1.0F);
 				var4.setTranslationF(0.0F, 0.0F, var6);
-				this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
+				this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, var2));
 				var4.setTranslationF(0.0F, 0.0F, -var6);
 				var4.draw();
 				var4.startDrawingQuads();
 				var4.setNormal(0.0F, 0.0F, 1.0F);
 				var4.setTranslationF(0.0F, 0.0F, -var6);
-				this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+				this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, var2));
 				var4.setTranslationF(0.0F, 0.0F, var6);
 				var4.draw();
 				var4.startDrawingQuads();
 				var4.setNormal(-1.0F, 0.0F, 0.0F);
 				var4.setTranslationF(var6, 0.0F, 0.0F);
-				this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
+				this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, var2));
 				var4.setTranslationF(-var6, 0.0F, 0.0F);
 				var4.draw();
 				var4.startDrawingQuads();
 				var4.setNormal(1.0F, 0.0F, 0.0F);
 				var4.setTranslationF(-var6, 0.0F, 0.0F);
-				this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+				this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, var2));
 				var4.setTranslationF(var6, 0.0F, 0.0F);
 				var4.draw();
 				GL11.glTranslatef(0.5F, 0.5F, 0.5F);
@@ -3274,27 +3365,27 @@
 						GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, -1.0F, 0.0F);
-						this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+						this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, 1.0F, 0.0F);
-						this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+						this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, 0.0F, -1.0F);
-						this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
+						this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, 0.0F, 1.0F);
-						this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+						this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(-1.0F, 0.0F, 0.0F);
-						this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
+						this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(1.0F, 0.0F, 0.0F);
-						this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+						this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, var2));
 						var4.draw();
 						GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 					}
@@ -3321,27 +3412,27 @@
 						GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, -1.0F, 0.0F);
-						this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+						this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, 1.0F, 0.0F);
-						this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+						this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, 0.0F, -1.0F);
-						this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
+						this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(0.0F, 0.0F, 1.0F);
-						this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+						this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(-1.0F, 0.0F, 0.0F);
-						this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
+						this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, var2));
 						var4.draw();
 						var4.startDrawingQuads();
 						var4.setNormal(1.0F, 0.0F, 0.0F);
-						this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+						this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, var2));
 						var4.draw();
 						GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 					}
@@ -3356,36 +3447,130 @@
 
 			var1.setBlockBoundsForItemRender();
 			GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
-			var4.startDrawingQuads();
-			var4.setNormal(0.0F, -1.0F, 0.0F);
-			this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, var2));
-			var4.draw();
-			var4.startDrawingQuads();
-			var4.setNormal(0.0F, 1.0F, 0.0F);
-			this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, var2));
-			var4.draw();
-			var4.startDrawingQuads();
-			var4.setNormal(0.0F, 0.0F, -1.0F);
-			this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, var2));
-			var4.draw();
-			var4.startDrawingQuads();
-			var4.setNormal(0.0F, 0.0F, 1.0F);
-			this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, var2));
-			var4.draw();
-			var4.startDrawingQuads();
-			var4.setNormal(-1.0F, 0.0F, 0.0F);
-			this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, var2));
-			var4.draw();
-			var4.startDrawingQuads();
-			var4.setNormal(1.0F, 0.0F, 0.0F);
-			this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, var2));
-			var4.draw();
+			int texture = var1.getBlockTextureFromSideAndMetadata(0, var2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						var4.startDrawingQuads();
+						var4.setNormal(0.0F, -1.0F, 0.0F);
+						this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, subTexture);
+						var4.draw();
+						GL11.glColor4f(var3, var3, var3, 1.0F);
+					}
+					GL11.glColor4f(r * var3, g * var3, b * var3, 1.0F);
+				}
+			} else {
+				var4.startDrawingQuads();
+				var4.setNormal(0.0F, -1.0F, 0.0F);
+				this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, texture);
+				var4.draw();
+			}
+			texture = var1.getBlockTextureFromSideAndMetadata(1, var2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						var4.startDrawingQuads();
+						var4.setNormal(0.0F, 1.0F, 0.0F);
+						this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, subTexture);
+						var4.draw();
+						GL11.glColor4f(var3, var3, var3, 1.0F);
+					}
+					GL11.glColor4f(r * var3, g * var3, b * var3, 1.0F);
+				}
+			} else {
+				var4.startDrawingQuads();
+				var4.setNormal(0.0F, 1.0F, 0.0F);
+				this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, texture);
+				var4.draw();
+			}
+			texture = var1.getBlockTextureFromSideAndMetadata(2, var2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						var4.startDrawingQuads();
+						var4.setNormal(0.0F, 0.0F, -1.0F);
+						this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, subTexture);
+						var4.draw();
+						GL11.glColor4f(var3, var3, var3, 1.0F);
+					}
+					GL11.glColor4f(r * var3, g * var3, b * var3, 1.0F);
+				}
+			} else {
+				var4.startDrawingQuads();
+				var4.setNormal(0.0F, 0.0F, -1.0F);
+				this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, texture);
+				var4.draw();
+			}
+			texture = var1.getBlockTextureFromSideAndMetadata(3, var2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						var4.startDrawingQuads();
+						var4.setNormal(0.0F, 0.0F, 1.0F);
+						this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, subTexture);
+						var4.draw();
+						GL11.glColor4f(var3, var3, var3, 1.0F);
+					}
+					GL11.glColor4f(r * var3, g * var3, b * var3, 1.0F);
+				}
+			} else {
+				var4.startDrawingQuads();
+				var4.setNormal(0.0F, 0.0F, 1.0F);
+				this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, texture);
+				var4.draw();
+			}
+			texture = var1.getBlockTextureFromSideAndMetadata(4, var2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						var4.startDrawingQuads();
+						var4.setNormal(-1.0F, 0.0F, 0.0F);
+						this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, subTexture);
+						var4.draw();
+						GL11.glColor4f(var3, var3, var3, 1.0F);
+					}
+					GL11.glColor4f(r * var3, g * var3, b * var3, 1.0F);
+				}
+			} else {
+				var4.startDrawingQuads();
+				var4.setNormal(-1.0F, 0.0F, 0.0F);
+				this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, texture);
+				var4.draw();
+			}
+			texture = var1.getBlockTextureFromSideAndMetadata(5, var2);
+			if (texture >= 1024) {
+				int[] multiTexture = TerrainLayout.getMultiTexture(texture - 1024);
+				if (multiTexture != null) {
+					for (int subTexture : multiTexture) {
+						var4.startDrawingQuads();
+						var4.setNormal(1.0F, 0.0F, 0.0F);
+						this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, subTexture);
+						var4.draw();
+						GL11.glColor4f(var3, var3, var3, 1.0F);
+					}
+					GL11.glColor4f(r * var3, g * var3, b * var3, 1.0F);
+				}
+			} else {
+				var4.startDrawingQuads();
+				var4.setNormal(1.0F, 0.0F, 0.0F);
+				this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, texture);
+				var4.draw();
+			}
 			GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 		}
-
 	}
 
 	public static boolean renderItemIn3d(int var0) {
-		return var0 == 0 ? true : (var0 == 13 ? true : (var0 == 10 ? true : (var0 == 11 ? true : var0 == 16)));
+		return var0 == 0
+				|| var0 == 7
+				|| var0 == 10
+				|| var0 == 11
+				|| var0 == 13
+				|| var0 == 16;
 	}
 }
--- /dev/null
+++ net/minecraft/util/Array2D.java
@@ -1,0 +1,35 @@
+package net.minecraft.util;
+
+import java.util.function.IntFunction;
+
+public class Array2D<T> {
+	private final T[] array;
+	public final int width, height;
+
+	public Array2D(IntFunction<T[]> arrayConstructor, int width, int height) {
+		this(arrayConstructor.apply(width * height), width, height);
+	}
+
+	public Array2D(T[] array, int width, int height) {
+		if (array.length < width * height) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.height = height;
+	}
+
+	public T get(int x, int y) {
+		return this.array[x * this.height + y];
+	}
+
+	public void set(int x, int y, T value) {
+		this.array[x * this.height + y] = value;
+	}
+
+	public T[] getArray() {
+		return array;
+	}
+
+}
--- net/minecraft/game/world/block/RailBlock.java
+++ net/minecraft/game/world/block/RailBlock.java
@@ -6,11 +6,25 @@
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.MovingObjectPosition;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
 import net.minecraft.game.world.material.Material;
 
 public class RailBlock extends Block {
+	private static final int TEX_POWERED_RAIL_OFF = TerrainLayout.texCoord("powered_rail_off");
+	private static final int TEX_CORNER_RAIL = TerrainLayout.texCoord("corner_rail");
+
+	public static final EnumProperty<Direction> DIRECTION = SharedProperties.DIRECTION;
+	public static final BooleanProperty POWERED = new BooleanProperty("powered");
+
 	private final boolean isPowered;
 
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, POWERED);
+	}
+
 	public static final boolean isRailBlockAt(World var0, int var1, int var2, int var3) {
 		int var4 = var0.getBlockId(var1, var2, var3);
 		return var4 == Block.rail.blockID || var4 == Block.poweredRail.blockID || var4 == Block.detectorRail.blockID;
@@ -56,10 +70,10 @@
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
 		if(this.isPowered) {
 			if(this.blockID == Block.poweredRail.blockID && (var2 & 8) == 0) {
-				return this.textureIndex - 16;
+				return TEX_POWERED_RAIL_OFF;
 			}
 		} else if(var2 >= 6) {
-			return this.textureIndex - 16;
+			return TEX_CORNER_RAIL;
 		}
 
 		return this.textureIndex;
--- net/minecraft/game/world/block/FlowerBlock.java
+++ net/minecraft/game/world/block/FlowerBlock.java
@@ -19,7 +19,7 @@
 	}
 
 	protected boolean canThisPlantGrowOnThisBlockID(int var1) {
-		return var1 == Block.grass.blockID || var1 == Block.dirt.blockID || var1 == Block.farmland.blockID;
+		return var1 == Block.grass.blockID || var1 == Block.dirt.blockID || var1 == Block.farmland.blockID || var1 == Block.mud.blockID;
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
--- /dev/null
+++ net/minecraft/util/IntArray2D.java
@@ -1,0 +1,88 @@
+package net.minecraft.util;
+
+public class IntArray2D {
+	private final int[] array;
+	public final int width, height;
+
+	public IntArray2D(int width, int height) {
+		this(null, width, height);
+	}
+
+	public IntArray2D(int[] array, int width, int height) {
+		if (array == null) {
+			array = new int[width * height];
+		} else if (array.length < width * height) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.height = height;
+	}
+
+	public static IntArray2D xFirst(int width, int height) {
+		return new XFirst(width, height);
+	}
+
+	public static IntArray2D xFirst(int[] array, int width, int height) {
+		return new XFirst(array, width, height);
+	}
+
+	public int get(int x, int y) {
+		return this.array[x * this.height + y];
+	}
+
+	public void set(int x, int y, int value) {
+		this.array[x * this.height + y] = value;
+	}
+
+	public int[] getArray() {
+		return array;
+	}
+
+	public IntArray2D toXFirst() {
+		IntArray2D xFirst = IntArray2D.xFirst(width, height);
+
+		for (int x = 0; x < this.width; x++) {
+			for (int y = 0; y < this.height; y++) {
+				xFirst.set(x, y, this.get(x, y));
+			}
+		}
+
+		return xFirst;
+	}
+
+	public IntArray2D toYFirst() {
+		return this;
+	}
+
+	private static class XFirst extends IntArray2D {
+		public XFirst(int width, int height) {
+			super(width, height);
+		}
+
+		public XFirst(int[] array, int width, int height) {
+			super(array, width, height);
+		}
+
+		public int get(int x, int y) {
+			return this.getArray()[x + y * this.width];
+		}
+
+		public void set(int x, int y, int value) {
+			this.getArray()[x + y * this.width] = value;
+		}
+
+		public IntArray2D toYFirst() {
+			IntArray2D yFirst = new IntArray2D(width, height);
+
+			for (int x = 0; x < this.width; x++) {
+				for (int y = 0; y < this.height; y++) {
+					yFirst.set(x, y, this.get(x, y));
+				}
+			}
+
+			return yFirst;
+		}
+	}
+}
--- argo/J_JsonNodeSelectors.java
+++ /dev/null
@@ -1,59 +1,0 @@
-package argo;
-
-import java.util.Arrays;
-
-public final class J_JsonNodeSelectors {
-	public static J_JsonNodeSelector func_27349_a(Object... var0) {
-		return func_27352_a(var0, new J_JsonNodeSelector(new J_JsonStringNodeSelector()));
-	}
-
-	public static J_JsonNodeSelector func_27346_b(Object... var0) {
-		return func_27352_a(var0, new J_JsonNodeSelector(new J_JsonArrayNodeSelector()));
-	}
-
-	public static J_JsonNodeSelector func_27353_c(Object... var0) {
-		return func_27352_a(var0, new J_JsonNodeSelector(new J_JsonObjectNodeSelector()));
-	}
-
-	public static J_JsonNodeSelector func_27348_a(String var0) {
-		return func_27350_a(J_JsonNodeFactories.func_27316_a(var0));
-	}
-
-	public static J_JsonNodeSelector func_27350_a(J_JsonStringNode var0) {
-		return new J_JsonNodeSelector(new J_JsonFieldNodeSelector(var0));
-	}
-
-	public static J_JsonNodeSelector func_27351_b(String var0) {
-		return func_27353_c(new Object[0]).func_27355_a(func_27348_a(var0));
-	}
-
-	public static J_JsonNodeSelector func_27347_a(int var0) {
-		return new J_JsonNodeSelector(new J_JsonElementNodeSelector(var0));
-	}
-
-	public static J_JsonNodeSelector func_27354_b(int var0) {
-		return func_27346_b(new Object[0]).func_27355_a(func_27347_a(var0));
-	}
-
-	private static J_JsonNodeSelector func_27352_a(Object[] var0, J_JsonNodeSelector var1) {
-		J_JsonNodeSelector var2 = var1;
-
-		for(int var3 = var0.length - 1; var3 >= 0; --var3) {
-			if(var0[var3] instanceof Integer) {
-				var2 = func_27345_a(func_27354_b(((Integer)var0[var3]).intValue()), var2);
-			} else {
-				if(!(var0[var3] instanceof String)) {
-					throw new IllegalArgumentException("Element [" + var0[var3] + "] of path elements" + " [" + Arrays.toString(var0) + "] was of illegal type [" + var0[var3].getClass().getCanonicalName() + "]; only Integer and String are valid.");
-				}
-
-				var2 = func_27345_a(func_27351_b((String)var0[var3]), var2);
-			}
-		}
-
-		return var2;
-	}
-
-	private static J_JsonNodeSelector func_27345_a(J_JsonNodeSelector var0, J_JsonNodeSelector var1) {
-		return new J_JsonNodeSelector(new J_ChainedFunctor(var0, var1));
-	}
-}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/Shader.java
@@ -1,0 +1,258 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import it.unimi.dsi.fastutil.ints.IntList;
+import net.mine_diver.smoothbeta.client.render.gl.*;
+import net.mine_diver.smoothbeta.util.UtilsFromHell;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.render.texture.TexturePackBase;
+import org.lwjgl.opengl.GL13;
+
+import java.io.*;
+import java.util.*;
+
+public class Shader implements GlShader, AutoCloseable {
+	private static final String CORE_DIRECTORY = "/shaders/core/";
+	private static final String INCLUDE_DIRECTORY = "/shaders/include/";
+	private static int activeShaderId;
+	private final Map<String, Object> samplers = new HashMap<>();
+	private final List<String> samplerNames = new ArrayList<>();
+	private final IntList loadedSamplerIds = new IntArrayList();
+	private final List<GlUniform> uniforms = new ArrayList<>();
+	private final Map<String, GlUniform> loadedUniforms = new HashMap<>();
+	private final int programId;
+	private final String name;
+	private final GlBlendState blendState;
+	private final Program vertexShader;
+	private final Program fragmentShader;
+	public final GlUniform
+			modelViewMat,
+			projectionMat,
+			fogMode,
+			chunkOffset;
+
+	public Shader(String name, ShaderInfo info) throws IOException {
+		this.name = name;
+
+		if (info.samplers != null) {
+			for (ShaderInfo.Sampler sampler : info.samplers) {
+				if (sampler.file == null) {
+					this.samplers.put(sampler.name, null);
+				}
+				this.samplerNames.add(sampler.name);
+			}
+		}
+
+		List<Integer> loadedAttributeIds = null;
+		List<String> attributeNames = null;
+		if (info.attributes != null) {
+			loadedAttributeIds = new ArrayList<>(info.attributes.length);
+			attributeNames = new ArrayList<>(info.attributes.length);
+			attributeNames.addAll(Arrays.asList(info.attributes));
+		}
+
+		if (info.uniforms != null) {
+			for (ShaderInfo.Uniform uniform : info.uniforms) {
+				if (uniform.values == null || uniform.values.length != uniform.count && uniform.values.length > 1) {
+					throw new ShaderParseException("Invalid amount of values specified (expected " + uniform.count + ", found " + (uniform.values == null ? 0 : uniform.values.length) + ")");
+				}
+
+				float[] values = new float[Math.max(uniform.count, 16)];
+				System.arraycopy(uniform.values, 0, values, 0, uniform.values.length);
+
+				if (uniform.count > 1 && uniform.values.length == 1) {
+					for (int i = 1; i <= uniform.count; i++) {
+						values[i] = values[0];
+					}
+				}
+
+				int type = GlUniform.getTypeIndex(uniform.type);
+				int offsetType = type;
+				if (uniform.count > 1 && uniform.count <= 4 && type < 8) {
+					offsetType += uniform.count - 1;
+				}
+
+				GlUniform glUniform = new GlUniform(uniform.name, offsetType, uniform.count);
+				if (offsetType <= 3) glUniform.setForDataType((int)values[0], (int)values[1], (int)values[2], (int)values[3]);
+				else if (offsetType <= 7) glUniform.setForDataType(values[0], values[1], values[2], values[3]);
+				else glUniform.set(values);
+
+				this.uniforms.add(glUniform);
+			}
+		}
+
+		this.blendState = info.blendState;
+		this.vertexShader = Shader.loadProgram(Program.Type.VERTEX, info.vertex);
+		this.fragmentShader = Shader.loadProgram(Program.Type.FRAGMENT, info.fragment);
+		this.programId = GlProgramManager.createProgram();
+
+		if (attributeNames != null) {
+			int i = 0;
+			for (String attributeName : info.vertexFormat.getAttributeNames()) {
+				GlUniform.bindAttribLocation(this.programId, i, attributeName);
+				loadedAttributeIds.add(i);
+				i++;
+			}
+		}
+
+		GlProgramManager.linkProgram(this);
+		this.loadReferences();
+
+		this.modelViewMat = this.getUniform("ModelViewMat");
+		this.projectionMat = this.getUniform("ProjMat");
+		this.fogMode = this.getUniform("FogMode");
+		this.chunkOffset = this.getUniform("ChunkOffset");
+	}
+
+	private static Program loadProgram(Program.Type type, String name) throws IOException {
+		Program program = type.getProgramCache().get(name);
+		if (program != null) return program;
+
+		String path = CORE_DIRECTORY + name + type.getFileExtension();
+		TexturePackBase texturePack = Minecraft.getInstance().texturePackList.selectedTexturePack;
+		try (InputStream inputStream = texturePack.getResourceAsStream(path)) {
+			String posixPath = UtilsFromHell.getPosixFullPath(path);
+			program = Program.createFromResource(type, name, inputStream, texturePack.texturePackFileName, new GLImportProcessor() {
+				private final Set<String> visitedImports = new HashSet<>();
+
+				@Override
+				public String loadImport(boolean inline, String name) {
+					String string;
+					name = UtilsFromHell.normalizeToPosix((inline ? posixPath : Shader.INCLUDE_DIRECTORY) + name);
+					if (!this.visitedImports.add(name)) return null;
+					BufferedReader reader;
+					reader = new BufferedReader(new InputStreamReader(texturePack.getResourceAsStream(name)));
+					try {
+						string = UtilsFromHell.toString(reader);
+					} catch (Throwable throwable) {
+						try {
+							if (reader != null) try {
+								((Reader) reader).close();
+							} catch (Throwable throwable2) {
+								throwable.addSuppressed(throwable2);
+							}
+							throw throwable;
+						} catch (IOException iOException) {
+							System.err.printf("Could not open GLSL import %s: %s%n", name, iOException.getMessage());
+							return "#error " + iOException.getMessage();
+						}
+					}
+					try {
+						((Reader) reader).close();
+					} catch (IOException e) {
+						throw new RuntimeException(e);
+					}
+					return string;
+				}
+			});
+		}
+
+		return program;
+	}
+
+	public void addSampler(String name, Object sampler) {
+		this.samplers.put(name, sampler);
+	}
+
+	public void close() {
+		for (GlUniform glUniform : this.uniforms) glUniform.close();
+		GlProgramManager.deleteProgram(this);
+	}
+
+	public void unbind() {
+		GlProgramManager.useProgram(0);
+		activeShaderId = -1;
+		int i = GlStateManager._getActiveTexture();
+
+		for(int j = 0; j < this.loadedSamplerIds.size(); ++j)
+			if (this.samplers.get(this.samplerNames.get(j)) != null) {
+				GlStateManager._activeTexture(GL13.GL_TEXTURE0 + j);
+				GlStateManager._bindTexture(0);
+			}
+
+		GlStateManager._activeTexture(i);
+	}
+
+	public void bind() {
+		this.blendState.enable();
+		if (this.programId != activeShaderId) {
+			GlProgramManager.useProgram(this.programId);
+			activeShaderId = this.programId;
+		}
+
+		int i = GlStateManager._getActiveTexture();
+
+		for(int j = 0; j < this.loadedSamplerIds.size(); ++j) {
+			String string = this.samplerNames.get(j);
+			if (this.samplers.get(string) != null) {
+				int k = GlUniform.getUniformLocation(this.programId, string);
+				GlUniform.uniform1(k, j);
+				GlStateManager._activeTexture(GL13.GL_TEXTURE0 + j);
+				GlStateManager._enableTexture();
+				Object object = this.samplers.get(string);
+				int l = -1;
+				if (object instanceof Integer) l = (Integer) object;
+
+				if (l != -1) GlStateManager._bindTexture(l);
+			}
+		}
+
+		GlStateManager._activeTexture(i);
+
+		for (GlUniform glUniform : this.uniforms) glUniform.upload();
+
+	}
+
+	public GlUniform getUniform(String name) {
+		return this.loadedUniforms.get(name);
+	}
+
+	private void loadReferences() {
+		IntList intList = new IntArrayList();
+
+		int i;
+		for(i = 0; i < this.samplerNames.size(); ++i) {
+			String string = this.samplerNames.get(i);
+			int j = GlUniform.getUniformLocation(this.programId, string);
+			if (j == -1) {
+				System.err.printf("Shader %s could not find sampler named %s in the specified shader program.%n", this.name, string);
+				this.samplers.remove(string);
+				intList.add(i);
+			} else this.loadedSamplerIds.add(j);
+		}
+
+		for(i = intList.size() - 1; i >= 0; --i) {
+			int k = intList.getInt(i);
+			this.samplerNames.remove(k);
+		}
+
+		for (GlUniform glUniform : this.uniforms) {
+			String string2 = glUniform.getName();
+			int l = GlUniform.getUniformLocation(this.programId, string2);
+			if (l == -1)
+				System.err.printf("Shader %s could not find uniform named %s in the specified shader program.%n", this.name, string2);
+			else {
+				glUniform.setLocation(l);
+				this.loadedUniforms.put(string2, glUniform);
+			}
+		}
+
+	}
+
+	public Program getVertexShader() {
+		return this.vertexShader;
+	}
+
+	public Program getFragmentShader() {
+		return this.fragmentShader;
+	}
+
+	public void attachReferencedShaders() {
+		this.fragmentShader.attachTo(this);
+		this.vertexShader.attachTo(this);
+	}
+
+	public int getProgramRef() {
+		return this.programId;
+	}
+}
--- net/minecraft/game/entity/animal/PigEntity.java
+++ net/minecraft/game/entity/animal/PigEntity.java
@@ -4,7 +4,6 @@
 import net.minecraft.game.entity.monster.PigZombieEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.entity.weather.LightningBoltEntity;
-import net.minecraft.game.item.Item;
 import net.minecraft.game.stats.achievement.AchievementList;
 import net.minecraft.game.world.World;
 
@@ -16,7 +15,7 @@
 	}
 
 	protected void entityInit() {
-		this.properties.addProperty(16, Byte.valueOf((byte)0));
+		this.properties.addProperty(16, (byte) 0);
 	}
 
 	public void writeEntityToNBT(CompoundTag var1) {
@@ -50,19 +49,15 @@
 		}
 	}
 
-	protected int getDropItemId() {
-		return this.fire > 0 ? Item.cookedPorkchop.itemID : Item.rawPorkchop.itemID;
-	}
-
 	public boolean getSaddled() {
 		return (this.properties.getByte(16) & 1) != 0;
 	}
 
 	public void setSaddled(boolean var1) {
 		if(var1) {
-			this.properties.updateProperty(16, Byte.valueOf((byte)1));
+			this.properties.updateProperty(16, (byte) 1);
 		} else {
-			this.properties.updateProperty(16, Byte.valueOf((byte)0));
+			this.properties.updateProperty(16, (byte) 0);
 		}
 
 	}
--- net/minecraft/client/gui/OptionsScreen.java
+++ net/minecraft/client/gui/OptionsScreen.java
@@ -1,74 +1,153 @@
 package net.minecraft.client.gui;
 
 import net.minecraft.client.GameSettings;
+import net.minecraft.client.KeyBinding;
 import net.minecraft.client.Option;
-import net.minecraft.client.gui.component.GuiButton;
-import net.minecraft.client.gui.component.GuiOptionsButton;
-import net.minecraft.client.gui.component.GuiSettingsSlider;
+import net.minecraft.client.gui.component.*;
+import net.minecraft.client.render.Tessellator;
 import net.minecraft.util.StringTranslate;
+import org.lwjgl.opengl.GL11;
+
+import java.util.List;
+
+import static net.minecraft.util.StringTranslate.i18n;
 
 public class OptionsScreen extends GuiScreen {
 	private GuiScreen parentScreen;
 	protected String screenTitle = "Options";
-	private GameSettings options;
-	private static Option[] field_22135_k = new Option[]{Option.MUSIC, Option.SOUND, Option.INVERT_MOUSE, Option.SENSITIVITY, Option.DIFFICULTY};
+	private GameSettings gameSettings;
+	private Option[] options = new Option[]{Option.MUSIC, Option.SOUND, Option.INVERT_MOUSE, Option.SENSITIVITY, Option.DIFFICULTY};
+	private int page;
+	private GuiButton keyBindButton;
 
 	public OptionsScreen(GuiScreen var1, GameSettings var2) {
 		this.parentScreen = var1;
-		this.options = var2;
+		this.gameSettings = var2;
 	}
 
 	public void initGui() {
+		this.keyBindButton = null;
+		this.controlList.clear();
+
 		StringTranslate var1 = StringTranslate.getInstance();
 		this.screenTitle = var1.translateKey("options.title");
 		int var2 = 0;
-		Option[] var3 = field_22135_k;
-		int var4 = var3.length;
+		List<Option> var3 = Option.SORTED_OPTIONS.get(Option.CATEGORIES.get(this.page));
+		int var4 = var3.size();
 
+		GuiContainer container = (GuiContainer)new GuiContainer().at(120, 0).size(-120, 0).alignedSize(1.0F, 1.0F);
 		for(int var5 = 0; var5 < var4; ++var5) {
-			Option var6 = var3[var5];
+			Option var6 = var3.get(var5);
 			if(!var6.isSlider()) {
-				this.controlList.add(new GuiOptionsButton(var6.getId(), this.width / 2 - 155 + var2 % 2 * 160, this.height / 6 + 24 * (var2 >> 1), var6, this.options.getKeyBinding(var6)));
+				container.addControl(new GuiOptionsButton(var6.getId(), -145 + var2 % 2 * 150, 30 + 24 * (var2 >> 1), var6,
+						this.gameSettings.getKeyBinding(var6)).alignedAt(0.5F, 0.0F));
 			} else {
-				this.controlList.add(new GuiSettingsSlider(var6.getId(), this.width / 2 - 155 + var2 % 2 * 160, this.height / 6 + 24 * (var2 >> 1), var6, this.options.getKeyBinding(var6), this.options.getOptionFloatValue(var6)));
+				container.addControl(new GuiSettingsSlider(var6.getId(), -145 + var2 % 2 * 150, 30 + 24 * (var2 >> 1), var6,
+						this.gameSettings.getKeyBinding(var6), this.gameSettings.getOptionFloatValue(var6)).alignedAt(0.5F, 0.0F));
 			}
 
 			++var2;
 		}
 
-		this.controlList.add(new GuiButton(101, this.width / 2 - 100, this.height / 6 + 96 + 12, var1.translateKey("options.video")));
-		this.controlList.add(new GuiButton(100, this.width / 2 - 100, this.height / 6 + 120 + 12, var1.translateKey("options.controls")));
-		this.controlList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 168, var1.translateKey("gui.done")));
+		if (Option.CATEGORIES.get(this.page).equals("options.category.controls")) {
+			KeyBinding[] keyBindings = this.gameSettings.keyBindings;
+			for(int var5 = 0; var5 < keyBindings.length; ++var5) {
+				container.addControl(new GuiOptionsButton(var5 - 200, -145 + var2 % 2 * 150, 30 + 24 * (var2 >> 1),
+						this.gameSettings.getKeyBindingDescription(var5)
+								+ ": " + this.gameSettings.getOptionDisplayString(var5)).alignedAt(0.5F, 0.0F));
+				++var2;
+			}
+		}
+
+		this.controlList.add(container);
+
+		this.controlList.add(new GuiButton(-1, 10, 30, 100, 20, var1.translateKey("gui.done")));
+
+		int y = 60;
+		for (int i = 0; i < Option.CATEGORIES.size(); i++) {
+			String text = i18n(Option.CATEGORIES.get(i));
+			if (this.page == i) text = "> " + text;
+			this.controlList.add(new GuiTransparentButton(i - 100, 10, y, 100, 20, text));
+			y += 20;
+		}
 	}
 
 	protected void actionPerformed(GuiButton var1) {
 		if(var1.enabled) {
-			if(var1.id < 100 && var1 instanceof GuiOptionsButton) {
-				this.options.setOptionValue(((GuiOptionsButton)var1).returnEnumOptions(), 1);
-				var1.displayString = this.options.getKeyBinding(Option.getOptionFromId(var1.id));
-			}
-
-			if(var1.id == 101) {
-				this.mc.gameSettings.saveOptions();
-				this.mc.displayGuiScreen(new VideoSettingsScreen(this, this.options));
+			if(var1.id >= 0 && var1.id < 100 && var1 instanceof GuiOptionsButton) {
+				this.gameSettings.setOptionValue(((GuiOptionsButton)var1).returnEnumOptions(), 1);
+				var1.displayString = this.gameSettings.getKeyBinding(Option.getOptionFromId(var1.id));
 			}
 
 			if(var1.id == 100) {
 				this.mc.gameSettings.saveOptions();
-				this.mc.displayGuiScreen(new ControlsScreen(this, this.options));
+				this.mc.displayGuiScreen(new ControlsScreen(this, this.gameSettings));
 			}
 
-			if(var1.id == 200) {
+			if(var1.id == -1) {
 				this.mc.gameSettings.saveOptions();
 				this.mc.displayGuiScreen(this.parentScreen);
 			}
 
-		}
+			if (var1.id >= -100 && var1.id < Option.CATEGORIES.size() - 100) {
+				this.page = var1.id + 100;
+				this.initGui();
+			}
+
+			if (var1.id >= -200 && var1.id < this.gameSettings.keyBindings.length - 200) {
+				int keyBindId = var1.id + 200;
+				if (this.keyBindButton != null) {
+					this.keyBindButton.displayString = this.gameSettings.getKeyBindingDescription(this.keyBindButton.id + 200)
+							+ ": " + this.gameSettings.getOptionDisplayString(this.keyBindButton.id + 200);
+				}
+				this.keyBindButton = var1;
+				var1.displayString = "> " + this.gameSettings.getKeyBindingDescription(keyBindId)
+						+ ": " + this.gameSettings.getOptionDisplayString(keyBindId) + " <";
+			}
+
+		}
+	}
+
+	protected void keyTyped(char var1, int var2) {
+		if(this.keyBindButton != null) {
+			this.gameSettings.setKeyBinding(this.keyBindButton.id + 200, var2);
+			this.keyBindButton.displayString = this.gameSettings.getKeyBindingDescription(this.keyBindButton.id + 200)
+							+ ": " + this.gameSettings.getOptionDisplayString(this.keyBindButton.id + 200);
+			this.keyBindButton = null;
+		} else {
+			super.keyTyped(var1, var2);
+		}
+
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
-		this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 20, 16777215);
+		this.drawDefaultBackground(var3);
+
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/gui/background.png"));
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		Tessellator t = Tessellator.instance;
+		t.startDrawingQuads();
+		t.setColorOpaque_I(2105376);
+		t.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+		t.addVertexWithUV(120.0D, 0.0D, 0.0D, 3.75D, 0.0D);
+		t.addVertexWithUV(120.0D, this.height, 0.0D, 3.75D, this.height / 32.0D);
+		t.addVertexWithUV(0.0D, this.height, 0.0D, 0.0D, this.height / 32.0D);
+		t.draw();
+
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);
+		t.startDrawingQuads();
+		t.setColorRGBA_F(0.0F, 0.0F, 0.0F, 1.0F);
+		t.addVertex(120.0D, this.height, 0.0D);
+		t.addVertex(120.0D, 0.0D, 0.0D);
+		t.setColorRGBA_F(0.0F, 0.0F, 0.0F, 0.0F);
+		t.addVertex(136.0D, 0.0D, 0.0D);
+		t.addVertex(136.0D, this.height, 0.0D);
+		t.draw();
+		GL11.glDisable(GL11.GL_BLEND);
+
+		this.drawString(this.fontRenderer, this.screenTitle, 10, 10, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
 }
--- net/minecraft/client/gui/ThreadConnectToServer.java
+++ net/minecraft/client/gui/ThreadConnectToServer.java
@@ -32,20 +32,20 @@
 				return;
 			}
 
-			this.mc.displayGuiScreen(new ConnectionFailedScreen("connect.failed", "disconnect.genericReason", new Object[]{"Unknown host \'" + this.hostName + "\'"}));
+			this.mc.displayGuiScreen(new ConnectionFailedScreen("connect.failed", "disconnect.genericReason", "Unknown host \'" + this.hostName + "\'"));
 		} catch (ConnectException var3) {
 			if(ConnectingScreen.isCancelled(this.connectingGui)) {
 				return;
 			}
 
-			this.mc.displayGuiScreen(new ConnectionFailedScreen("connect.failed", "disconnect.genericReason", new Object[]{var3.getMessage()}));
+			this.mc.displayGuiScreen(new ConnectionFailedScreen("connect.failed", "disconnect.genericReason", var3.getMessage()));
 		} catch (Exception var4) {
 			if(ConnectingScreen.isCancelled(this.connectingGui)) {
 				return;
 			}
 
 			var4.printStackTrace();
-			this.mc.displayGuiScreen(new ConnectionFailedScreen("connect.failed", "disconnect.genericReason", new Object[]{var4.toString()}));
+			this.mc.displayGuiScreen(new ConnectionFailedScreen("connect.failed", "disconnect.genericReason", var4.toString()));
 		}
 
 	}
--- net/minecraft/network/packet/Packet15Place.java
+++ net/minecraft/network/packet/Packet15Place.java
@@ -26,7 +26,7 @@
 
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.xPosition = var1.readInt();
-		this.yPosition = var1.read();
+		this.yPosition = var1.readInt();
 		this.zPosition = var1.readInt();
 		this.direction = var1.read();
 		short var2 = var1.readShort();
@@ -42,7 +42,7 @@
 
 	public void writePacketData(DataOutputStream var1) throws IOException {
 		var1.writeInt(this.xPosition);
-		var1.write(this.yPosition);
+		var1.writeInt(this.yPosition);
 		var1.writeInt(this.zPosition);
 		var1.write(this.direction);
 		if(this.itemStack == null) {
@@ -60,6 +60,6 @@
 	}
 
 	public int getPacketSize() {
-		return 15;
+		return 18;
 	}
 }
--- net/minecraft/client/gui/component/GuiYesNo.java
+++ net/minecraft/client/gui/component/GuiYesNo.java
@@ -29,7 +29,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.message1, this.width / 2, 70, 16777215);
 		this.drawCenteredString(this.fontRenderer, this.message2, this.width / 2, 90, 16777215);
 		super.drawScreen(var1, var2, var3);
--- /dev/null
+++ net/minecraft/game/world/block/properties/PropertyPadding.java
@@ -1,0 +1,29 @@
+package net.minecraft.game.world.block.properties;
+
+public class PropertyPadding implements Property<Void> {
+	private final int size;
+
+	public PropertyPadding(int size) {
+		this.size = size;
+	}
+
+	public Void getValue(int metadataSlice) {
+		return null;
+	}
+
+	public int getIntValue(Void value) {
+		return 0;
+	}
+
+	public String toString(Void value) {
+		return null;
+	}
+
+	public String getName() {
+		return null;
+	}
+
+	public int getSize() {
+		return this.size;
+	}
+}
--- /dev/null
+++ net/minecraft/util/BiomePreviewer.java
@@ -1,0 +1,60 @@
+package net.minecraft.util;
+
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.game.world.biome.ClimaticBiomeSource;
+
+import java.awt.*;
+import java.awt.datatransfer.DataFlavor;
+import java.awt.datatransfer.Transferable;
+import java.awt.datatransfer.UnsupportedFlavorException;
+import java.awt.image.BufferedImage;
+
+public class BiomePreviewer {
+	public static void main(String[] args) {
+		long seed = "Glacier".hashCode();
+
+		int width = 1024;
+		int height = 1024;
+		double scale = 16.0D;
+
+		ClimaticBiomeSource biomeSource = new ClimaticBiomeSource(seed, true);
+		Biome[] biomes = biomeSource.loadBlockGeneratorData(new Biome[width * height], 0, 0, width, height, scale);
+
+		BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+		for (int x = 0; x < width; x++) {
+			for (int z = 0; z < height; z++) {
+				int i = x + z * width;
+				Biome biome = biomes[i];
+				img.setRGB(x, z, biome.mapColor);
+			}
+		}
+		copyImage(img);
+	}
+
+	private static void copyImage(BufferedImage image) {
+		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new ImageTransferable(image), null);
+	}
+
+	private static class ImageTransferable implements Transferable {
+	    private final BufferedImage image;
+
+	    public ImageTransferable(BufferedImage image) {
+	        this.image = image;
+	    }
+
+	    public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {
+	        if (flavor.equals(DataFlavor.imageFlavor)) {
+		        return image;
+	        }
+            throw new UnsupportedFlavorException(flavor);
+	    }
+
+	    public DataFlavor[] getTransferDataFlavors() {
+	        return new DataFlavor[]{DataFlavor.imageFlavor};
+	    }
+
+	    public boolean isDataFlavorSupported(DataFlavor flavor) {
+	        return flavor.equals(DataFlavor.imageFlavor);
+	    }
+	}
+}
--- net/minecraft/game/world/block/PistonBaseBlock.java
+++ net/minecraft/game/world/block/PistonBaseBlock.java
@@ -3,16 +3,29 @@
 import java.util.ArrayList;
 import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.PistonItem;
+import net.minecraft.game.item.SubtypedItem;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
 import net.minecraft.game.world.block.tileentity.PistonTileEntity;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
 import net.minecraft.util.MathHelper;
 
 public class PistonBaseBlock extends Block {
-	private boolean isSticky;
+	public static final int TEX_SIDE = TerrainLayout.texCoord("piston_side");
+	public static final int TEX_BOTTOM = TerrainLayout.texCoord("piston_bottom");
+	public static final int TEX_EXTENSION = TerrainLayout.texCoord("piston_extension");
+
+	public static final EnumProperty<Direction> DIRECTION = SharedProperties.DIRECTION;
+	public static final BooleanProperty EXTENDED = new BooleanProperty("extended");
+	private final boolean isSticky;
 	private boolean ignoreUpdates;
 
 	public PistonBaseBlock(int var1, int var2, boolean var3) {
@@ -22,13 +35,29 @@
 		this.setHardness(0.5F);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, EXTENDED);
+	}
+
+	protected Item getItem() {
+		return new PistonItem(this.blockID - 256);
+	}
+
 	public int getFaceTexture() {
-		return this.isSticky ? 106 : 107;
+		return this.isSticky ? Block.stickyPiston.textureIndex : Block.piston.textureIndex;
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		int var3 = getOrientation(var2);
-		return var3 > 5 ? this.textureIndex : (var1 == var3 ? (!isExtended(var2) && this.minX <= 0.0D && this.minY <= 0.0D && this.minZ <= 0.0D && this.maxX >= 1.0D && this.maxY >= 1.0D && this.maxZ >= 1.0D ? this.textureIndex : 110) : (var1 == Direction.oppositeFace[var3] ? 109 : 108));
+		Direction var3 = getOrientation(var2);
+		return var3 == null
+				? this.textureIndex
+				: var1 == var3.ordinal()
+						? !isExtended(var2) && this.minX <= 0.0D && this.minY <= 0.0D && this.minZ <= 0.0D && this.maxX >= 1.0D && this.maxY >= 1.0D && this.maxZ >= 1.0D
+								? this.textureIndex
+								: TEX_EXTENSION
+						: var1 == var3.getOpposite().ordinal()
+								? TEX_BOTTOM
+								: TEX_SIDE;
 	}
 
 	public int getRenderType() {
@@ -68,45 +97,57 @@
 
 	private void updatePistonState(World var1, int var2, int var3, int var4) {
 		int var5 = var1.getBlockMetadata(var2, var3, var4);
-		int var6 = getOrientation(var5);
+		Direction var6 = getOrientation(var5);
 		boolean var7 = this.isPowered(var1, var2, var3, var4, var6);
 		if(var5 != 7) {
 			if(var7 && !isExtended(var5)) {
 				if(canExtend(var1, var2, var3, var4, var6)) {
-					var1.setBlockMetadata(var2, var3, var4, var6 | 8);
-					var1.playNoteAt(var2, var3, var4, 0, var6);
+					var1.setBlockProperty(var2, var3, var4, EXTENDED, true);
+					var1.playNoteAt(var2, var3, var4, 0, var6.ordinal() | 8);
 				}
 			} else if(!var7 && isExtended(var5)) {
-				var1.setBlockMetadata(var2, var3, var4, var6);
-				var1.playNoteAt(var2, var3, var4, 1, var6);
+				var1.setBlockProperty(var2, var3, var4, EXTENDED, false);
+				var1.playNoteAt(var2, var3, var4, 1, var6.ordinal());
 			}
 
 		}
 	}
 
-	private boolean isPowered(World var1, int var2, int var3, int var4, int var5) {
-		return var5 != 0 && var1.isBlockIndirectlyProvidingPowerTo(var2, var3 - 1, var4, 0) ? true : (var5 != 1 && var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 1, var4, 1) ? true : (var5 != 2 && var1.isBlockIndirectlyProvidingPowerTo(var2, var3, var4 - 1, 2) ? true : (var5 != 3 && var1.isBlockIndirectlyProvidingPowerTo(var2, var3, var4 + 1, 3) ? true : (var5 != 5 && var1.isBlockIndirectlyProvidingPowerTo(var2 + 1, var3, var4, 5) ? true : (var5 != 4 && var1.isBlockIndirectlyProvidingPowerTo(var2 - 1, var3, var4, 4) ? true : (var1.isBlockIndirectlyProvidingPowerTo(var2, var3, var4, 0) ? true : (var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 2, var4, 1) ? true : (var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 1, var4 - 1, 2) ? true : (var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 1, var4 + 1, 3) ? true : (var1.isBlockIndirectlyProvidingPowerTo(var2 - 1, var3 + 1, var4, 4) ? true : var1.isBlockIndirectlyProvidingPowerTo(var2 + 1, var3 + 1, var4, 5)))))))))));
+	private boolean isPowered(World var1, int var2, int var3, int var4, Direction var5) {
+		return (var5 == null || var5.ordinal() != 0) && var1.isBlockIndirectlyProvidingPowerTo(var2, var3 - 1, var4, 0)
+				|| (var5 == null || var5.ordinal() != 1) && var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 1, var4, 1)
+				|| (var5 == null || var5.ordinal() != 2) && var1.isBlockIndirectlyProvidingPowerTo(var2, var3, var4 - 1, 2)
+				|| (var5 == null || var5.ordinal() != 3) && var1.isBlockIndirectlyProvidingPowerTo(var2, var3, var4 + 1, 3)
+				|| (var5 == null || var5.ordinal() != 5) && var1.isBlockIndirectlyProvidingPowerTo(var2 + 1, var3, var4, 5)
+				|| (var5 == null || var5.ordinal() != 4) && var1.isBlockIndirectlyProvidingPowerTo(var2 - 1, var3, var4, 4)
+				|| var1.isBlockIndirectlyProvidingPowerTo(var2, var3, var4, 0)
+				|| var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 2, var4, 1)
+				|| var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 1, var4 - 1, 2)
+				|| var1.isBlockIndirectlyProvidingPowerTo(var2, var3 + 1, var4 + 1, 3)
+				|| var1.isBlockIndirectlyProvidingPowerTo(var2 - 1, var3 + 1, var4, 4)
+				|| var1.isBlockIndirectlyProvidingPowerTo(var2 + 1, var3 + 1, var4, 5);
 	}
 
 	public void playBlock(World var1, int var2, int var3, int var4, int var5, int var6) {
+		Direction var6d = this.properties.get(var6, DIRECTION);
 		this.ignoreUpdates = true;
 		if(var5 == 0) {
-			if(this.tryExtend(var1, var2, var3, var4, var6)) {
-				var1.setBlockMetadataWithNotify(var2, var3, var4, var6 | 8);
+			if(this.tryExtend(var1, var2, var3, var4, var6d)) {
+				var1.setBlockPropertyWithNotify(var2, var3, var4, EXTENDED, true);
 				var1.playSoundEffect((double)var2 + 0.5D, (double)var3 + 0.5D, (double)var4 + 0.5D, "tile.piston.out", 0.5F, var1.rand.nextFloat() * 0.25F + 0.6F);
 			}
 		} else if(var5 == 1) {
-			TileEntity var8 = var1.getBlockTileEntity(var2 + Direction.faceToX[var6], var3 + Direction.faceToY[var6], var4 + Direction.faceToZ[var6]);
+			TileEntity var8 = var1.getBlockTileEntity(var2 + var6d.X, var3 + var6d.Y, var4 + var6d.Z);
 			if(var8 != null && var8 instanceof PistonTileEntity) {
 				((PistonTileEntity)var8).clearPistonTileEntity();
 			}
 
 			var1.setBlockAndMetadata(var2, var3, var4, Block.movingPiston.blockID, var6);
-			var1.setBlockTileEntity(var2, var3, var4, MovingPistonBlock.getTileEntity(this.blockID, var6, var6, false, true));
+			var1.setBlockTileEntity(var2, var3, var4, MovingPistonBlock.getTileEntity(this.blockID, var6, var6d, false, true));
 			if(this.isSticky) {
-				int var9 = var2 + Direction.faceToX[var6] * 2;
-				int var10 = var3 + Direction.faceToY[var6] * 2;
-				int var11 = var4 + Direction.faceToZ[var6] * 2;
+				int var9 = var2 + var6d.X * 2;
+				int var10 = var3 + var6d.Y * 2;
+				int var11 = var4 + var6d.Z * 2;
 				int var12 = var1.getBlockId(var9, var10, var11);
 				int var13 = var1.getBlockMetadata(var9, var10, var11);
 				boolean var14 = false;
@@ -114,7 +155,7 @@
 					TileEntity var15 = var1.getBlockTileEntity(var9, var10, var11);
 					if(var15 != null && var15 instanceof PistonTileEntity) {
 						PistonTileEntity var16 = (PistonTileEntity)var15;
-						if(var16.getOrientation() == var6 && var16.isExtending()) {
+						if(var16.getOrientation() == var6d && var16.isExtending()) {
 							var16.clearPistonTileEntity();
 							var12 = var16.getStoredBlockID();
 							var13 = var16.getBlockMetadata();
@@ -126,22 +167,22 @@
 				if(var14 || var12 <= 0 || !canPushBlock(var12, var1, var9, var10, var11, false) || Block.blocksList[var12].getMobilityFlag() != 0 && var12 != Block.piston.blockID && var12 != Block.stickyPiston.blockID) {
 					if(!var14) {
 						this.ignoreUpdates = false;
-						var1.setBlockWithNotify(var2 + Direction.faceToX[var6], var3 + Direction.faceToY[var6], var4 + Direction.faceToZ[var6], 0);
+						var1.setBlockWithNotify(var2 + var6d.X, var3 + var6d.Y, var4 + var6d.Z, 0);
 						this.ignoreUpdates = true;
 					}
 				} else {
 					this.ignoreUpdates = false;
 					var1.setBlockWithNotify(var9, var10, var11, 0);
 					this.ignoreUpdates = true;
-					var2 += Direction.faceToX[var6];
-					var3 += Direction.faceToY[var6];
-					var4 += Direction.faceToZ[var6];
+					var2 += var6d.X;
+					var3 += var6d.Y;
+					var4 += var6d.Z;
 					var1.setBlockAndMetadata(var2, var3, var4, Block.movingPiston.blockID, var13);
-					var1.setBlockTileEntity(var2, var3, var4, MovingPistonBlock.getTileEntity(var12, var13, var6, false, false));
+					var1.setBlockTileEntity(var2, var3, var4, MovingPistonBlock.getTileEntity(var12, var13, var6d, false, false));
 				}
 			} else {
 				this.ignoreUpdates = false;
-				var1.setBlockWithNotify(var2 + Direction.faceToX[var6], var3 + Direction.faceToY[var6], var4 + Direction.faceToZ[var6], 0);
+				var1.setBlockWithNotify(var2 + var6d.X, var3 + var6d.Y, var4 + var6d.Z, 0);
 				this.ignoreUpdates = true;
 			}
 
@@ -155,22 +196,22 @@
 		int var5 = var1.getBlockMetadata(var2, var3, var4);
 		if(isExtended(var5)) {
 			switch(getOrientation(var5)) {
-			case 0:
+			case BOTTOM:
 				this.setBlockBounds(0.0F, 0.25F, 0.0F, 1.0F, 1.0F, 1.0F);
 				break;
-			case 1:
+			case TOP:
 				this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 12.0F / 16.0F, 1.0F);
 				break;
-			case 2:
+			case NORTH:
 				this.setBlockBounds(0.0F, 0.0F, 0.25F, 1.0F, 1.0F, 1.0F);
 				break;
-			case 3:
+			case SOUTH:
 				this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 12.0F / 16.0F);
 				break;
-			case 4:
+			case WEST:
 				this.setBlockBounds(0.25F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
 				break;
-			case 5:
+			case EAST:
 				this.setBlockBounds(0.0F, 0.0F, 0.0F, 12.0F / 16.0F, 1.0F, 1.0F);
 			}
 		} else {
@@ -192,12 +233,12 @@
 		return false;
 	}
 
-	public static int getOrientation(int var0) {
-		return var0 & 7;
+	public static Direction getOrientation(int var0) {
+		return Block.piston.properties.get(var0, DIRECTION);
 	}
 
 	public static boolean isExtended(int var0) {
-		return (var0 & 8) != 0;
+		return Block.piston.properties.getBoolean(var0, EXTENDED);
 	}
 
 	private static int determineOrientation(World var0, int var1, int var2, int var3, PlayerEntity var4) {
@@ -241,18 +282,14 @@
 		}
 	}
 
-	private static boolean canExtend(World var0, int var1, int var2, int var3, int var4) {
-		int var5 = var1 + Direction.faceToX[var4];
-		int var6 = var2 + Direction.faceToY[var4];
-		int var7 = var3 + Direction.faceToZ[var4];
+	private static boolean canExtend(World var0, int var1, int var2, int var3, Direction var4) {
+		int var5 = var1 + var4.X;
+		int var6 = var2 + var4.Y;
+		int var7 = var3 + var4.Z;
 		int var8 = 0;
 
 		while(true) {
 			if(var8 < 13) {
-				if(var6 <= 0 || var6 >= 127) {
-					return false;
-				}
-
 				int var9 = var0.getBlockId(var5, var6, var7);
 				if(var9 != 0) {
 					if(!canPushBlock(var9, var0, var5, var6, var7, true)) {
@@ -264,9 +301,9 @@
 							return false;
 						}
 
-						var5 += Direction.faceToX[var4];
-						var6 += Direction.faceToY[var4];
-						var7 += Direction.faceToZ[var4];
+						var5 += var4.X;
+						var6 += var4.Y;
+						var7 += var4.Z;
 						++var8;
 						continue;
 					}
@@ -277,19 +314,15 @@
 		}
 	}
 
-	private boolean tryExtend(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = var2 + Direction.faceToX[var5];
-		int var7 = var3 + Direction.faceToY[var5];
-		int var8 = var4 + Direction.faceToZ[var5];
+	private boolean tryExtend(World var1, int var2, int var3, int var4, Direction var5) {
+		int var6 = var2 + var5.X;
+		int var7 = var3 + var5.Y;
+		int var8 = var4 + var5.Z;
 		int var9 = 0;
 
 		while(true) {
 			int var10;
 			if(var9 < 13) {
-				if(var7 <= 0 || var7 >= 127) {
-					return false;
-				}
-
 				var10 = var1.getBlockId(var6, var7, var8);
 				if(var10 != 0) {
 					if(!canPushBlock(var10, var1, var6, var7, var8, true)) {
@@ -301,9 +334,9 @@
 							return false;
 						}
 
-						var6 += Direction.faceToX[var5];
-						var7 += Direction.faceToY[var5];
-						var8 += Direction.faceToZ[var5];
+						var6 += var5.X;
+						var7 += var5.Y;
+						var8 += var5.Z;
 						++var9;
 						continue;
 					}
@@ -314,14 +347,14 @@
 			}
 
 			while(var6 != var2 || var7 != var3 || var8 != var4) {
-				var9 = var6 - Direction.faceToX[var5];
-				var10 = var7 - Direction.faceToY[var5];
-				int var11 = var8 - Direction.faceToZ[var5];
+				var9 = var6 - var5.X;
+				var10 = var7 - var5.Y;
+				int var11 = var8 - var5.Z;
 				int var12 = var1.getBlockId(var9, var10, var11);
 				int var13 = var1.getBlockMetadata(var9, var10, var11);
 				if(var12 == this.blockID && var9 == var2 && var10 == var3 && var11 == var4) {
-					var1.setBlockAndMetadata(var6, var7, var8, Block.movingPiston.blockID, var5 | (this.isSticky ? 8 : 0));
-					var1.setBlockTileEntity(var6, var7, var8, MovingPistonBlock.getTileEntity(Block.pistonExtension.blockID, var5 | (this.isSticky ? 8 : 0), var5, true, false));
+					var1.setBlockAndMetadata(var6, var7, var8, Block.movingPiston.blockID, var5.ordinal() | (this.isSticky ? 8 : 0));
+					var1.setBlockTileEntity(var6, var7, var8, MovingPistonBlock.getTileEntity(Block.pistonExtension.blockID, var5.ordinal() | (this.isSticky ? 8 : 0), var5, true, false));
 				} else {
 					var1.setBlockAndMetadata(var6, var7, var8, Block.movingPiston.blockID, var13);
 					var1.setBlockTileEntity(var6, var7, var8, MovingPistonBlock.getTileEntity(var12, var13, var5, true, false));
--- net/minecraft/server/world/WorldServer.java
+++ net/minecraft/server/world/WorldServer.java
@@ -2,11 +2,15 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.WaterMobEntity;
 import net.minecraft.game.entity.animal.AnimalEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.world.Explosion;
+import net.minecraft.game.world.NewWorldInfo;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.chunk.ChunkProvider;
@@ -20,7 +24,6 @@
 import net.minecraft.network.packet.Packet70Bed;
 import net.minecraft.network.packet.Packet71Weather;
 import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.MCHash;
 import net.minecraft.util.MathHelper;
 
 public class WorldServer extends World {
@@ -28,10 +31,10 @@
 	public boolean field_819_z = false;
 	public boolean levelSaving;
 	private MinecraftServer mcServer;
-	private MCHash field_20912_E = new MCHash();
+	private Int2ObjectMap<Entity> field_20912_E = new Int2ObjectOpenHashMap<>();
 
-	public WorldServer(MinecraftServer var1, SaveHandler var2, String var3, int var4, long var5) {
-		super(var2, var3, var5, Dimension.getProviderForDimension(var4));
+	public WorldServer(MinecraftServer var1, SaveHandler var2, int var4, NewWorldInfo var3) {
+		super(var2, var3, Dimension.getProviderForDimension(var4));
 		this.mcServer = var1;
 	}
 
@@ -79,18 +82,18 @@
 		return var6 > 16 || this.mcServer.configManager.isOp(var1.username);
 	}
 
-	protected void obtainEntitySkin(Entity var1) {
+	public void obtainEntitySkin(Entity var1) {
 		super.obtainEntitySkin(var1);
-		this.field_20912_E.addKey(var1.entityId, var1);
+		this.field_20912_E.put(var1.entityId, var1);
 	}
 
 	protected void releaseEntitySkin(Entity var1) {
 		super.releaseEntitySkin(var1);
-		this.field_20912_E.removeObject(var1.entityId);
+		this.field_20912_E.remove(var1.entityId);
 	}
 
 	public Entity func_6158_a(int var1) {
-		return (Entity)this.field_20912_E.lookup(var1);
+		return this.field_20912_E.get(var1);
 	}
 
 	public boolean addWeatherEffect(Entity var1) {
--- net/minecraft/game/entity/animal/WolfEntity.java
+++ net/minecraft/game/entity/animal/WolfEntity.java
@@ -34,9 +34,9 @@
 
 	protected void entityInit() {
 		super.entityInit();
-		this.properties.addProperty(16, Byte.valueOf((byte)0));
+		this.properties.addProperty(16, (byte) 0);
 		this.properties.addProperty(17, "");
-		this.properties.addProperty(18, new Integer(this.health));
+		this.properties.addProperty(18, this.health);
 	}
 
 	protected boolean canTriggerWalking() {
@@ -91,10 +91,6 @@
 		return 0.4F;
 	}
 
-	protected int getDropItemId() {
-		return -1;
-	}
-
 	protected void updatePlayerActionState() {
 		super.updatePlayerActionState();
 		if(!this.hasAttacked && !this.hasPath() && this.isTamed() && this.ridingEntity == null) {
@@ -119,7 +115,7 @@
 		}
 
 		if(!this.worldObj.remoteWorld) {
-			this.properties.updateProperty(18, Integer.valueOf(this.health));
+			this.properties.updateProperty(18, this.health);
 		}
 
 	}
@@ -453,9 +449,9 @@
 	public void setSitting(boolean var1) {
 		byte var2 = this.properties.getByte(16);
 		if(var1) {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 | 1)));
+			this.properties.updateProperty(16, (byte) (var2 | 1));
 		} else {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 & -2)));
+			this.properties.updateProperty(16, (byte) (var2 & -2));
 		}
 
 	}
@@ -467,9 +463,9 @@
 	public void setAngry(boolean var1) {
 		byte var2 = this.properties.getByte(16);
 		if(var1) {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 | 2)));
+			this.properties.updateProperty(16, (byte) (var2 | 2));
 		} else {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 & -3)));
+			this.properties.updateProperty(16, (byte) (var2 & -3));
 		}
 
 	}
@@ -481,9 +477,9 @@
 	public void setTamed(boolean var1) {
 		byte var2 = this.properties.getByte(16);
 		if(var1) {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 | 4)));
+			this.properties.updateProperty(16, (byte) (var2 | 4));
 		} else {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 & -5)));
+			this.properties.updateProperty(16, (byte) (var2 & -5));
 		}
 
 	}
--- /dev/null
+++ argo/jdom/JdomParser.java
@@ -1,0 +1,24 @@
+package argo.jdom;
+
+import argo.saj.InvalidSyntaxException;
+import argo.saj.SajParser;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+
+public final class JdomParser {
+	public JsonRootNode parse(Reader var1) throws InvalidSyntaxException, IOException {
+		JsonListenerToJdomAdapter var2 = new JsonListenerToJdomAdapter();
+		(new SajParser()).parse(var1, var2);
+		return var2.getDocument();
+	}
+
+	public JsonRootNode parse(String var1) throws InvalidSyntaxException {
+		try {
+            return this.parse(new StringReader(var1));
+		} catch (IOException var4) {
+			throw new RuntimeException("Coding failure in Argo:  StringWriter gave an IOException", var4);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/block/properties/BooleanProperty.java
@@ -1,0 +1,40 @@
+package net.minecraft.game.world.block.properties;
+
+public class BooleanProperty implements Property<Boolean> {
+	private final String name;
+	private final String trueName, falseName;
+
+	public BooleanProperty(String name) {
+		this(name, "§atrue", "§cfalse");
+	}
+
+	public BooleanProperty(String name, String trueName, String falseName) {
+		this.name = name;
+		this.trueName = trueName;
+		this.falseName = falseName;
+	}
+
+	public Boolean getValue(int metadataSlice) {
+		return metadataSlice != 0;
+	}
+
+	public int getIntValue(Boolean value) {
+		return value ? 1 : 0;
+	}
+
+	public String toString(Boolean value) {
+		return value ? this.trueName : this.falseName;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public int getSize() {
+		return 1;
+	}
+
+	public boolean supportDynamicSize() {
+		return false;
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerApplyVariants.java
@@ -1,0 +1,22 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.util.IntArray2D;
+
+public class LayerApplyVariants extends Layer {
+	private final int size;
+
+	public LayerApplyVariants(long seed, Layer parent, int size) {
+		super(seed, parent);
+		this.size = size;
+	}
+
+	protected IntArray2D getData(int x, int z, int width, int length) {
+		return forEach(x, z, width, length, (i, ox, oz) -> {
+			if (this.size == 0) {
+				this.setChunkSeed((ox + x >> 1) + this.nextInt(3) / 2, (oz + z >> 1) + this.nextInt(3) / 2);
+			}
+			return Biome.biomeIndex[i].getVariant(this.size, this::nextInt).id;
+		});
+	}
+}
--- net/minecraft/game/world/block/StairsBlock.java
+++ net/minecraft/game/world/block/StairsBlock.java
@@ -2,25 +2,44 @@
 
 import java.util.ArrayList;
 import java.util.Random;
+
+import com.sun.org.apache.xpath.internal.operations.Bool;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.SubtypedItem;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.*;
+import net.minecraft.game.world.material.Material;
 import net.minecraft.util.MathHelper;
 
 public class StairsBlock extends Block {
-	private Block modelBlock;
-
-	protected StairsBlock(int var1, Block var2) {
-		super(var1, var2.textureIndex, var2.material);
-		this.modelBlock = var2;
-		this.setHardness(var2.hardness);
-		this.setResistance(var2.resistance / 3.0F);
-		this.setStepSound(var2.stepSound);
+	public static final EnumProperty<StairDirection> DIRECTION = new EnumProperty<>(StairDirection.class);
+	public static final BooleanProperty HALF = new BooleanProperty("half", "bottom", "top");
+	public static final IntProperty TYPE = new IntProperty("type");
+
+	private final ModelBlock[] modelBlocks;
+
+	protected StairsBlock(int var1, Material var2, ModelBlock[] var3) {
+		super(var1, 1, var2);
+		if (var3.length > 32) {
+			throw new IllegalArgumentException("Too many stair types! 32 maximum!");
+		}
+		this.modelBlocks = var3;
 		this.setLightOpacity(255);
+		this.setSpecialLighting();
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, HALF, TYPE);
+	}
+
+	protected Item getItem() {
+		return new SubtypedItem(this.blockID - 256);
 	}
 
 	public void setBlockBoundsBasedOnState(BlockAccess var1, int var2, int var3, int var4) {
@@ -47,147 +66,124 @@
 		return super.shouldSideBeRendered(var1, var2, var3, var4, var5);
 	}
 
+	public void doShape(BlockAccess blockAccess, int x, int y, int z, Runnable action) {
+		boolean finishedTop = false;
+
+		StairDirection dir = blockAccess.getBlockProperty(x, y, z, DIRECTION);
+		boolean half = blockAccess.getBlockBooleanProperty(x, y, z, HALF);
+
+		float yOffBot = half ? 0.5F : 0.0F;
+		float yOffTop = half ? 0.0F : 0.5F;
+
+		// Inner corner checks
+		if (!finishedTop) {
+			int frontX = x + dir.getFrontX();
+			int frontZ = z + dir.getFrontZ();
+			Block frontBlock = blockAccess.getBlock(frontX, y, frontZ);
+
+			if (frontBlock instanceof StairsBlock
+					&& blockAccess.getBlockBooleanProperty(frontX, y, frontZ, HALF) == half) {
+				StairDirection frontDir = blockAccess.getBlockProperty(frontX, y, frontZ, DIRECTION);
+				if (frontDir.getPerpLeft() == dir || frontDir.getPerpRight() == dir) {
+					StairDirection drawDir = frontDir == dir.getPerpRight() ? dir.getBehind() : dir.getPerpLeft();
+
+					this.setBlockBounds(
+							dir.getStairMinX(), yOffTop, dir.getStairMinZ(),
+							dir.getStairMaxX(), yOffTop + 0.5F, dir.getStairMaxZ()
+					);
+					action.run();
+
+					this.setBlockBounds(
+							drawDir.getInnerStairMinX(), yOffTop, drawDir.getInnerStairMinZ(),
+							drawDir.getInnerStairMaxX(), yOffTop + 0.5F, drawDir.getInnerStairMaxZ()
+					);
+					action.run();
+					finishedTop = true;
+				}
+			}
+		}
+
+		// Outer corner checks
+		if (!finishedTop) {
+			int backX = x + dir.getBackX();
+			int backZ = z + dir.getBackZ();
+			Block backBlock = blockAccess.getBlock(backX, y, backZ);
+
+			if (backBlock instanceof StairsBlock
+					&& blockAccess.getBlockBooleanProperty(backZ, y, backZ, HALF) == half) {
+				StairDirection backDir = blockAccess.getBlockProperty(backX, y, backZ, DIRECTION);
+				StairDirection drawDir = null;
+
+				if (backDir == dir.getPerpLeft()) {
+					drawDir = dir;
+					finishedTop = true;
+				} else if (backDir == dir.getPerpRight()) {
+					drawDir = dir.getPerpRight();
+					finishedTop = true;
+				}
+
+				if (finishedTop) {
+					this.setBlockBounds(
+							drawDir.getInnerStairMinX(), yOffTop, drawDir.getInnerStairMinZ(),
+							drawDir.getInnerStairMaxX(), yOffTop + 0.5F, drawDir.getInnerStairMaxZ()
+					);
+					action.run();
+				}
+			}
+		}
+
+		// Default drawing
+		if (!finishedTop) {
+			this.setBlockBounds(
+					dir.getStairMinX(), yOffTop, dir.getStairMinZ(),
+					dir.getStairMaxX(), yOffTop + 0.5F, dir.getStairMaxZ()
+			);
+			action.run();
+			finishedTop = true;
+		}
+
+		this.setBlockBounds(0.0F, yOffBot, 0.0F, 1.0F, yOffBot + 0.5F, 1.0F);
+		action.run();
+		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+	}
+
 	public void getCollidingBoundingBoxes(World var1, int var2, int var3, int var4, AxisAlignedBB var5, ArrayList var6) {
-		int var7 = var1.getBlockMetadata(var2, var3, var4);
-		if(var7 == 0) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 0.5F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		} else if(var7 == 1) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 1.0F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		} else if(var7 == 2) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 0.5F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 1.0F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		} else if(var7 == 3) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 0.5F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 0.5F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		}
-
-		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-	}
-
-	public void randomDisplayTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.modelBlock.randomDisplayTick(var1, var2, var3, var4, var5);
-	}
-
-	public void onBlockClicked(World var1, int var2, int var3, int var4, PlayerEntity var5) {
-		this.modelBlock.onBlockClicked(var1, var2, var3, var4, var5);
-	}
-
-	public void onBlockDestroyedByPlayer(World var1, int var2, int var3, int var4, int var5) {
-		this.modelBlock.onBlockDestroyedByPlayer(var1, var2, var3, var4, var5);
-	}
-
-	public float getBlockBrightness(BlockAccess var1, int var2, int var3, int var4) {
-		return this.modelBlock.getBlockBrightness(var1, var2, var3, var4);
-	}
-
-	public float getExplosionResistance(Entity var1) {
-		return this.modelBlock.getExplosionResistance(var1);
-	}
-
-	public int getRenderBlockPass() {
-		return this.modelBlock.getRenderBlockPass();
-	}
-
-	public int idDropped(int var1, Random var2) {
-		return this.modelBlock.idDropped(var1, var2);
-	}
-
-	public int quantityDropped(Random var1) {
-		return this.modelBlock.quantityDropped(var1);
+		this.doShape(var1, var2, var3, var4,
+				() -> super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6));
+	}
+
+	protected int damageDropped(int var1) {
+		return this.properties.getInt(var1, TYPE);
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return this.modelBlock.getBlockTextureFromSideAndMetadata(var1, var2);
-	}
-
-	public int getBlockTextureFromSide(int var1) {
-		return this.modelBlock.getBlockTextureFromSide(var1);
-	}
-
-	public int getBlockTexture(BlockAccess var1, int var2, int var3, int var4, int var5) {
-		return this.modelBlock.getBlockTexture(var1, var2, var3, var4, var5);
-	}
-
-	public int tickRate() {
-		return this.modelBlock.tickRate();
-	}
-
-	public AxisAlignedBB getSelectedBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
-		return this.modelBlock.getSelectedBoundingBoxFromPool(var1, var2, var3, var4);
-	}
-
-	public void velocityToAddToEntity(World var1, int var2, int var3, int var4, Entity var5, Vec3D var6) {
-		this.modelBlock.velocityToAddToEntity(var1, var2, var3, var4, var5, var6);
-	}
-
-	public boolean isCollidable() {
-		return this.modelBlock.isCollidable();
-	}
-
-	public boolean canCollideCheck(int var1, boolean var2) {
-		return this.modelBlock.canCollideCheck(var1, var2);
-	}
-
-	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
-		return this.modelBlock.canPlaceBlockAt(var1, var2, var3, var4);
+		return this.modelBlocks[this.properties.getInt(var2, TYPE)].getTextureFromSide(var1);
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
 		this.onNeighborBlockChange(var1, var2, var3, var4, 0);
-		this.modelBlock.onBlockAdded(var1, var2, var3, var4);
-	}
-
-	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
-		this.modelBlock.onBlockRemoval(var1, var2, var3, var4);
-	}
-
-	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
-		this.modelBlock.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
-	}
-
-	public void onEntityWalking(World var1, int var2, int var3, int var4, Entity var5) {
-		this.modelBlock.onEntityWalking(var1, var2, var3, var4, var5);
-	}
-
-	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.modelBlock.updateTick(var1, var2, var3, var4, var5);
-	}
-
-	public boolean blockActivated(World var1, int var2, int var3, int var4, PlayerEntity var5) {
-		return this.modelBlock.blockActivated(var1, var2, var3, var4, var5);
-	}
-
-	public void onBlockDestroyedByExplosion(World var1, int var2, int var3, int var4) {
-		this.modelBlock.onBlockDestroyedByExplosion(var1, var2, var3, var4);
+	}
+
+	public AxisAlignedBB getSelectedBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
+		return AxisAlignedBB.getBoundingBoxFromPool(var2 + 0.0F, var3 + 0.0F, var4 + 0.0F, var2 + 1.0F, var3 + 1.0F, var4 + 1.0F);
+	}
+
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		if (var5 == 0) {
+			var1.setBlockProperty(var2, var3, var4, HALF, true);
+		}
 	}
 
 	public void onBlockPlacedBy(World var1, int var2, int var3, int var4, LivingEntity var5) {
 		int var6 = MathHelper.floor((double)(var5.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3;
 		if(var6 == 0) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 2);
-		}
-
-		if(var6 == 1) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 1);
-		}
-
-		if(var6 == 2) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 3);
-		}
-
-		if(var6 == 3) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 0);
-		}
-
+			var1.setBlockPropertyWithNotify(var2, var3, var4, DIRECTION, StairDirection.SOUTH);
+		} else if(var6 == 1) {
+			var1.setBlockPropertyWithNotify(var2, var3, var4, DIRECTION, StairDirection.WEST);
+		} else if(var6 == 2) {
+			var1.setBlockPropertyWithNotify(var2, var3, var4, DIRECTION, StairDirection.NORTH);
+		} else {
+			var1.setBlockPropertyWithNotify(var2, var3, var4, DIRECTION, StairDirection.EAST);
+		}
 	}
 }
--- net/minecraft/client/model/ModelRenderer.java
+++ net/minecraft/client/model/ModelRenderer.java
@@ -8,6 +8,8 @@
 public class ModelRenderer {
 	private ModelVertex[] corners;
 	private TexturedQuad[] faces;
+	public float textureWidth;
+	public float textureHeight;
 	private int textureOffsetX;
 	private int textureOffsetY;
 	public float rotationPointX;
@@ -23,6 +25,8 @@
 	public boolean skipRender = false;
 
 	public ModelRenderer(int var1, int var2) {
+		this.textureWidth = 64.0F;
+		this.textureHeight = 32.0F;
 		this.textureOffsetX = var1;
 		this.textureOffsetY = var2;
 	}
@@ -65,12 +69,12 @@
 		this.corners[5] = var16;
 		this.corners[6] = var17;
 		this.corners[7] = var18;
-		this.faces[0] = new TexturedQuad(new ModelVertex[]{var16, var12, var13, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6 + var5);
-		this.faces[1] = new TexturedQuad(new ModelVertex[]{var20, var15, var18, var14}, this.textureOffsetX + 0, this.textureOffsetY + var6, this.textureOffsetX + var6, this.textureOffsetY + var6 + var5);
-		this.faces[2] = new TexturedQuad(new ModelVertex[]{var16, var15, var20, var12}, this.textureOffsetX + var6, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6);
-		this.faces[3] = new TexturedQuad(new ModelVertex[]{var13, var14, var18, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4 + var4, this.textureOffsetY + var6);
-		this.faces[4] = new TexturedQuad(new ModelVertex[]{var12, var20, var14, var13}, this.textureOffsetX + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6 + var5);
-		this.faces[5] = new TexturedQuad(new ModelVertex[]{var15, var16, var17, var18}, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6 + var4, this.textureOffsetY + var6 + var5);
+		this.faces[0] = new TexturedQuad(new ModelVertex[]{var16, var12, var13, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6 + var5, this.textureWidth, this.textureHeight);
+		this.faces[1] = new TexturedQuad(new ModelVertex[]{var20, var15, var18, var14}, this.textureOffsetX + 0, this.textureOffsetY + var6, this.textureOffsetX + var6, this.textureOffsetY + var6 + var5, this.textureWidth, this.textureHeight);
+		this.faces[2] = new TexturedQuad(new ModelVertex[]{var16, var15, var20, var12}, this.textureOffsetX + var6, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6, this.textureWidth, this.textureHeight);
+		this.faces[3] = new TexturedQuad(new ModelVertex[]{var13, var14, var18, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4 + var4, this.textureOffsetY + var6, this.textureWidth, this.textureHeight);
+		this.faces[4] = new TexturedQuad(new ModelVertex[]{var12, var20, var14, var13}, this.textureOffsetX + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6 + var5, this.textureWidth, this.textureHeight);
+		this.faces[5] = new TexturedQuad(new ModelVertex[]{var15, var16, var17, var18}, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6 + var4, this.textureOffsetY + var6 + var5, this.textureWidth, this.textureHeight);
 		if(this.mirror) {
 			for(int var19 = 0; var19 < this.faces.length; ++var19) {
 				this.faces[var19].flipFace();
@@ -191,5 +195,11 @@
 
 		GL11.glEndList();
 		this.compiled = true;
+	}
+
+	public ModelRenderer setTextureSize(int var1, int var2) {
+		this.textureWidth = (float)var1;
+		this.textureHeight = (float)var2;
+		return this;
 	}
 }
--- net/minecraft/game/entity/monster/ZombieEntity.java
+++ net/minecraft/game/entity/monster/ZombieEntity.java
@@ -1,6 +1,5 @@
 package net.minecraft.game.entity.monster;
 
-import net.minecraft.game.item.Item;
 import net.minecraft.game.world.World;
 import net.minecraft.util.MathHelper;
 
@@ -35,7 +34,4 @@
 		return "mob.zombiedeath";
 	}
 
-	protected int getDropItemId() {
-		return Item.feather.itemID;
-	}
 }
--- net/minecraft/client/gui/VideoSettingsScreen.java
+++ net/minecraft/client/gui/VideoSettingsScreen.java
@@ -11,7 +11,7 @@
 	private GuiScreen field_22110_h;
 	protected String field_22107_a = "Video Settings";
 	private GameSettings guiGameSettings;
-	private static Option[] field_22108_k = new Option[]{Option.GRAPHICS, Option.RENDER_DISTANCE, Option.AMBIENT_OCCLUSION, Option.FRAMERATE_LIMIT, Option.ANAGLYPH, Option.VIEW_BOBBING, Option.GUI_SCALE, Option.ADVANCED_OPENGL};
+	private static Option[] field_22108_k = new Option[]{Option.GRAPHICS, Option.RENDER_DISTANCE, Option.AMBIENT_OCCLUSION, Option.MAX_FPS, Option.ANAGLYPH, Option.VIEW_BOBBING, Option.GUI_SCALE, Option.ADVANCED_OPENGL};
 
 	public VideoSettingsScreen(GuiScreen var1, GameSettings var2) {
 		this.field_22110_h = var1;
@@ -28,15 +28,15 @@
 		for(int var5 = 0; var5 < var4; ++var5) {
 			Option var6 = var3[var5];
 			if(!var6.isSlider()) {
-				this.controlList.add(new GuiOptionsButton(var6.getId(), this.width / 2 - 155 + var2 % 2 * 160, this.height / 6 + 24 * (var2 >> 1), var6, this.guiGameSettings.getKeyBinding(var6)));
+				this.controlList.add(new GuiOptionsButton(var6.getId(), -155 + var2 % 2 * 160, 24 * (var2 >> 1), var6, this.guiGameSettings.getKeyBinding(var6)).alignedAt(0.5F, 1.0F / 6.0F));
 			} else {
-				this.controlList.add(new GuiSettingsSlider(var6.getId(), this.width / 2 - 155 + var2 % 2 * 160, this.height / 6 + 24 * (var2 >> 1), var6, this.guiGameSettings.getKeyBinding(var6), this.guiGameSettings.getOptionFloatValue(var6)));
+				this.controlList.add(new GuiSettingsSlider(var6.getId(), -155 + var2 % 2 * 160, 24 * (var2 >> 1), var6, this.guiGameSettings.getKeyBinding(var6), this.guiGameSettings.getOptionFloatValue(var6)).alignedAt(0.5F, 1.0F / 6.0F));
 			}
 
 			++var2;
 		}
 
-		this.controlList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 168, var1.translateKey("gui.done")));
+		this.controlList.add(new GuiButton(200, -100, 168, var1.translateKey("gui.done")).alignedAt(0.5F, 1.0F / 6.0F));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -59,7 +59,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.field_22107_a, this.width / 2, 20, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
--- net/minecraft/game/world/block/Block.java
+++ net/minecraft/game/world/block/Block.java
@@ -7,15 +7,7 @@
 import net.minecraft.game.entity.MobType;
 import net.minecraft.game.entity.misc.ItemEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
-import net.minecraft.game.item.BlockItem;
-import net.minecraft.game.item.Item;
-import net.minecraft.game.item.ItemStack;
-import net.minecraft.game.item.LeavesItem;
-import net.minecraft.game.item.PistonItem;
-import net.minecraft.game.item.SaplingItem;
-import net.minecraft.game.item.SlabItem;
-import net.minecraft.game.item.SubtypedItem;
-import net.minecraft.game.item.WoolItem;
+import net.minecraft.game.item.*;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.stats.StatCollector;
@@ -23,9 +15,12 @@
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.MovingObjectPosition;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.block.tileentity.SignTileEntity;
 import net.minecraft.game.world.material.Material;
 
+import static net.minecraft.game.world.block.TerrainLayout.texCoord;
+
 public class Block {
 	public static final StepSound soundPowderFootstep = new StepSound("stone", 1.0F, 1.0F);
 	public static final StepSound soundWoodFootstep = new StepSound("wood", 1.0F, 1.0F);
@@ -44,102 +39,116 @@
 	public static final boolean[] canBlockGrass = new boolean[256];
 	public static final int[] lightValue = new int[256];
 	public static final boolean[] requiresSelfNotify = new boolean[256];
-	public static final Block stone = (new StoneBlock(1, 1)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stone");
+	public static final boolean[] specialLighting = new boolean[256];
+	public static final Block stone = (new StoneBlock(1, texCoord("stone"))).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stone");
 	public static final GrassBlock grass = (GrassBlock)(new GrassBlock(2)).setHardness(0.6F).setStepSound(soundGrassFootstep).setName("grass");
-	public static final Block dirt = (new DirtBlock(3, 2)).setHardness(0.5F).setStepSound(soundGravelFootstep).setName("dirt");
-	public static final Block cobblestone = (new Block(4, 16, Material.stone)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stonebrick");
-	public static final Block planks = (new Block(5, 4, Material.wood)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setName("wood").setRequiresSelfNotify();
-	public static final Block sapling = (new SaplingBlock(6, 15)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("sapling").setRequiresSelfNotify();
-	public static final Block bedrock = (new Block(7, 17, Material.stone)).setBlockUnbreakable().setResistance(6000000.0F).setStepSound(soundStoneFootstep).setName("bedrock").disableStats();
+	public static final Block dirt = (new DirtBlock(3, texCoord("dirt"))).setHardness(0.5F).setStepSound(soundGravelFootstep).setName("dirt");
+	public static final Block cobblestone = (new Block(4, texCoord("cobblestone"), Material.stone)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stonebrick");
+	public static final Block planks = (new PlanksBlock(5)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setName("wood").setRequiresSelfNotify();
+	public static final Block sapling = (new SaplingBlock(6, texCoord("oak_sapling"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("sapling").setRequiresSelfNotify();
+	public static final Block bedrock = (new Block(7, texCoord("bedrock"), Material.stone)).setBlockUnbreakable().setResistance(6000000.0F).setStepSound(soundStoneFootstep).setName("bedrock").disableStats();
 	public static final Block flowingWater = (new FlowingLiquidBlock(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setName("water").disableStats().setRequiresSelfNotify();
 	public static final Block stillWater = (new StillLiquidBlock(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setName("water").disableStats().setRequiresSelfNotify();
 	public static final Block flowingLava = (new FlowingLiquidBlock(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setLightOpacity(255).setName("lava").disableStats().setRequiresSelfNotify();
 	public static final Block stillLava = (new StillLiquidBlock(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setLightOpacity(255).setName("lava").disableStats().setRequiresSelfNotify();
-	public static final Block sand = (new SandBlock(12, 18)).setHardness(0.5F).setStepSound(soundSandFootstep).setName("sand");
-	public static final Block gravel = (new GravelBlock(13, 19)).setHardness(0.6F).setStepSound(soundGravelFootstep).setName("gravel");
-	public static final Block goldOre = (new OreBlock(14, 32)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreGold");
-	public static final Block ironOre = (new OreBlock(15, 33)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreIron");
-	public static final Block coalOre = (new OreBlock(16, 34)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreCoal");
+	public static final Block sand = (new SandBlock(12, texCoord("sand"))).setHardness(0.5F).setStepSound(soundSandFootstep).setName("sand");
+	public static final Block gravel = (new GravelBlock(13, texCoord("gravel"))).setHardness(0.6F).setStepSound(soundGravelFootstep).setName("gravel");
+	public static final Block goldOre = (new OreBlock(14, texCoord("gold_ore"))).setHardness(3.0F).setResistance(5.0F).setHarvestLevel(2).setStepSound(soundStoneFootstep).setName("oreGold");
+	public static final Block ironOre = (new OreBlock(15, texCoord("iron_ore"))).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreIron");
+	public static final Block coalOre = (new OreBlock(16, texCoord("coal_ore"))).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreCoal");
 	public static final Block log = (new LogBlock(17)).setHardness(2.0F).setStepSound(soundWoodFootstep).setName("log").setRequiresSelfNotify();
-	public static final LeavesBlock leaves = (LeavesBlock)(new LeavesBlock(18, 52)).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep).setName("leaves").disableStats().setRequiresSelfNotify();
+	public static final LeavesBlock leaves = (LeavesBlock)(new LeavesBlock(18, texCoord("oak_leaves"))).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep).setName("leaves").disableStats().setRequiresSelfNotify();
 	public static final Block sponge = (new SpongeBlock(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setName("sponge");
-	public static final Block glass = (new GlassBlock(20, 49, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setName("glass");
-	public static final Block lapisOre = (new OreBlock(21, 160)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreLapis");
-	public static final Block lapisBlock = (new Block(22, 144, Material.stone)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("blockLapis");
+	public static final Block glass = (new GlassBlock(20, texCoord("glass"), Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setName("glass");
+	public static final Block lapisOre = (new OreBlock(21, texCoord("lapis_ore"))).setHardness(3.0F).setResistance(5.0F).setHarvestLevel(1).setStepSound(soundStoneFootstep).setName("oreLapis");
+	public static final Block lapisBlock = (new Block(22, texCoord("lapis_block"), Material.stone)).setHardness(3.0F).setResistance(5.0F).setHarvestLevel(1).setStepSound(soundStoneFootstep).setName("blockLapis");
 	public static final Block dispenser = (new DispenserBlock(23)).setHardness(3.5F).setStepSound(soundStoneFootstep).setName("dispenser").setRequiresSelfNotify();
 	public static final Block sandstone = (new SandstoneBlock(24)).setStepSound(soundStoneFootstep).setHardness(0.8F).setName("sandStone");
 	public static final Block noteBlock = (new NoteBlock(25)).setHardness(0.8F).setName("musicBlock").setRequiresSelfNotify();
-	public static final Block bed = (new BedBlock(26)).setHardness(0.2F).setName("bed").disableStats().setRequiresSelfNotify();
-	public static final Block poweredRail = (new RailBlock(27, 179, true)).setHardness(0.7F).setStepSound(soundMetalFootstep).setName("goldenRail").setRequiresSelfNotify();
-	public static final Block detectorRail = (new DetectorRailBlock(28, 195)).setHardness(0.7F).setStepSound(soundMetalFootstep).setName("detectorRail").setRequiresSelfNotify();
-	public static final Block stickyPiston = (new PistonBaseBlock(29, 106, true)).setName("pistonStickyBase").setRequiresSelfNotify();
-	public static final Block web = (new WebBlock(30, 11)).setLightOpacity(1).setHardness(4.0F).setName("web");
-	public static final TallGrassBlock tallGrass = (TallGrassBlock)(new TallGrassBlock(31, 39)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("tallgrass");
-	public static final DeadBushBlock deadBush = (DeadBushBlock)(new DeadBushBlock(32, 55)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("deadbush");
-	public static final Block piston = (new PistonBaseBlock(33, 107, false)).setName("pistonBase").setRequiresSelfNotify();
-	public static final PistonExtensionBlock pistonExtension = (PistonExtensionBlock)(new PistonExtensionBlock(34, 107)).setRequiresSelfNotify();
+	public static final Block bed = (new BedBlock(26)).setHardness(0.2F).setEffectiveTool(ToolType.AXE).setName("bed").disableStats().setRequiresSelfNotify();
+	public static final Block poweredRail = (new RailBlock(27, texCoord("powered_rail_on"), true)).setHardness(0.7F).setStepSound(soundMetalFootstep).setName("goldenRail").setRequiresSelfNotify();
+	public static final Block detectorRail = (new DetectorRailBlock(28, texCoord("detector_rail"))).setHardness(0.7F).setStepSound(soundMetalFootstep).setName("detectorRail").setRequiresSelfNotify();
+	public static final Block stickyPiston = (new PistonBaseBlock(29, texCoord("sticky_piston_front"), true)).setName("pistonStickyBase").setRequiresSelfNotify();
+	public static final Block web = (new WebBlock(30, texCoord("web"))).setLightOpacity(1).setHardness(4.0F).setName("web");
+	public static final TallGrassBlock tallGrass = (TallGrassBlock)(new TallGrassBlock(31, texCoord("tall_grass"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("tallgrass");
+	public static final DeadBushBlock deadBush = (DeadBushBlock)(new DeadBushBlock(32, texCoord("dead_bush"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("deadbush");
+	public static final Block piston = (new PistonBaseBlock(33, texCoord("piston_front"), false)).setName("pistonBase").setRequiresSelfNotify();
+	public static final PistonExtensionBlock pistonExtension = (PistonExtensionBlock)(new PistonExtensionBlock(34, texCoord("piston_front"))).setRequiresSelfNotify();
 	public static final Block wool = (new WoolBlock()).setHardness(0.8F).setStepSound(soundClothFootstep).setName("cloth").setRequiresSelfNotify();
 	public static final MovingPistonBlock movingPiston = new MovingPistonBlock(36);
-	public static final FlowerBlock flower = (FlowerBlock)(new FlowerBlock(37, 13)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("flower");
-	public static final FlowerBlock rose = (FlowerBlock)(new FlowerBlock(38, 12)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("rose");
-	public static final FlowerBlock brownMushroom = (FlowerBlock)(new MushroomBlock(39, 29)).setHardness(0.0F).setStepSound(soundGrassFootstep).setLightValue(2.0F / 16.0F).setName("mushroom");
-	public static final FlowerBlock redMushroom = (FlowerBlock)(new MushroomBlock(40, 28)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("mushroom");
-	public static final Block goldBlock = (new MineralBlock(41, 23)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setName("blockGold");
-	public static final Block ironBlock = (new MineralBlock(42, 22)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setName("blockIron");
-	public static final Block doubleStoneSlab = (new SlabBlock(43, true)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stoneSlab");
-	public static final Block stoneSlab = (new SlabBlock(44, false)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stoneSlab");
-	public static final Block brick = (new Block(45, 7, Material.stone)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("brick");
-	public static final Block tnt = (new TNTBlock(46, 8)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("tnt");
-	public static final Block bookshelf = (new BookshelfBlock(47, 35)).setHardness(1.5F).setStepSound(soundWoodFootstep).setName("bookshelf");
-	public static final Block mossyCobblestone = (new Block(48, 36, Material.stone)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stoneMoss");
-	public static final Block obsidian = (new ObsidianBlock(49, 37)).setHardness(10.0F).setResistance(2000.0F).setStepSound(soundStoneFootstep).setName("obsidian");
-	public static final Block torch = (new TorchBlock(50, 80)).setHardness(0.0F).setLightValue(15.0F / 16.0F).setStepSound(soundWoodFootstep).setName("torch").setRequiresSelfNotify();
-	public static final FireBlock fire = (FireBlock)(new FireBlock(51, 31)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setName("fire").disableStats().setRequiresSelfNotify();
-	public static final Block mobSpawner = (new MobSpawnerBlock(52, 65)).setHardness(5.0F).setStepSound(soundMetalFootstep).setName("mobSpawner").disableStats();
-	public static final Block woodenStairs = (new StairsBlock(53, planks)).setName("stairsWood").setRequiresSelfNotify();
+	public static final FlowerBlock flower = (FlowerBlock)(new FlowerBlock(37, texCoord("dandelion"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("flower");
+	public static final FlowerBlock rose = (FlowerBlock)(new FlowerBlock(38, texCoord("rose"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("rose");
+	public static final FlowerBlock brownMushroom = (FlowerBlock)(new MushroomBlock(39, texCoord("brown_mushroom"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setLightValue(2.0F / 16.0F).setName("mushroom");
+	public static final FlowerBlock redMushroom = (FlowerBlock)(new MushroomBlock(40, texCoord("red_mushroom"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("mushroom");
+	public static final Block goldBlock = (new MineralBlock(41, texCoord("gold_block"))).setHardness(3.0F).setResistance(10.0F).setHarvestLevel(2).setStepSound(soundMetalFootstep).setName("blockGold");
+	public static final Block ironBlock = (new MineralBlock(42, texCoord("iron_block"))).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setName("blockIron");
+	public static final SlabBlock doubleStoneSlab = (SlabBlock)(new SlabBlock(43, Material.stone, true, new ModelBlock[]{
+			new ModelBlock(texCoord("smooth_stone_slab"), texCoord("smooth_stone")),
+			new ModelBlock(texCoord("sandstone_side"), texCoord("sandstone_top"), texCoord("sandstone_bottom")),
+			new ModelBlock(texCoord("oak_planks")),
+			new ModelBlock(texCoord("cobblestone")),
+	})).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stoneSlab");
+	public static final SlabBlock stoneSlab = (SlabBlock)(new SlabBlock(44, Material.stone, false, doubleStoneSlab.slabTypes)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stoneSlab");
+	public static final Block brick = (new Block(45, texCoord("brick"), Material.stone)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("brick");
+	public static final Block tnt = (new TNTBlock(46, texCoord("tnt_side"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("tnt");
+	public static final Block bookshelf = (new BookshelfBlock(47, texCoord("bookshelf"))).setHardness(1.5F).setStepSound(soundWoodFootstep).setName("bookshelf");
+	public static final Block mossyCobblestone = (new Block(48, texCoord("mossy_cobblestone"), Material.stone)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stoneMoss");
+	public static final Block obsidian = (new ObsidianBlock(49, texCoord("obsidian"))).setHardness(10.0F).setResistance(2000.0F).setHarvestLevel(3).setStepSound(soundStoneFootstep).setName("obsidian");
+	public static final Block torch = (new TorchBlock(50, texCoord("torch"))).setHardness(0.0F).setLightValue(15.0F / 16.0F).setStepSound(soundWoodFootstep).setName("torch").setRequiresSelfNotify();
+	public static final FireBlock fire = (FireBlock)(new FireBlock(51, texCoord("fire"))).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setName("fire").disableStats().setRequiresSelfNotify();
+	public static final Block mobSpawner = (new MobSpawnerBlock(52, texCoord("mob_spawner"))).setHardness(5.0F).setStepSound(soundMetalFootstep).setName("mobSpawner").disableStats();
+	public static final Block woodenStairs = (new StairsBlock(53, Material.wood, new ModelBlock[] {
+			new ModelBlock(texCoord("oak_planks"))
+	})).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setName("stairsWood").setRequiresSelfNotify();
 	public static final Block chest = (new ChestBlock(54)).setHardness(2.5F).setStepSound(soundWoodFootstep).setName("chest").setRequiresSelfNotify();
-	public static final Block redstoneWire = (new RedstoneWireBlock(55, 164)).setHardness(0.0F).setStepSound(soundPowderFootstep).setName("redstoneDust").disableStats().setRequiresSelfNotify();
-	public static final Block diamondOre = (new OreBlock(56, 50)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreDiamond");
-	public static final Block diamondBlock = (new MineralBlock(57, 24)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setName("blockDiamond");
+	public static final Block redstoneWire = (new RedstoneWireBlock(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setName("redstoneDust").disableStats().setRequiresSelfNotify();
+	public static final Block diamondOre = (new OreBlock(56, texCoord("diamond_ore"))).setHardness(3.0F).setResistance(5.0F).setHarvestLevel(2).setStepSound(soundStoneFootstep).setName("oreDiamond");
+	public static final Block diamondBlock = (new MineralBlock(57, texCoord("diamond_block"))).setHardness(5.0F).setResistance(10.0F).setHarvestLevel(2).setStepSound(soundMetalFootstep).setName("blockDiamond");
 	public static final Block workbench = (new WorkbenchBlock(58)).setHardness(2.5F).setStepSound(soundWoodFootstep).setName("workbench");
-	public static final Block crops = (new CropsBlock(59, 88)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("crops").disableStats().setRequiresSelfNotify();
+	public static final Block crops = (new CropsBlock(59, "wheat")).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("crops").disableStats().setRequiresSelfNotify();
 	public static final Block farmland = (new FarmlandBlock(60)).setHardness(0.6F).setStepSound(soundGravelFootstep).setName("farmland");
 	public static final Block furnace = (new FurnaceBlock(61, false)).setHardness(3.5F).setStepSound(soundStoneFootstep).setName("furnace").setRequiresSelfNotify();
 	public static final Block activeFurnace = (new FurnaceBlock(62, true)).setHardness(3.5F).setStepSound(soundStoneFootstep).setLightValue(14.0F / 16.0F).setName("furnace").setRequiresSelfNotify();
 	public static final Block standingSign = (new SignBlock(63, SignTileEntity.class, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setName("sign").disableStats().setRequiresSelfNotify();
-	public static final Block door = (new DoorBlock(64, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setName("doorWood").disableStats().setRequiresSelfNotify();
-	public static final Block ladder = (new LadderBlock(65, 83)).setHardness(0.4F).setStepSound(soundWoodFootstep).setName("ladder").setRequiresSelfNotify();
-	public static final Block rail = (new RailBlock(66, 128, false)).setHardness(0.7F).setStepSound(soundMetalFootstep).setName("rail").setRequiresSelfNotify();
-	public static final Block cobblestoneStairs = (new StairsBlock(67, cobblestone)).setName("stairsStone").setRequiresSelfNotify();
+	public static final Block door = (new DoorBlock(64, Material.wood, "oak_door")).setHardness(3.0F).setStepSound(soundWoodFootstep).setName("doorWood").disableStats().setRequiresSelfNotify();
+	public static final Block ladder = (new LadderBlock(65, texCoord("ladder"))).setHardness(0.4F).setStepSound(soundWoodFootstep).setName("ladder").setRequiresSelfNotify();
+	public static final Block rail = (new RailBlock(66, texCoord("rail"), false)).setHardness(0.7F).setStepSound(soundMetalFootstep).setName("rail").setRequiresSelfNotify();
+	public static final Block cobblestoneStairs = (new StairsBlock(67, Material.stone, new ModelBlock[] {
+			new ModelBlock(texCoord("cobblestone"))
+	})).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("stairsStone").setRequiresSelfNotify();
 	public static final Block wallSign = (new SignBlock(68, SignTileEntity.class, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setName("sign").disableStats().setRequiresSelfNotify();
-	public static final Block lever = (new LeverBlock(69, 96)).setHardness(0.5F).setStepSound(soundWoodFootstep).setName("lever").setRequiresSelfNotify();
+	public static final Block lever = (new LeverBlock(69, texCoord("lever"))).setHardness(0.5F).setStepSound(soundWoodFootstep).setName("lever").setRequiresSelfNotify();
 	public static final Block stonePressurePlate = (new PressurePlateBlock(70, stone.textureIndex, MobType.mobs, Material.stone)).setHardness(0.5F).setStepSound(soundStoneFootstep).setName("pressurePlate").setRequiresSelfNotify();
-	public static final Block ironDoor = (new DoorBlock(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setName("doorIron").disableStats().setRequiresSelfNotify();
+	public static final Block ironDoor = (new DoorBlock(71, Material.iron, "iron_door")).setHardness(5.0F).setStepSound(soundMetalFootstep).setName("doorIron").disableStats().setRequiresSelfNotify();
 	public static final Block woodenPressurePlate = (new PressurePlateBlock(72, planks.textureIndex, MobType.everything, Material.wood)).setHardness(0.5F).setStepSound(soundWoodFootstep).setName("pressurePlate").setRequiresSelfNotify();
-	public static final Block redstoneOre = (new RedstoneOreBlock(73, 51, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreRedstone").setRequiresSelfNotify();
-	public static final Block glowingRedstoneOre = (new RedstoneOreBlock(74, 51, true)).setLightValue(10.0F / 16.0F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setName("oreRedstone").setRequiresSelfNotify();
-	public static final Block redstoneTorchOff = (new RedstoneTorchBlock(75, 115, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setName("notGate").setRequiresSelfNotify();
-	public static final Block redstoneTorchOn = (new RedstoneTorchBlock(76, 99, true)).setHardness(0.0F).setLightValue(0.5F).setStepSound(soundWoodFootstep).setName("notGate").setRequiresSelfNotify();
+	public static final Block redstoneOre = (new RedstoneOreBlock(73, texCoord("redstone_ore"), false)).setHardness(3.0F).setResistance(5.0F).setHarvestLevel(2).setStepSound(soundStoneFootstep).setName("oreRedstone").setRequiresSelfNotify();
+	public static final Block glowingRedstoneOre = (new RedstoneOreBlock(74, texCoord("redstone_ore"), true)).setLightValue(10.0F / 16.0F).setHardness(3.0F).setResistance(5.0F).setHarvestLevel(2).setStepSound(soundStoneFootstep).setName("oreRedstone").setRequiresSelfNotify();
+	public static final Block redstoneTorchOff = (new RedstoneTorchBlock(75, texCoord("redstone_torch_off"), false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setName("notGate").setRequiresSelfNotify();
+	public static final Block redstoneTorchOn = (new RedstoneTorchBlock(76, texCoord("redstone_torch_on"), true)).setHardness(0.0F).setLightValue(0.5F).setStepSound(soundWoodFootstep).setName("notGate").setRequiresSelfNotify();
 	public static final Block button = (new ButtonBlock(77, stone.textureIndex)).setHardness(0.5F).setStepSound(soundStoneFootstep).setName("button").setRequiresSelfNotify();
-	public static final Block snowLayer = (new SnowLayerBlock(78, 66)).setHardness(0.1F).setStepSound(soundClothFootstep).setName("snow");
-	public static final Block ice = (new IceBlock(79, 67)).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep).setName("ice");
-	public static final Block snow = (new SnowBlock(80, 66)).setHardness(0.2F).setStepSound(soundClothFootstep).setName("snow");
-	public static final Block cactus = (new CactusBlock(81, 70)).setHardness(0.4F).setStepSound(soundClothFootstep).setName("cactus");
-	public static final Block clayBlock = (new ClayBlock(82, 72)).setHardness(0.6F).setStepSound(soundGravelFootstep).setName("clay");
-	public static final Block reed = (new ReedBlock(83, 73)).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("reeds").disableStats();
-	public static final Block jukebox = (new JukeboxBlock(84, 74)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("jukebox").setRequiresSelfNotify();
-	public static final Block fence = (new FenceBlock(85, 4)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setName("fence").setRequiresSelfNotify();
-	public static final Block pumpkin = (new PumpkinBlock(86, 102, false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setName("pumpkin").setRequiresSelfNotify();
-	public static final Block netherrack = (new NetherrackBlock(87, 103)).setHardness(0.4F).setStepSound(soundStoneFootstep).setName("hellrock");
-	public static final Block soulSand = (new SoulSandBlock(88, 104)).setHardness(0.5F).setStepSound(soundSandFootstep).setName("hellsand");
-	public static final Block glowstone = (new GlowstoneBlock(89, 105, Material.stone)).setHardness(0.3F).setStepSound(soundGlassFootstep).setLightValue(1.0F).setName("lightgem");
-	public static final PortalBlock portal = (PortalBlock)(new PortalBlock(90, 14)).setHardness(-1.0F).setStepSound(soundGlassFootstep).setLightValue(12.0F / 16.0F).setName("portal");
-	public static final Block jackOLantern = (new PumpkinBlock(91, 102, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setLightValue(1.0F).setName("litpumpkin").setRequiresSelfNotify();
-	public static final Block cake = (new CakeBlock(92, 121)).setHardness(0.5F).setStepSound(soundClothFootstep).setName("cake").disableStats().setRequiresSelfNotify();
+	public static final Block snowLayer = (new SnowLayerBlock(78, texCoord("snow"))).setHardness(0.1F).setStepSound(soundClothFootstep).setName("snow");
+	public static final Block ice = (new IceBlock(79, texCoord("ice"))).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep).setName("ice");
+	public static final Block snow = (new SnowBlock(80, texCoord("snow"))).setHardness(0.2F).setStepSound(soundClothFootstep).setName("snow");
+	public static final Block cactus = (new CactusBlock(81, texCoord("cactus_side"))).setHardness(0.4F).setStepSound(soundClothFootstep).setName("cactus");
+	public static final Block clayBlock = (new ClayBlock(82, texCoord("clay"))).setHardness(0.6F).setStepSound(soundGravelFootstep).setName("clay");
+	public static final Block reed = (new ReedBlock(83, texCoord("sugar_cane"))).setHardness(0.0F).setStepSound(soundGrassFootstep).setName("reeds").disableStats();
+	public static final Block jukebox = (new JukeboxBlock(84, texCoord("note_block"))).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setName("jukebox").setRequiresSelfNotify();
+	public static final Block fence = (new FenceBlock(85, texCoord("oak_planks"))).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep).setName("fence").setRequiresSelfNotify();
+	public static final Block pumpkin = (new PumpkinBlock(86, texCoord("pumpkin_top"), false)).setHardness(1.0F).setStepSound(soundWoodFootstep).setName("pumpkin").setRequiresSelfNotify();
+	public static final Block netherrack = (new NetherrackBlock(87, texCoord("netherrack"))).setHardness(0.4F).setStepSound(soundStoneFootstep).setName("hellrock");
+	public static final Block soulSand = (new SoulSandBlock(88, texCoord("soul_sand"))).setHardness(0.5F).setStepSound(soundSandFootstep).setName("hellsand");
+	public static final Block glowstone = (new GlowstoneBlock(89, texCoord("glowstone"), Material.stone)).setHardness(0.3F).setStepSound(soundGlassFootstep).setLightValue(1.0F).setName("lightgem");
+	public static final PortalBlock portal = (PortalBlock)(new PortalBlock(90, texCoord("portal"))).setHardness(-1.0F).setStepSound(soundGlassFootstep).setLightValue(12.0F / 16.0F).setName("portal");
+	public static final Block jackOLantern = (new PumpkinBlock(91, texCoord("pumpkin_top"), true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setLightValue(1.0F).setName("litpumpkin").setRequiresSelfNotify();
+	public static final Block cake = (new CakeBlock(92, texCoord("cake_top"))).setHardness(0.5F).setStepSound(soundClothFootstep).setName("cake").disableStats().setRequiresSelfNotify();
 	public static final Block redstoneRepeaterOff = (new RedstoneRepeaterBlock(93, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setName("diode").disableStats().setRequiresSelfNotify();
 	public static final Block redstoneRepeaterOn = (new RedstoneRepeaterBlock(94, true)).setHardness(0.0F).setLightValue(10.0F / 16.0F).setStepSound(soundWoodFootstep).setName("diode").disableStats().setRequiresSelfNotify();
 	public static final Block lockedChest = (new LockedChestBlock(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setName("lockedchest").setTickOnLoad(true).setRequiresSelfNotify();
-	public static final Block trapdoor = (new TrapDoorBlock(96, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setName("trapdoor").disableStats().setRequiresSelfNotify();
+	public static final Block trapdoor = (new TrapDoorBlock(96, texCoord("oak_trapdoor"), Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setName("trapdoor").disableStats().setRequiresSelfNotify();
+	public static final Block mud = (new DirtBlock(97, texCoord("mud"))).setHardness(0.8F).setStepSound(soundGravelFootstep).setName("mud");
+	public static final Block hardenedClay = (new HardenedClayBlock(98, texCoord("hardened_clay"), Material.stone)).setHardness(1.25F).setResistance(4.2F).setStepSound(soundStoneFootstep).setName("hardenedClay");
+	public static final Block redSand = (new SandBlock(99, texCoord("red_sand"))).setHardness(0.5F).setStepSound(soundSandFootstep).setName("redSand");
+	public final PropertyList properties = this.getProperties();
 	public int textureIndex;
 	public final int blockID;
 	protected float hardness;
@@ -156,6 +165,8 @@
 	public float particleGravity;
 	public final Material material;
 	public float slipperiness;
+	public int harvestLevel;
+	public ToolType effectiveTool;
 	private String name;
 
 	protected Block(int var1, Material var2) {
@@ -166,16 +177,25 @@
 		this.slipperiness = 0.6F;
 		if(blocksList[var1] != null) {
 			throw new IllegalArgumentException("Slot " + var1 + " is already occupied by " + blocksList[var1] + " when adding " + this);
-		} else {
-			this.material = var2;
-			blocksList[var1] = this;
-			this.blockID = var1;
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-			opaqueCubeLookup[var1] = this.isOpaqueCube();
-			lightOpacity[var1] = this.isOpaqueCube() ? 255 : 0;
-			canBlockGrass[var1] = !var2.canBlockGrass();
-			isBlockContainer[var1] = false;
 		}
+
+		this.material = var2;
+		blocksList[var1] = this;
+		this.blockID = var1;
+		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+		opaqueCubeLookup[var1] = this.isOpaqueCube();
+		lightOpacity[var1] = this.isOpaqueCube() ? 255 : 0;
+		canBlockGrass[var1] = !var2.canBlockGrass();
+		isBlockContainer[var1] = false;
+		this.effectiveTool = var2.getEffectiveTool();
+	}
+
+	protected PropertyList getProperties() {
+		return PropertyList.EMPTY;
+	}
+
+	protected Item getItem() {
+		return new BlockItem(this.blockID - 256);
 	}
 
 	protected Block setRequiresSelfNotify() {
@@ -183,6 +203,11 @@
 		return this;
 	}
 
+	protected Block setSpecialLighting() {
+		specialLighting[this.blockID] = true;
+		return this;
+	}
+
 	protected void initializeBlock() {
 	}
 
@@ -233,6 +258,16 @@
 		return this;
 	}
 
+	protected Block setEffectiveTool(ToolType effectiveTool) {
+		this.effectiveTool = effectiveTool;
+		return this;
+	}
+
+	protected Block setHarvestLevel(int harvestLevel) {
+		this.harvestLevel = harvestLevel;
+		return this;
+	}
+
 	public float getHardness() {
 		return this.hardness;
 	}
@@ -583,17 +618,9 @@
 	}
 
 	static {
-		Item.itemsList[wool.blockID] = (new WoolItem(wool.blockID - 256)).setName("cloth");
-		Item.itemsList[log.blockID] = (new SubtypedItem(log.blockID - 256)).setName("log");
-		Item.itemsList[stoneSlab.blockID] = (new SlabItem(stoneSlab.blockID - 256)).setName("stoneSlab");
-		Item.itemsList[sapling.blockID] = (new SaplingItem(sapling.blockID - 256)).setName("sapling");
-		Item.itemsList[leaves.blockID] = (new LeavesItem(leaves.blockID - 256)).setName("leaves");
-		Item.itemsList[piston.blockID] = new PistonItem(piston.blockID - 256);
-		Item.itemsList[stickyPiston.blockID] = new PistonItem(stickyPiston.blockID - 256);
-
 		for(int var0 = 0; var0 < 256; ++var0) {
 			if(blocksList[var0] != null && Item.itemsList[var0] == null) {
-				Item.itemsList[var0] = new BlockItem(var0 - 256);
+				Item.itemsList[var0] = blocksList[var0].getItem();
 				blocksList[var0].initializeBlock();
 			}
 		}
--- net/minecraft/game/world/World.java
+++ net/minecraft/game/world/World.java
@@ -1,5 +1,6 @@
 package net.minecraft.game.world;
 
+import ca.spottedleaf.starlight.StarlightEngine;
 import com.mojang.nbt.CompoundTag;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -9,22 +10,24 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.entity.weather.LightningBoltEntity;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.world.biome.Biome;
-import net.minecraft.game.world.biome.ClimaticBiomeSource;
+import net.minecraft.game.world.biome.BiomeSource;
+import net.minecraft.game.world.biome.BiomeColorType;
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.block.LiquidBlock;
+import net.minecraft.game.world.block.properties.Property;
 import net.minecraft.game.world.block.tileentity.TileEntity;
-import net.minecraft.game.world.chunk.Chunk;
-import net.minecraft.game.world.chunk.ChunkCache;
-import net.minecraft.game.world.chunk.ChunkCoordIntPair;
-import net.minecraft.game.world.chunk.ChunkProvider;
-import net.minecraft.game.world.chunk.ChunkProviderImpl;
-import net.minecraft.game.world.chunk.ChunkProviderLoadOrGenerate;
+import net.minecraft.game.world.chunk.*;
 import net.minecraft.game.world.chunk.loader.ChunkLoader;
 import net.minecraft.game.world.dimension.Dimension;
 import net.minecraft.game.world.map.MapDataBase;
@@ -61,6 +64,7 @@
 	private long lockTimestamp;
 	protected int autosavePeriod;
 	public int difficultySetting;
+	public int simulationDistance = 8;
 	public Random rand;
 	public boolean isNewWorld;
 	public final Dimension dimension;
@@ -77,12 +81,26 @@
 	private boolean spawnHostileMobs;
 	private boolean spawnPeacefulMobs;
 	static int lightingUpdatesScheduled = 0;
-	private Set positionsToUpdate;
+	private LongSet positionsToUpdate;
 	private int soundCounter;
 	private List entitiesInAABB;
 	public boolean remoteWorld;
-
-	public ClimaticBiomeSource getBiomeSource() {
+	public final StarlightEngine blockLight = new StarlightEngine(false, this);
+	public final StarlightEngine skyLight = new StarlightEngine(true, this);
+
+	public Biome getBiomeAt(int x, int z) {
+//		if (this.blockExists(x, 0, z)) {
+		Chunk chunk = this.getChunkFromBlockCoords(x, z);
+
+		if (chunk != null) {
+			return chunk.getBiome(x & 15, z & 15, this.dimension.biomeSource);
+		}
+//		}
+
+		return this.dimension.biomeSource.getBiomeGenAt(x, z);
+	}
+
+	public BiomeSource getBiomeSource() {
 		return this.dimension.biomeSource;
 	}
 
@@ -105,7 +123,7 @@
 		this.lightningFlash = 0;
 		this.editingBlocks = false;
 		this.lockTimestamp = System.currentTimeMillis();
-		this.autosavePeriod = 40;
+		this.autosavePeriod = 400;
 		this.rand = new Random();
 		this.isNewWorld = false;
 		this.worldAccesses = new ArrayList();
@@ -113,7 +131,7 @@
 		this.lightingUpdatesCounter = 0;
 		this.spawnHostileMobs = true;
 		this.spawnPeacefulMobs = true;
-		this.positionsToUpdate = new HashSet();
+		this.positionsToUpdate = new LongOpenHashSet();
 		this.soundCounter = this.rand.nextInt(12000);
 		this.entitiesInAABB = new ArrayList();
 		this.remoteWorld = false;
@@ -146,7 +164,7 @@
 		this.lightningFlash = 0;
 		this.editingBlocks = false;
 		this.lockTimestamp = System.currentTimeMillis();
-		this.autosavePeriod = 40;
+		this.autosavePeriod = 400;
 		this.rand = new Random();
 		this.isNewWorld = false;
 		this.worldAccesses = new ArrayList();
@@ -154,7 +172,7 @@
 		this.lightingUpdatesCounter = 0;
 		this.spawnHostileMobs = true;
 		this.spawnPeacefulMobs = true;
-		this.positionsToUpdate = new HashSet();
+		this.positionsToUpdate = new LongOpenHashSet();
 		this.soundCounter = this.rand.nextInt(12000);
 		this.entitiesInAABB = new ArrayList();
 		this.remoteWorld = false;
@@ -169,11 +187,11 @@
 		this.initWeather();
 	}
 
-	public World(SaveHandler var1, String var2, long var3) {
-		this(var1, var2, var3, (Dimension)null);
+	public World(SaveHandler var1, NewWorldInfo var3) {
+		this(var1, var3, (Dimension)null);
 	}
 
-	public World(SaveHandler var1, String var2, long var3, Dimension var5) {
+	public World(SaveHandler var1, NewWorldInfo var3, Dimension var5) {
 		this.scheduledUpdatesAreImmediate = false;
 		this.lightingToUpdate = new ArrayList();
 		this.loadedEntityList = new ArrayList();
@@ -192,7 +210,7 @@
 		this.lightningFlash = 0;
 		this.editingBlocks = false;
 		this.lockTimestamp = System.currentTimeMillis();
-		this.autosavePeriod = 40;
+		this.autosavePeriod = 400;
 		this.rand = new Random();
 		this.isNewWorld = false;
 		this.worldAccesses = new ArrayList();
@@ -200,7 +218,7 @@
 		this.lightingUpdatesCounter = 0;
 		this.spawnHostileMobs = true;
 		this.spawnPeacefulMobs = true;
-		this.positionsToUpdate = new HashSet();
+		this.positionsToUpdate = new LongOpenHashSet();
 		this.soundCounter = this.rand.nextInt(12000);
 		this.entitiesInAABB = new ArrayList();
 		this.remoteWorld = false;
@@ -218,10 +236,10 @@
 
 		boolean var6 = false;
 		if(this.worldInfo == null) {
-			this.worldInfo = new WorldInfo(var3, var2);
+			this.worldInfo = new WorldInfo(var3);
 			var6 = true;
 		} else {
-			this.worldInfo.setWorldName(var2);
+			this.worldInfo.setWorldName(var3.name);
 		}
 
 		this.dimension.registerWorld(this);
@@ -244,9 +262,10 @@
 		int var1 = 0;
 		byte var2 = 64;
 
-		int var3;
-		for(var3 = 0; !this.dimension.canCoordinateBeSpawn(var1, var3); var3 += this.rand.nextInt(64) - this.rand.nextInt(64)) {
+		int var3 = 0;
+		for(int attempts = 0; !this.dimension.canCoordinateBeSpawn(var1, var3) && attempts < 1000; attempts++) {
 			var1 += this.rand.nextInt(64) - this.rand.nextInt(64);
+			var3 += this.rand.nextInt(64) - this.rand.nextInt(64);
 		}
 
 		this.worldInfo.setSpawn(var1, var2, var3);
@@ -288,13 +307,6 @@
 				this.worldInfo.setPlayerNBTTagCompound((CompoundTag)null);
 			}
 
-			if(this.chunkProvider instanceof ChunkProviderLoadOrGenerate) {
-				ChunkProviderLoadOrGenerate var3 = (ChunkProviderLoadOrGenerate)this.chunkProvider;
-				int var4 = MathHelper.floor((float)((int)var1.posX)) >> 4;
-				int var5 = MathHelper.floor((float)((int)var1.posZ)) >> 4;
-				var3.setCurrentChunkOver(var4, var5);
-			}
-
 			this.entityJoinedWorld(var1);
 		} catch (Exception var6) {
 			var6.printStackTrace();
@@ -336,7 +348,7 @@
 	}
 
 	public int getBlockId(int var1, int var2, int var3) {
-		return var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000 ? (var2 < 0 ? 0 : (var2 >= 128 ? 0 : this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4).getBlockID(var1 & 15, var2, var3 & 15))) : 0;
+		return var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000 ? this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4).getBlockID(var1 & 15, var2, var3 & 15) : 0;
 	}
 
 	public boolean isAirBlock(int var1, int var2, int var3) {
@@ -344,7 +356,7 @@
 	}
 
 	public boolean blockExists(int var1, int var2, int var3) {
-		return var2 >= 0 && var2 < 128 ? this.chunkExists(var1 >> 4, var3 >> 4) : false;
+		return this.chunkExists(var1 >> 4, var3 >> 4);
 	}
 
 	public boolean doChunksNearChunkExist(int var1, int var2, int var3, int var4) {
@@ -352,32 +364,32 @@
 	}
 
 	public boolean checkChunksExist(int var1, int var2, int var3, int var4, int var5, int var6) {
-		if(var5 >= 0 && var2 < 128) {
-			var1 >>= 4;
-			var2 >>= 4;
-			var3 >>= 4;
-			var4 >>= 4;
-			var5 >>= 4;
-			var6 >>= 4;
+		var1 >>= 4;
+		var2 >>= 4;
+		var3 >>= 4;
+		var4 >>= 4;
+		var5 >>= 4;
+		var6 >>= 4;
 
-			for(int var7 = var1; var7 <= var4; ++var7) {
-				for(int var8 = var3; var8 <= var6; ++var8) {
-					if(!this.chunkExists(var7, var8)) {
-						return false;
-					}
+		for(int var7 = var1; var7 <= var4; ++var7) {
+			for(int var8 = var3; var8 <= var6; ++var8) {
+				if(!this.chunkExists(var7, var8)) {
+					return false;
 				}
 			}
-
-			return true;
-		} else {
-			return false;
 		}
+
+		return true;
 	}
 
-	private boolean chunkExists(int var1, int var2) {
+	public boolean chunkExists(int var1, int var2) {
 		return this.chunkProvider.chunkExists(var1, var2);
 	}
 
+	public boolean chunkSaved(int var1, int var2) {
+		return this.chunkProvider.chunkSaved(var1, var2);
+	}
+
 	public Chunk getChunkFromBlockCoords(int var1, int var2) {
 		return this.getChunkFromChunkCoords(var1 >> 4, var2 >> 4);
 	}
@@ -387,52 +399,29 @@
 	}
 
 	public boolean setBlockAndMetadata(int var1, int var2, int var3, int var4, int var5) {
-		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
-			if(var2 < 0) {
-				return false;
-			} else if(var2 >= 128) {
-				return false;
-			} else {
-				Chunk var6 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
-				return var6.setBlockAndMetadata(var1 & 15, var2, var3 & 15, var4, var5);
-			}
+		if(var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000) {
+			Chunk var6 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
+			return var6.setBlockAndMetadata(var1 & 15, var2, var3 & 15, var4, var5);
 		} else {
 			return false;
 		}
 	}
 
 	public boolean setBlock(int var1, int var2, int var3, int var4) {
-		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
-			if(var2 < 0) {
-				return false;
-			} else if(var2 >= 128) {
-				return false;
-			} else {
-				Chunk var5 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
-				return var5.setBlock(var1 & 15, var2, var3 & 15, var4);
-			}
+		if(var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000) {
+			Chunk var5 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
+			return var5.setBlock(var1 & 15, var2, var3 & 15, var4);
 		} else {
 			return false;
 		}
-	}
-
-	public Material getBlockMaterial(int var1, int var2, int var3) {
-		int var4 = this.getBlockId(var1, var2, var3);
-		return var4 == 0 ? Material.air : Block.blocksList[var4].material;
 	}
 
 	public int getBlockMetadata(int var1, int var2, int var3) {
-		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
-			if(var2 < 0) {
-				return 0;
-			} else if(var2 >= 128) {
-				return 0;
-			} else {
-				Chunk var4 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
-				var1 &= 15;
-				var3 &= 15;
-				return var4.getBlockMetadata(var1, var2, var3);
-			}
+		if(var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000) {
+			Chunk var4 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
+			var1 &= 15;
+			var3 &= 15;
+			return var4.getBlockMetadata(var1, var2, var3);
 		} else {
 			return 0;
 		}
@@ -451,18 +440,12 @@
 	}
 
 	public boolean setBlockMetadata(int var1, int var2, int var3, int var4) {
-		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
-			if(var2 < 0) {
-				return false;
-			} else if(var2 >= 128) {
-				return false;
-			} else {
-				Chunk var5 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
-				var1 &= 15;
-				var3 &= 15;
-				var5.setBlockMetadata(var1, var2, var3, var4);
-				return true;
-			}
+		if(var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000) {
+			Chunk var5 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
+			var1 &= 15;
+			var3 &= 15;
+			var5.setBlockMetadata(var1, var2, var3, var4);
+			return true;
 		} else {
 			return false;
 		}
@@ -546,15 +529,7 @@
 	}
 
 	public int getFullBlockLightValue(int var1, int var2, int var3) {
-		if(var2 < 0) {
-			return 0;
-		} else {
-			if(var2 >= 128) {
-				var2 = 127;
-			}
-
-			return this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4).getBlockLightValue(var1 & 15, var2, var3 & 15, 0);
-		}
+		return this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4).getBlockLightValue(var1 & 15, var2, var3 & 15, 0);
 	}
 
 	public int getBlockLightValue(int var1, int var2, int var3) {
@@ -562,10 +537,10 @@
 	}
 
 	public int getBlockLightValue_do(int var1, int var2, int var3, boolean var4) {
-		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
+		if(var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000) {
 			if(var4) {
 				int var5 = this.getBlockId(var1, var2, var3);
-				if(var5 == Block.stoneSlab.blockID || var5 == Block.farmland.blockID || var5 == Block.cobblestoneStairs.blockID || var5 == Block.woodenStairs.blockID) {
+				if(Block.specialLighting[var5]) {
 					int var6 = this.getBlockLightValue_do(var1, var2 + 1, var3, false);
 					int var7 = this.getBlockLightValue_do(var1 + 1, var2, var3, false);
 					int var8 = this.getBlockLightValue_do(var1 - 1, var2, var3, false);
@@ -591,30 +566,18 @@
 				}
 			}
 
-			if(var2 < 0) {
-				return 0;
-			} else {
-				if(var2 >= 128) {
-					var2 = 127;
-				}
-
-				Chunk var11 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
-				var1 &= 15;
-				var3 &= 15;
-				return var11.getBlockLightValue(var1, var2, var3, this.skylightSubtracted);
-			}
+			Chunk var11 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
+			var1 &= 15;
+			var3 &= 15;
+			return var11.getBlockLightValue(var1, var2, var3, this.skylightSubtracted);
 		} else {
 			return 15;
 		}
 	}
 
 	public boolean canExistingBlockSeeTheSky(int var1, int var2, int var3) {
-		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
-			if(var2 < 0) {
-				return false;
-			} else if(var2 >= 128) {
-				return true;
-			} else if(!this.chunkExists(var1 >> 4, var3 >> 4)) {
+		if(var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000) {
+			if(!this.chunkExists(var1 >> 4, var3 >> 4)) {
 				return false;
 			} else {
 				Chunk var4 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
@@ -628,7 +591,7 @@
 	}
 
 	public int getHeightValue(int var1, int var2) {
-		if(var1 >= -32000000 && var2 >= -32000000 && var1 < 32000000 && var2 <= 32000000) {
+		if(var1 >= -32000000 && var2 >= -32000000 && var1 <= 32000000 && var2 <= 32000000) {
 			if(!this.chunkExists(var1 >> 4, var2 >> 4)) {
 				return 0;
 			} else {
@@ -663,15 +626,7 @@
 	}
 
 	public int getSavedLightValue(LightType var1, int var2, int var3, int var4) {
-		if(var3 < 0) {
-			var3 = 0;
-		}
-
-		if(var3 >= 128) {
-			var3 = 127;
-		}
-
-		if(var3 >= 0 && var3 < 128 && var2 >= -32000000 && var4 >= -32000000 && var2 < 32000000 && var4 <= 32000000) {
+		if(var2 >= -32000000 && var3 >= -32000000 && var4 >= -32000000 && var2 <= 32000000 && var3 <= 32000000 && var4 <= 32000000) {
 			int var5 = var2 >> 4;
 			int var6 = var4 >> 4;
 			if(!this.chunkExists(var5, var6)) {
@@ -686,19 +641,15 @@
 	}
 
 	public void setLightValue(LightType var1, int var2, int var3, int var4, int var5) {
-		if(var2 >= -32000000 && var4 >= -32000000 && var2 < 32000000 && var4 <= 32000000) {
-			if(var3 >= 0) {
-				if(var3 < 128) {
-					if(this.chunkExists(var2 >> 4, var4 >> 4)) {
-						Chunk var6 = this.getChunkFromChunkCoords(var2 >> 4, var4 >> 4);
-						var6.setLightValue(var1, var2 & 15, var3, var4 & 15, var5);
-
-						for(int var7 = 0; var7 < this.worldAccesses.size(); ++var7) {
-							((WorldAccess)this.worldAccesses.get(var7)).markBlockNeedsUpdate(var2, var3, var4);
-						}
-
-					}
+		if(var2 >= -32000000 && var3 >= -32000000 && var4 >= -32000000 && var2 <= 32000000 && var3 <= 32000000 && var4 <= 32000000) {
+			if(this.chunkExists(var2 >> 4, var4 >> 4)) {
+				Chunk var6 = this.getChunkFromChunkCoords(var2 >> 4, var4 >> 4);
+				var6.setLightValue(var1, var2 & 15, var3, var4 & 15, var5);
+
+				for(int var7 = 0; var7 < this.worldAccesses.size(); ++var7) {
+					((WorldAccess)this.worldAccesses.get(var7)).markBlockNeedsUpdate(var2, var3, var4);
 				}
+
 			}
 		}
 	}
@@ -936,7 +887,7 @@
 		}
 	}
 
-	protected void obtainEntitySkin(Entity var1) {
+	public void obtainEntitySkin(Entity var1) {
 		for(int var2 = 0; var2 < this.worldAccesses.size(); ++var2) {
 			((WorldAccess)this.worldAccesses.get(var2)).obtainEntitySkin(var1);
 		}
@@ -1063,8 +1014,7 @@
 
 		int var5 = MathHelper.floor(var1.posX);
 		int var6 = MathHelper.floor(var1.posZ);
-		float var7 = (float)this.getBiomeSource().getTemperature(var5, var6);
-		int var8 = this.getBiomeSource().getBiomeGenAt(var5, var6).getSkyColorByTemp(var7);
+		int var8 = this.getBiomeSource().getColorAt(var5, var6, BiomeColorType.SKY);
 		float var9 = (float)(var8 >> 16 & 255) / 255.0F;
 		float var10 = (float)(var8 >> 8 & 255) / 255.0F;
 		float var11 = (float)(var8 & 255) / 255.0F;
@@ -1157,10 +1107,10 @@
 
 	public int getTopSolidOrLiquidBlock(int var1, int var2) {
 		Chunk var3 = this.getChunkFromBlockCoords(var1, var2);
-		int var4 = 127;
+		int var4 = (var3.getMaxLevel() << 4) + 15;
 		var1 &= 15;
 
-		for(var2 &= 15; var4 > 0; --var4) {
+		for(var2 &= 15; var4 > var3.getMinLevel() << 4; --var4) {
 			int var5 = var3.getBlockID(var1, var4, var2);
 			Material var6 = var5 == 0 ? Material.air : Block.blocksList[var5].material;
 			if(var6.getIsSolid() || var6.isLiquid()) {
@@ -1173,10 +1123,10 @@
 
 	public int findTopSolidBlock(int var1, int var2) {
 		Chunk var3 = this.getChunkFromBlockCoords(var1, var2);
-		int var4 = 127;
+		int var4 = (var3.getMaxLevel() << 4) + 15;
 		var1 &= 15;
 
-		for(var2 &= 15; var4 > 0; --var4) {
+		for(var2 &= 15; var4 > var3.getMinLevel() << 4; --var4) {
 			int var5 = var3.getBlockID(var1, var4, var2);
 			if(var5 != 0 && Block.blocksList[var5].material.getIsSolid()) {
 				return var4 + 1;
@@ -1720,16 +1670,6 @@
 
 	}
 
-	public boolean isBlockOpaqueCube(int var1, int var2, int var3) {
-		Block var4 = Block.blocksList[this.getBlockId(var1, var2, var3)];
-		return var4 == null ? false : var4.isOpaqueCube();
-	}
-
-	public boolean isBlockNormalCube(int var1, int var2, int var3) {
-		Block var4 = Block.blocksList[this.getBlockId(var1, var2, var3)];
-		return var4 == null ? false : var4.material.isOpaque() && var4.renderAsNormalBlock();
-	}
-
 	public void saveWorldIndirectly(ProgressUpdate var1) {
 		this.saveWorld(true, var1);
 	}
@@ -1955,11 +1895,13 @@
 			PlayerEntity var2 = (PlayerEntity)this.playerEntities.get(var1);
 			var3 = MathHelper.floor(var2.posX / 16.0D);
 			var4 = MathHelper.floor(var2.posZ / 16.0D);
-			byte var5 = 9;
+			int var5 = this.simulationDistance + 1;
 
 			for(var6 = -var5; var6 <= var5; ++var6) {
 				for(var7 = -var5; var7 <= var5; ++var7) {
-					this.positionsToUpdate.add(new ChunkCoordIntPair(var6 + var3, var7 + var4));
+					if (this.chunkExists(var6 + var3, var7 + var4)) {
+						this.positionsToUpdate.add(ChunkCoordIntPair.chunkXZ2Int(var6 + var3, var7 + var4));
+					}
 				}
 			}
 		}
@@ -1968,33 +1910,19 @@
 			--this.soundCounter;
 		}
 
-		Iterator var12 = this.positionsToUpdate.iterator();
+		LongIterator var12 = this.positionsToUpdate.iterator();
 
 		while(var12.hasNext()) {
-			ChunkCoordIntPair var13 = (ChunkCoordIntPair)var12.next();
-			var3 = var13.chunkXPos * 16;
-			var4 = var13.chunkZPos * 16;
-			Chunk var14 = this.getChunkFromChunkCoords(var13.chunkXPos, var13.chunkZPos);
+			long var13 = var12.nextLong();
+			int chunkXPos = ChunkCoordIntPair.getChunkX(var13);
+			int chunkZPos = ChunkCoordIntPair.getChunkZ(var13);
+
+			var3 = chunkXPos * 16;
+			var4 = chunkZPos * 16;
+			Chunk var14 = this.getChunkFromChunkCoords(chunkXPos, chunkZPos);
 			int var8;
 			int var9;
 			int var10;
-			if(this.soundCounter == 0) {
-				this.distHashCounter = this.distHashCounter * 3 + 1013904223;
-				var6 = this.distHashCounter >> 2;
-				var7 = var6 & 15;
-				var8 = var6 >> 8 & 15;
-				var9 = var6 >> 16 & 127;
-				var10 = var14.getBlockID(var7, var9, var8);
-				var7 += var3;
-				var8 += var4;
-				if(var10 == 0 && this.getFullBlockLightValue(var7, var9, var8) <= this.rand.nextInt(8) && this.getSavedLightValue(LightType.SKY, var7, var9, var8) <= 0) {
-					PlayerEntity var11 = this.getClosestPlayer((double)var7 + 0.5D, (double)var9 + 0.5D, (double)var8 + 0.5D, 8.0D);
-					if(var11 != null && var11.getDistanceSq((double)var7 + 0.5D, (double)var9 + 0.5D, (double)var8 + 0.5D) > 4.0D) {
-						this.playSoundEffect((double)var7 + 0.5D, (double)var9 + 0.5D, (double)var8 + 0.5D, "ambient.cave.cave", 0.7F, 0.8F + this.rand.nextFloat() * 0.2F);
-						this.soundCounter = this.rand.nextInt(12000) + 6000;
-					}
-				}
-			}
 
 			if(this.rand.nextInt(100000) == 0 && this.canRain() && this.canThunder()) {
 				this.distHashCounter = this.distHashCounter * 3 + 1013904223;
@@ -2014,29 +1942,33 @@
 				var6 = this.distHashCounter >> 2;
 				var7 = var6 & 15;
 				var8 = var6 >> 8 & 15;
-				var9 = this.getTopSolidOrLiquidBlock(var7 + var3, var8 + var4);
-				if(this.getBiomeSource().getBiomeGenAt(var7 + var3, var8 + var4).getEnableSnow() && var9 >= 0 && var9 < 128 && var14.getSavedLightValue(LightType.BLOCK, var7, var9, var8) < 10) {
-					var10 = var14.getBlockID(var7, var9 - 1, var8);
-					var15 = var14.getBlockID(var7, var9, var8);
-					if(this.canRain() && var15 == 0 && Block.snowLayer.canPlaceBlockAt(this, var7 + var3, var9, var8 + var4) && var10 != 0 && var10 != Block.ice.blockID && Block.blocksList[var10].material.getIsSolid()) {
-						this.setBlockWithNotify(var7 + var3, var9, var8 + var4, Block.snowLayer.blockID);
-					}
+				if(this.getBiomeAt(var7 + var3, var8 + var4).getEnableSnow()) {
+					var9 = this.getTopSolidOrLiquidBlock(var7 + var3, var8 + var4);
+					if(var14.getSavedLightValue(LightType.BLOCK, var7, var9, var8) < 10) {
+						var10 = var14.getBlockID(var7, var9 - 1, var8);
+						var15 = var14.getBlockID(var7, var9, var8);
+						if(this.canRain() && var15 == 0 && Block.snowLayer.canPlaceBlockAt(this, var7 + var3, var9, var8 + var4) && var10 != 0 && var10 != Block.ice.blockID && Block.blocksList[var10].material.getIsSolid()) {
+							this.setBlockWithNotify(var7 + var3, var9, var8 + var4, Block.snowLayer.blockID);
+						}
 
-					if(var10 == Block.stillWater.blockID && var14.getBlockMetadata(var7, var9 - 1, var8) == 0) {
-						this.setBlockWithNotify(var7 + var3, var9 - 1, var8 + var4, Block.ice.blockID);
+						if(var10 == Block.stillWater.blockID && var14.getBlockMetadata(var7, var9 - 1, var8) == 0) {
+							this.setBlockWithNotify(var7 + var3, var9 - 1, var8 + var4, Block.ice.blockID);
+						}
 					}
 				}
 			}
 
-			for(var6 = 0; var6 < 80; ++var6) {
-				this.distHashCounter = this.distHashCounter * 3 + 1013904223;
-				var7 = this.distHashCounter >> 2;
-				var8 = var7 & 15;
-				var9 = var7 >> 8 & 15;
-				var10 = var7 >> 16 & 127;
-				var15 = var14.blocks[var8 << 11 | var9 << 7 | var10] & 255;
-				if(Block.tickOnLoad[var15]) {
-					Block.blocksList[var15].updateTick(this, var8 + var3, var10, var9 + var4, this.rand);
+			for (Int2ObjectMap.Entry<ChunkSection> kvSection : var14.sections.int2ObjectEntrySet()) {
+				for (int i = 0; i < 10; i++) {
+					this.distHashCounter = this.distHashCounter * 3 + 1013904223;
+					int rand = this.distHashCounter >> 2;
+					int x = rand & 15;
+					int y = rand >> 8 & 15;
+					int z = rand >> 16 & 15;
+					int block = kvSection.getValue().getBlock(x, y, z);
+					if (Block.tickOnLoad[block]) {
+						Block.blocksList[block].updateTick(this, x + var3, y + (kvSection.getIntKey() << 4), z + var4, this.rand);
+					}
 				}
 			}
 		}
@@ -2048,8 +1980,8 @@
 		if(var2 != this.scheduledTickSet.size()) {
 			throw new IllegalStateException("TickNextTick list out of synch");
 		} else {
-			if(var2 > 1000) {
-				var2 = 1000;
+			if(var2 > 10000) {
+				var2 = 10000;
 			}
 
 			for(int var3 = 0; var3 < var2; ++var3) {
@@ -2153,16 +2085,16 @@
 		return var2;
 	}
 
-	public void addLoadedEntities(List var1) {
+	public void addLoadedEntities(Set<Entity> var1) {
 		this.loadedEntityList.addAll(var1);
 
-		for(int var2 = 0; var2 < var1.size(); ++var2) {
-			this.obtainEntitySkin((Entity)var1.get(var2));
+		for(Entity entity : var1) {
+			this.obtainEntitySkin(entity);
 		}
 
 	}
 
-	public void addUnloadedEntities(List var1) {
+	public void addUnloadedEntities(Set<Entity> var1) {
 		this.unloadedEntityList.addAll(var1);
 	}
 
@@ -2275,94 +2207,10 @@
 	}
 
 	public byte[] getChunkData(int var1, int var2, int var3, int var4, int var5, int var6) {
-		byte[] var7 = new byte[var4 * var5 * var6 * 5 / 2];
-		int var8 = var1 >> 4;
-		int var9 = var3 >> 4;
-		int var10 = var1 + var4 - 1 >> 4;
-		int var11 = var3 + var6 - 1 >> 4;
-		int var12 = 0;
-		int var13 = var2;
-		int var14 = var2 + var5;
-		if(var2 < 0) {
-			var13 = 0;
-		}
-
-		if(var14 > 128) {
-			var14 = 128;
-		}
-
-		for(int var15 = var8; var15 <= var10; ++var15) {
-			int var16 = var1 - var15 * 16;
-			int var17 = var1 + var4 - var15 * 16;
-			if(var16 < 0) {
-				var16 = 0;
-			}
-
-			if(var17 > 16) {
-				var17 = 16;
-			}
-
-			for(int var18 = var9; var18 <= var11; ++var18) {
-				int var19 = var3 - var18 * 16;
-				int var20 = var3 + var6 - var18 * 16;
-				if(var19 < 0) {
-					var19 = 0;
-				}
-
-				if(var20 > 16) {
-					var20 = 16;
-				}
-
-				var12 = this.getChunkFromChunkCoords(var15, var18).getChunkData(var7, var16, var13, var19, var17, var14, var20, var12);
-			}
-		}
-
-		return var7;
+		return null;
 	}
 
 	public void setChunkData(int var1, int var2, int var3, int var4, int var5, int var6, byte[] var7) {
-		int var8 = var1 >> 4;
-		int var9 = var3 >> 4;
-		int var10 = var1 + var4 - 1 >> 4;
-		int var11 = var3 + var6 - 1 >> 4;
-		int var12 = 0;
-		int var13 = var2;
-		int var14 = var2 + var5;
-		if(var2 < 0) {
-			var13 = 0;
-		}
-
-		if(var14 > 128) {
-			var14 = 128;
-		}
-
-		for(int var15 = var8; var15 <= var10; ++var15) {
-			int var16 = var1 - var15 * 16;
-			int var17 = var1 + var4 - var15 * 16;
-			if(var16 < 0) {
-				var16 = 0;
-			}
-
-			if(var17 > 16) {
-				var17 = 16;
-			}
-
-			for(int var18 = var9; var18 <= var11; ++var18) {
-				int var19 = var3 - var18 * 16;
-				int var20 = var3 + var6 - var18 * 16;
-				if(var19 < 0) {
-					var19 = 0;
-				}
-
-				if(var20 > 16) {
-					var20 = 16;
-				}
-
-				var12 = this.getChunkFromChunkCoords(var15, var18).setChunkData(var7, var16, var13, var19, var17, var14, var20, var12);
-				this.markBlocksDirty(var15 * 16 + var16, var13, var18 * 16 + var19, var15 * 16 + var17, var14, var18 * 16 + var20);
-			}
-		}
-
 	}
 
 	public void sendQuittingDisconnectingPacket() {
@@ -2570,7 +2418,7 @@
 		} else if(this.getTopSolidOrLiquidBlock(var1, var3) > var2) {
 			return false;
 		} else {
-			Biome var4 = this.getBiomeSource().getBiomeGenAt(var1, var3);
+			Biome var4 = this.getBiomeAt(var1, var3);
 			return var4.getEnableSnow() ? false : var4.canSpawnLightningBolt();
 		}
 	}
@@ -2596,5 +2444,179 @@
 			((WorldAccess)this.worldAccesses.get(var7)).playAuxEffect(var1, var2, var3, var4, var5, var6);
 		}
 
+	}
+
+	// Blame Java generics for this mess
+	// Project Valhalla, please bless us
+
+	public <T> T getBlockProperty(int x, int y, int z, Property<T> property) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return null;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return null;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return null;
+
+		int metadata = section.getMetadata(x, y, z);
+		return block.properties.get(metadata, property);
+	}
+
+	public int getBlockIntProperty(int x, int y, int z, Property<?> property) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return 0;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return 0;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return 0;
+
+		int metadata = section.getMetadata(x, y, z);
+		return block.properties.getInt(metadata, property);
+	}
+
+	public boolean getBlockBooleanProperty(int x, int y, int z, Property<?> property) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return false;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return false;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return false;
+
+		int metadata = section.getMetadata(x, y, z);
+		return block.properties.getBoolean(metadata, property);
+	}
+
+	public <T> void setBlockProperty(int x, int y, int z, Property<T> property, T value) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return;
+
+		int metadata = section.getMetadata(x, y, z);
+		section.setMetadata(x, y, z, block.properties.set(metadata, property, value));
+	}
+
+	public <T> void setBlockPropertyWithNotify(int x, int y, int z, Property<T> property, T value) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return;
+
+		int metadata = section.getMetadata(x, y, z);
+		section.setMetadata(x, y, z, block.properties.set(metadata, property, value));
+
+		if (Block.requiresSelfNotify[block.blockID]) {
+			this.notifyBlockChange(x, y, z, block.blockID);
+		} else {
+			this.notifyBlockOfNeighborChange(x, y, z, block.blockID);
+		}
+	}
+
+	public void setBlockProperty(int x, int y, int z, Property<?> property, int value) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return;
+
+		int metadata = section.getMetadata(x, y, z);
+		section.setMetadata(x, y, z, block.properties.set(metadata, property, value));
+	}
+
+	public void setBlockPropertyWithNotify(int x, int y, int z, Property<?> property, int value) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return;
+
+		int metadata = section.getMetadata(x, y, z);
+		section.setMetadata(x, y, z, block.properties.set(metadata, property, value));
+
+		if (Block.requiresSelfNotify[block.blockID]) {
+			this.notifyBlockChange(x, y, z, block.blockID);
+		} else {
+			this.notifyBlockOfNeighborChange(x, y, z, block.blockID);
+		}
+	}
+
+	public void setBlockProperty(int x, int y, int z, Property<?> property, boolean value) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return;
+
+		int metadata = section.getMetadata(x, y, z);
+		section.setMetadata(x, y, z, block.properties.set(metadata, property, value));
+	}
+
+	public void setBlockPropertyWithNotify(int x, int y, int z, Property<?> property, boolean value) {
+		if(x < -32000000 || y < -32000000 || z < -32000000 || x > 32000000 || y > 32000000 || z > 32000000) return;
+		Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return;
+
+		int metadata = section.getMetadata(x, y, z);
+		section.setMetadata(x, y, z, block.properties.set(metadata, property, value));
+
+		if (Block.requiresSelfNotify[block.blockID]) {
+			this.notifyBlockChange(x, y, z, block.blockID);
+		} else {
+			this.notifyBlockOfNeighborChange(x, y, z, block.blockID);
+		}
 	}
 }
--- net/minecraft/game/entity/misc/EnumArt.java
+++ net/minecraft/game/entity/misc/EnumArt.java
@@ -25,7 +25,8 @@
 	Pigscene("Pigscene", 64, 64, 64, 192),
 	BurningSkull("BurningSkull", 64, 64, 128, 192),
 	Skeleton("Skeleton", 64, 48, 192, 64),
-	DonkeyKong("DonkeyKong", 64, 48, 192, 112);
+	DonkeyKong("DonkeyKong", 64, 48, 192, 112),
+	VulpinePop("VulpinePop", 48, 64, 192, 192);
 
 	public static final int maxArtTitleLength = "SkullAndRoses".length();
 	public final String title;
--- /dev/null
+++ argo/saj/PositionTrackingPushbackReader.java
@@ -1,0 +1,75 @@
+package argo.saj;
+
+import java.io.IOException;
+import java.io.PushbackReader;
+import java.io.Reader;
+
+final class PositionTrackingPushbackReader implements ThingWithPosition {
+	private final PushbackReader pushbackReader;
+	private int characterCount = 0;
+	private int lineCount = 1;
+	private boolean lastCharacterWasCarriageReturn = false;
+
+	public PositionTrackingPushbackReader(Reader var1) {
+		this.pushbackReader = new PushbackReader(var1);
+	}
+
+	public void unread(char var1) throws IOException {
+		--this.characterCount;
+		if(this.characterCount < 0) {
+			this.characterCount = 0;
+		}
+
+		this.pushbackReader.unread(var1);
+	}
+
+	public void uncount(char[] var1) {
+		this.characterCount -= var1.length;
+		if(this.characterCount < 0) {
+			this.characterCount = 0;
+		}
+
+	}
+
+	public int read() throws IOException {
+		int var1 = this.pushbackReader.read();
+		this.updateCharacterAndLineCounts(var1);
+		return var1;
+	}
+
+	public int read(char[] var1) throws IOException {
+		int var2 = this.pushbackReader.read(var1);
+
+        for (char var6 : var1) {
+            this.updateCharacterAndLineCounts(var6);
+        }
+
+		return var2;
+	}
+
+	private void updateCharacterAndLineCounts(int var1) {
+		if(13 == var1) {
+			this.characterCount = 0;
+			++this.lineCount;
+			this.lastCharacterWasCarriageReturn = true;
+		} else {
+			if(10 == var1 && !this.lastCharacterWasCarriageReturn) {
+				this.characterCount = 0;
+				++this.lineCount;
+			} else {
+				++this.characterCount;
+			}
+
+			this.lastCharacterWasCarriageReturn = false;
+		}
+
+	}
+
+	public int getColumn() {
+		return this.characterCount;
+	}
+
+	public int getRow() {
+		return this.lineCount;
+	}
+}
--- net/minecraft/client/gui/component/GuiOptionsButton.java
+++ net/minecraft/client/gui/component/GuiOptionsButton.java
@@ -15,7 +15,7 @@
 	}
 
 	public GuiOptionsButton(int var1, int var2, int var3, Option var4, String var5) {
-		super(var1, var2, var3, 150, 20, var5);
+		super(var1, var2, var3, 140, 20, var5);
 		this.enumOptions = var4;
 	}
 
--- net/minecraft/game/world/block/BedBlock.java
+++ net/minecraft/game/world/block/BedBlock.java
@@ -8,30 +8,57 @@
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.BlockPos;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.material.Material;
 
 public class BedBlock extends Block {
-	public static final int[][] headBlockToFootBlockMap = new int[][]{{0, 1}, {-1, 0}, {0, -1}, {1, 0}};
+	public enum BedDirection {
+		SOUTH(0, 1),
+		WEST(-1, 0),
+		NORTH(0, -1),
+		EAST(1, 0);
+
+		public final int x, z;
+
+		BedDirection(int x, int z) {
+			this.x = x;
+			this.z = z;
+		}
+	}
+
+	private static final int TEX_FOOT = TerrainLayout.texCoord("bed_foot");
+	private static final int TEX_HEAD = TerrainLayout.texCoord("bed_head");
+	private static final int TEX_FOOT_SIDE = TerrainLayout.texCoord("bed_foot_side");
+	private static final int TEX_HEAD_SIDE = TerrainLayout.texCoord("bed_head_side");
+	private static final int TEX_FOOT_TOP = TerrainLayout.texCoord("bed_foot_top");
+	private static final int TEX_HEAD_TOP = TerrainLayout.texCoord("bed_head_top");
+
+	public static final EnumProperty<BedDirection> DIRECTION = new EnumProperty<>("direction", BedDirection.class);
+	public static final BooleanProperty IS_HEAD = new BooleanProperty("side", "head", "foot");
+	public static final BooleanProperty OCCUPIED = new BooleanProperty("occupied");
 
 	public BedBlock(int var1) {
-		super(var1, 134, Material.cloth);
+		super(var1, TEX_FOOT_TOP, Material.cloth);
 		this.setBounds();
+	}
+
+	protected PropertyList getProperties() {
+	return new PropertyList(DIRECTION, IS_HEAD, OCCUPIED);
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, PlayerEntity var5) {
 		if(var1.remoteWorld) {
 			return true;
 		} else {
-			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			if(!isBlockFootOfBed(var6)) {
-				int var7 = getDirectionFromMetadata(var6);
-				var2 += headBlockToFootBlockMap[var7][0];
-				var4 += headBlockToFootBlockMap[var7][1];
+			if(!var1.getBlockBooleanProperty(var2, var3, var4, IS_HEAD)) {
+				BedDirection var7 = var1.getBlockProperty(var2, var3, var4, DIRECTION);
+				var2 += var7.x;
+				var4 += var7.z;
 				if(var1.getBlockId(var2, var3, var4) != this.blockID) {
 					return true;
 				}
-
-				var6 = var1.getBlockMetadata(var2, var3, var4);
 			}
 
 			if(!var1.dimension.canRespawnHere()) {
@@ -39,9 +66,9 @@
 				double var17 = (double)var3 + 0.5D;
 				double var11 = (double)var4 + 0.5D;
 				var1.setBlockWithNotify(var2, var3, var4, 0);
-				int var13 = getDirectionFromMetadata(var6);
-				var2 += headBlockToFootBlockMap[var13][0];
-				var4 += headBlockToFootBlockMap[var13][1];
+				BedDirection var13 = var1.getBlockProperty(var2, var3, var4, DIRECTION);
+				var2 += var13.x;
+				var4 += var13.z;
 				if(var1.getBlockId(var2, var3, var4) == this.blockID) {
 					var1.setBlockWithNotify(var2, var3, var4, 0);
 					var16 = (var16 + (double)var2 + 0.5D) / 2.0D;
@@ -52,7 +79,7 @@
 				var1.newExplosion((Entity)null, (double)((float)var2 + 0.5F), (double)((float)var3 + 0.5F), (double)((float)var4 + 0.5F), 5.0F, true);
 				return true;
 			} else {
-				if(isBedOccupied(var6)) {
+				if(var1.getBlockBooleanProperty(var2, var3, var4, OCCUPIED)) {
 					PlayerEntity var14 = null;
 					Iterator var8 = var1.playerEntities.iterator();
 
@@ -71,12 +98,12 @@
 						return true;
 					}
 
-					setBedOccupied(var1, var2, var3, var4, false);
+					var1.setBlockPropertyWithNotify(var2, var3, var4, OCCUPIED, false);
 				}
 
 				SleepStatus var15 = var5.sleepInBedAt(var2, var3, var4);
 				if(var15 == SleepStatus.OK) {
-					setBedOccupied(var1, var2, var3, var4, true);
+					var1.setBlockPropertyWithNotify(var2, var3, var4, OCCUPIED, true);
 					return true;
 				} else {
 					if(var15 == SleepStatus.NOT_POSSIBLE_NOW) {
@@ -93,9 +120,18 @@
 		if(var1 == 0) {
 			return Block.planks.textureIndex;
 		} else {
-			int var3 = getDirectionFromMetadata(var2);
+			int var3 = this.properties.getInt(var2, DIRECTION);
 			int var4 = ModelBed.bedDirection[var3][var1];
-			return isBlockFootOfBed(var2) ? (var4 == 2 ? this.textureIndex + 2 + 16 : (var4 != 5 && var4 != 4 ? this.textureIndex + 1 : this.textureIndex + 1 + 16)) : (var4 == 3 ? this.textureIndex - 1 + 16 : (var4 != 5 && var4 != 4 ? this.textureIndex : this.textureIndex + 16));
+			return this.properties.getBoolean(var2, IS_HEAD)
+					? var4 == 2
+							? TEX_HEAD
+							: var4 != 5 && var4 != 4
+									? TEX_HEAD_TOP
+									: TEX_HEAD_SIDE
+							: var4 == 3 ? TEX_FOOT
+					: var4 != 5 && var4 != 4
+							? TEX_FOOT_TOP
+							: TEX_FOOT_SIDE;
 		}
 	}
 
@@ -117,12 +153,12 @@
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
 		int var6 = var1.getBlockMetadata(var2, var3, var4);
-		int var7 = getDirectionFromMetadata(var6);
-		if(isBlockFootOfBed(var6)) {
-			if(var1.getBlockId(var2 - headBlockToFootBlockMap[var7][0], var3, var4 - headBlockToFootBlockMap[var7][1]) != this.blockID) {
+		BedDirection var7 = this.properties.get(var6, DIRECTION);
+		if(this.properties.getBoolean(var6, IS_HEAD)) {
+			if(var1.getBlockId(var2 - var7.x, var3, var4 - var7.z) != this.blockID) {
 				var1.setBlockWithNotify(var2, var3, var4, 0);
 			}
-		} else if(var1.getBlockId(var2 + headBlockToFootBlockMap[var7][0], var3, var4 + headBlockToFootBlockMap[var7][1]) != this.blockID) {
+		} else if(var1.getBlockId(var2 + var7.x, var3, var4 + var7.z) != this.blockID) {
 			var1.setBlockWithNotify(var2, var3, var4, 0);
 			if(!var1.remoteWorld) {
 				this.dropBlockAsItem(var1, var2, var3, var4, var6);
@@ -132,43 +168,19 @@
 	}
 
 	public int idDropped(int var1, Random var2) {
-		return isBlockFootOfBed(var1) ? 0 : Item.bed.itemID;
+		return this.properties.getBoolean(var1, IS_HEAD) ? 0 : Item.bed.itemID;
 	}
 
 	private void setBounds() {
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 9.0F / 16.0F, 1.0F);
 	}
 
-	public static int getDirectionFromMetadata(int var0) {
-		return var0 & 3;
-	}
-
-	public static boolean isBlockFootOfBed(int var0) {
-		return (var0 & 8) != 0;
-	}
-
-	public static boolean isBedOccupied(int var0) {
-		return (var0 & 4) != 0;
-	}
-
-	public static void setBedOccupied(World var0, int var1, int var2, int var3, boolean var4) {
-		int var5 = var0.getBlockMetadata(var1, var2, var3);
-		if(var4) {
-			var5 |= 4;
-		} else {
-			var5 &= -5;
-		}
-
-		var0.setBlockMetadataWithNotify(var1, var2, var3, var5);
-	}
-
 	public static BlockPos getNearestEmptyChunkCoordinates(World var0, int var1, int var2, int var3, int var4) {
-		int var5 = var0.getBlockMetadata(var1, var2, var3);
-		int var6 = getDirectionFromMetadata(var5);
+		BedDirection var6 = var0.getBlockProperty(var1, var2, var3, DIRECTION);
 
 		for(int var7 = 0; var7 <= 1; ++var7) {
-			int var8 = var1 - headBlockToFootBlockMap[var6][0] * var7 - 1;
-			int var9 = var3 - headBlockToFootBlockMap[var6][1] * var7 - 1;
+			int var8 = var1 - var6.x * var7 - 1;
+			int var9 = var3 - var6.z * var7 - 1;
 			int var10 = var8 + 2;
 			int var11 = var9 + 2;
 
@@ -189,7 +201,7 @@
 	}
 
 	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
-		if(!isBlockFootOfBed(var5)) {
+		if(!this.properties.getBoolean(var5, IS_HEAD)) {
 			super.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
 		}
 
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/Shaders.java
@@ -1,0 +1,76 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import net.mine_diver.smoothbeta.client.render.gl.GlBlendState;
+import net.mine_diver.smoothbeta.client.render.gl.Program;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Supplier;
+
+public class Shaders {
+    public static final Application application;
+    private static Shader terrainShader;
+
+    static {
+        applyShader(application = loadShaders());
+    }
+
+    public static class Application {
+        final Runnable clearCache;
+        final Supplier<Shader> shaderFactory;
+
+        public Application(Runnable clearCache, Supplier<Shader> shaderFactory) {
+            this.clearCache = clearCache;
+            this.shaderFactory = shaderFactory;
+        }
+    }
+
+    private static Application loadShaders() {
+        List<Program> list = new ArrayList<>();
+        list.addAll(Program.Type.FRAGMENT.getProgramCache().values());
+        list.addAll(Program.Type.VERTEX.getProgramCache().values());
+
+        Supplier<Shader> shaderFactory = () -> {
+            try {
+                return new Shader("terrain", new ShaderInfo(
+                        "terrain",
+                        "terrain",
+                        new String[] { "Position", "UV0", "Color", "Normal" },
+                        new ShaderInfo.Sampler[] { new ShaderInfo.Sampler("Sampler0", null) },
+                        new ShaderInfo.Uniform[] {
+                                new ShaderInfo.Uniform("ModelViewMat", "matrix4x4", 16, new float[] { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 }),
+                                new ShaderInfo.Uniform("ProjMat", "matrix4x4", 16, new float[] { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 }),
+                                new ShaderInfo.Uniform("ChunkOffset", "float", 3, new float[] { 0, 0, 0 }),
+                                new ShaderInfo.Uniform("FogMode", "int", 1, new float[] { 0 }),
+                                new ShaderInfo.Uniform("FogShape", "int", 1, new float[] { 0 })
+                        },
+                        new GlBlendState(
+                                GlBlendState.getComponentFromString("srcalpha"),
+                                GlBlendState.getComponentFromString("1-srcalpha"),
+                                GlBlendState.getFuncFromString("add")
+                        ),
+                        VertexFormats.POSITION_TEXTURE_COLOR_NORMAL
+                ));
+            } catch (IOException e) {
+                throw new RuntimeException("Could not reload terrain shader", e);
+            }
+        };
+
+        return new Application(() -> list.forEach(Program::release), shaderFactory);
+    }
+
+    private static void applyShader(Application application) {
+        application.clearCache.run();
+
+        if (terrainShader != null) {
+            terrainShader.close();
+        }
+
+        terrainShader = application.shaderFactory.get();
+    }
+
+    public static Shader getTerrainShader() {
+        return terrainShader;
+    }
+}
--- argo/J_JsonObjectNodeList.java
+++ /dev/null
@@ -1,19 +1,0 @@
-package argo;
-
-import java.util.HashMap;
-import java.util.Iterator;
-
-class J_JsonObjectNodeList extends HashMap {
-	final J_JsonObjectNodeBuilder field_27308_a;
-
-	J_JsonObjectNodeList(J_JsonObjectNodeBuilder var1) {
-		this.field_27308_a = var1;
-		Iterator var2 = J_JsonObjectNodeBuilder.func_27236_a(this.field_27308_a).iterator();
-
-		while(var2.hasNext()) {
-			J_JsonFieldBuilder var3 = (J_JsonFieldBuilder)var2.next();
-			this.put(var3.func_27303_b(), var3.func_27302_c());
-		}
-
-	}
-}
--- net/minecraft/game/world/block/SnowLayerBlock.java
+++ net/minecraft/game/world/block/SnowLayerBlock.java
@@ -40,7 +40,7 @@
 
 	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
 		int var5 = var1.getBlockId(var2, var3 - 1, var4);
-		return var5 != 0 && Block.blocksList[var5].isOpaqueCube() ? var1.getBlockMaterial(var2, var3 - 1, var4).getIsSolid() : false;
+		return var5 != 0 && Block.blocksList[var5].isOpaqueCube() && var1.getBlockMaterial(var2, var3 - 1, var4).getIsSolid() || var5 == Block.leaves.blockID;
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
--- /dev/null
+++ argo/jdom/Functor.java
@@ -1,0 +1,9 @@
+package argo.jdom;
+
+interface Functor {
+	boolean matchesNode(Object var1);
+
+	Object applyTo(Object var1);
+
+	String shortForm();
+}
--- net/minecraft/game/item/MapItem.java
+++ net/minecraft/game/item/MapItem.java
@@ -18,7 +18,6 @@
 	}
 
 	public static MapData getMapDataFromId(short var0, World var1) {
-		(new StringBuilder()).append("map_").append(var0).toString();
 		MapData var3 = (MapData)var1.loadItemData(MapData.class, "map_" + var0);
 		if(var3 == null) {
 			int var4 = var1.getUniqueDataId("map");
@@ -31,7 +30,6 @@
 	}
 
 	public MapData getMapData(ItemStack var1, World var2) {
-		(new StringBuilder()).append("map_").append(var1.getItemDamage()).toString();
 		MapData var4 = (MapData)var2.loadItemData(MapData.class, "map_" + var1.getItemDamage());
 		if(var4 == null) {
 			var1.setItemDamage(var2.getUniqueDataId("map"));
--- net/minecraft/game/world/block/TallGrassBlock.java
+++ net/minecraft/game/world/block/TallGrassBlock.java
@@ -3,17 +3,34 @@
 import java.util.Random;
 import net.minecraft.client.render.color.ColorizerGrass;
 import net.minecraft.game.item.Item;
+import net.minecraft.game.item.SubtypedItem;
 import net.minecraft.game.world.BlockAccess;
+import net.minecraft.game.world.biome.BiomeColorType;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.StringProperty;
 
 public class TallGrassBlock extends FlowerBlock {
+	private static final int[] TEX_TYPES = TerrainLayout.texCoordArray("dead_bush", "tall_grass", "fern");
+	public static final StringProperty TYPE = new StringProperty("type", "shrub", "tall_grass", "fern");
+
 	protected TallGrassBlock(int var1, int var2) {
 		super(var1, var2);
 		float var3 = 0.4F;
 		this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, 0.8F, 0.5F + var3);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(TYPE);
+	}
+
+	protected Item getItem() {
+		return new SubtypedItem(this.blockID - 256);
+	}
+
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return var2 == 1 ? this.textureIndex : (var2 == 2 ? this.textureIndex + 16 + 1 : (var2 == 0 ? this.textureIndex + 16 : this.textureIndex));
+		var2 = this.properties.getInt(var2, TYPE);
+		if (var2 >= TEX_TYPES.length) var2 = 0;
+		return TEX_TYPES[var2];
 	}
 
 	public int getColorMultiplier(BlockAccess var1, int var2, int var3, int var4) {
@@ -21,16 +38,17 @@
 		if(var5 == 0) {
 			return 16777215;
 		} else {
-			long var6 = (long)(var2 * 3129871 + var4 * 6129781 + var3);
-			var6 = var6 * var6 * 42317861L + var6 * 11L;
-			var2 = (int)((long)var2 + (var6 >> 14 & 31L));
-			var3 = (int)((long)var3 + (var6 >> 19 & 31L));
-			var4 = (int)((long)var4 + (var6 >> 24 & 31L));
-			var1.getBiomeSource().getBlockGeneratorData(var2, var4, 1, 1);
-			double var8 = var1.getBiomeSource().temperature[0];
-			double var10 = var1.getBiomeSource().humidity[0];
-			return ColorizerGrass.getGrassColor(var8, var10);
+//			long var6 = (long)(var2 * 3129871 + var4 * 6129781 + var3);
+//			var6 = var6 * var6 * 42317861L + var6 * 11L;
+//			var2 = (int)((long)var2 + (var6 >> 14 & 31L));
+//			var3 = (int)((long)var3 + (var6 >> 19 & 31L));
+//			var4 = (int)((long)var4 + (var6 >> 24 & 31L));
+			return var1.getBiomeSource().getColorAt(var2, var4, BiomeColorType.GRASS);
 		}
+	}
+
+	public int getInventoryColor(int var1) {
+		return var1 == 0 ? 16777215 : ColorizerGrass.getGrassColor(1.0D, 0.5D);
 	}
 
 	public int idDropped(int var1, Random var2) {
--- net/minecraft/isom/CanvasIsomPreview.java
+++ net/minecraft/isom/CanvasIsomPreview.java
@@ -20,6 +20,7 @@
 import java.util.List;
 import java.util.Random;
 import net.minecraft.game.world.BlockPos;
+import net.minecraft.game.world.NewWorldInfo;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.save.SaveHandlerImpl;
 
@@ -97,7 +98,7 @@
 
 	public void loadWorld(String var1) {
 		this.field_1785_i = this.field_1784_j = 0;
-		this.worldObj = new World(new SaveHandlerImpl(new File(this.dataFolder, "saves"), var1, false), var1, (new Random()).nextLong());
+		this.worldObj = new World(new SaveHandlerImpl(new File(this.dataFolder, "saves"), var1, false), new NewWorldInfo(var1, (new Random()).nextLong()));
 		this.worldObj.skylightSubtracted = 0;
 		List var2 = this.imageBufferList;
 		synchronized(var2) {
--- net/minecraft/game/world/terrain/feature/SpruceTreeFeature.java
+++ net/minecraft/game/world/terrain/feature/SpruceTreeFeature.java
@@ -6,92 +6,80 @@
 
 public class SpruceTreeFeature extends Feature {
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
-		int var6 = var2.nextInt(4) + 6;
+		int var6 = var2.nextInt(7) + 7;
 		int var7 = 1 + var2.nextInt(2);
 		int var8 = var6 - var7;
 		int var9 = 2 + var2.nextInt(2);
 		boolean var10 = true;
-		if(var4 >= 1 && var4 + var6 + 1 <= 128) {
-			int var11;
-			int var13;
-			int var15;
-			int var21;
-			for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
-				boolean var12 = true;
-				if(var11 - var4 < var7) {
-					var21 = 0;
-				} else {
-					var21 = var9;
-				}
-
-				for(var13 = var3 - var21; var13 <= var3 + var21 && var10; ++var13) {
-					for(int var14 = var5 - var21; var14 <= var5 + var21 && var10; ++var14) {
-						if(var11 >= 0 && var11 < 128) {
-							var15 = var1.getBlockId(var13, var11, var14);
-							if(var15 != 0 && var15 != Block.leaves.blockID) {
-								var10 = false;
-							}
-						} else {
-							var10 = false;
-						}
-					}
-				}
-			}
-
-			if(!var10) {
-				return false;
+		int var11;
+		int var13;
+		int var15;
+		int var21;
+		for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
+			boolean var12 = true;
+			if(var11 - var4 < var7) {
+				var21 = 0;
 			} else {
-				var11 = var1.getBlockId(var3, var4 - 1, var5);
-				if((var11 == Block.grass.blockID || var11 == Block.dirt.blockID) && var4 < 128 - var6 - 1) {
-					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
-					var21 = var2.nextInt(2);
-					var13 = 1;
-					byte var22 = 0;
-
-					int var16;
-					int var17;
-					for(var15 = 0; var15 <= var8; ++var15) {
-						var16 = var4 + var6 - var15;
-
-						for(var17 = var3 - var21; var17 <= var3 + var21; ++var17) {
-							int var18 = var17 - var3;
-
-							for(int var19 = var5 - var21; var19 <= var5 + var21; ++var19) {
-								int var20 = var19 - var5;
-								if((Math.abs(var18) != var21 || Math.abs(var20) != var21 || var21 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var17, var16, var19)]) {
-									var1.setBlockAndMetadata(var17, var16, var19, Block.leaves.blockID, 1);
-								}
-							}
-						}
-
-						if(var21 >= var13) {
-							var21 = var22;
-							var22 = 1;
-							++var13;
-							if(var13 > var9) {
-								var13 = var9;
-							}
-						} else {
-							++var21;
-						}
-					}
-
-					var15 = var2.nextInt(3);
-
-					for(var16 = 0; var16 < var6 - var15; ++var16) {
-						var17 = var1.getBlockId(var3, var4 + var16, var5);
-						if(var17 == 0 || var17 == Block.leaves.blockID) {
-							var1.setBlockAndMetadata(var3, var4 + var16, var5, Block.log.blockID, 1);
-						}
-					}
-
-					return true;
-				} else {
-					return false;
+				var21 = var9;
+			}
+
+			for(var13 = var3 - var21; var13 <= var3 + var21 && var10; ++var13) {
+				for(int var14 = var5 - var21; var14 <= var5 + var21 && var10; ++var14) {
+					var15 = var1.getBlockId(var13, var11, var14);
+					if(var15 != 0 && var15 != Block.leaves.blockID) {
+						var10 = false;
+					}
 				}
 			}
-		} else {
+		}
+
+		if(!var10) {
 			return false;
+		} else {
+			if (!Block.sapling.canPlaceBlockAt(var1, var3, var4, var5)) return false;
+			if (var1.getBlockId(var3, var4 - 1, var5) == Block.grass.blockID) var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+			var21 = var2.nextInt(2);
+			var13 = 1;
+			byte var22 = 0;
+
+			int var16;
+			int var17;
+			for(var15 = 0; var15 <= var8; ++var15) {
+				var16 = var4 + var6 - var15;
+
+				for(var17 = var3 - var21; var17 <= var3 + var21; ++var17) {
+					int var18 = var17 - var3;
+
+					for(int var19 = var5 - var21; var19 <= var5 + var21; ++var19) {
+						int var20 = var19 - var5;
+						if((Math.abs(var18) != var21 || Math.abs(var20) != var21 || var21 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var17, var16, var19)]) {
+							var1.setBlockAndMetadata(var17, var16, var19, Block.leaves.blockID, 1);
+						}
+					}
+				}
+
+				if(var21 >= var13) {
+					var21 = var22;
+					var22 = 1;
+					++var13;
+					if(var13 > var9) {
+						var13 = var9;
+					}
+				} else {
+					++var21;
+				}
+			}
+
+			var15 = var2.nextInt(3);
+
+			for(var16 = 0; var16 < var6 - var15; ++var16) {
+				var17 = var1.getBlockId(var3, var4 + var16, var5);
+				if(var17 == 0 || var17 == Block.leaves.blockID) {
+					var1.setBlockAndMetadata(var3, var4 + var16, var5, Block.log.blockID, 1);
+				}
+			}
+
+			return true;
 		}
 	}
 }
--- com/mojang/nbt/NBTBaseTag.java
+++ com/mojang/nbt/NBTBaseTag.java
@@ -66,6 +66,12 @@
 			return new ListTag();
 		case 10:
 			return new CompoundTag();
+		case 11:
+			return new IntArrayTag();
+		case 12:
+			return new LongArrayTag();
+		case 13:
+			return new ShortArrayTag();
 		default:
 			return null;
 		}
@@ -95,8 +101,16 @@
 			return "TAG_List";
 		case 10:
 			return "TAG_Compound";
+		case 11:
+			return "TAG_Int_Array";
+		case 12:
+			return "TAG_Long_Array";
+		case 13:
+			return "TAG_Short_Array";
 		default:
 			return "UNKNOWN";
 		}
 	}
+
+	public abstract NBTBaseTag copy();
 }
--- net/minecraft/client/player/MovementInput.java
+++ net/minecraft/client/player/MovementInput.java
@@ -8,6 +8,7 @@
 	public boolean field_1177_c = false;
 	public boolean jump = false;
 	public boolean sneak = false;
+	public boolean run = false;
 
 	public void updatePlayerMoveState(PlayerEntity var1) {
 	}
--- net/minecraft/game/entity/player/PlayerEntity.java
+++ net/minecraft/game/entity/player/PlayerEntity.java
@@ -4,6 +4,8 @@
 import com.mojang.nbt.ListTag;
 import java.util.Iterator;
 import java.util.List;
+
+import net.minecraft.client.player.ThreadGetSkin;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.entity.animal.PigEntity;
@@ -45,6 +47,7 @@
 	public float prevRideThing;
 	public float rideThing;
 	public boolean isSwinging = false;
+	public boolean creative = false;
 	public int swingProgressInt = 0;
 	public String username;
 	public int dimension;
@@ -69,6 +72,12 @@
 	public float prevTimeInPortal;
 	private int damageRemainder = 0;
 	public FishEntity fishEntity = null;
+	public boolean isSlim = false;
+	public boolean isSkinFound = false;
+	public float energy = 20.0F;
+	public float energyRegenAmount = 0.0F;
+	public boolean energyRegen;
+	public boolean tired = false;
 
 	public PlayerEntity(World var1) {
 		super(var1);
@@ -86,7 +95,7 @@
 
 	protected void entityInit() {
 		super.entityInit();
-		this.properties.addProperty(16, Byte.valueOf((byte)0));
+		this.properties.addProperty(16, (byte) 0);
 	}
 
 	public void onUpdate() {
@@ -165,9 +174,14 @@
 		this.craftingInventory = this.inventorySlots;
 	}
 
-	public void updateCloak() {
-		this.playerCloakUrl = "http://s3.amazonaws.com/MinecraftCloaks/" + this.username + ".png";
-		this.cloakUrl = this.playerCloakUrl;
+	public void updateCloak() { // Is it really a cloak now?
+		if (this.skinUrl == null && !this.isSkinFound) {
+			(new ThreadGetSkin(this)).start();
+		}
+
+		if (this.isSlim) {
+			this.texture = "/mob/alex.png";
+		}
 	}
 
 	public void updateRidden() {
@@ -203,6 +217,8 @@
 	}
 
 	public void onLivingUpdate() {
+		this.preUpdate();
+
 		if(this.worldObj.difficultySetting == 0 && this.health < 20 && this.ticksExisted % 20 * 12 == 0) {
 			this.heal(1);
 		}
@@ -210,6 +226,25 @@
 		this.inventory.decrementAnimations();
 		this.prevRideThing = this.rideThing;
 		super.onLivingUpdate();
+
+		if (this.creative && this.fire > 0) {
+			this.fire = 0;
+		}
+
+		if (this.flying) {
+			if (this.isSneaking() && this.isJumping) {
+				this.motionY = 0.0F;
+			} else if (this.isJumping) {
+				this.motionY = 0.4F;
+			} else if (this.isSneaking()) {
+				this.motionY = -0.4F;
+			} else {
+				this.motionY *= 0.5F;
+			}
+			this.flying = !this.onGround;
+			this.distanceWalkedModified = this.prevDistanceWalkedModified;
+		}
+
 		float var1 = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
 		float var2 = (float)Math.atan(-this.motionY * (double)0.2F) * 15.0F;
 		if(var1 > 0.1F) {
@@ -238,6 +273,33 @@
 			}
 		}
 
+		if (this.isRunning()) {
+			this.energy -= 0.15F;
+			this.energyRegenAmount = 0.0F;
+		} else {
+			this.energyRegenAmount += 0.004F;
+			this.energy += this.energyRegenAmount;
+		}
+		this.energy = MathHelper.clamp(this.energy, 0.0F, 20.0F);
+		this.tired = this.energyRegen;
+		this.energyRegen =
+				(this.energyRegen ? this.energy < 20.0F
+				: !this.isRunning() ? this.tired
+				: this.energy <= 0.0F)
+				&& !this.creative;
+
+		if (this.creative) {
+			this.health = 20;
+			this.energy = 20.0F;
+		}
+	}
+
+	public void preUpdate() {
+		float runFactor = 0.4F + this.energy / 100.0F;
+		this.groundSpeedMultiplier = this.isRunning() ? 1.0F + runFactor : 1.0F;
+		this.airSpeedMultiplier = this.flying
+				? this.isRunning() ? 10.0F : 2.5F
+				: this.isRunning() ? 1.0F + runFactor * 2.0F : 1.0F;
 	}
 
 	private void collideWithPlayer(Entity var1) {
@@ -342,6 +404,8 @@
 		super.readEntityFromNBT(var1);
 		ListTag var2 = var1.getTagList("Inventory");
 		this.inventory.readFromNBT(var2);
+		this.energy = var1.hasKey("Energy") ? var1.getFloat("Energy") : 20.0F;
+		this.energyRegen = var1.getBoolean("RegeneratingEnergy");
 		this.dimension = var1.getInteger("Dimension");
 		this.sleeping = var1.getBoolean("Sleeping");
 		this.sleepTimer = var1.getShort("SleepTimer");
@@ -359,6 +423,8 @@
 	public void writeEntityToNBT(CompoundTag var1) {
 		super.writeEntityToNBT(var1);
 		var1.setTag("Inventory", this.inventory.writeToNBT(new ListTag()));
+		var1.setFloat("Energy", this.energy);
+		var1.setBoolean("RegeneratingEnergy", this.energyRegen);
 		var1.setInteger("Dimension", this.dimension);
 		var1.setBoolean("Sleeping", this.sleeping);
 		var1.setShort("SleepTimer", (short)this.sleepTimer);
@@ -389,7 +455,7 @@
 
 	public boolean hurt(Entity var1, int var2) {
 		this.age = 0;
-		if(this.health <= 0) {
+		if(this.health <= 0 || this.creative) {
 			return false;
 		} else {
 			if(this.isPlayerSleeping() && !this.worldObj.remoteWorld) {
@@ -590,7 +656,7 @@
 		this.yOffset = 0.2F;
 		if(this.worldObj.blockExists(var1, var2, var3)) {
 			int var4 = this.worldObj.getBlockMetadata(var1, var2, var3);
-			int var5 = BedBlock.getDirectionFromMetadata(var4);
+			int var5 = Block.bed.properties.getInt(var4, BedBlock.DIRECTION);
 			float var6 = 0.5F;
 			float var7 = 0.5F;
 			switch(var5) {
@@ -647,7 +713,7 @@
 		this.yOffset = 0.2F;
 		if(this.worldObj.blockExists(var1, var2, var3)) {
 			int var4 = this.worldObj.getBlockMetadata(var1, var2, var3);
-			int var5 = BedBlock.getDirectionFromMetadata(var4);
+			int var5 = Block.bed.properties.getInt(var4, BedBlock.DIRECTION);
 			float var6 = 0.5F;
 			float var7 = 0.5F;
 			switch(var5) {
@@ -706,7 +772,7 @@
 		BlockPos var4 = this.bedChunkCoordinates;
 		BlockPos var5 = this.bedChunkCoordinates;
 		if(var4 != null && this.worldObj.getBlockId(var4.x, var4.y, var4.z) == Block.bed.blockID) {
-			BedBlock.setBedOccupied(this.worldObj, var4.x, var4.y, var4.z, false);
+			this.worldObj.setBlockPropertyWithNotify(var4.x, var4.y, var4.z, BedBlock.OCCUPIED, false);
 			var5 = BedBlock.getNearestEmptyChunkCoordinates(this.worldObj, var4.x, var4.y, var4.z, 0);
 			if(var5 == null) {
 				var5 = new BlockPos(var4.x, var4.y + 1, var4.z);
@@ -753,7 +819,7 @@
 	public float getBedOrientationInDegrees() {
 		if(this.bedChunkCoordinates != null) {
 			int var1 = this.worldObj.getBlockMetadata(this.bedChunkCoordinates.x, this.bedChunkCoordinates.y, this.bedChunkCoordinates.z);
-			int var2 = BedBlock.getDirectionFromMetadata(var1);
+			int var2 = Block.bed.properties.getInt(var1, BedBlock.DIRECTION);
 			switch(var2) {
 			case 0:
 				return 90.0F;
--- /dev/null
+++ argo/jdom/JsonNode.java
@@ -1,0 +1,31 @@
+package argo.jdom;
+
+import java.util.List;
+import java.util.Map;
+
+public abstract class JsonNode {
+	public abstract JsonNodeType getType();
+
+	public abstract String getText();
+
+	public abstract Map<JsonStringNode, JsonNode> getFields();
+
+	public abstract List<JsonNode> getElements();
+
+	public final String getStringValue(Object... var1) {
+		return (String)this.wrapExceptionsFor(JsonNodeSelectors.func_27349_a(var1), this, var1);
+	}
+
+	@SuppressWarnings("unchecked")
+	public final List<JsonNode> getArrayNode(Object... var1) {
+		return (List<JsonNode>)this.wrapExceptionsFor(JsonNodeSelectors.func_27346_b(var1), this, var1);
+	}
+
+	private Object wrapExceptionsFor(JsonNodeSelector var1, JsonNode var2, Object[] var3) {
+		try {
+			return var1.getValue(var2);
+		} catch (JsonNodeDoesNotMatchChainedJsonNodeSelectorException var5) {
+			throw JsonNodeDoesNotMatchPathElementsException.func_27319_a(var5, var3, JsonNodeFactories.aJsonArray(var2));
+		}
+	}
+}
--- net/minecraft/client/Option.java
+++ net/minecraft/client/Option.java
@@ -1,23 +1,56 @@
 package net.minecraft.client;
 
+import java.util.*;
+
 public enum Option {
-	MUSIC("options.music", true, false),
-	SOUND("options.sound", true, false),
-	INVERT_MOUSE("options.invertMouse", false, true),
-	SENSITIVITY("options.sensitivity", true, false),
-	RENDER_DISTANCE("options.renderDistance", false, false),
-	VIEW_BOBBING("options.viewBobbing", false, true),
-	ANAGLYPH("options.anaglyph", false, true),
-	ADVANCED_OPENGL("options.advancedOpengl", false, true),
-	FRAMERATE_LIMIT("options.framerateLimit", false, false),
-	DIFFICULTY("options.difficulty", false, false),
-	GRAPHICS("options.graphics", false, false),
-	AMBIENT_OCCLUSION("options.ao", false, true),
-	GUI_SCALE("options.guiScale", false, false);
+	MUSIC               ("options.music",               "options.category.audio",       true,  false),
+	SOUND               ("options.sound",               "options.category.audio",       true,  false),
+	INVERT_MOUSE        ("options.invertMouse",         "options.category.controls",    false, true),
+	SENSITIVITY         ("options.sensitivity",         "options.category.controls",    true,  false),
+	RENDER_DISTANCE     ("options.renderDistance",      "options.category.graphics",    true,  false),
+	SIMULATION_DISTANCE ("options.simulationDistance",  "options.category.graphics",    true,  false),
+	FOG_SHAPE           ("options.fogShape",            "options.category.graphics",    false, false),
+	FOG_DENSITY         ("options.fogDensity",          "options.category.graphics",    true,  false),
+	FOG_DISTANCE        ("options.fogDistance",         "options.category.graphics",    true,  false),
+	FOV			        ("options.fov",				  "options.category.graphics",    true,  false),
+	VIEW_BOBBING        ("options.viewBobbing",         "options.category.graphics",    false, true),
+	ANAGLYPH            ("options.anaglyph",            "options.category.graphics",    false, true),
+	ADVANCED_OPENGL     ("options.advancedOpengl",      "options.category.graphics",    false, true),
+	FRAMERATE_LIMIT     ("options.framerateLimit",      "options.category.graphics",    false, false),
+	MAX_FPS             ("options.maxFps",              "options.category.graphics",    true,  false),
+	DIFFICULTY          ("options.difficulty",          "options.category.misc",        false, false),
+	GRAPHICS            ("options.graphics",            "options.category.graphics",    false, false),
+	AMBIENT_OCCLUSION   ("options.ao",                  "options.category.graphics",    false, true),
+	GUI_SCALE           ("options.guiScale",            "options.category.graphics",    false, false);
+
+	public static final List<String> CATEGORIES = Arrays.asList(
+			"options.category.graphics",
+			"options.category.audio",
+			"options.category.controls",
+			"options.category.misc"
+	);
+	public static final Map<String, List<Option>> SORTED_OPTIONS;
+
+	static {
+		Map<String, List<Option>> sortedOptions = new HashMap<>();
+		for (Option option : values()) {
+			sortedOptions.compute(option.category, (k, v) -> {
+				if (v == null) {
+					v = new ArrayList<>();
+				}
+				v.add(option);
+				return v;
+			});
+		}
+
+		sortedOptions.replaceAll((k, v) -> Collections.unmodifiableList(v));
+		SORTED_OPTIONS = Collections.unmodifiableMap(sortedOptions);
+	}
 
 	private final boolean isSlider;
 	private final boolean isToggle;
 	private final String name;
+	private final String category;
 
 	public static Option getOptionFromId(int var0) {
 		Option[] var1 = values();
@@ -33,8 +66,9 @@
 		return null;
 	}
 
-	private Option(String var3, boolean var4, boolean var5) {
+	private Option(String var3, String var3a, boolean var4, boolean var5) {
 		this.name = var3;
+		this.category = var3a;
 		this.isSlider = var4;
 		this.isToggle = var5;
 	}
@@ -53,5 +87,9 @@
 
 	public String getName() {
 		return this.name;
+	}
+
+	public String getCategory() {
+		return this.category;
 	}
 }
--- /dev/null
+++ ca/spottedleaf/starlight/StarlightEngine.java
@@ -1,0 +1,702 @@
+package ca.spottedleaf.starlight;
+
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.chunk.ChunkSection;
+import net.minecraft.util.HalfByteArray3D;
+import net.minecraft.util.NibbleArray;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class StarlightEngine {
+
+    protected static final int AIR_BLOCK_STATE = 0;
+
+    protected static enum AxisDirection {
+
+        // Declaration order is important and relied upon. Do not change without modifying propagation code.
+        POSITIVE_X(1, 0, 0), NEGATIVE_X(-1, 0, 0),
+        POSITIVE_Z(0, 0, 1), NEGATIVE_Z(0, 0, -1),
+        POSITIVE_Y(0, 1, 0), NEGATIVE_Y(0, -1, 0);
+
+        static {
+            POSITIVE_X.opposite = NEGATIVE_X; NEGATIVE_X.opposite = POSITIVE_X;
+            POSITIVE_Z.opposite = NEGATIVE_Z; NEGATIVE_Z.opposite = POSITIVE_Z;
+            POSITIVE_Y.opposite = NEGATIVE_Y; NEGATIVE_Y.opposite = POSITIVE_Y;
+        }
+
+        protected AxisDirection opposite;
+
+        public final int x;
+        public final int y;
+        public final int z;
+        public final long everythingButThisDirection;
+        public final long everythingButTheOppositeDirection;
+
+        AxisDirection(final int x, final int y, final int z) {
+            this.x = x;
+            this.y = y;
+            this.z = z;
+            this.everythingButThisDirection = (long)(ALL_DIRECTIONS_BITSET ^ (1 << this.ordinal()));
+            // positive is always even, negative is always odd. Flip the 1 bit to get the negative direction.
+            this.everythingButTheOppositeDirection = (long)(ALL_DIRECTIONS_BITSET ^ (1 << (this.ordinal() ^ 1)));
+        }
+
+        public AxisDirection getOpposite() {
+            return this.opposite;
+        }
+    }
+
+    protected static final AxisDirection[] DIRECTIONS = AxisDirection.values();
+    protected static final AxisDirection[] AXIS_DIRECTIONS = DIRECTIONS;
+    protected static final AxisDirection[] ONLY_HORIZONTAL_DIRECTIONS = new AxisDirection[] {
+            AxisDirection.POSITIVE_X, AxisDirection.NEGATIVE_X,
+            AxisDirection.POSITIVE_Z, AxisDirection.NEGATIVE_Z
+    };
+
+    protected static final AxisDirection[][] OLD_CHECK_DIRECTIONS = new AxisDirection[1 << 6][];
+    protected static final int ALL_DIRECTIONS_BITSET = (1 << 6) - 1;
+    static {
+        for (int i = 0; i < OLD_CHECK_DIRECTIONS.length; ++i) {
+            final List<AxisDirection> directions = new ArrayList<>();
+            for (int bitset = i, len = Integer.bitCount(i), index = 0; index < len; ++index, bitset ^= (-bitset & bitset)) {
+                directions.add(AXIS_DIRECTIONS[Integer.numberOfTrailingZeros(bitset)]);
+            }
+            OLD_CHECK_DIRECTIONS[i] = directions.toArray(new AxisDirection[0]);
+        }
+    }
+
+    // always initialsed during start of lighting.
+    // index = x + (z * 5)
+    protected final Chunk[] chunkCache = new Chunk[5 * 5];
+
+    protected int encodeOffsetX;
+    protected int encodeOffsetY;
+    protected int encodeOffsetZ;
+
+    protected int coordinateOffset;
+
+    protected int chunkOffsetX;
+    protected int chunkOffsetY;
+    protected int chunkOffsetZ;
+
+    protected int chunkIndexOffset;
+    protected int chunkSectionIndexOffset;
+
+    protected final boolean skylightPropagator;
+    protected final int emittedLightMask;
+    protected final boolean isClientSide;
+
+    protected final World world;
+
+    public StarlightEngine(final boolean skylightPropagator, final World world) {
+        this.skylightPropagator = skylightPropagator;
+        this.emittedLightMask = skylightPropagator ? 0 : 0xF;
+        this.isClientSide = false;
+        this.world = world;
+    }
+
+    protected final void setupEncodeOffset(final int centerX, final int centerY, final int centerZ) {
+        // 31 = center + encodeOffset
+        this.encodeOffsetX = 31 - centerX;
+        this.encodeOffsetY = (-(-1 - 1) << 4); // we want 0 to be the smallest encoded value
+        this.encodeOffsetZ = 31 - centerZ;
+
+        // coordinateIndex = x | (z << 6) | (y << 12)
+        this.coordinateOffset = this.encodeOffsetX + (this.encodeOffsetZ << 6) + (this.encodeOffsetY << 12);
+
+        // 2 = (centerX >> 4) + chunkOffset
+        this.chunkOffsetX = 2 - (centerX >> 4);
+        this.chunkOffsetY = -(-1 - 1); // lowest should be 0
+        this.chunkOffsetZ = 2 - (centerZ >> 4);
+
+        // chunk index = x + (5 * z)
+        this.chunkIndexOffset = this.chunkOffsetX + (5 * this.chunkOffsetZ);
+
+        // chunk section index = x + (5 * z) + ((5*5) * y)
+        this.chunkSectionIndexOffset = this.chunkIndexOffset + ((5 * 5) * this.chunkOffsetY);
+    }
+
+    protected final void setupCaches(final World chunkProvider, final int centerX, final int centerY, final int centerZ,
+                                     final boolean relaxed) {
+        final int centerChunkX = centerX >> 4;
+        final int centerChunkY = centerY >> 4;
+        final int centerChunkZ = centerZ >> 4;
+
+        this.setupEncodeOffset(centerChunkX * 16 + 7, centerChunkY * 16 + 7, centerChunkZ * 16 + 7);
+
+        final int radius = 1;
+
+        for (int dz = -radius; dz <= radius; ++dz) {
+            for (int dx = -radius; dx <= radius; ++dx) {
+                final int cx = centerChunkX + dx;
+                final int cz = centerChunkZ + dz;
+                final Chunk chunk = !chunkProvider.chunkExists(cx, cz) ? null : chunkProvider.getChunkFromChunkCoords(cx, cz);
+
+                if (chunk == null) {
+                    if (relaxed) {
+                        continue;
+                    }
+                    throw new IllegalArgumentException("Trying to propagate light update before 1 radius neighbours ready");
+                }
+
+                this.setChunkInCache(cx, cz, chunk);
+            }
+        }
+    }
+
+    protected final Chunk getChunkInCache(final int chunkX, final int chunkZ) {
+        return this.chunkCache[chunkX + 5*chunkZ + this.chunkIndexOffset];
+    }
+
+    protected final void setChunkInCache(final int chunkX, final int chunkZ, final Chunk chunk) {
+        this.chunkCache[chunkX + 5*chunkZ + this.chunkIndexOffset] = chunk;
+    }
+
+    protected final HalfByteArray3D getNibbleFromCache(final int chunkX, final int chunkY, final int chunkZ) {
+        final Chunk chunk = this.getChunkInCache(chunkX, chunkZ);
+		if (chunk == null) return null;
+
+		final ChunkSection section = chunk.getSection(chunkY);
+		if (section == null) return null;
+
+		return this.skylightPropagator ? section.getSkyLightArray() : section.getBlockLightArray();
+    }
+
+    protected final int getBlockState(final int worldX, final int worldY, final int worldZ) {
+        final Chunk chunk = this.getChunkInCache(worldX >> 4, worldZ >> 4);
+
+        if (chunk == null) {
+            return AIR_BLOCK_STATE;
+        }
+
+        return chunk.getBlockID(worldX & 15, worldY, worldZ & 15);
+    }
+
+
+    protected final int getLightLevel(final int worldX, final int worldY, final int worldZ) {
+        final HalfByteArray3D nibble = this.getNibbleFromCache(worldX >> 4, worldY >> 4, worldZ >> 4);
+
+        if (nibble != null) {
+            return nibble.get(worldX & 15, worldY & 15, worldZ & 15);
+        }
+
+        if (this.skylightPropagator) {
+            return nibble == null ? 15 : Math.max(0, nibble.get(worldX & 15, 0, worldZ & 15) - worldY); // best approximation
+        } else {
+            return 0;
+        }
+    }
+
+    protected final void destroyCaches() {
+        Arrays.fill(this.chunkCache, null);
+    }
+
+    protected final void setLightLevel(final int worldX, final int worldY, final int worldZ, final int level) {
+        final HalfByteArray3D nibble = this.getNibbleFromCache(worldX >> 4, worldY >> 4, worldZ >> 4);
+
+        if (nibble != null) {
+            nibble.set(worldX & 15, worldY & 15, worldZ & 15, level);
+        }
+    }
+
+    protected final void postLightUpdate(final int worldX, final int worldY, final int worldZ) {
+        // not needed server side
+        this.world.markBlockNeedsUpdate(worldX, worldY, worldZ);
+    }
+
+    // contains:
+    // lower (6 + 6 + 16) = 28 bits: encoded coordinate position (x | (z << 6) | (y << (6 + 6))))
+    // next 4 bits: propagated light level (0, 15]
+    // next 6 bits: propagation direction bitset
+    // next 24 bits: unused
+    // last 3 bits: state flags
+    // state flags:
+    // whether the increase propagator needs to write the propagated level to the position, used to avoid cascading light
+    // updates for block sources
+    protected static final long FLAG_WRITE_LEVEL = Long.MIN_VALUE >>> 2;
+    // whether the propagation needs to check if its current level is equal to the expected level
+    // used only in increase propagation
+    protected static final long FLAG_RECHECK_LEVEL = Long.MIN_VALUE >>> 1;
+    // whether the propagation needs to consider if its block is conditionally transparent
+    protected static final long FLAG_HAS_SIDED_TRANSPARENT_BLOCKS = Long.MIN_VALUE;
+
+    protected long[] increaseQueue = new long[16 * 16 * 16];
+    protected int increaseQueueInitialLength;
+    protected long[] decreaseQueue = new long[16 * 16 * 16];
+    protected int decreaseQueueInitialLength;
+
+    protected final long[] resizeIncreaseQueue() {
+        return this.increaseQueue = Arrays.copyOf(this.increaseQueue, this.increaseQueue.length * 2);
+    }
+
+    protected final long[] resizeDecreaseQueue() {
+        return this.decreaseQueue = Arrays.copyOf(this.decreaseQueue, this.decreaseQueue.length * 2);
+    }
+
+    protected final void appendToIncreaseQueue(final long value) {
+        final int idx = this.increaseQueueInitialLength++;
+        long[] queue = this.increaseQueue;
+        if (idx >= queue.length) {
+            queue = this.resizeIncreaseQueue();
+            queue[idx] = value;
+        } else {
+            queue[idx] = value;
+        }
+    }
+
+    protected final void appendToDecreaseQueue(final long value) {
+        final int idx = this.decreaseQueueInitialLength++;
+        long[] queue = this.decreaseQueue;
+        if (idx >= queue.length) {
+            queue = this.resizeDecreaseQueue();
+            queue[idx] = value;
+        } else {
+            queue[idx] = value;
+        }
+    }
+
+    protected final void performLightIncrease(final World world) {
+        long[] queue = this.increaseQueue;
+        int queueReadIndex = 0;
+        int queueLength = this.increaseQueueInitialLength;
+        this.increaseQueueInitialLength = 0;
+        final int decodeOffsetX = -this.encodeOffsetX;
+        final int decodeOffsetY = -this.encodeOffsetY;
+        final int decodeOffsetZ = -this.encodeOffsetZ;
+        final int encodeOffset = this.coordinateOffset;
+
+        while (queueReadIndex < queueLength) {
+            final long queueValue = queue[queueReadIndex++];
+
+            final int posX = ((int)queueValue & 63) + decodeOffsetX;
+            final int posZ = (((int)queueValue >>> 6) & 63) + decodeOffsetZ;
+            final int posY = (((int)queueValue >>> 12) & ((1 << 16) - 1)) + decodeOffsetY;
+            final int propagatedLightLevel = (int)((queueValue >>> (6 + 6 + 16)) & 0xFL);
+            final AxisDirection[] checkDirections = OLD_CHECK_DIRECTIONS[(int)((queueValue >>> (6 + 6 + 16 + 4)) & 63L)];
+
+            if ((queueValue & FLAG_RECHECK_LEVEL) != 0L) {
+                if (this.getLightLevel(posX, posY, posZ) != propagatedLightLevel) {
+                    // not at the level we expect, so something changed.
+                    continue;
+                }
+            } else if ((queueValue & FLAG_WRITE_LEVEL) != 0L) {
+                // these are used to restore block sources after a propagation decrease
+                this.setLightLevel(posX, posY, posZ, propagatedLightLevel);
+            }
+
+            // we don't need to worry about our state here.
+            for (final AxisDirection propagate : checkDirections) {
+                final int offX = posX + propagate.x;
+                final int offY = posY + propagate.y;
+                final int offZ = posZ + propagate.z;
+
+                final HalfByteArray3D currentNibble = this.getNibbleFromCache(offX >> 4, offY >> 4, offZ >> 4);
+                final int currentLevel;
+                if (currentNibble == null || (currentLevel = currentNibble.get(offX & 15, offY & 15, offZ & 15)) >= (propagatedLightLevel - 1)) {
+                    continue; // already at the level we want or unloaded
+                }
+
+                final int blockState = this.getBlockState(offX, offY, offZ);
+                final int opacityCached = Block.lightOpacity[blockState];
+
+                final int targetLevel = propagatedLightLevel - Math.max(1, opacityCached);
+                if (targetLevel > currentLevel) {
+                    currentNibble.set(offX & 15, offY & 15, offZ & 15, targetLevel);
+                    this.postLightUpdate(offX, offY, offZ);
+
+                    if (targetLevel > 1) {
+                        if (queueLength >= queue.length) {
+                            queue = this.resizeIncreaseQueue();
+                        }
+                        queue[queueLength++] =
+                                ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                        | ((targetLevel & 0xFL) << (6 + 6 + 16))
+                                        | (propagate.everythingButTheOppositeDirection << (6 + 6 + 16 + 4));
+                        continue;
+                    }
+                }
+            }
+        }
+    }
+
+    protected final void performLightDecrease(final World world) {
+        long[] queue = this.decreaseQueue;
+        long[] increaseQueue = this.increaseQueue;
+        int queueReadIndex = 0;
+        int queueLength = this.decreaseQueueInitialLength;
+        this.decreaseQueueInitialLength = 0;
+        int increaseQueueLength = this.increaseQueueInitialLength;
+        final int decodeOffsetX = -this.encodeOffsetX;
+        final int decodeOffsetY = -this.encodeOffsetY;
+        final int decodeOffsetZ = -this.encodeOffsetZ;
+        final int encodeOffset = this.coordinateOffset;
+        final int emittedMask = this.emittedLightMask;
+
+        while (queueReadIndex < queueLength) {
+            final long queueValue = queue[queueReadIndex++];
+
+            final int posX = ((int)queueValue & 63) + decodeOffsetX;
+            final int posZ = (((int)queueValue >>> 6) & 63) + decodeOffsetZ;
+            final int posY = (((int)queueValue >>> 12) & ((1 << 16) - 1)) + decodeOffsetY;
+            final int propagatedLightLevel = (int)((queueValue >>> (6 + 6 + 16)) & 0xF);
+            final AxisDirection[] checkDirections = OLD_CHECK_DIRECTIONS[(int)((queueValue >>> (6 + 6 + 16 + 4)) & 63)];
+
+            // we don't need to worry about our state here.
+            for (final AxisDirection propagate : checkDirections) {
+                final int offX = posX + propagate.x;
+                final int offY = posY + propagate.y;
+                final int offZ = posZ + propagate.z;
+
+                final HalfByteArray3D currentNibble = this.getNibbleFromCache(offX >> 4, offY >> 4, offZ >> 4);
+                final int lightLevel;
+
+                if (currentNibble == null || (lightLevel = currentNibble.get(offX & 15, offY & 15, offZ & 15)) == 0) {
+                    // already at lowest (or unloaded), nothing we can do
+                    continue;
+                }
+
+                final int blockState = this.getBlockState(offX, offY, offZ);
+                final int opacityCached = Block.lightOpacity[blockState];
+
+                final int targetLevel = Math.max(0, propagatedLightLevel - Math.max(1, opacityCached));
+                if (lightLevel > targetLevel) {
+                    // it looks like another source propagated here, so re-propagate it
+                    if (increaseQueueLength >= increaseQueue.length) {
+                        increaseQueue = this.resizeIncreaseQueue();
+                    }
+                    increaseQueue[increaseQueueLength++] =
+                            ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                    | ((lightLevel & 0xFL) << (6 + 6 + 16))
+                                    | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                    | FLAG_RECHECK_LEVEL;
+                    continue;
+                }
+                final int emittedLight = Block.lightValue[blockState] & emittedMask;
+                if (emittedLight != 0) {
+                    // re-propagate source
+                    // note: do not set recheck level, or else the propagation will fail
+                    if (increaseQueueLength >= increaseQueue.length) {
+                        increaseQueue = this.resizeIncreaseQueue();
+                    }
+                    increaseQueue[increaseQueueLength++] =
+                            ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                    | ((emittedLight & 0xFL) << (6 + 6 + 16))
+                                    | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                    | (FLAG_WRITE_LEVEL);
+                }
+
+                currentNibble.set(offX & 15, offY & 15, offZ & 15, 0);
+                this.postLightUpdate(offX, offY, offZ);
+
+                if (targetLevel > 0) { // we actually need to propagate 0 just in case we find a neighbour...
+                    if (queueLength >= queue.length) {
+                        queue = this.resizeDecreaseQueue();
+                    }
+                    queue[queueLength++] =
+                            ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                    | ((targetLevel & 0xFL) << (6 + 6 + 16))
+                                    | ((propagate.everythingButTheOppositeDirection) << (6 + 6 + 16 + 4));
+                    continue;
+                }
+                continue;
+            }
+        }
+
+        // propagate sources we clobbered
+        this.increaseQueueInitialLength = increaseQueueLength;
+        this.performLightIncrease(world);
+    }
+
+    public final void checkBlockEmittance(final int worldX, final int worldY, final int worldZ) {
+        this.setupCaches(this.world, worldX, worldY, worldZ, true);
+        try {
+            // blocks can change opacity
+            // blocks can change emitted light
+            // blocks can change direction of propagation
+
+            final int encodeOffset = this.coordinateOffset;
+            final int emittedMask = this.emittedLightMask;
+
+            final int currentLevel = this.getLightLevel(worldX, worldY, worldZ);
+            final int blockState = this.getBlockState(worldX, worldY, worldZ);
+            final int emittedLevel = Block.lightValue[blockState] & emittedMask;
+
+            this.setLightLevel(worldX, worldY, worldZ, emittedLevel);
+            // this accounts for change in emitted light that would cause an increase
+            if (emittedLevel != 0) {
+                this.appendToIncreaseQueue(
+                        ((worldX + (worldZ << 6) + (worldY << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                | (emittedLevel & 0xFL) << (6 + 6 + 16)
+                                | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                );
+            }
+            // this also accounts for a change in emitted light that would cause a decrease
+            // this also accounts for the change of direction of propagation (i.e old block was full transparent, new block is full opaque or vice versa)
+            // as it checks all neighbours (even if current level is 0)
+            this.appendToDecreaseQueue(
+                    ((worldX + (worldZ << 6) + (worldY << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                            | (currentLevel & 0xFL) << (6 + 6 + 16)
+                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                    // always keep sided transparent false here, new block might be conditionally transparent which would
+                    // prevent us from decreasing sources in the directions where the new block is opaque
+                    // if it turns out we were wrong to de-propagate the source, the re-propagate logic WILL always
+                    // catch that and fix it.
+            );
+            // re-propagating neighbours (done by the decrease queue) will also account for opacity changes in this block
+
+            this.performLightDecrease(this.world);
+        } finally {
+            this.destroyCaches();
+        }
+    }
+
+    public final void checkSkyEmittance(final int worldX, final int worldY, final int worldZ) {
+        this.setupCaches(this.world, worldX, worldY, worldZ, true);
+        try {
+            // try and propagate from the above y
+            // delay light set until after processing all sources to setup
+            final int maxPropagationY = this.tryPropagateSkylight(this.world, worldX, worldY, worldZ);
+
+            // maxPropagationY is now the highest block that could not be propagated to
+
+            // remove all sources below that are 15
+            final long propagateDirection = AxisDirection.POSITIVE_Y.everythingButThisDirection;
+            final int encodeOffset = this.coordinateOffset;
+
+            if (this.getLightLevel(worldX, maxPropagationY, worldZ) == 15) {
+                final Chunk chunk = this.getChunkInCache(worldX >> 4, worldZ >> 4);
+                int minY = chunk != null ? chunk.getMinLevel() << 4 : 0;
+
+                for (int currY = maxPropagationY; currY >= minY; --currY) {
+                    final HalfByteArray3D nibble = this.getNibbleFromCache(worldX >> 4, currY >> 4, worldZ >> 4);
+                    if (nibble == null || nibble.get(worldX & 15, currY & 15, worldZ & 15) != 15) {
+                        break;
+                    }
+
+                    this.appendToDecreaseQueue(
+                            ((worldX + (worldZ << 6) + (currY << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                    | (15L << (6 + 6 + 16))
+                                    | (propagateDirection << (6 + 6 + 16 + 4))
+                            // do not set transparent blocks for the same reason we don't in the checkBlock method
+                    );
+
+                    nibble.set(worldX & 15, currY & 15, worldZ & 15, 0);
+                }
+            }
+
+            // inlined checkBlock
+
+            // blocks can change opacity
+            // blocks can change direction of propagation
+
+            // same logic applies from BlockStarLightEngine#checkBlock
+
+            final int currentLevel = this.getLightLevel(worldX, worldY, worldZ);
+
+            if (currentLevel == 15) {
+                // must re-propagate clobbered source
+                this.appendToIncreaseQueue(
+                        ((worldX + (worldZ << 6) + (worldY << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                | (currentLevel & 0xFL) << (6 + 6 + 16)
+                                | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                | FLAG_HAS_SIDED_TRANSPARENT_BLOCKS // don't know if the block is conditionally transparent
+                );
+            } else {
+                this.setLightLevel(worldX, worldY, worldZ, 0);
+            }
+
+            this.appendToDecreaseQueue(
+                    ((worldX + (worldZ << 6) + (worldY << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                            | (currentLevel & 0xFL) << (6 + 6 + 16)
+                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+            );
+
+            this.performLightDecrease(this.world);
+        } finally {
+            this.destroyCaches();
+        }
+    }
+
+    // delaying the light set is useful for block changes since they need to worry about initialising nibblearrays
+    // while also queueing light at the same time (initialising nibblearrays might depend on nibbles above, so
+    // clobbering the light values will result in broken propagation)
+    protected final int tryPropagateSkylight(final World world, final int worldX, int startY, final int worldZ) {
+        final int encodeOffset = this.coordinateOffset;
+        final long propagateDirection = AxisDirection.POSITIVE_Y.everythingButThisDirection; // just don't check upwards.
+
+        if (this.getLightLevel(worldX, startY + 1, worldZ) != 15) {
+            return startY;
+        }
+
+        int above = this.getBlockState(worldX, startY + 1, worldZ);
+		Chunk chunk = this.getChunkInCache(worldX >> 4, worldZ >> 4);
+		int endY = chunk != null ? chunk.getMinLevel() << 4 : 0;
+
+        for (;startY >= endY; --startY) {
+            int current = this.getBlockState(worldX, startY, worldZ);
+
+            final int opacityIfCached = Block.lightOpacity[current];
+            // does light propagate from the top down?
+            if (opacityIfCached != 0) {
+                // we cannot propagate 15 through this
+                break;
+            }
+
+            // most of the time it falls here.
+            // add to propagate
+            // light set delayed until we determine if this nibble section is null
+            this.appendToIncreaseQueue(
+                    ((worldX + (worldZ << 6) + (startY << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                            | (15L << (6 + 6 + 16)) // we know we're at full lit here
+                            | (propagateDirection << (6 + 6 + 16 + 4))
+            );
+
+            above = current;
+
+            this.setLightLevel(worldX, startY, worldZ, 15);
+        }
+
+        return startY;
+    }
+
+    public final void initSkylight(final int chunkX, final int chunkZ) {
+        this.setupCaches(this.world, (chunkX << 4) | 7, 64, (chunkZ << 4) | 7, true);
+		Chunk chunk = this.getChunkInCache(chunkX, chunkZ);
+		int maxY = chunk != null ? (chunk.getMaxLevel() << 4) + 15 : 0;
+        try {
+            // now setup sources
+            final int worldChunkX = chunkX << 4;
+            final int worldChunkZ = chunkZ << 4;
+
+            for (int currZ = 0; currZ <= 15; ++currZ) {
+                for (int currX = 0; currX <= 15; ++currX) {
+                    final int worldX = currX | worldChunkX;
+                    final int worldZ = currZ | worldChunkZ;
+                    this.tryPropagateSkylight(this.world, worldX, maxY + 1, worldZ);
+                }
+            }
+
+            this.propagateNeighbourLevels(chunkX, chunkZ);
+
+            this.performLightIncrease(this.world);
+        } finally {
+            this.destroyCaches();
+        }
+    }
+
+    public final void initBlockLight(final int chunkX, final int chunkZ) {
+        this.setupCaches(this.world, (chunkX << 4) | 7, 64, (chunkZ << 4) | 7, true);
+        try {
+            if (this.world.dimension.isNether) {
+                final Chunk chunk = this.getChunkInCache(chunkX, chunkZ);
+                final int encodeOffset = this.coordinateOffset;
+
+                for (int y = chunk.getMinLevel() << 4; y <= (chunk.getMaxLevel() << 4) + 15; ++y) {
+	                final HalfByteArray3D nibble = this.getNibbleFromCache(chunkX, y >> 4, chunkZ);
+                    for (int z = 0; z <= 15; ++z) {
+                        for (int x = 0; x <= 15; ++x) {
+                            final int blockState = chunk.getBlockID(x, y, z);
+                            if (blockState == AIR_BLOCK_STATE) {
+                                continue;
+                            }
+                            final int emittedLight = Block.lightValue[blockState];
+
+                            if (emittedLight != 0) {
+                                nibble.set(x, y, z, emittedLight);
+                                this.appendToIncreaseQueue(
+                                        (((x | (chunkX << 4)) + ((z | (chunkZ << 4)) << 6) + (y << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                                | ((emittedLight & 0xFL) << (6 + 6 + 16))
+                                                | ((long)ALL_DIRECTIONS_BITSET << (6 + 6 + 16 + 4))
+                                                | FLAG_HAS_SIDED_TRANSPARENT_BLOCKS // don't know if the current block is transparent, must check.
+                                );
+                            }
+                        }
+                    }
+                }
+            }
+
+            this.propagateNeighbourLevels(chunkX, chunkZ);
+
+            this.performLightIncrease(this.world);
+        } finally {
+            this.destroyCaches();
+        }
+    }
+
+    protected final void propagateNeighbourLevels(final int chunkX, final int chunkZ) {
+		Chunk chunk = this.getChunkInCache(chunkX, chunkZ);
+		int maxLevel = chunk != null ? chunk.getMaxLevel() : 7;
+
+        for (int currSectionY = maxLevel; currSectionY >= 0; --currSectionY) {
+            for (final AxisDirection direction : ONLY_HORIZONTAL_DIRECTIONS) {
+                final int neighbourOffX = direction.x;
+                final int neighbourOffY = direction.y;
+                final int neighbourOffZ = direction.z;
+
+                final HalfByteArray3D neighbourNibble = this.getNibbleFromCache(chunkX + neighbourOffX,
+                        currSectionY + neighbourOffY, chunkZ + neighbourOffZ);
+
+                if (neighbourNibble == null) {
+                    // can't pull from 0
+                    continue;
+                }
+
+                // neighbour chunk
+                final int incX;
+                final int incZ;
+                final int startX;
+                final int startZ;
+
+                if (neighbourOffX != 0) {
+                    // x direction
+                    incX = 0;
+                    incZ = 1;
+
+                    if (direction.x < 0) {
+                        // negative
+                        startX = (chunkX << 4) - 1;
+                    } else {
+                        startX = (chunkX << 4) + 16;
+                    }
+                    startZ = chunkZ << 4;
+                } else {
+                    // z direction
+                    incX = 1;
+                    incZ = 0;
+
+                    if (neighbourOffZ < 0) {
+                        // negative
+                        startZ = (chunkZ << 4) - 1;
+                    } else {
+                        startZ = (chunkZ << 4) + 16;
+                    }
+                    startX = chunkX << 4;
+                }
+
+                final long propagateDirection = 1L << direction.getOpposite().ordinal(); // we only want to check in this direction towards this chunk
+                final int encodeOffset = this.coordinateOffset;
+
+                for (int currY = currSectionY << 4, maxY = currY | 15; currY <= maxY; ++currY) {
+                    for (int i = 0, currX = startX, currZ = startZ; i < 16; ++i, currX += incX, currZ += incZ) {
+                        final int level = neighbourNibble.get(currX & 15, currY & 15, currZ & 15);
+
+                        if (level <= 1) {
+                            // nothing to propagate
+                            continue;
+                        }
+
+                        this.appendToIncreaseQueue(
+                                ((currX + (currZ << 6) + (currY << (6 + 6)) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
+                                        | ((level & 0xFL) << (6 + 6 + 16))
+                                        | (propagateDirection << (6 + 6 + 16 + 4))
+                                        | FLAG_HAS_SIDED_TRANSPARENT_BLOCKS // don't know if the current block is transparent, must check.
+                        );
+                    }
+                }
+            }
+        }
+    }
+}
--- net/minecraft/network/packet/Packet.java
+++ net/minecraft/network/packet/Packet.java
@@ -5,35 +5,39 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import net.minecraft.network.NetHandler;
 
 public abstract class Packet {
-	private static Map packetIdToClassMap = new HashMap();
-	private static Map packetClassToIdMap = new HashMap();
-	private static Set clientPacketIdList = new HashSet();
-	private static Set serverPacketIdList = new HashSet();
+	private static final Int2ObjectMap<Class<? extends Packet>> packetIdToClassMap = new Int2ObjectOpenHashMap<>();
+	private static final Object2IntMap<Class<? extends Packet>> packetClassToIdMap = new Object2IntOpenHashMap<>();
+	private static final IntSet clientPacketIdList = new IntOpenHashSet();
+	private static final IntSet serverPacketIdList = new IntOpenHashSet();
 	public final long creationTimeMillis = System.currentTimeMillis();
 	public boolean isChunkDataPacket = false;
 	private static HashMap packetStats;
 	private static int totalPacketsCount;
 
-	static void addIdClassMapping(int var0, boolean var1, boolean var2, Class var3) {
-		if(packetIdToClassMap.containsKey(Integer.valueOf(var0))) {
+	static void addIdClassMapping(int var0, boolean var1, boolean var2, Class<? extends Packet> var3) {
+		if(packetIdToClassMap.containsKey(var0)) {
 			throw new IllegalArgumentException("Duplicate packet id:" + var0);
 		} else if(packetClassToIdMap.containsKey(var3)) {
 			throw new IllegalArgumentException("Duplicate packet class:" + var3);
 		} else {
-			packetIdToClassMap.put(Integer.valueOf(var0), var3);
-			packetClassToIdMap.put(var3, Integer.valueOf(var0));
+			packetIdToClassMap.put(var0, var3);
+			packetClassToIdMap.put(var3, var0);
 			if(var1) {
-				clientPacketIdList.add(Integer.valueOf(var0));
+				clientPacketIdList.add(var0);
 			}
 
 			if(var2) {
-				serverPacketIdList.add(Integer.valueOf(var0));
+				serverPacketIdList.add(var0);
 			}
 
 		}
@@ -41,8 +45,8 @@
 
 	public static Packet getNewPacket(int var0) {
 		try {
-			Class var1 = (Class)packetIdToClassMap.get(Integer.valueOf(var0));
-			return var1 == null ? null : (Packet)var1.newInstance();
+			Class<? extends Packet> var1 = packetIdToClassMap.get(var0);
+			return var1 == null ? null : var1.newInstance();
 		} catch (Exception var2) {
 			var2.printStackTrace();
 			System.out.println("Skipping packet with id " + var0);
@@ -51,7 +55,7 @@
 	}
 
 	public final int getPacketId() {
-		return ((Integer)packetClassToIdMap.get(this.getClass())).intValue();
+		return packetClassToIdMap.getInt(this.getClass());
 	}
 
 	public static Packet readPacket(DataInputStream var0, boolean var1) throws IOException {
@@ -65,7 +69,7 @@
 				return null;
 			}
 
-			if(var1 && !serverPacketIdList.contains(Integer.valueOf(var6)) || !var1 && !clientPacketIdList.contains(Integer.valueOf(var6))) {
+			if(var1 && !serverPacketIdList.contains(var6) || !var1 && !clientPacketIdList.contains(var6)) {
 				throw new IOException("Bad packet id " + var6);
 			}
 
@@ -80,10 +84,10 @@
 			return null;
 		}
 
-		PacketCounter var4 = (PacketCounter)packetStats.get(Integer.valueOf(var6));
+		PacketCounter var4 = (PacketCounter)packetStats.get(var6);
 		if(var4 == null) {
 			var4 = new PacketCounter((PacketConstants)null);
-			packetStats.put(Integer.valueOf(var6), var4);
+			packetStats.put(var6, var4);
 		}
 
 		var4.addPacket(var3.getPacketSize());
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/IndexBuffer.java
@@ -1,0 +1,91 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import net.minecraft.util.MathHelper;
+import org.lwjgl.opengl.GL15;
+
+import java.nio.ByteBuffer;
+import java.util.function.IntConsumer;
+
+public final class IndexBuffer {
+    private static final IndexBuffer sharedSequential = new IndexBuffer(1, 1, IntConsumer::accept);
+    private static final IndexBuffer sharedSequentialQuad = new IndexBuffer(4, 6, (intConsumer, i) -> {
+        intConsumer.accept(i);
+        intConsumer.accept(i + 1);
+        intConsumer.accept(i + 2);
+        intConsumer.accept(i + 2);
+        intConsumer.accept(i + 3);
+        intConsumer.accept(i);
+    });
+    private static final IndexBuffer sharedSequentialLines = new IndexBuffer(4, 6, (intConsumer, i) -> {
+        intConsumer.accept(i);
+        intConsumer.accept(i + 1);
+        intConsumer.accept(i + 2);
+        intConsumer.accept(i + 3);
+        intConsumer.accept(i + 2);
+        intConsumer.accept(i + 1);
+    });
+
+    public static IndexBuffer getSequentialBuffer(VertexFormat.DrawMode drawMode) {
+        switch (drawMode) {
+            case QUADS: return sharedSequentialQuad;
+            case LINES: return sharedSequentialLines;
+            default: return sharedSequential;
+        }
+    }
+
+    private final int sizeMultiplier;
+    private final int increment;
+    private final IndexMapper indexMapper;
+    private int id;
+    private VertexFormat.IndexType indexType = VertexFormat.IndexType.BYTE;
+    private int size;
+
+    IndexBuffer(int sizeMultiplier, int increment, IndexMapper indexMapper) {
+        this.sizeMultiplier = sizeMultiplier;
+        this.increment = increment;
+        this.indexMapper = indexMapper;
+    }
+
+    public boolean isSizeLessThanOrEqual(int size) {
+        return size <= this.size;
+    }
+
+    public void bindAndGrow(int newSize) {
+        if (this.id == 0) this.id = GL15.glGenBuffers();
+        GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, this.id);
+        this.grow(newSize);
+    }
+
+    private void grow(int newSize) {
+        if (this.isSizeLessThanOrEqual(newSize)) return;
+        newSize = MathHelper.roundUpToMultiple(newSize * 2, this.increment);
+//        System.out.printf("Growing IndexBuffer: Old limit %s, new limit %s.%n", this.size, newSize);
+        VertexFormat.IndexType indexType = VertexFormat.IndexType.smallestFor(newSize);
+        int i = MathHelper.roundUpToMultiple(newSize * indexType.size, 4);
+        GL15.glBufferData(GL15.GL_ELEMENT_ARRAY_BUFFER, i, GL15.GL_DYNAMIC_DRAW);
+        ByteBuffer byteBuffer = GL15.glMapBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, GL15.GL_WRITE_ONLY, null);
+        if (byteBuffer == null) throw new RuntimeException("Failed to map GL buffer");
+        this.indexType = indexType;
+        IntConsumer intConsumer = this.getIndexConsumer(byteBuffer);
+        for (int j = 0; j < newSize; j += this.increment)
+            this.indexMapper.accept(intConsumer, j * this.sizeMultiplier / this.increment);
+        GL15.glUnmapBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER);
+        this.size = newSize;
+    }
+
+    private IntConsumer getIndexConsumer(ByteBuffer indicesBuffer) {
+        switch (this.indexType) {
+            case BYTE: return index -> indicesBuffer.put((byte) index);
+            case SHORT: return index -> indicesBuffer.putShort((short) index);
+            default: return indicesBuffer::putInt;
+        }
+    }
+
+    public VertexFormat.IndexType getIndexType() {
+        return this.indexType;
+    }
+
+    interface IndexMapper {
+        void accept(IntConsumer var1, int var2);
+    }
+}
--- net/minecraft/client/Session.java
+++ net/minecraft/client/Session.java
@@ -2,10 +2,15 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.block.Block;
 
 public class Session {
 	public static List registeredBlocksList = new ArrayList();
+	public static ItemStack[] hotbarList = new ItemStack[9];
+	public static boolean betaBlocks = true;
 	public String username;
 	public String sessionId;
 	public String mpPassParameter;
@@ -16,33 +21,135 @@
 	}
 
 	static {
-		registeredBlocksList.add(Block.stone);
-		registeredBlocksList.add(Block.cobblestone);
-		registeredBlocksList.add(Block.brick);
-		registeredBlocksList.add(Block.dirt);
-		registeredBlocksList.add(Block.planks);
-		registeredBlocksList.add(Block.log);
-		registeredBlocksList.add(Block.leaves);
-		registeredBlocksList.add(Block.torch);
-		registeredBlocksList.add(Block.stoneSlab);
-		registeredBlocksList.add(Block.glass);
-		registeredBlocksList.add(Block.mossyCobblestone);
-		registeredBlocksList.add(Block.sapling);
-		registeredBlocksList.add(Block.flower);
-		registeredBlocksList.add(Block.rose);
-		registeredBlocksList.add(Block.brownMushroom);
-		registeredBlocksList.add(Block.redMushroom);
-		registeredBlocksList.add(Block.sand);
-		registeredBlocksList.add(Block.gravel);
-		registeredBlocksList.add(Block.sponge);
-		registeredBlocksList.add(Block.wool);
-		registeredBlocksList.add(Block.coalOre);
-		registeredBlocksList.add(Block.ironOre);
-		registeredBlocksList.add(Block.goldOre);
-		registeredBlocksList.add(Block.ironBlock);
-		registeredBlocksList.add(Block.goldBlock);
-		registeredBlocksList.add(Block.bookshelf);
-		registeredBlocksList.add(Block.tnt);
-		registeredBlocksList.add(Block.obsidian);
+		hotbarList[0] = new ItemStack(Block.stone, 1, 0);
+		hotbarList[1] = new ItemStack(Block.cobblestone, 1, 0);
+		hotbarList[2] = new ItemStack(Block.brick, 1, 0);
+		hotbarList[3] = new ItemStack(Block.dirt, 1, 0);
+		hotbarList[4] = new ItemStack(Block.planks, 1, 0);
+		hotbarList[5] = new ItemStack(Block.log, 1, 0);
+		hotbarList[6] = new ItemStack(Block.leaves, 1, 0);
+		hotbarList[7] = new ItemStack(Block.torch, 1, 0);
+		hotbarList[8] = new ItemStack(Block.stoneSlab, 1, 0);
+
+		registeredBlocksList.add(new ItemStack(Block.stone, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.cobblestone, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.brick, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.dirt, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.planks, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.log, 1, 0));
+		if(betaBlocks) {
+			registeredBlocksList.add(new ItemStack(Block.log, 1, 1));
+			registeredBlocksList.add(new ItemStack(Block.log, 1, 2));
+		}
+		registeredBlocksList.add(new ItemStack(Block.leaves, 1, 0));
+		if(betaBlocks) {
+			registeredBlocksList.add(new ItemStack(Block.leaves, 1, 1));
+			registeredBlocksList.add(new ItemStack(Block.leaves, 1, 2));
+		}
+		registeredBlocksList.add(new ItemStack(Block.torch, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.stoneSlab, 1, 0));
+		if(betaBlocks) {
+			registeredBlocksList.add(new ItemStack(Block.stoneSlab, 1, 1));
+			registeredBlocksList.add(new ItemStack(Block.stoneSlab, 1, 2));
+			registeredBlocksList.add(new ItemStack(Block.stoneSlab, 1, 3));
+		}
+		registeredBlocksList.add(new ItemStack(Block.woodenStairs, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.cobblestoneStairs, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.glass, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.mossyCobblestone, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.sapling, 1, 0));
+		if(betaBlocks) {
+			registeredBlocksList.add(new ItemStack(Block.sapling, 1, 1));
+			registeredBlocksList.add(new ItemStack(Block.sapling, 1, 2));
+		}
+		registeredBlocksList.add(new ItemStack(Block.flower, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.rose, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.brownMushroom, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.redMushroom, 1, 0));
+		if(betaBlocks) registeredBlocksList.add(new ItemStack(Block.web, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.sand, 1, 0));
+		if(betaBlocks) registeredBlocksList.add(new ItemStack(Block.sandstone, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.gravel, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.clayBlock, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.snow, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.ice, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.sponge, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 1));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 2));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 3));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 4));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 5));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 6));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 7));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 8));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 9));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 10));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 11));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 12));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 13));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 14));
+		registeredBlocksList.add(new ItemStack(Block.wool, 1, 15));
+		registeredBlocksList.add(new ItemStack(Block.coalOre, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.ironOre, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.goldOre, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.diamondOre, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.redstoneOre, 1, 0));
+		if(betaBlocks) registeredBlocksList.add(new ItemStack(Block.lapisOre, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.ironBlock, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.goldBlock, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.diamondBlock, 1, 0));
+		if(betaBlocks) registeredBlocksList.add(new ItemStack(Block.lapisBlock, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.bookshelf, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.workbench, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.furnace, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.chest, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.painting, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.sign, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.ladder, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.fence, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.door, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.ironDoor, 1, 0));
+		if (betaBlocks) registeredBlocksList.add(new ItemStack(Block.trapdoor, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.lever, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.button, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.woodenPressurePlate, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.stonePressurePlate, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.redstone, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.redstoneTorchOn, 1, 0));
+		if(betaBlocks) {
+			registeredBlocksList.add(new ItemStack(Item.redstoneRepeater, 1, 0));
+			registeredBlocksList.add(new ItemStack(Block.dispenser, 1, 0));
+			registeredBlocksList.add(new ItemStack(Block.piston, 1, 0));
+			registeredBlocksList.add(new ItemStack(Block.stickyPiston, 1, 0));
+		}
+		registeredBlocksList.add(new ItemStack(Block.tnt, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.obsidian, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.jukebox, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.disc13, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.discCat, 1, 0));
+		registeredBlocksList.add(new ItemStack(Block.farmland, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.seeds, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.sugarCane, 1, 0));
+		if(betaBlocks) {
+			registeredBlocksList.add(new ItemStack(Block.pumpkin, 1, 0));
+			registeredBlocksList.add(new ItemStack(Block.jackOLantern, 1, 0));
+			registeredBlocksList.add(new ItemStack(Item.cake, 1, 0));
+			registeredBlocksList.add(new ItemStack(Item.dye, 1, 0));
+		}
+		registeredBlocksList.add(new ItemStack(Block.rail, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.minecart, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.minecartWithChest, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.minecartWithFurnace, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.boat, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.flintAndSteel, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.emptyBucket, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.waterBucket, 1, 0));
+		registeredBlocksList.add(new ItemStack(Item.lavaBucket, 1, 0));
+		if(betaBlocks) {
+			registeredBlocksList.add(new ItemStack(Block.netherrack, 1, 0));
+			registeredBlocksList.add(new ItemStack(Block.soulSand, 1, 0));
+			registeredBlocksList.add(new ItemStack(Block.glowstone, 1, 0));
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/LayeredBiomeSource.java
@@ -1,0 +1,65 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.layers.Layer;
+import net.minecraft.util.IntArray2D;
+
+public class LayeredBiomeSource extends BiomeSource {
+	private final Layer biomeLayer;
+	private final Layer oceanLayer;
+	private final Layer edgeLayer;
+	private final Layer[] colorLayers = new Layer[BiomeColorType.values().length];
+
+	public LayeredBiomeSource(World world) {
+		Layer[] layers = Layer.getLayerArray(world);
+		this.biomeLayer = layers[0];
+		this.oceanLayer = layers[1];
+		this.edgeLayer = layers[2];
+		for (int i = 0; i < colorLayers.length; i++) {
+			this.colorLayers[i] = layers[i + 3];
+		}
+	}
+
+	public int[] loadColorData(int[] colors, int x, int z, int width, int length, BiomeColorType type) {
+		if(colors == null || colors.length < width * length) {
+			colors = new int[width * length];
+		}
+
+		IntArray2D colorData = this.colorLayers[type.ordinal()].getCachedData(x, z, width, length);
+		System.arraycopy(colorData.toYFirst().getArray(), 0, colors, 0, width * length);
+		return colors;
+	}
+
+	public int[] loadEdgeData(int[] edge, int x, int z, int width, int length) {
+		if(edge == null || edge.length < width * length) {
+			edge = new int[width * length];
+		}
+
+		IntArray2D edgeData = this.edgeLayer.getCachedData(x, z, width, length);
+		System.arraycopy(edgeData.toYFirst().getArray(), 0, edge, 0, width * length);
+		return edge;
+	}
+
+	public int[] loadOceanData(int[] ocean, int x, int z, int width, int length) {
+		if(ocean == null || ocean.length < width * length) {
+			ocean = new int[width * length];
+		}
+
+		IntArray2D oceanData = this.oceanLayer.getCachedData(x, z, width, length);
+		System.arraycopy(oceanData.toYFirst().getArray(), 0, ocean, 0, width * length);
+		return ocean;
+	}
+
+	public Biome[] loadBlockGeneratorData(Biome[] biomes, int x, int z, int width, int length) {
+		if(biomes == null || biomes.length < width * length) {
+			biomes = new Biome[width * length];
+		}
+
+		int[] biomeInts = this.biomeLayer.getCachedData(x, z, width, length).toYFirst().getArray();
+		for (int i = 0; i < width * length; i++) {
+			biomes[i] = Biome.biomeIndex[biomeInts[i]];
+		}
+
+		return biomes;
+	}
+}
--- net/minecraft/client/gui/stats/StatsSlot.java
+++ net/minecraft/client/gui/stats/StatsSlot.java
@@ -35,8 +35,8 @@
 		return false;
 	}
 
-	protected void drawBackground() {
-		this.field_27269_g.drawDefaultBackground();
+	protected void drawBackground(float var3) {
+		this.field_27269_g.drawDefaultBackground(var3);
 	}
 
 	protected void func_27260_a(int var1, int var2, Tessellator var3) {
@@ -144,7 +144,7 @@
 					var5 = this.func_27263_a(2);
 				}
 
-				var5 = ("" + StringTranslate.getInstance().translateKey(var5)).trim();
+				var5 = (StringTranslate.getInstance().translateKey(var5)).trim();
 				if(var5.length() > 0) {
 					int var6 = var1 + 12;
 					int var7 = var2 - 12;
@@ -160,7 +160,7 @@
 	protected void func_27267_a(StatCrafting var1, int var2, int var3) {
 		if(var1 != null) {
 			Item var4 = Item.itemsList[var1.getItem()];
-			String var5 = ("" + StringTranslate.getInstance().translateNamedKey(var4.getName())).trim();
+			String var5 = (StringTranslate.getInstance().translateNamedKey(var4.getName())).trim();
 			if(var5.length() > 0) {
 				int var6 = var2 + 12;
 				int var7 = var3 - 12;
--- net/minecraft/game/world/material/Material.java
+++ net/minecraft/game/world/material/Material.java
@@ -1,42 +1,44 @@
 package net.minecraft.game.world.material;
 
+import net.minecraft.game.item.ToolType;
 import net.minecraft.game.world.map.MapColor;
 
 public class Material {
 	public static final Material air = new MaterialTransparent(MapColor.airColor);
-	public static final Material grass = new Material(MapColor.grassColor);
-	public static final Material ground = new Material(MapColor.dirtColor);
-	public static final Material wood = (new Material(MapColor.woodColor)).setBurning();
-	public static final Material stone = (new Material(MapColor.stoneColor)).setNoHarvest();
-	public static final Material iron = (new Material(MapColor.ironColor)).setNoHarvest();
+	public static final Material grass = new Material(MapColor.grassColor).setEffectiveTool(ToolType.SHOVEL);
+	public static final Material ground = new Material(MapColor.dirtColor).setEffectiveTool(ToolType.SHOVEL);
+	public static final Material wood = (new Material(MapColor.woodColor)).setBurning().setEffectiveTool(ToolType.AXE);
+	public static final Material stone = (new Material(MapColor.stoneColor)).setNoHarvest().setEffectiveTool(ToolType.PICKAXE);
+	public static final Material iron = (new Material(MapColor.ironColor)).setNoHarvest().setEffectiveTool(ToolType.PICKAXE);
 	public static final Material water = (new MaterialLiquid(MapColor.waterColor)).setNoPushMobility();
 	public static final Material lava = (new MaterialLiquid(MapColor.tntColor)).setNoPushMobility();
-	public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setIsTranslucent().setNoPushMobility();
+	public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setIsTranslucent().setNoPushMobility().setEffectiveTool(ToolType.AXE);
 	public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility();
 	public static final Material sponge = new Material(MapColor.clothColor);
-	public static final Material cloth = (new Material(MapColor.clothColor)).setBurning();
+	public static final Material cloth = (new Material(MapColor.clothColor)).setBurning().setEffectiveTool(ToolType.SHEARS);
 	public static final Material fire = (new MaterialTransparent(MapColor.airColor)).setNoPushMobility();
-	public static final Material sand = new Material(MapColor.sandColor);
+	public static final Material sand = new Material(MapColor.sandColor).setEffectiveTool(ToolType.SHOVEL);
 	public static final Material circuits = (new MaterialLogic(MapColor.airColor)).setNoPushMobility();
-	public static final Material glass = (new Material(MapColor.airColor)).setIsTranslucent();
+	public static final Material glass = (new Material(MapColor.airColor)).setIsTranslucent().setEffectiveTool(ToolType.PICKAXE);
 	public static final Material tnt = (new Material(MapColor.tntColor)).setBurning().setIsTranslucent();
 	public static final Material wug = (new Material(MapColor.foliageColor)).setNoPushMobility();
-	public static final Material ice = (new Material(MapColor.iceColor)).setIsTranslucent();
-	public static final Material snow = (new MaterialLogic(MapColor.snowColor)).setIsGroundCover().setIsTranslucent().setNoHarvest().setNoPushMobility();
-	public static final Material builtSnow = (new Material(MapColor.snowColor)).setNoHarvest();
+	public static final Material ice = (new Material(MapColor.iceColor)).setIsTranslucent().setEffectiveTool(ToolType.PICKAXE);
+	public static final Material snow = (new MaterialLogic(MapColor.snowColor)).setIsGroundCover().setIsTranslucent().setNoHarvest().setNoPushMobility().setEffectiveTool(ToolType.SHOVEL);
+	public static final Material builtSnow = (new Material(MapColor.snowColor)).setNoHarvest().setEffectiveTool(ToolType.SHOVEL);
 	public static final Material cactus = (new Material(MapColor.foliageColor)).setIsTranslucent().setNoPushMobility();
-	public static final Material clay = new Material(MapColor.clayColor);
-	public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility();
+	public static final Material clay = new Material(MapColor.clayColor).setEffectiveTool(ToolType.SHOVEL);
+	public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility().setEffectiveTool(ToolType.AXE);
 	public static final Material portal = (new MaterialPortal(MapColor.airColor)).setImmovableMobility();
 	public static final Material cakeMaterial = (new Material(MapColor.airColor)).setNoPushMobility();
-	public static final Material web = (new Material(MapColor.clothColor)).setNoHarvest().setNoPushMobility();
-	public static final Material piston = (new Material(MapColor.stoneColor)).setImmovableMobility();
+	public static final Material web = (new Material(MapColor.clothColor)).setNoHarvest().setNoPushMobility().setEffectiveTool(ToolType.SWORD);
+	public static final Material piston = (new Material(MapColor.stoneColor)).setImmovableMobility().setEffectiveTool(ToolType.PICKAXE);
 	private boolean canBurn;
 	private boolean groundCover;
 	private boolean isTranslucent;
 	public final MapColor materialMapColor;
 	private boolean canHarvest = true;
 	private int mobilityFlag;
+	private ToolType effectiveTool;
 
 	public Material(MapColor var1) {
 		this.materialMapColor = var1;
@@ -77,7 +79,7 @@
 		return this.canBurn;
 	}
 
-	public Material setIsGroundCover() {
+	protected Material setIsGroundCover() {
 		this.groundCover = true;
 		return this;
 	}
@@ -106,5 +108,14 @@
 	protected Material setImmovableMobility() {
 		this.mobilityFlag = 2;
 		return this;
+	}
+
+	private Material setEffectiveTool(ToolType effectiveTool) {
+		this.effectiveTool = effectiveTool;
+		return this;
+	}
+
+	public ToolType getEffectiveTool() {
+		return this.effectiveTool;
 	}
 }
--- net/minecraft/game/world/block/SlabBlock.java
+++ net/minecraft/game/world/block/SlabBlock.java
@@ -1,26 +1,80 @@
 package net.minecraft.game.world.block;
 
+import java.util.ArrayList;
 import java.util.Random;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.SlabItem;
+import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.IntProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.material.Material;
 
 public class SlabBlock extends Block {
 	public static final String[] slabNames = new String[]{"stone", "sand", "wood", "cobble"};
+	public static final IntProperty TYPE = new IntProperty("type", 7);
+	public static final BooleanProperty HALF = new BooleanProperty("half", "top", "bottom");
+
 	private boolean doubleSlab;
-
-	public SlabBlock(int var1, boolean var2) {
-		super(var1, 6, Material.stone);
-		this.doubleSlab = var2;
-		if(!var2) {
+	protected final ModelBlock[] slabTypes;
+
+	public SlabBlock(int var1, Material var2, boolean var3, ModelBlock[] var4) {
+		super(var1, 6, var2);
+		if (var4.length > 128) {
+			throw new IllegalArgumentException("Too many slab types! 128 maximum!");
+		}
+
+		this.slabTypes = var4;
+		this.doubleSlab = var3;
+		this.textureIndex = var4[0].topTexture;
+		if(!var3) {
 			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+			this.setSpecialLighting();
 		}
 
 		this.setLightOpacity(255);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(TYPE, HALF);
+	}
+
+	protected Item getItem() {
+		return this.doubleSlab ? super.getItem() : new SlabItem(this, (SlabBlock)Block.blocksList[this.blockID - 1]);
+	}
+
+	public void setBlockBoundsBasedOnState(BlockAccess var1, int var2, int var3, int var4) {
+		if (this.doubleSlab) {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else if (var1.getBlockBooleanProperty(var2, var3, var4, HALF)) {
+			this.setBlockBounds(0.0F, 0.5F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+		}
+	}
+
+	public void setBlockBoundsForItemRender() {
+		if (this.doubleSlab) {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+		}
+	}
+
+	public void getCollidingBoundingBoxes(World var1, int var2, int var3, int var4, AxisAlignedBB var5, ArrayList var6) {
+		this.setBlockBoundsBasedOnState(var1, var2, var3, var4);
+		super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
+	}
+
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return var2 == 0 ? (var1 <= 1 ? 6 : 5) : (var2 == 1 ? (var1 == 0 ? 208 : (var1 == 1 ? 176 : 192)) : (var2 == 2 ? 4 : (var2 == 3 ? 16 : 6)));
+		int type = this.properties.getInt(var2, TYPE);
+		if (type < slabTypes.length) {
+			return slabTypes[type].getTextureFromSide(var1);
+		}
+		return var1 <= 1 ? 14 : 13;
 	}
 
 	public int getBlockTextureFromSide(int var1) {
@@ -31,25 +85,14 @@
 		return this.doubleSlab;
 	}
 
-	public void onBlockAdded(World var1, int var2, int var3, int var4) {
-		if(this != Block.stoneSlab) {
-			super.onBlockAdded(var1, var2, var3, var4);
-		}
-
-		int var5 = var1.getBlockId(var2, var3 - 1, var4);
-		int var6 = var1.getBlockMetadata(var2, var3, var4);
-		int var7 = var1.getBlockMetadata(var2, var3 - 1, var4);
-		if(var6 == var7) {
-			if(var5 == stoneSlab.blockID) {
-				var1.setBlockWithNotify(var2, var3, var4, 0);
-				var1.setBlockAndMetadataWithNotify(var2, var3 - 1, var4, Block.doubleStoneSlab.blockID, var6);
-			}
-
+	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+		if (!this.doubleSlab && var5 == 0) {
+			var1.setBlockProperty(var2, var3, var4, HALF, true);
 		}
 	}
 
 	public int idDropped(int var1, Random var2) {
-		return Block.stoneSlab.blockID;
+		return this.doubleSlab ? this.blockID + 1 : this.blockID;
 	}
 
 	public int quantityDropped(Random var1) {
@@ -57,7 +100,7 @@
 	}
 
 	protected int damageDropped(int var1) {
-		return var1;
+		return TYPE.getIntValue(var1);
 	}
 
 	public boolean renderAsNormalBlock() {
@@ -65,10 +108,25 @@
 	}
 
 	public boolean shouldSideBeRendered(BlockAccess var1, int var2, int var3, int var4, int var5) {
-		if(this != Block.stoneSlab) {
-			super.shouldSideBeRendered(var1, var2, var3, var4, var5);
-		}
-
-		return var5 == 1 ? true : (!super.shouldSideBeRendered(var1, var2, var3, var4, var5) ? false : (var5 == 0 ? true : var1.getBlockId(var2, var3, var4) != this.blockID));
-	}
+        if (this.doubleSlab) {
+            return super.shouldSideBeRendered(var1, var2, var3, var4, var5);
+        } else if (var5 != 1 && var5 != 0 && !super.shouldSideBeRendered(var1, var2, var3, var4, var5)) {
+            return false;
+        } else {
+			Direction dir = Direction.fromId(var5);
+            int var6 = var2 + dir.getOpposite().X;
+            int var7 = var3 + dir.getOpposite().Y;
+            int var8 = var4 + dir.getOpposite().Z;
+            boolean var9 = var1.getBlockBooleanProperty(var6, var7, var8, HALF);
+            return var9
+                    ? var5 == 0
+		                    || var5 == 1 && super.shouldSideBeRendered(var1, var2, var3, var4, var5)
+		                    || !(var1.getBlock(var2, var3, var4) instanceof SlabBlock)
+		                    || !var1.getBlockBooleanProperty(var2, var3, var4, HALF)
+                    : var5 == 1
+		                    || var5 == 0 && super.shouldSideBeRendered(var1, var2, var3, var4, var5)
+		                    || !(var1.getBlock(var2, var3, var4) instanceof SlabBlock)
+		                    || var1.getBlockBooleanProperty(var2, var3, var4, HALF);
+        }
+    }
 }
--- net/minecraft/client/ImageBufferDownload.java
+++ net/minecraft/client/ImageBufferDownload.java
@@ -11,45 +11,42 @@
 	private int imageHeight;
 
 	public BufferedImage parseUserSkin(BufferedImage var1) {
-		if(var1 == null) {
+		if (var1 == null) {
 			return null;
 		} else {
 			this.imageWidth = 64;
-			this.imageHeight = 32;
-			BufferedImage var2 = new BufferedImage(this.imageWidth, this.imageHeight, 2);
-			Graphics var3 = var2.getGraphics();
-			var3.drawImage(var1, 0, 0, (ImageObserver)null);
-			var3.dispose();
-			this.imageData = ((DataBufferInt)var2.getRaster().getDataBuffer()).getData();
+			this.imageHeight = 64;
+			BufferedImage buffer = new BufferedImage(this.imageWidth, this.imageHeight, 2);
+			Graphics g = buffer.getGraphics();
+			g.drawImage(var1, 0, 0, (ImageObserver)null);
+
+			if (var1.getHeight() == 32) {
+				g.drawImage(buffer, 24, 48, 20, 52, 4, 16, 8, 20, (ImageObserver)null);
+				g.drawImage(buffer, 28, 48, 24, 52, 8, 16, 12, 20, (ImageObserver)null);
+				g.drawImage(buffer, 20, 52, 16, 64, 8, 20, 12, 32, (ImageObserver)null);
+				g.drawImage(buffer, 24, 52, 20, 64, 4, 20, 8, 32, (ImageObserver)null);
+				g.drawImage(buffer, 28, 52, 24, 64, 0, 20, 4, 32, (ImageObserver)null);
+				g.drawImage(buffer, 32, 52, 28, 64, 12, 20, 16, 32, (ImageObserver)null);
+				g.drawImage(buffer, 40, 48, 36, 52, 44, 16, 48, 20, (ImageObserver)null);
+				g.drawImage(buffer, 44, 48, 40, 52, 48, 16, 52, 20, (ImageObserver)null);
+				g.drawImage(buffer, 36, 52, 32, 64, 48, 20, 52, 32, (ImageObserver)null);
+				g.drawImage(buffer, 40, 52, 36, 64, 44, 20, 48, 32, (ImageObserver)null);
+				g.drawImage(buffer, 44, 52, 40, 64, 40, 20, 44, 32, (ImageObserver)null);
+				g.drawImage(buffer, 48, 52, 44, 64, 52, 20, 56, 32, (ImageObserver)null);
+			}
+
+			g.dispose();
+			this.imageData = ((DataBufferInt)buffer.getRaster().getDataBuffer()).getData();
 			this.func_884_b(0, 0, 32, 16);
 			this.func_885_a(32, 0, 64, 32);
 			this.func_884_b(0, 16, 64, 32);
-			boolean var4 = false;
-
-			int var5;
-			int var6;
-			int var7;
-			for(var5 = 32; var5 < 64; ++var5) {
-				for(var6 = 0; var6 < 16; ++var6) {
-					var7 = this.imageData[var5 + var6 * 64];
-					if((var7 >> 24 & 255) < 128) {
-						var4 = true;
-					}
-				}
-			}
-
-			if(!var4) {
-				for(var5 = 32; var5 < 64; ++var5) {
-					for(var6 = 0; var6 < 16; ++var6) {
-						var7 = this.imageData[var5 + var6 * 64];
-						if((var7 >> 24 & 255) < 128) {
-							var4 = true;
-						}
-					}
-				}
-			}
-
-			return var2;
+			this.func_885_a(0, 32, 16, 48);
+			this.func_885_a(16, 32, 40, 48);
+			this.func_885_a(40, 32, 56, 48);
+			this.func_885_a(0, 48, 16, 64);
+			this.func_884_b(16, 48, 48, 64);
+			this.func_885_a(48, 48, 64, 64);
+			return buffer;
 		}
 	}
 
--- com/mojang/nbt/ShortTag.java
+++ com/mojang/nbt/ShortTag.java
@@ -29,4 +29,8 @@
 	public String toString() {
 		return "" + this.shortValue;
 	}
+
+	public NBTBaseTag copy() {
+		return new ShortTag(this.shortValue).setKey(this.getKey());
+	}
 }
--- /dev/null
+++ net/minecraft/game/world/terrain/feature/MahoganyTreeFeature.java
@@ -1,0 +1,127 @@
+package net.minecraft.game.world.terrain.feature;
+
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.game.world.block.Block;
+
+import java.util.Random;
+
+public class MahoganyTreeFeature extends Feature {
+	private int trunkHeightVariation = 6;
+	private int trunkHeightMin = 6;
+	private int leavesHeightMin = 3;
+	private int leavesHeightVariation = 3;
+	private boolean tall;
+
+	public MahoganyTreeFeature() {
+		this(false);
+	}
+
+	public MahoganyTreeFeature(boolean tall) {
+		if (tall) {
+			this.tall = true;
+			this.trunkHeightMin = 12;
+			this.trunkHeightVariation = 12;
+			this.leavesHeightVariation = 4;
+		}
+	}
+
+	public boolean generate(World world, Random rand, int x, int y, int z) {
+		if (!Block.sapling.canPlaceBlockAt(world, x, y, z)) return false;
+
+		final int maxLeaves = 4;
+		int trunkHeight = rand.nextInt(trunkHeightVariation) + trunkHeightMin;
+		int leavesWidth = rand.nextInt(2) + 1;
+		int leavesHeight = rand.nextInt(leavesHeightVariation) + this.leavesHeightMin;
+
+		for (int sy = y; sy < y + trunkHeight; sy++) {
+			for (int sx = x - leavesWidth; sx <= x + leavesWidth; sx++) {
+				for (int sz = z - leavesWidth; sz <= z + leavesWidth; sz++) {
+					int block = world.getBlockId(sx, sy, sz);
+					if (block != 0 && block != Block.leaves.blockID) {
+						return false;
+					}
+				}
+			}
+		}
+
+		int ogx = x;
+		int ogz = z;
+
+		if (world.getBlockId(x, y - 1, z) == Block.grass.blockID) world.setBlock(x, y - 1, z, Block.dirt.blockID);
+		for (int ty = y; ty < y + trunkHeight; ty++) {
+			world.setBlockAndMetadata(x, ty, z, Block.log.blockID, 3);
+			if (rand.nextInt(5) == 0) {
+				int add = rand.nextInt(3) - 1;
+				if (rand.nextInt(2) == 0) {
+					x += add;
+					x = Math.min(Math.max(x, ogx - 1), ogx + 1);
+				} else {
+					z += add;
+					z = Math.min(Math.max(z, ogz - 1), ogz + 1);
+				}
+			}
+
+			if (ty - y > 2 && ty - y < trunkHeight - 4 && rand.nextInt(this.tall ? 3 : 4) == 0) {
+				int by = rand.nextInt(trunkHeight / 2) + trunkHeight / 4 + y;
+				int bdx = rand.nextInt(3) - 1;
+				int bdz = rand.nextInt(3) - 1;
+				int blen = rand.nextInt(3) + 2;
+
+				int bx = x;
+				int bz = z;
+				world.setBlockAndMetadata(bx, by, bz, Block.log.blockID, 3);
+				for (int j = 0; j < blen; j++) {
+					if (rand.nextInt(2) == 0) by++;
+					bx += bdx;
+					bz += bdz;
+					world.setBlockAndMetadata(bx, by, bz, Block.log.blockID, 3);
+				}
+
+				for (int ly = 0; ly < 3; ly++) {
+					int lyWorld = ly + by - 1;
+					int lc = (ly < 2 ? 2 : 1) + (rand.nextInt(3) + 1) / 2;
+
+					for (int j = 0; j < lc; j++) {
+						int lx = bx + (rand.nextInt(3) - 1);
+						int lz = bz + (rand.nextInt(3) - 1);
+						this.placeLeaves(world, rand, lx, lyWorld, lz, 3 + rand.nextInt(3) / 2);
+					}
+				}
+			}
+		}
+
+		for (int ly = 0; ly < leavesHeight; ly++) {
+			int lyWorld = y + trunkHeight - ly;
+			int lq = rand.nextInt(maxLeaves) + 2 + rand.nextInt(2);
+			int lr = Math.min(leavesHeight - ly, 3);
+
+			for (int i = 0; i < lq; i++) {
+				int lx = x + (rand.nextInt(leavesWidth * 2 + 1) - leavesWidth);
+				int lz = z + (rand.nextInt(leavesWidth * 2 + 1) - leavesWidth);
+				this.placeLeaves(world, rand, lx, lyWorld, lz, 3 + rand.nextInt(lr));
+			}
+		}
+
+		return true;
+	}
+
+	private void placeLeaves(World world, Random random, int x, int y, int z, int leafSize) {
+		if (this.tall) leafSize++;
+		int sx = (int)(x - leafSize / 2.0F);
+		int ex = (int)(x + leafSize / 2.0F);
+		int sz = (int)(z - leafSize / 2.0F);
+		int ez = (int)(z + leafSize / 2.0F);
+		int ey = this.tall ? y + 1 : y;
+		for (int lx = sx; lx < ex; lx++) {
+			for (int lz = sz; lz < ez; lz++) {
+				for (int ly = y; ly <= ey; ly++) {
+					if ((lx == sx || lx == ex - 1) && (lz == sz || lz == ez - 1) && random.nextInt(3) != 0) continue;
+					if (world.getBlockId(lx, ly, lz) == 0) {
+					   world.setBlockAndMetadata(lx, ly, lz, Block.leaves.blockID, 3);
+					}
+				}
+			}
+		}
+	}
+}
--- net/minecraft/game/world/block/LiquidBlock.java
+++ net/minecraft/game/world/block/LiquidBlock.java
@@ -6,15 +6,25 @@
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.IntProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.material.Material;
 
 public abstract class LiquidBlock extends Block {
+	public static final IntProperty LEVEL = new IntProperty("level", 3);
+	public static final BooleanProperty FALLING = new BooleanProperty("falling");
+
 	protected LiquidBlock(int var1, Material var2) {
-		super(var1, (var2 == Material.lava ? 14 : 12) * 16 + 13, var2);
+		super(var1, (var2 == Material.lava ? 30 : 28) * 32 + 29, var2);
 		float var3 = 0.0F;
 		float var4 = 0.0F;
 		this.setBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
 		this.setTickOnLoad(true);
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(LEVEL, FALLING);
 	}
 
 	public int getColorMultiplier(BlockAccess var1, int var2, int var3, int var4) {
--- net/minecraft/game/world/biome/DesertBiome.java
+++ net/minecraft/game/world/biome/DesertBiome.java
@@ -1,4 +1,38 @@
 package net.minecraft.game.world.biome;
 
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.terrain.NoiseSettings;
+
 public class DesertBiome extends Biome {
+	public DesertBiome(int i) {
+		super(i);
+		this.topBlock = (byte)Block.sand.blockID;
+		this.fillerBlock = (byte)Block.sand.blockID;
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return 0;
+	}
+
+	public int getDeadBushCount() {
+		return 2;
+	}
+
+	public int getCactusCount() {
+		return 10;
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(40.0D)
+				.heightOffset(10.0D)
+				.selectorThreshold(1.0D)
+				.noiseUnderDamp(2.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings()
+				.noiseStretch(80.0D)
+				.heightOffset(20.0D);
+	}
 }
--- com/mojang/nbt/FloatTag.java
+++ com/mojang/nbt/FloatTag.java
@@ -29,4 +29,8 @@
 	public String toString() {
 		return "" + this.floatValue;
 	}
+
+	public NBTBaseTag copy() {
+		return new FloatTag(this.floatValue).setKey(this.getKey());
+	}
 }
--- net/minecraft/client/render/tileentity/TileEntityRenderer.java
+++ net/minecraft/client/render/tileentity/TileEntityRenderer.java
@@ -1,6 +1,6 @@
 package net.minecraft.client.render.tileentity;
 
-import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.Map;
 import net.minecraft.client.gui.FontRenderer;
@@ -14,7 +14,7 @@
 import org.lwjgl.opengl.GL11;
 
 public class TileEntityRenderer {
-	private Map specialRendererMap = new HashMap();
+	private Map specialRendererMap = new IdentityHashMap();
 	public static TileEntityRenderer instance = new TileEntityRenderer();
 	private FontRenderer fontRenderer;
 	public static double staticPlayerX;
--- /dev/null
+++ net/minecraft/client/gui/component/GuiTransparentButton.java
@@ -1,0 +1,37 @@
+package net.minecraft.client.gui.component;
+
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.FontRenderer;
+import org.lwjgl.opengl.GL11;
+
+public class GuiTransparentButton extends GuiButton {
+	public GuiTransparentButton(int var1, int var2, int var3, String var4) {
+		super(var1, var2, var3, var4);
+	}
+
+	public GuiTransparentButton(int var1, int var2, int var3, int var4, int var5, String var6) {
+		super(var1, var2, var3, var4, var5, var6);
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
+		if(this.visible) {
+			int sx = this.getScaledX();
+			int sy = this.getScaledY();
+			int sw = this.getScaledWidth();
+			int sh = this.getScaledHeight();
+
+			FontRenderer fontRenderer4 = var1.fontRenderer;
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			boolean var5 = var2 >= sx && var3 >= sy && var2 < sx + sw && var3 < sy + sh;
+			this.mouseDragged(var1, var2, var3);
+			if(!this.enabled) {
+				this.drawString(fontRenderer4, this.displayString, sx, sy + (this.buttonHeight - 8) / 2, -6250336);
+			} else if(var5) {
+				this.drawString(fontRenderer4, this.displayString, sx, sy + (this.buttonHeight - 8) / 2, 16777120);
+			} else {
+				this.drawString(fontRenderer4, this.displayString, sx, sy + (this.buttonHeight - 8) / 2, 14737632);
+			}
+
+		}
+	}
+}
--- argo/J_FieldNodeContainer.java
+++ /dev/null
@@ -1,19 +1,0 @@
-package argo;
-
-class J_FieldNodeContainer implements J_NodeContainer {
-	final J_JsonFieldBuilder field_27292_a;
-	final J_JsonListenerToJdomAdapter field_27291_b;
-
-	J_FieldNodeContainer(J_JsonListenerToJdomAdapter var1, J_JsonFieldBuilder var2) {
-		this.field_27291_b = var1;
-		this.field_27292_a = var2;
-	}
-
-	public void func_27290_a(J_JsonNodeBuilder var1) {
-		this.field_27292_a.func_27300_b(var1);
-	}
-
-	public void func_27289_a(J_JsonFieldBuilder var1) {
-		throw new RuntimeException("Coding failure in Argo:  Attempt to add a field to a field.");
-	}
-}
--- net/minecraft/network/packet/Packet1Login.java
+++ net/minecraft/network/packet/Packet1Login.java
@@ -8,7 +8,6 @@
 public class Packet1Login extends Packet {
 	public int protocolVersion;
 	public String username;
-	public long mapSeed;
 	public byte dimension;
 
 	public Packet1Login() {
@@ -22,14 +21,12 @@
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.protocolVersion = var1.readInt();
 		this.username = readString(var1, 16);
-		this.mapSeed = var1.readLong();
 		this.dimension = var1.readByte();
 	}
 
 	public void writePacketData(DataOutputStream var1) throws IOException {
 		var1.writeInt(this.protocolVersion);
 		writeString(this.username, var1);
-		var1.writeLong(this.mapSeed);
 		var1.writeByte(this.dimension);
 	}
 
@@ -38,13 +35,12 @@
 	}
 
 	public int getPacketSize() {
-		return 4 + this.username.length() + 4 + 5;
+		return 4 + 2 + this.username.length() + 1;
 	}
 
-	public Packet1Login(String var1, int var2, long var3, byte var5) {
+	public Packet1Login(String var1, int var2, byte var5) {
 		this.username = var1;
 		this.protocolVersion = var2;
-		this.mapSeed = var3;
 		this.dimension = var5;
 	}
 }
--- /dev/null
+++ net/minecraft/game/world/terrain/feature/WillowTreeFeature.java
@@ -1,0 +1,101 @@
+package net.minecraft.game.world.terrain.feature;
+
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.material.Material;
+
+import java.util.Random;
+
+public class WillowTreeFeature extends Feature {
+	private final int woodMetadata;
+	private final int leavesMetadata;
+
+	public WillowTreeFeature() {
+		this(4, 4);
+	}
+
+	public WillowTreeFeature(int metadata) {
+		this(metadata, metadata);
+	}
+
+	public WillowTreeFeature(int woodMetadata, int leavesMetadata) {
+		this.woodMetadata = woodMetadata;
+		this.leavesMetadata = leavesMetadata;
+	}
+
+	public boolean generate(World world, Random rand, int x, int y, int z) {
+		for (int i = 0; i < 3 && !world.isBlockNormalCube(x, y - 1, z); i++) {
+			y--;
+		}
+
+		if (!Block.sapling.canPlaceBlockAt(world, x, y, z)
+				&& !(world.getBlockMaterial(x, y, z) == Material.water
+						&& world.isBlockNormalCube(x, y - 1, z))) {
+			return false;
+		}
+
+		int height = 6 + rand.nextInt(6);
+
+		for (int sy = y; sy < y + height; sy++) {
+			int r = Math.min(sy - y, 3);
+			for (int sx = x - r; sx <= x + r; sx++) {
+				for (int sz = z - r; sz <= z + r; sz++) {
+					int block = world.getBlockId(sx, sy, sz);
+					if (world.isBlockNormalCube(sx, sy, sz) && block != Block.leaves.blockID) {
+						return false;
+					}
+				}
+			}
+		}
+
+		if (world.getBlockId(x, y - 1, z) == Block.grass.blockID) {
+			world.setBlock(x, y - 1, z, Block.dirt.blockID);
+		}
+
+		for (int ty = 0; ty < height; ty++) {
+			world.setBlockAndMetadata(x, y + ty, z, Block.log.blockID, this.woodMetadata);
+		}
+
+		int minHeight = world.getChunkFromBlockCoords(x, z).getMinY();
+
+		for (int i = 0; i < 4; i++) {
+			int tx = x + (i == 0 ? -1 : i == 1 ? 1 : 0);
+			int tz = z + (i == 2 ? -1 : i == 3 ? 1 : 0);
+			int c = rand.nextInt(4);
+
+			for (int ty = y + c - 1; ty > minHeight && !world.isBlockNormalCube(tx, ty, tz) && (ty > y - 2 || rand.nextFloat() < 0.6F); ty--) {
+				world.setBlockAndMetadata(tx, ty, tz, Block.log.blockID, this.woodMetadata);
+			}
+		}
+
+		for (int tx = -2; tx <= 2; tx++) {
+			for (int tz = -2; tz <= 2; tz++) {
+				for (int ty = height + 1; ty > height - 3; ty--) {
+					if ((ty > height - 2 && (Math.abs(tx) != 2 || Math.abs(tz) != 2 || ty < height + 1)
+							|| ty == height - 2 && (Math.abs(tx) > 1 || Math.abs(tz) > 1))
+							&& (world.isAirBlock(x + tx, y + ty, z + tz)
+									|| world.getBlockMaterial(x + tx, y + ty, z + tz) == Material.water)) {
+						world.setBlockAndMetadata(x + tx, y + ty, z + tz, Block.leaves.blockID, this.leavesMetadata);
+					}
+				}
+			}
+		}
+
+		for (int i = 0; i < 20; i++) {
+			int j = i % 5;
+			int tx = x + (i < 10 ? -2 + j : i < 15 ? 3 : -3);
+			int tz = z + (i < 5 ? 3 : i < 10 ? -3 : -2 + j);
+			int tyMax = y + height;
+			if (j == 0 || j == 4 || rand.nextInt(3) == 0) tyMax--;
+			int tyMin = y + height - 2 - rand.nextInt(5);
+
+			for (int ty = tyMax; ty >= tyMin; ty--) {
+				if (world.isAirBlock(tx, ty, tz) || world.getBlockMaterial(tx, ty, tz) == Material.water) {
+					world.setBlockAndMetadata(tx, ty, tz, Block.leaves.blockID, this.leavesMetadata);
+				}
+			}
+		}
+
+		return true;
+	}
+}
--- net/minecraft/server/EntityTrackerEntry.java
+++ net/minecraft/server/EntityTrackerEntry.java
@@ -187,9 +187,7 @@
 	}
 
 	public void removeFromTrackedPlayers(ServerPlayerEntity var1) {
-		if(this.trackedPlayers.contains(var1)) {
-			this.trackedPlayers.remove(var1);
-		}
+		this.trackedPlayers.remove(var1);
 
 	}
 
@@ -291,6 +289,10 @@
 
 					if(var3.blockID == Block.gravel.blockID) {
 						return new Packet23VehicleSpawn(this.trackedEntity, 71);
+					}
+
+					if(var3.blockID == Block.redSand.blockID) {
+						return new Packet23VehicleSpawn(this.trackedEntity, 72);
 					}
 				}
 
--- net/minecraft/server/EntityTracker.java
+++ net/minecraft/server/EntityTracker.java
@@ -4,6 +4,9 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.animal.IAnimals;
 import net.minecraft.game.entity.animal.SquidEntity;
@@ -20,11 +23,10 @@
 import net.minecraft.game.entity.vehicle.MinecartEntity;
 import net.minecraft.network.packet.Packet;
 import net.minecraft.server.player.ServerPlayerEntity;
-import net.minecraft.util.MCHash;
 
 public class EntityTracker {
 	private Set trackedEntitySet = new HashSet();
-	private MCHash trackedEntityHashTable = new MCHash();
+	private Int2ObjectMap<EntityTrackerEntry> trackedEntityHashTable = new Int2ObjectOpenHashMap<>();
 	private MinecraftServer mcServer;
 	private int maxTrackingDistanceThreshold;
 	private int field_28113_e;
@@ -86,12 +88,12 @@
 			var2 = this.maxTrackingDistanceThreshold;
 		}
 
-		if(this.trackedEntityHashTable.containsItem(var1.entityId)) {
+		if(this.trackedEntityHashTable.containsKey(var1.entityId)) {
 			throw new IllegalStateException("Entity is already tracked!");
 		} else {
 			EntityTrackerEntry var5 = new EntityTrackerEntry(var1, var2, var3, var4);
 			this.trackedEntitySet.add(var5);
-			this.trackedEntityHashTable.addKey(var1.entityId, var5);
+			this.trackedEntityHashTable.put(var1.entityId, var5);
 			var5.updatePlayerEntities(this.mcServer.getWorldManager(this.field_28113_e).playerEntities);
 		}
 	}
@@ -107,7 +109,7 @@
 			}
 		}
 
-		EntityTrackerEntry var5 = (EntityTrackerEntry)this.trackedEntityHashTable.removeObject(var1.entityId);
+		EntityTrackerEntry var5 = this.trackedEntityHashTable.remove(var1.entityId);
 		if(var5 != null) {
 			this.trackedEntitySet.remove(var5);
 			var5.sendDestroyEntityPacketToTrackedPlayers();
@@ -123,7 +125,7 @@
 			EntityTrackerEntry var3 = (EntityTrackerEntry)var2.next();
 			var3.updatePlayerList(this.mcServer.getWorldManager(this.field_28113_e).playerEntities);
 			if(var3.playerEntitiesUpdated && var3.trackedEntity instanceof ServerPlayerEntity) {
-				var1.add((ServerPlayerEntity)var3.trackedEntity);
+				var1.add(var3.trackedEntity);
 			}
 		}
 
@@ -142,7 +144,7 @@
 	}
 
 	public void sendPacketToTrackedPlayers(Entity var1, Packet var2) {
-		EntityTrackerEntry var3 = (EntityTrackerEntry)this.trackedEntityHashTable.lookup(var1.entityId);
+		EntityTrackerEntry var3 = this.trackedEntityHashTable.get(var1.entityId);
 		if(var3 != null) {
 			var3.sendPacketToTrackedPlayers(var2);
 		}
@@ -150,7 +152,7 @@
 	}
 
 	public void sendPacketToTrackedPlayersAndTrackedEntity(Entity var1, Packet var2) {
-		EntityTrackerEntry var3 = (EntityTrackerEntry)this.trackedEntityHashTable.lookup(var1.entityId);
+		EntityTrackerEntry var3 = this.trackedEntityHashTable.get(var1.entityId);
 		if(var3 != null) {
 			var3.sendPacketToTrackedPlayersAndTrackedEntity(var2);
 		}
--- net/minecraft/game/item/recipe/RecipesWeapons.java
+++ net/minecraft/game/item/recipe/RecipesWeapons.java
@@ -14,11 +14,11 @@
 
 			for(int var4 = 0; var4 < this.recipeItems.length - 1; ++var4) {
 				Item var5 = (Item)this.recipeItems[var4 + 1][var2];
-				var1.addRecipe(new ItemStack(var5), new Object[]{this.recipePatterns[var4], Character.valueOf('#'), Item.stick, Character.valueOf('X'), var3});
+				var1.addRecipe(new ItemStack(var5), this.recipePatterns[var4], '#', Item.stick, 'X', var3);
 			}
 		}
 
-		var1.addRecipe(new ItemStack(Item.bow, 1), new Object[]{" #X", "# X", " #X", Character.valueOf('X'), Item.string, Character.valueOf('#'), Item.stick});
-		var1.addRecipe(new ItemStack(Item.arrow, 4), new Object[]{"X", "#", "Y", Character.valueOf('Y'), Item.feather, Character.valueOf('X'), Item.flint, Character.valueOf('#'), Item.stick});
+		var1.addRecipe(new ItemStack(Item.bow, 1), " #X", "# X", " #X", 'X', Item.string, '#', Item.stick);
+		var1.addRecipe(new ItemStack(Item.arrow, 4), "X", "#", "Y", 'Y', Item.feather, 'X', Item.flint, '#', Item.stick);
 	}
 }
--- net/minecraft/game/world/chunk/ChunkProvider.java
+++ net/minecraft/game/world/chunk/ChunkProvider.java
@@ -18,4 +18,8 @@
 	boolean canSave();
 
 	String getDebugInfo();
+
+	default boolean chunkSaved(int var1, int var2) {
+		return false;
+	}
 }
--- argo/J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException.java
+++ /dev/null
@@ -1,48 +1,0 @@
-package argo;
-
-import java.util.LinkedList;
-import java.util.List;
-
-public final class J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException extends J_JsonNodeDoesNotMatchJsonNodeSelectorException {
-	final J_Functor field_27326_a;
-	final List field_27325_b;
-
-	static J_JsonNodeDoesNotMatchJsonNodeSelectorException func_27322_a(J_Functor var0) {
-		return new J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException(var0, new LinkedList());
-	}
-
-	static J_JsonNodeDoesNotMatchJsonNodeSelectorException func_27323_a(J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, J_JsonNodeSelector var1) {
-		LinkedList var2 = new LinkedList(var0.field_27325_b);
-		var2.add(var1);
-		return new J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException(var0.field_27326_a, var2);
-	}
-
-	static J_JsonNodeDoesNotMatchJsonNodeSelectorException func_27321_b(J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, J_JsonNodeSelector var1) {
-		LinkedList var2 = new LinkedList();
-		var2.add(var1);
-		return new J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException(var0.field_27326_a, var2);
-	}
-
-	private J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException(J_Functor var1, List var2) {
-		super("Failed to match any JSON node at [" + func_27324_a(var2) + "]");
-		this.field_27326_a = var1;
-		this.field_27325_b = var2;
-	}
-
-	static String func_27324_a(List var0) {
-		StringBuilder var1 = new StringBuilder();
-
-		for(int var2 = var0.size() - 1; var2 >= 0; --var2) {
-			var1.append(((J_JsonNodeSelector)var0.get(var2)).func_27358_a());
-			if(var2 != 0) {
-				var1.append(".");
-			}
-		}
-
-		return var1.toString();
-	}
-
-	public String toString() {
-		return "JsonNodeDoesNotMatchJsonNodeSelectorException{failedNode=" + this.field_27326_a + ", failPath=" + this.field_27325_b + '}';
-	}
-}
--- /dev/null
+++ argo/jdom/JsonStringNodeBuilder.java
@@ -1,0 +1,13 @@
+package argo.jdom;
+
+public final class JsonStringNodeBuilder implements JsonNodeBuilder {
+	private final String field_27244_a;
+
+	JsonStringNodeBuilder(String var1) {
+		this.field_27244_a = var1;
+	}
+
+	public JsonStringNode buildNode() {
+		return JsonNodeFactories.aJsonString(this.field_27244_a);
+	}
+}
--- net/minecraft/game/entity/monster/PigZombieEntity.java
+++ net/minecraft/game/entity/monster/PigZombieEntity.java
@@ -88,10 +88,6 @@
 		return "mob.zombiepig.zpigdeath";
 	}
 
-	protected int getDropItemId() {
-		return Item.cookedPorkchop.itemID;
-	}
-
 	public ItemStack getHeldItem() {
 		return defaultHeldItem;
 	}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/SmoothTessellator.java
@@ -1,0 +1,10 @@
+package net.mine_diver.smoothbeta.client.render;
+
+public interface SmoothTessellator {
+    void smoothbeta_startRenderingTerrain(SmoothChunkRenderer chunkRenderer);
+
+    void smoothbeta_stopRenderingTerrain();
+
+    boolean smoothbeta_isRenderingTerrain();
+
+}
--- net/minecraft/game/stats/StatBase.java
+++ net/minecraft/game/stats/StatBase.java
@@ -34,11 +34,11 @@
 	}
 
 	public StatBase registerStat() {
-		if(StatList.idToStat.containsKey(Integer.valueOf(this.statId))) {
-			throw new RuntimeException("Duplicate stat id: \"" + ((StatBase)StatList.idToStat.get(Integer.valueOf(this.statId))).statName + "\" and \"" + this.statName + "\" at id " + this.statId);
+		if(StatList.idToStat.containsKey(this.statId)) {
+			throw new RuntimeException("Duplicate stat id: \"" + ((StatBase)StatList.idToStat.get(this.statId)).statName + "\" and \"" + this.statName + "\" at id " + this.statId);
 		} else {
 			StatList.statList.add(this);
-			StatList.idToStat.put(Integer.valueOf(this.statId), this);
+			StatList.idToStat.put(this.statId, this);
 			this.statGuid = AchievementMap.getGuid(this.statId);
 			return this;
 		}
--- net/minecraft/network/packet/Packet14BlockDig.java
+++ net/minecraft/network/packet/Packet14BlockDig.java
@@ -26,7 +26,7 @@
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.status = var1.read();
 		this.xPosition = var1.readInt();
-		this.yPosition = var1.read();
+		this.yPosition = var1.readInt();
 		this.zPosition = var1.readInt();
 		this.face = var1.read();
 	}
@@ -34,7 +34,7 @@
 	public void writePacketData(DataOutputStream var1) throws IOException {
 		var1.write(this.status);
 		var1.writeInt(this.xPosition);
-		var1.write(this.yPosition);
+		var1.writeInt(this.yPosition);
 		var1.writeInt(this.zPosition);
 		var1.write(this.face);
 	}
@@ -44,6 +44,6 @@
 	}
 
 	public int getPacketSize() {
-		return 11;
+		return 14;
 	}
 }
--- net/minecraft/client/model/BipedModel.java
+++ net/minecraft/client/model/BipedModel.java
@@ -132,6 +132,7 @@
 			this.bipedRightLeg.rotationPointY = 9.0F;
 			this.bipedLeftLeg.rotationPointY = 9.0F;
 			this.bipedHead.rotationPointY = 1.0F;
+			this.bipedHeadwear.rotationPointY = 1.0F;
 		} else {
 			this.bipedBody.rotateAngleX = 0.0F;
 			this.bipedRightLeg.rotationPointZ = 0.0F;
@@ -139,6 +140,7 @@
 			this.bipedRightLeg.rotationPointY = 12.0F;
 			this.bipedLeftLeg.rotationPointY = 12.0F;
 			this.bipedHead.rotationPointY = 0.0F;
+			this.bipedHeadwear.rotationPointY = 0.0F;
 		}
 
 		this.bipedRightArm.rotateAngleZ += MathHelper.cos(var3 * 0.09F) * 0.05F + 0.05F;
--- /dev/null
+++ net/minecraft/util/DoubleArray2D.java
@@ -1,0 +1,34 @@
+package net.minecraft.util;
+
+public class DoubleArray2D {
+	private final double[] array;
+	public final int width, height;
+
+	public DoubleArray2D(int width, int height) {
+		this(null, width, height);
+	}
+
+	public DoubleArray2D(double[] array, int width, int height) {
+		if (array == null) {
+			array = new double[width * height];
+		} else if (array.length < width * height) {
+			throw new IllegalArgumentException("Array is too small!");
+		}
+
+		this.array = array;
+		this.width = width;
+		this.height = height;
+	}
+
+	public double get(int x, int y) {
+		return this.array[x * this.height + y];
+	}
+
+	public void set(int x, int y, double value) {
+		this.array[x * this.height + y] = value;
+	}
+
+	public double[] getArray() {
+		return array;
+	}
+}
--- net/minecraft/game/world/dimension/Dimension.java
+++ net/minecraft/game/world/dimension/Dimension.java
@@ -2,7 +2,8 @@
 
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.world.World;
-import net.minecraft.game.world.biome.ClimaticBiomeSource;
+import net.minecraft.game.world.biome.BiomeSource;
+import net.minecraft.game.world.biome.LayeredBiomeSource;
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.chunk.ChunkProvider;
 import net.minecraft.game.world.terrain.OverworldChunkProvider;
@@ -10,7 +11,7 @@
 
 public abstract class Dimension {
 	public World worldObj;
-	public ClimaticBiomeSource biomeSource;
+	public BiomeSource biomeSource;
 	public boolean isNether = false;
 	public boolean isHellWorld = false;
 	public boolean hasNoSky = false;
@@ -35,7 +36,7 @@
 	}
 
 	protected void registerWorldChunkManager() {
-		this.biomeSource = new ClimaticBiomeSource(this.worldObj);
+		this.biomeSource = new LayeredBiomeSource(this.worldObj);
 	}
 
 	public ChunkProvider getChunkProvider() {
@@ -110,7 +111,7 @@
 	}
 
 	public float getCloudHeight() {
-		return 108.0F;
+		return 144.0F;
 	}
 
 	public boolean canSleep() {
--- net/minecraft/client/sound/SoundManager.java
+++ net/minecraft/client/sound/SoundManager.java
@@ -20,7 +20,7 @@
 	private GameSettings options;
 	private static boolean loaded = false;
 	private Random rand = new Random();
-	private int ticksBeforeMusic = this.rand.nextInt(12000);
+	private MusicType currentMusicType;
 
 	public void loadSoundSettings(GameSettings var1) {
 		this.soundPoolStreaming.field_1657_b = false;
@@ -84,21 +84,24 @@
 		this.soundPoolStreaming.addSound(var1, var2);
 	}
 
-	public void addMusic(String var1, File var2) {
-		this.soundPoolMusic.addSound(var1, var2);
-	}
-
-	public void playRandomMusicIfReady() {
+	public void playRandomMusicIfReady(MusicType musicType) {
 		if(loaded && this.options.musicVolume != 0.0F) {
+			if (musicType != this.currentMusicType) {
+				this.currentMusicType = musicType;
+				if (sndSystem.playing("BgMusic")) {
+					sndSystem.fadeOut("BgMusic", null, null, 2500);
+				}
+				return;
+			}
+
 			if(!sndSystem.playing("BgMusic") && !sndSystem.playing("streaming")) {
-				if(this.ticksBeforeMusic > 0) {
-					--this.ticksBeforeMusic;
+				if(!musicType.canPlay()) {
 					return;
 				}
 
-				SoundPoolEntry var1 = this.soundPoolMusic.getRandomSound();
+				SoundPoolEntry var1 = musicType.soundPool.getRandomSound();
 				if(var1 != null) {
-					this.ticksBeforeMusic = this.rand.nextInt(12000) + 12000;
+					musicType.setNewDelay(this.rand);
 					sndSystem.backgroundMusic("BgMusic", var1.soundUrl, var1.soundName, false);
 					sndSystem.setVolume("BgMusic", this.options.musicVolume);
 					sndSystem.play("BgMusic");
@@ -194,6 +197,35 @@
 				sndSystem.play(var5);
 			}
 
+		}
+	}
+
+	public enum MusicType {
+		MENU(20, 600),
+		GAME(12000, 24000),
+		CREATIVE(1200, 3600);
+
+		public final SoundPool soundPool = new SoundPool();
+		private final int minDelay, maxDelay;
+		private int delay;
+
+		MusicType(int minDelay, int maxDelay) {
+			this.minDelay = minDelay;
+			this.maxDelay = maxDelay;
+			this.delay = new Random().nextInt(this.minDelay / 2);
+		}
+
+		public void setNewDelay(Random random) {
+			this.delay = this.minDelay;
+			if (this.maxDelay - this.minDelay > 0) {
+				this.delay += random.nextInt(this.maxDelay - this.minDelay);
+			}
+		}
+
+		public boolean canPlay() {
+			if (this.delay <= 0) return true;
+			this.delay--;
+			return false;
 		}
 	}
 }
--- argo/J_PositionTrackingPushbackReader.java
+++ /dev/null
@@ -1,78 +1,0 @@
-package argo;
-
-import java.io.IOException;
-import java.io.PushbackReader;
-import java.io.Reader;
-
-final class J_PositionTrackingPushbackReader implements J_ThingWithPosition {
-	private final PushbackReader field_27338_a;
-	private int field_27337_b = 0;
-	private int field_27340_c = 1;
-	private boolean field_27339_d = false;
-
-	public J_PositionTrackingPushbackReader(Reader var1) {
-		this.field_27338_a = new PushbackReader(var1);
-	}
-
-	public void func_27334_a(char var1) throws IOException {
-		--this.field_27337_b;
-		if(this.field_27337_b < 0) {
-			this.field_27337_b = 0;
-		}
-
-		this.field_27338_a.unread(var1);
-	}
-
-	public void func_27335_a(char[] var1) {
-		this.field_27337_b -= var1.length;
-		if(this.field_27337_b < 0) {
-			this.field_27337_b = 0;
-		}
-
-	}
-
-	public int func_27333_c() throws IOException {
-		int var1 = this.field_27338_a.read();
-		this.func_27332_a(var1);
-		return var1;
-	}
-
-	public int func_27336_b(char[] var1) throws IOException {
-		int var2 = this.field_27338_a.read(var1);
-		char[] var3 = var1;
-		int var4 = var1.length;
-
-		for(int var5 = 0; var5 < var4; ++var5) {
-			char var6 = var3[var5];
-			this.func_27332_a(var6);
-		}
-
-		return var2;
-	}
-
-	private void func_27332_a(int var1) {
-		if(13 == var1) {
-			this.field_27337_b = 0;
-			++this.field_27340_c;
-			this.field_27339_d = true;
-		} else {
-			if(10 == var1 && !this.field_27339_d) {
-				this.field_27337_b = 0;
-				++this.field_27340_c;
-			} else {
-				++this.field_27337_b;
-			}
-
-			this.field_27339_d = false;
-		}
-
-	}
-
-	public int func_27331_a() {
-		return this.field_27337_b;
-	}
-
-	public int func_27330_b() {
-		return this.field_27340_c;
-	}
-}
--- argo/EnumJsonNodeType.java
+++ /dev/null
@@ -1,11 +1,0 @@
-package argo;
-
-public enum EnumJsonNodeType {
-	OBJECT,
-	ARRAY,
-	STRING,
-	NUMBER,
-	TRUE,
-	FALSE,
-	NULL;
-}
--- net/minecraft/game/world/biome/Biome.java
+++ net/minecraft/game/world/biome/Biome.java
@@ -4,6 +4,8 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
+import java.util.function.IntUnaryOperator;
+
 import net.minecraft.game.entity.SpawnableMobType;
 import net.minecraft.game.entity.animal.ChickenEntity;
 import net.minecraft.game.entity.animal.CowEntity;
@@ -17,37 +19,75 @@
 import net.minecraft.game.entity.monster.ZombieEntity;
 import net.minecraft.game.world.SpawnListEntry;
 import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
 import net.minecraft.game.world.terrain.feature.BigTreeFeature;
 import net.minecraft.game.world.terrain.feature.Feature;
+import net.minecraft.game.world.terrain.feature.PopulatorHost;
 import net.minecraft.game.world.terrain.feature.TreeFeature;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+import net.minecraft.util.MathHelper;
 
 public class Biome {
-	public static final Biome rainforest = (new RainforestBiome()).setMapColor(588342).setName("Rainforest").setUnusedFoliageColor(2094168);
-	public static final Biome swampland = (new SwamplandBiome()).setMapColor(522674).setName("Swampland").setUnusedFoliageColor(9154376);
-	public static final Biome seasonalForest = (new Biome()).setMapColor(10215459).setName("Seasonal Forest");
-	public static final Biome forest = (new ForestBiome()).setMapColor(353825).setName("Forest").setUnusedFoliageColor(5159473);
-	public static final Biome savanna = (new DesertBiome()).setMapColor(14278691).setName("Savanna");
-	public static final Biome shrubland = (new Biome()).setMapColor(10595616).setName("Shrubland");
-	public static final Biome taiga = (new TaigaBiome()).setMapColor(3060051).setName("Taiga").enableSnow().setUnusedFoliageColor(8107825);
-	public static final Biome desert = (new DesertBiome()).setMapColor(16421912).setName("Desert").disablePrecipitation();
-	public static final Biome plains = (new DesertBiome()).setMapColor(16767248).setName("Plains");
-	public static final Biome iceDesert = (new DesertBiome()).setMapColor(16772499).setName("Ice Desert").enableSnow().disablePrecipitation().setUnusedFoliageColor(12899129);
-	public static final Biome tundra = (new Biome()).setMapColor(5762041).setName("Tundra").enableSnow().setUnusedFoliageColor(12899129);
-	public static final Biome nether = (new NetherBiome()).setMapColor(16711680).setName("Hell").disablePrecipitation();
-	public static final Biome sky = (new SkyBiome()).setMapColor(8421631).setName("Sky").disablePrecipitation();
+	public static final Biome[] biomeIndex = new Biome[256];
+	public static final Biome[][] climateZones = new Biome[25][];
+	public static final Biome ocean = (new OceanBiome(0)).setName("Ocean").setMapColor(0x00007f);
+	public static final Biome plains = (new PlainsBiome(1)).setName("Plains");
+	public static final Biome beach = (new BeachBiome(2)).setName("Beach").setMapColor(0xffff7f);
+	public static final Biome forest = (new ForestBiome(3)).setName("Forest").setColoring(0x6bff58, 0x00dd39, -1);
+	public static final Biome desert = (new DesertBiome(4)).setName("Desert").setColoring(0xe4d481, 0xb4a059, 0x71c7e5).disablePrecipitation();
+	public static final Biome taiga = (new TaigaBiome(5)).setName("Taiga").setColoring(0x2bc576, 0x2ac163, 0x89a6f8);
+	public static final Biome mountains = (new MountainBiome(6)).setName("Mountains").setColoring(0x66e191, 0x2ce355, 0x73b7ff);
+	public static final Biome mapleForest = (new MapleForestBiome(7)).setName("Maple Forest").setColoring(0xc0ff5f, 0x7dff3a, 0x5bd1ff);
+	public static final Biome snowyTaiga = (new TaigaBiome(8)).setName("Snowy Taiga").enableSnow().setColoring(0x8ef4cd, 0x188d68, 0x948cff);
+	public static final Biome savanna = (new SavannaBiome(9)).setName("Savanna").setColoring(0xf8e57c, 0xb9ff31, 0x5cc1e3).disablePrecipitation();
+	public static final Biome swamp = (new SwampBiome(10)).setName("Swamp").setColoring(0x2a7d22, 0x6ede2a, 0x33849b);
+	public static final Biome rainforest = (new RainforestBiome(11)).setName("Rainforest").setColoring(0x33f12f, 0x72ff00, 0x60e3ff);
+	public static final Biome tundra = (new TundraBiome(12)).setName("Tundra").enableSnow().setColoring(0x8ef4cd, 0x188d68, 0x948cff);
+	public static final Biome badlands = (new BadlandsBiome(13)).setName("Badlands").setColoring(0x818229, 0x5f750f, 0x71c7e5).disablePrecipitation();
+	public static final Biome bloomingMapleForest = (new MapleForestBiome(14, true)).setName("Blooming Maple Forest").setMapColor(0xff77da).setColoring(0xc0ff5f, 0x7dff3a, 0x5bd1ff);
+	public static final Biome frostyMountains = (new MountainBiome(15)).setName("Frosty Mountains").enableSnow().setColoring(0xaafbdd, 0x5ee4a2, 0x658cff);
+	public static final Biome bloomingForest = (new ForestBiome(16, true)).setName("Blooming Forest").setColoring(0x93ef3f, 0xb8ff4d, -1);
+	public static final Biome freshwaterForest = (new FreshwaterForestBiome(17)).setName("Freshwater Forest").setColoring(0x54f054, 0x23e34d, -1);
+	public static final Biome rockyValley = (new RockyValleyBiome(18)).setName("Rocky Valley").setColoring(0x49ef69, 0x0ac150, 0x73b7ff);
+	public static final Biome bloomingTundra = (new MapleForestBiome(19, true)).setName("Blossom Tundra").setMapColor(0xff77da).enableSnow().setColoring(0x87f7b5, 0x5ee4a2, 0xdcb9ff);
+	public static final Biome nether = (new NetherBiome(-1)).setMapColor(16711680).setName("Hell").disablePrecipitation();
+	public static final Biome sky = (new SkyBiome(-1)).setMapColor(8421631).setName("Sky").disablePrecipitation();
+	public NoiseSettings minNoiseSettings = this.buildNoiseSettings().build();
+	public NoiseSettings maxNoiseSettings = this.buildBoostedNoiseSettings().build();
+	public final int id;
 	public String name;
-	public int mapColor;
+	public int mapColor = 0x9dff5c;
 	public byte topBlock = (byte)Block.grass.blockID;
+	public byte topMeta = 0;
 	public byte fillerBlock = (byte)Block.dirt.blockID;
+	public byte fillerMeta = 0;
+	public byte stoneBlock = (byte)Block.stone.blockID;
+	public byte stoneMeta = 0;
 	public int unusedFoliageColor = 5169201;
-	protected List spawnableMonsterList = new ArrayList();
-	protected List spawnableCreatureList = new ArrayList();
-	protected List spawnableWaterCreatureList = new ArrayList();
+	private int grassColor = 0x9dff5c;
+	private int foliageColor = 0x55ff3f;
+	private int skyColor = 0x88bbff;
+	protected List<SpawnListEntry> spawnableMonsterList = new ArrayList();
+	protected List<SpawnListEntry> spawnableCreatureList = new ArrayList();
+	protected List<SpawnListEntry> spawnableWaterCreatureList = new ArrayList();
 	private boolean enableSnow;
 	private boolean enableRain = true;
+	private boolean hasBeach = true;
+	private final List<Variant>[] variants = new List[10];
 	private static Biome[] biomeLookupTable = new Biome[4096];
 
-	protected Biome() {
+	private static PerlinNoiseOctaves erosionNoise;
+
+	protected Biome(int id) {
+		if (id >= 0) {
+			if (biomeIndex[id] != null) throw new IllegalArgumentException("Biome of ID " + id + " already exists!");
+			this.id = id;
+			biomeIndex[id] = this;
+		} else {
+			this.id = -1;
+		}
+
 		this.spawnableMonsterList.add(new SpawnListEntry(SpiderEntity.class, 10));
 		this.spawnableMonsterList.add(new SpawnListEntry(ZombieEntity.class, 10));
 		this.spawnableMonsterList.add(new SpawnListEntry(SkeletonEntity.class, 10));
@@ -60,24 +100,75 @@
 		this.spawnableWaterCreatureList.add(new SpawnListEntry(SquidEntity.class, 10));
 	}
 
+	static {
+		registerClimateZones();
+
+		plains.addVariant(forest, 4, 1);
+		plains.addVariant(bloomingMapleForest, 8, 0);
+		tundra.addVariant(bloomingTundra, 5, 0);
+		forest.addVariant(plains, 5, 2);
+		bloomingForest.addVariant(plains, 5, 2);
+		taiga.addVariant(mountains, 5, 1);
+		snowyTaiga.addVariant(frostyMountains, 5, 1);
+		mountains.addVariant(rockyValley, 5, 1);
+	}
+
+	public static void initializeAllNoise(Random random) {
+		erosionNoise = new PerlinNoiseOctaves(random, 4);
+
+		for (Biome biome : biomeIndex) {
+			if (biome != null) {
+				biome.initializeNoise(random);
+			}
+		}
+	}
+
+	protected void initializeNoise(Random random) {
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return new NoiseSettings.Builder();
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings()
+				.noiseStretch(40.0D, 60.0D)
+				.heightOffset(20.0D);
+	}
+
+	protected void rebuildNoiseSettings() {
+		this.minNoiseSettings = this.buildNoiseSettings().build();
+		this.maxNoiseSettings = this.buildBoostedNoiseSettings().build();
+	}
+
 	private Biome disablePrecipitation() {
 		this.enableRain = false;
 		return this;
 	}
 
-	public static void generateBiomeLookup() {
-		for(int var0 = 0; var0 < 64; ++var0) {
-			for(int var1 = 0; var1 < 64; ++var1) {
-				biomeLookupTable[var0 + var1 * 64] = getBiome((float)var0 / 63.0F, (float)var1 / 63.0F);
-			}
-		}
-
-		desert.topBlock = desert.fillerBlock = (byte)Block.sand.blockID;
-		iceDesert.topBlock = iceDesert.fillerBlock = (byte)Block.sand.blockID;
-	}
-
 	public Feature getRandomTreeFeature(Random var1) {
-		return (Feature)(var1.nextInt(10) == 0 ? new BigTreeFeature() : new TreeFeature());
+		return var1.nextInt(10) == 0 ? new BigTreeFeature() : new TreeFeature();
+	}
+
+	public Feature modifyGrownTree(Feature var1, Random var2) {
+		return var1;
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return treeBonus;
+	}
+
+	public int getDeadBushCount() {
+		return 0;
+	}
+
+	public int getCactusCount() {
+		return 0;
+	}
+
+	protected Biome removeBeach() {
+		this.hasBeach = false;
+		return this;
 	}
 
 	protected Biome enableSnow() {
@@ -100,43 +191,328 @@
 		return this;
 	}
 
-	public static Biome getBiomeFromLookup(double var0, double var2) {
-		int var4 = (int)(var0 * 63.0D);
-		int var5 = (int)(var2 * 63.0D);
-		return biomeLookupTable[var4 + var5 * 64];
-	}
-
-	public static Biome getBiome(float var0, float var1) {
-		var1 *= var0;
-		return var0 < 0.1F ? tundra : (var1 < 0.2F ? (var0 < 0.5F ? tundra : (var0 < 0.95F ? savanna : desert)) : (var1 > 0.5F && var0 < 0.7F ? swampland : (var0 < 0.5F ? taiga : (var0 < 0.97F ? (var1 < 0.35F ? shrubland : forest) : (var1 < 0.45F ? plains : (var1 < 0.9F ? seasonalForest : rainforest))))));
-	}
-
-	public int getSkyColorByTemp(float var1) {
-		var1 /= 3.0F;
-		if(var1 < -1.0F) {
-			var1 = -1.0F;
-		}
-
-		if(var1 > 1.0F) {
-			var1 = 1.0F;
-		}
-
-		return Color.getHSBColor(224.0F / 360.0F - var1 * 0.05F, 0.5F + var1 * 0.1F, 1.0F).getRGB();
-	}
-
-	public List getSpawnableList(SpawnableMobType var1) {
+	protected Biome setColoring(int grass, int foliage, int sky) {
+		if (grass >= 0 && this.mapColor == this.grassColor) this.mapColor = grass;
+		if (grass >= 0) this.grassColor = grass;
+		if (foliage >= 0) this.foliageColor = foliage;
+		if (sky >= 0) this.skyColor = sky;
+		return this;
+	}
+
+	private void addVariant(Biome biome, int rarity, int size) {
+		if (this.variants[size] == null) {
+			this.variants[size] = new ArrayList<>();
+		}
+		this.variants[size].add(new Variant(biome, rarity));
+	}
+
+	public static Biome getBiomeFromLookup(double var0, double var2, double ocean) {
+		if (ocean < -0.3D) {
+			return Biome.ocean;
+		} else if (ocean < 0.0D) {
+			return Biome.beach;
+		}
+
+		return plains;
+	}
+
+	public Biome getVariant(int size, IntUnaryOperator rand) {
+		List<Variant> variants = this.variants[size];
+		if (variants == null) return this;
+
+		Biome biome = this;
+		for (Variant variant : variants) {
+			if (rand.applyAsInt(variant.rarity) == 0) {
+				biome = variant.biome;
+			}
+		}
+		return biome;
+	}
+
+	public int getSkyColorByTemp(float var1, float var2) {
+		return Color.getHSBColor(
+				MathHelper.floorMod(224.0F / 360.0F - (var1 - 0.5F) * 0.1F, 1.0F),
+				MathHelper.clamp(0.5F + (var2 - 0.5F) * 0.1F, 0.0F, 1.0F),
+				MathHelper.clamp(1.0F + (var2 - 0.5F) * 0.1F, 0.0F, 1.0F)
+		).getRGB();
+	}
+
+	public List<SpawnListEntry> getSpawnableList(SpawnableMobType var1) {
 		return var1 == SpawnableMobType.monster ? this.spawnableMonsterList : (var1 == SpawnableMobType.creature ? this.spawnableCreatureList : (var1 == SpawnableMobType.waterCreature ? this.spawnableWaterCreatureList : null));
 	}
 
+	public void decorate(PopulatorHost populator) {
+	}
+
 	public boolean getEnableSnow() {
 		return this.enableSnow;
 	}
 
 	public boolean canSpawnLightningBolt() {
-		return this.enableSnow ? false : this.enableRain;
-	}
-
-	static {
-		generateBiomeLookup();
+		return !this.enableSnow && this.enableRain;
+	}
+
+	public NoiseSettings getNoiseSettings(int x, int z, double boost, double ocean, double edge) {
+		return new NoiseSettings(this.minNoiseSettings, this.maxNoiseSettings, boost);
+	}
+
+	public int getGrassColor() {
+		return this.grassColor;
+	}
+
+	public int getFoliageColor() {
+		return this.foliageColor;
+	}
+
+	public int getSkyColor() {
+		return this.skyColor;
+	}
+
+	public boolean hasBeach() {
+		return this.hasBeach;
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		this.buildDefaultSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+	}
+
+	private void buildDefaultSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		int wx = chunk.xPosition * 16 + x;
+		int wz = chunk.zPosition * 16 + z;
+
+		int topBlock = this.topBlock;
+		int topMeta = this.topMeta;
+		int fillerBlock = this.fillerBlock;
+		int fillerMeta = this.fillerMeta;
+		int stoneBlock = this.stoneBlock;
+		int stoneMeta = this.stoneMeta;
+		int baseErosion = (int)(erosionNoise.generateNoise2D(wx / 16.0D, wz / 16.0D) / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+		int erosion = -1;
+
+		for (int y = chunk.getMaxY(); y >= chunk.getMinY(); --y) {
+			if(y - chunk.getMinY() <= random.nextInt(5)) {
+				chunk.setBlockRaw(x, y, z, Block.bedrock.blockID);
+			} else {
+				int block = chunk.getBlockID(x, y, z);
+				if(block == 0) {
+					erosion = -1;
+				} else if(block == Block.stone.blockID) {
+					if(erosion == -1) {
+						if(baseErosion <= 0) {
+							topBlock = 0;
+							topMeta = 0;
+							fillerBlock = this.stoneBlock;
+							fillerMeta = this.stoneMeta;
+						} else if (y >= seaLevel - 4 && y <= seaLevel) {
+							topBlock = this.topBlock;
+							topMeta = this.topMeta;
+							fillerBlock = this.fillerBlock;
+							fillerMeta = this.fillerMeta;
+						}
+
+						erosion = baseErosion;
+						if(y >= 63) {
+							chunk.setBlockRaw(x, y, z, topBlock);
+							chunk.setBlockMetadata(x, y, z, topMeta);
+						} else {
+							chunk.setBlockRaw(x, y, z, fillerBlock);
+							chunk.setBlockMetadata(x, y, z, fillerMeta);
+						}
+					} else if(erosion > 0) {
+						--erosion;
+						chunk.setBlockRaw(x, y, z, fillerBlock);
+						chunk.setBlockMetadata(x, y, z, fillerMeta);
+						if(erosion == 0 && fillerBlock == Block.sand.blockID) {
+							erosion = random.nextInt(4);
+							fillerBlock = Block.sandstone.blockID;
+						}
+					} else {
+						chunk.setBlockRaw(x, y, z, stoneBlock);
+						chunk.setBlockMetadata(x, y, z, stoneMeta);
+					}
+				}
+			}
+		}
+	}
+
+	private static void registerClimateZones() {
+		registerFrozenClimateZones();
+		registerColdClimateZones();
+		registerTemperateClimateZones();
+		registerWarmClimateZones();
+		registerHotClimateZones();
+	}
+
+	private static void registerFrozenClimateZones() {
+		climateZones[0 * 5 + 0] = new Biome[] {
+				tundra,
+				frostyMountains,
+				frostyMountains,
+		};
+		climateZones[0 * 5 + 1] = new Biome[] {
+				tundra,
+				frostyMountains,
+				tundra,
+				snowyTaiga,
+		};
+		climateZones[0 * 5 + 2] = new Biome[] {
+				tundra,
+				snowyTaiga,
+				frostyMountains,
+				tundra,
+				snowyTaiga,
+		};
+		climateZones[0 * 5 + 3] = new Biome[] {
+				tundra,
+				snowyTaiga,
+				snowyTaiga,
+				frostyMountains,
+		};
+		climateZones[0 * 5 + 4] = new Biome[] {
+				snowyTaiga,
+				frostyMountains,
+		};
+	}
+
+	private static void registerColdClimateZones() {
+		climateZones[1 * 5 + 0] = new Biome[] {
+				rockyValley,
+				mountains
+		};
+		climateZones[1 * 5 + 1] = new Biome[] {
+				taiga,
+				rockyValley,
+				mountains
+		};
+		climateZones[1 * 5 + 2] = new Biome[] {
+				taiga,
+				taiga,
+				rockyValley,
+				mountains
+		};
+		climateZones[1 * 5 + 3] = new Biome[] {
+				taiga,
+				taiga,
+				taiga,
+				rockyValley,
+				mountains,
+				mountains,
+		};
+		climateZones[1 * 5 + 4] = new Biome[] {
+				taiga,
+				taiga,
+				rockyValley,
+				mountains,
+				mountains,
+		};
+	}
+
+	private static void registerTemperateClimateZones() {
+		climateZones[2 * 5 + 0] = new Biome[] {
+				plains,
+				forest,
+				plains,
+				mountains,
+				rockyValley
+		};
+		climateZones[2 * 5 + 1] = new Biome[] {
+				plains,
+				forest,
+		};
+		climateZones[2 * 5 + 2] = new Biome[] {
+				plains,
+				plains,
+				forest,
+				forest,
+				bloomingForest,
+				freshwaterForest
+		};
+		climateZones[2 * 5 + 3] = new Biome[] {
+				plains,
+				forest,
+				forest,
+				bloomingForest,
+				freshwaterForest
+		};
+		climateZones[2 * 5 + 4] = new Biome[] {
+				forest,
+				bloomingForest,
+				freshwaterForest,
+				freshwaterForest,
+				swamp
+		};
+	}
+
+	private static void registerWarmClimateZones() {
+		climateZones[3 * 5 + 0] = new Biome[] {
+				savanna,
+				bloomingForest,
+				plains
+		};
+		climateZones[3 * 5 + 1] = new Biome[] {
+				savanna,
+				bloomingForest,
+				forest,
+				plains
+		};
+		climateZones[3 * 5 + 2] = new Biome[] {
+				bloomingForest,
+				mapleForest,
+				forest,
+				plains,
+				swamp,
+				swamp
+		};
+		climateZones[3 * 5 + 3] = new Biome[] {
+				mapleForest,
+				bloomingForest,
+				swamp
+		};
+		climateZones[3 * 5 + 4] = new Biome[] {
+				mapleForest,
+				mapleForest,
+		};
+	}
+
+	private static void registerHotClimateZones() {
+		climateZones[4 * 5 + 0] = new Biome[] {
+				desert,
+				desert,
+				badlands
+		};
+		climateZones[4 * 5 + 1] = new Biome[] {
+				desert,
+				badlands,
+				savanna
+		};
+		climateZones[4 * 5 + 2] = new Biome[] {
+				savanna,
+				savanna,
+				desert,
+				rainforest
+		};
+		climateZones[4 * 5 + 3] = new Biome[] {
+				savanna,
+				rainforest,
+				rainforest,
+				mapleForest,
+				swamp
+		};
+		climateZones[4 * 5 + 4] = new Biome[] {
+				rainforest,
+				rainforest,
+				rainforest,
+				swamp
+		};
+	}
+
+	private static class Variant {
+		public final Biome biome;
+		public final int rarity;
+
+		public Variant(Biome biome, int rarity) {
+			this.biome = biome;
+			this.rarity = rarity;
+		}
 	}
 }
--- net/minecraft/client/PanelCrashReport.java
+++ net/minecraft/client/PanelCrashReport.java
@@ -25,7 +25,7 @@
 		try {
 			var5 = var5 + "Generated " + (new SimpleDateFormat()).format(new Date()) + "\n";
 			var5 = var5 + "\n";
-			var5 = var5 + "Minecraft: Minecraft Beta 1.7.3\n";
+			var5 = var5 + "Minecraft: " + Minecraft.VERSION + "\n";
 			var5 = var5 + "OS: " + System.getProperty("os.name") + " (" + System.getProperty("os.arch") + ") version " + System.getProperty("os.version") + "\n";
 			var5 = var5 + "Java: " + System.getProperty("java.version") + ", " + System.getProperty("java.vendor") + "\n";
 			var5 = var5 + "VM: " + System.getProperty("java.vm.name") + " (" + System.getProperty("java.vm.info") + "), " + System.getProperty("java.vm.vendor") + "\n";
@@ -75,7 +75,7 @@
 		var6 = var6 + "\n";
 		var6 = var6 + "\n";
 		TextArea var7 = new TextArea(var6, 0, 0, 1);
-		var7.setFont(new Font("Monospaced", 0, 12));
+		var7.setFont(new Font("Monospaced", Font.PLAIN, 12));
 		this.add(new CanvasMojangLogo(), "North");
 		this.add(new CanvasCrashReport(80), "East");
 		this.add(new CanvasCrashReport(80), "West");
--- argo/J_JsonArrayNodeBuilder.java
+++ /dev/null
@@ -1,30 +1,0 @@
-package argo;
-
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-
-public final class J_JsonArrayNodeBuilder implements J_JsonNodeBuilder {
-	private final List field_27242_a = new LinkedList();
-
-	public J_JsonArrayNodeBuilder func_27240_a(J_JsonNodeBuilder var1) {
-		this.field_27242_a.add(var1);
-		return this;
-	}
-
-	public J_JsonRootNode func_27241_a() {
-		LinkedList var1 = new LinkedList();
-		Iterator var2 = this.field_27242_a.iterator();
-
-		while(var2.hasNext()) {
-			J_JsonNodeBuilder var3 = (J_JsonNodeBuilder)var2.next();
-			var1.add(var3.func_27234_b());
-		}
-
-		return J_JsonNodeFactories.func_27309_a(var1);
-	}
-
-	public J_JsonNode func_27234_b() {
-		return this.func_27241_a();
-	}
-}
--- net/minecraft/game/world/terrain/feature/BirchTreeFeature.java
+++ net/minecraft/game/world/terrain/feature/BirchTreeFeature.java
@@ -5,76 +5,74 @@
 import net.minecraft.game.world.block.Block;
 
 public class BirchTreeFeature extends Feature {
+	private final boolean boost;
+
+	public BirchTreeFeature() {
+		this(false);
+	}
+
+	public BirchTreeFeature(boolean boost) {
+		this.boost = boost;
+	}
+
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
-		int var6 = var2.nextInt(3) + 5;
+		int var6 = var2.nextInt(this.boost ? 9 : 3) + 5;
 		boolean var7 = true;
-		if(var4 >= 1 && var4 + var6 + 1 <= 128) {
-			int var8;
-			int var10;
-			int var11;
-			int var12;
-			for(var8 = var4; var8 <= var4 + 1 + var6; ++var8) {
-				byte var9 = 1;
-				if(var8 == var4) {
-					var9 = 0;
-				}
-
-				if(var8 >= var4 + 1 + var6 - 2) {
-					var9 = 2;
-				}
-
-				for(var10 = var3 - var9; var10 <= var3 + var9 && var7; ++var10) {
-					for(var11 = var5 - var9; var11 <= var5 + var9 && var7; ++var11) {
-						if(var8 >= 0 && var8 < 128) {
-							var12 = var1.getBlockId(var10, var8, var11);
-							if(var12 != 0 && var12 != Block.leaves.blockID) {
-								var7 = false;
-							}
-						} else {
-							var7 = false;
-						}
-					}
-				}
-			}
-
-			if(!var7) {
-				return false;
-			} else {
-				var8 = var1.getBlockId(var3, var4 - 1, var5);
-				if((var8 == Block.grass.blockID || var8 == Block.dirt.blockID) && var4 < 128 - var6 - 1) {
-					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
-
-					int var16;
-					for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
-						var10 = var16 - (var4 + var6);
-						var11 = 1 - var10 / 2;
-
-						for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
-							int var13 = var12 - var3;
-
-							for(int var14 = var5 - var11; var14 <= var5 + var11; ++var14) {
-								int var15 = var14 - var5;
-								if((Math.abs(var13) != var11 || Math.abs(var15) != var11 || var2.nextInt(2) != 0 && var10 != 0) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var16, var14)]) {
-									var1.setBlockAndMetadata(var12, var16, var14, Block.leaves.blockID, 2);
-								}
-							}
-						}
-					}
-
-					for(var16 = 0; var16 < var6; ++var16) {
-						var10 = var1.getBlockId(var3, var4 + var16, var5);
-						if(var10 == 0 || var10 == Block.leaves.blockID) {
-							var1.setBlockAndMetadata(var3, var4 + var16, var5, Block.log.blockID, 2);
-						}
-					}
-
-					return true;
-				} else {
-					return false;
-				}
-			}
-		} else {
+		int var8;
+		int var10;
+		int var11;
+		int var12;
+		for(var8 = var4; var8 <= var4 + 1 + var6; ++var8) {
+			byte var9 = 1;
+			if(var8 == var4) {
+				var9 = 0;
+			}
+
+			if(var8 >= var4 + 1 + var6 - 2) {
+				var9 = 2;
+			}
+
+			for(var10 = var3 - var9; var10 <= var3 + var9 && var7; ++var10) {
+				for(var11 = var5 - var9; var11 <= var5 + var9 && var7; ++var11) {
+					var12 = var1.getBlockId(var10, var8, var11);
+					if(var12 != 0 && var12 != Block.leaves.blockID) {
+						var7 = false;
+					}
+				}
+			}
+		}
+
+		if(!var7) {
 			return false;
+		} else {
+			if (!Block.sapling.canPlaceBlockAt(var1, var3, var4, var5)) return false;
+			if (var1.getBlockId(var3, var4 - 1, var5) == Block.grass.blockID) var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+
+			int var16;
+			for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
+				var10 = var16 - (var4 + var6);
+				var11 = 1 - var10 / 2;
+
+				for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
+					int var13 = var12 - var3;
+
+					for(int var14 = var5 - var11; var14 <= var5 + var11; ++var14) {
+						int var15 = var14 - var5;
+						if((Math.abs(var13) != var11 || Math.abs(var15) != var11 || var2.nextInt(2) != 0 && var10 != 0) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var16, var14)]) {
+							var1.setBlockAndMetadata(var12, var16, var14, Block.leaves.blockID, 2);
+						}
+					}
+				}
+			}
+
+			for(var16 = 0; var16 < var6; ++var16) {
+				var10 = var1.getBlockId(var3, var4 + var16, var5);
+				if(var10 == 0 || var10 == Block.leaves.blockID) {
+					var1.setBlockAndMetadata(var3, var4 + var16, var5, Block.log.blockID, 2);
+				}
+			}
+
+			return true;
 		}
 	}
 }
--- net/minecraft/game/item/recipe/CraftingManager.java
+++ net/minecraft/game/item/recipe/CraftingManager.java
@@ -11,7 +11,7 @@
 
 public class CraftingManager {
 	private static final CraftingManager instance = new CraftingManager();
-	private List recipes = new ArrayList();
+	private final List recipes = new ArrayList();
 
 	public static final CraftingManager getInstance() {
 		return instance;
@@ -25,63 +25,66 @@
 		(new RecipesCrafting()).addRecipes(this);
 		(new RecipesArmor()).addRecipes(this);
 		(new RecipesDyes()).addRecipes(this);
-		this.addRecipe(new ItemStack(Item.paper, 3), new Object[]{"###", Character.valueOf('#'), Item.sugarCane});
-		this.addRecipe(new ItemStack(Item.book, 1), new Object[]{"#", "#", "#", Character.valueOf('#'), Item.paper});
-		this.addRecipe(new ItemStack(Block.fence, 2), new Object[]{"###", "###", Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Block.jukebox, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Item.diamond});
-		this.addRecipe(new ItemStack(Block.noteBlock, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Item.redstone});
-		this.addRecipe(new ItemStack(Block.bookshelf, 1), new Object[]{"###", "XXX", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Item.book});
-		this.addRecipe(new ItemStack(Block.snow, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.snowball});
-		this.addRecipe(new ItemStack(Block.clayBlock, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.clay});
-		this.addRecipe(new ItemStack(Block.brick, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.brick});
-		this.addRecipe(new ItemStack(Block.glowstone, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.glowstoneDust});
-		this.addRecipe(new ItemStack(Block.wool, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.string});
-		this.addRecipe(new ItemStack(Block.tnt, 1), new Object[]{"X#X", "#X#", "X#X", Character.valueOf('X'), Item.gunpowder, Character.valueOf('#'), Block.sand});
-		this.addRecipe(new ItemStack(Block.stoneSlab, 3, 3), new Object[]{"###", Character.valueOf('#'), Block.cobblestone});
-		this.addRecipe(new ItemStack(Block.stoneSlab, 3, 0), new Object[]{"###", Character.valueOf('#'), Block.stone});
-		this.addRecipe(new ItemStack(Block.stoneSlab, 3, 1), new Object[]{"###", Character.valueOf('#'), Block.sandstone});
-		this.addRecipe(new ItemStack(Block.stoneSlab, 3, 2), new Object[]{"###", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.ladder, 2), new Object[]{"# #", "###", "# #", Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Item.door, 1), new Object[]{"##", "##", "##", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.trapdoor, 2), new Object[]{"###", "###", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Item.ironDoor, 1), new Object[]{"##", "##", "##", Character.valueOf('#'), Item.ironIngot});
-		this.addRecipe(new ItemStack(Item.sign, 1), new Object[]{"###", "###", " X ", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Item.stick});
-		this.addRecipe(new ItemStack(Item.cake, 1), new Object[]{"AAA", "BEB", "CCC", Character.valueOf('A'), Item.milkBucket, Character.valueOf('B'), Item.sugar, Character.valueOf('C'), Item.wheat, Character.valueOf('E'), Item.egg});
-		this.addRecipe(new ItemStack(Item.sugar, 1), new Object[]{"#", Character.valueOf('#'), Item.sugarCane});
-		this.addRecipe(new ItemStack(Block.planks, 4), new Object[]{"#", Character.valueOf('#'), Block.log});
-		this.addRecipe(new ItemStack(Item.stick, 4), new Object[]{"#", "#", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.torch, 4), new Object[]{"X", "#", Character.valueOf('X'), Item.coal, Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Block.torch, 4), new Object[]{"X", "#", Character.valueOf('X'), new ItemStack(Item.coal, 1, 1), Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Item.bowlEmpty, 4), new Object[]{"# #", " # ", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.rail, 16), new Object[]{"X X", "X#X", "X X", Character.valueOf('X'), Item.ironIngot, Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Block.poweredRail, 6), new Object[]{"X X", "X#X", "XRX", Character.valueOf('X'), Item.goldIngot, Character.valueOf('R'), Item.redstone, Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Block.detectorRail, 6), new Object[]{"X X", "X#X", "XRX", Character.valueOf('X'), Item.ironIngot, Character.valueOf('R'), Item.redstone, Character.valueOf('#'), Block.stonePressurePlate});
-		this.addRecipe(new ItemStack(Item.minecart, 1), new Object[]{"# #", "###", Character.valueOf('#'), Item.ironIngot});
-		this.addRecipe(new ItemStack(Block.jackOLantern, 1), new Object[]{"A", "B", Character.valueOf('A'), Block.pumpkin, Character.valueOf('B'), Block.torch});
-		this.addRecipe(new ItemStack(Item.minecartWithChest, 1), new Object[]{"A", "B", Character.valueOf('A'), Block.chest, Character.valueOf('B'), Item.minecart});
-		this.addRecipe(new ItemStack(Item.minecartWithFurnace, 1), new Object[]{"A", "B", Character.valueOf('A'), Block.furnace, Character.valueOf('B'), Item.minecart});
-		this.addRecipe(new ItemStack(Item.boat, 1), new Object[]{"# #", "###", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Item.emptyBucket, 1), new Object[]{"# #", " # ", Character.valueOf('#'), Item.ironIngot});
-		this.addRecipe(new ItemStack(Item.flintAndSteel, 1), new Object[]{"A ", " B", Character.valueOf('A'), Item.ironIngot, Character.valueOf('B'), Item.flint});
-		this.addRecipe(new ItemStack(Item.bread, 1), new Object[]{"###", Character.valueOf('#'), Item.wheat});
-		this.addRecipe(new ItemStack(Block.woodenStairs, 4), new Object[]{"#  ", "## ", "###", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Item.fishingRod, 1), new Object[]{"  #", " #X", "# X", Character.valueOf('#'), Item.stick, Character.valueOf('X'), Item.string});
-		this.addRecipe(new ItemStack(Block.cobblestoneStairs, 4), new Object[]{"#  ", "## ", "###", Character.valueOf('#'), Block.cobblestone});
-		this.addRecipe(new ItemStack(Item.painting, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Item.stick, Character.valueOf('X'), Block.wool});
-		this.addRecipe(new ItemStack(Item.goldenApple, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.goldBlock, Character.valueOf('X'), Item.apple});
-		this.addRecipe(new ItemStack(Block.lever, 1), new Object[]{"X", "#", Character.valueOf('#'), Block.cobblestone, Character.valueOf('X'), Item.stick});
-		this.addRecipe(new ItemStack(Block.redstoneTorchOn, 1), new Object[]{"X", "#", Character.valueOf('#'), Item.stick, Character.valueOf('X'), Item.redstone});
-		this.addRecipe(new ItemStack(Item.redstoneRepeater, 1), new Object[]{"#X#", "III", Character.valueOf('#'), Block.redstoneTorchOn, Character.valueOf('X'), Item.redstone, Character.valueOf('I'), Block.stone});
-		this.addRecipe(new ItemStack(Item.clock, 1), new Object[]{" # ", "#X#", " # ", Character.valueOf('#'), Item.goldIngot, Character.valueOf('X'), Item.redstone});
-		this.addRecipe(new ItemStack(Item.compass, 1), new Object[]{" # ", "#X#", " # ", Character.valueOf('#'), Item.ironIngot, Character.valueOf('X'), Item.redstone});
-		this.addRecipe(new ItemStack(Item.map, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Item.paper, Character.valueOf('X'), Item.compass});
-		this.addRecipe(new ItemStack(Block.button, 1), new Object[]{"#", "#", Character.valueOf('#'), Block.stone});
-		this.addRecipe(new ItemStack(Block.stonePressurePlate, 1), new Object[]{"##", Character.valueOf('#'), Block.stone});
-		this.addRecipe(new ItemStack(Block.woodenPressurePlate, 1), new Object[]{"##", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.dispenser, 1), new Object[]{"###", "#X#", "#R#", Character.valueOf('#'), Block.cobblestone, Character.valueOf('X'), Item.bow, Character.valueOf('R'), Item.redstone});
-		this.addRecipe(new ItemStack(Block.piston, 1), new Object[]{"TTT", "#X#", "#R#", Character.valueOf('#'), Block.cobblestone, Character.valueOf('X'), Item.ironIngot, Character.valueOf('R'), Item.redstone, Character.valueOf('T'), Block.planks});
-		this.addRecipe(new ItemStack(Block.stickyPiston, 1), new Object[]{"S", "P", Character.valueOf('S'), Item.slimeBall, Character.valueOf('P'), Block.piston});
-		this.addRecipe(new ItemStack(Item.bed, 1), new Object[]{"###", "XXX", Character.valueOf('#'), Block.wool, Character.valueOf('X'), Block.planks});
+		this.addRecipe(new ItemStack(Item.paper, 3), "###", '#', Item.sugarCane);
+		this.addRecipe(new ItemStack(Item.book, 1), "#", "#", "#", '#', Item.paper);
+		this.addRecipe(new ItemStack(Block.fence, 2), "###", "###", '#', Item.stick);
+		this.addRecipe(new ItemStack(Block.jukebox, 1), "###", "#X#", "###", '#', Block.planks, 'X', Item.diamond);
+		this.addRecipe(new ItemStack(Block.noteBlock, 1), "###", "#X#", "###", '#', Block.planks, 'X', Item.redstone);
+		this.addRecipe(new ItemStack(Block.bookshelf, 1), "###", "XXX", "###", '#', Block.planks, 'X', Item.book);
+		this.addRecipe(new ItemStack(Block.snow, 1), "##", "##", '#', Item.snowball);
+		this.addRecipe(new ItemStack(Block.clayBlock, 1), "##", "##", '#', Item.clay);
+		this.addRecipe(new ItemStack(Block.brick, 1), "##", "##", '#', Item.brick);
+		this.addRecipe(new ItemStack(Block.glowstone, 1), "##", "##", '#', Item.glowstoneDust);
+		this.addRecipe(new ItemStack(Block.wool, 1), "##", "##", '#', Item.string);
+		this.addRecipe(new ItemStack(Block.tnt, 1), "X#X", "#X#", "X#X", 'X', Item.gunpowder, '#', Block.sand);
+		this.addRecipe(new ItemStack(Block.stoneSlab, 6, 3), "###", '#', Block.cobblestone);
+		this.addRecipe(new ItemStack(Block.stoneSlab, 6, 0), "###", '#', Block.stone);
+		this.addRecipe(new ItemStack(Block.stoneSlab, 6, 1), "###", '#', Block.sandstone);
+		this.addRecipe(new ItemStack(Block.stoneSlab, 6, 2), "###", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.ladder, 2), "# #", "###", "# #", '#', Item.stick);
+		this.addRecipe(new ItemStack(Item.door, 1), "##", "##", "##", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.trapdoor, 2), "###", "###", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.ironDoor, 1), "##", "##", "##", '#', Item.ironIngot);
+		this.addRecipe(new ItemStack(Item.sign, 1), "###", "###", " X ", '#', Block.planks, 'X', Item.stick);
+		this.addRecipe(new ItemStack(Item.cake, 1), "AAA", "BEB", "CCC", 'A', Item.milkBucket, 'B', Item.sugar, 'C', Item.wheat, 'E', Item.egg);
+		this.addRecipe(new ItemStack(Item.sugar, 1), "#", '#', Item.sugarCane);
+		this.addRecipe(new ItemStack(Block.planks, 4, 0), "#", '#', new ItemStack(Block.log, 1, 0));
+		this.addRecipe(new ItemStack(Block.planks, 4, 1), "#", '#', new ItemStack(Block.log, 1, 1));
+		this.addRecipe(new ItemStack(Block.planks, 4, 2), "#", '#', new ItemStack(Block.log, 1, 2));
+		this.addRecipe(new ItemStack(Block.planks, 4, 3), "#", '#', new ItemStack(Block.log, 1, 3));
+		this.addRecipe(new ItemStack(Item.stick, 4), "#", "#", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.torch, 4), "X", "#", 'X', Item.coal, '#', Item.stick);
+		this.addRecipe(new ItemStack(Block.torch, 4), "X", "#", 'X', new ItemStack(Item.coal, 1, 1), '#', Item.stick);
+		this.addRecipe(new ItemStack(Item.bowlEmpty, 4), "# #", " # ", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.rail, 16), "X X", "X#X", "X X", 'X', Item.ironIngot, '#', Item.stick);
+		this.addRecipe(new ItemStack(Block.poweredRail, 6), "X X", "X#X", "XRX", 'X', Item.goldIngot, 'R', Item.redstone, '#', Item.stick);
+		this.addRecipe(new ItemStack(Block.detectorRail, 6), "X X", "X#X", "XRX", 'X', Item.ironIngot, 'R', Item.redstone, '#', Block.stonePressurePlate);
+		this.addRecipe(new ItemStack(Item.minecart, 1), "# #", "###", '#', Item.ironIngot);
+		this.addRecipe(new ItemStack(Block.jackOLantern, 1), "A", "B", 'A', Block.pumpkin, 'B', Block.torch);
+		this.addRecipe(new ItemStack(Item.minecartWithChest, 1), "A", "B", 'A', Block.chest, 'B', Item.minecart);
+		this.addRecipe(new ItemStack(Item.minecartWithFurnace, 1), "A", "B", 'A', Block.furnace, 'B', Item.minecart);
+		this.addRecipe(new ItemStack(Item.boat, 1), "# #", "###", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.emptyBucket, 1), "# #", " # ", '#', Item.ironIngot);
+		this.addRecipe(new ItemStack(Item.flintAndSteel, 1), "A ", " B", 'A', Item.ironIngot, 'B', Item.flint);
+		this.addRecipe(new ItemStack(Item.bread, 1), "###", '#', Item.wheat);
+		this.addRecipe(new ItemStack(Block.woodenStairs, 8), "#  ", "## ", "###", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.fishingRod, 1), "  #", " #X", "# X", '#', Item.stick, 'X', Item.string);
+		this.addRecipe(new ItemStack(Block.cobblestoneStairs, 8), "#  ", "## ", "###", '#', Block.cobblestone);
+		this.addRecipe(new ItemStack(Item.painting, 1), "###", "#X#", "###", '#', Item.stick, 'X', Block.wool);
+		this.addRecipe(new ItemStack(Item.goldenApple, 1), "###", "#X#", "###", '#', Block.goldBlock, 'X', Item.apple);
+		this.addRecipe(new ItemStack(Block.lever, 1), "X", "#", '#', Block.cobblestone, 'X', Item.stick);
+		this.addRecipe(new ItemStack(Block.redstoneTorchOn, 1), "X", "#", '#', Item.stick, 'X', Item.redstone);
+		this.addRecipe(new ItemStack(Item.redstoneRepeater, 1), "#X#", "III", '#', Block.redstoneTorchOn, 'X', Item.redstone, 'I', Block.stone);
+		this.addRecipe(new ItemStack(Item.clock, 1), " # ", "#X#", " # ", '#', Item.goldIngot, 'X', Item.redstone);
+		this.addRecipe(new ItemStack(Item.compass, 1), " # ", "#X#", " # ", '#', Item.ironIngot, 'X', Item.redstone);
+		this.addRecipe(new ItemStack(Item.emptyMap, 1), "###", "#X#", "###", '#', Item.paper, 'X', Item.compass);
+		this.addRecipe(new ItemStack(Block.button, 1), "#", "#", '#', Block.stone);
+		this.addRecipe(new ItemStack(Block.stonePressurePlate, 1), "##", '#', Block.stone);
+		this.addRecipe(new ItemStack(Block.woodenPressurePlate, 1), "##", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.dispenser, 1), "###", "#X#", "#R#", '#', Block.cobblestone, 'X', Item.bow, 'R', Item.redstone);
+		this.addRecipe(new ItemStack(Block.piston, 1), "TTT", "#X#", "#R#", '#', Block.cobblestone, 'X', Item.ironIngot, 'R', Item.redstone, 'T', Block.planks);
+		this.addRecipe(new ItemStack(Block.stickyPiston, 1), "S", "P", 'S', Item.slimeBall, 'P', Block.piston);
+		this.addRecipe(new ItemStack(Item.bed, 1), "###", "XXX", '#', Block.wool, 'X', Block.planks);
 		Collections.sort(this.recipes, new RecipeSorter(this));
 		System.out.println(this.recipes.size() + " recipes");
 	}
@@ -92,7 +95,7 @@
 		int var5 = 0;
 		int var6 = 0;
 		if(var2[var4] instanceof String[]) {
-			String[] var11 = (String[])((String[])var2[var4++]);
+			String[] var11 = (String[]) var2[var4++];
 
 			for(int var8 = 0; var8 < var11.length; ++var8) {
 				String var9 = var11[var8];
@@ -128,8 +131,8 @@
 
 		for(int var16 = 0; var16 < var5 * var6; ++var16) {
 			char var10 = var3.charAt(var16);
-			if(var12.containsKey(Character.valueOf(var10))) {
-				var14[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
+			if(var12.containsKey(var10)) {
+				var14[var16] = ((ItemStack)var12.get(var10)).copy();
 			} else {
 				var14[var16] = null;
 			}
@@ -151,7 +154,7 @@
 				var3.add(new ItemStack((Item)var7));
 			} else {
 				if(!(var7 instanceof Block)) {
-					throw new RuntimeException("Invalid shapeless recipy!");
+					throw new RuntimeException("Invalid shapeless recipe!");
 				}
 
 				var3.add(new ItemStack((Block)var7));
--- net/minecraft/client/player/ClientPlayerEntity.java
+++ net/minecraft/client/player/ClientPlayerEntity.java
@@ -29,20 +29,21 @@
 	private MouseFilter field_21903_bJ = new MouseFilter();
 	private MouseFilter field_21904_bK = new MouseFilter();
 	private MouseFilter field_21902_bL = new MouseFilter();
+	private int flyToggleTimer;
 
 	public ClientPlayerEntity(Minecraft var1, World var2, Session var3, int var4) {
 		super(var2);
 		this.mc = var1;
 		this.dimension = var4;
-		if(var3 != null && var3.username != null && var3.username.length() > 0) {
-			this.skinUrl = "http://s3.amazonaws.com/MinecraftSkins/" + var3.username + ".png";
+
+		if (var3 != null && var3.username != null && !var3.username.isEmpty()) {
+			this.username = var3.username;
+			this.updateCloak();
 		}
-
-		this.username = var3.username;
 	}
 
-	public void moveEntity(double var1, double var3, double var5) {
-		super.moveEntity(var1, var3, var5);
+	public boolean moveInRemoteWorld() {
+		return true;
 	}
 
 	public void updatePlayerActionState() {
@@ -53,6 +54,10 @@
 	}
 
 	public void onLivingUpdate() {
+		if(this.flyToggleTimer > 0) {
+			--this.flyToggleTimer;
+		}
+
 		if(!this.mc.statFileWriter.hasAchievementUnlocked(AchievementList.openInventory)) {
 			this.mc.guiAchievement.queueAchievementInformation(AchievementList.openInventory);
 		}
@@ -96,7 +101,17 @@
 			--this.timeUntilPortal;
 		}
 
+		boolean prevJump = this.movementInput.jump;
 		this.movementInput.updatePlayerMoveState(this);
+		if(this.creative && this.movementInput.jump && !prevJump) {
+			if(this.flyToggleTimer == 0) {
+				this.flyToggleTimer = 7;
+			} else {
+				this.flying = !this.flying;
+				this.flyToggleTimer = 0;
+			}
+		}
+
 		if(this.movementInput.sneak && this.ySize < 0.2F) {
 			this.ySize = 0.2F;
 		}
@@ -166,6 +181,12 @@
 		return this.movementInput.sneak && !this.sleeping;
 	}
 
+	public boolean isRunning() {
+		return this.movementInput.run
+				&& !this.energyRegen
+				&& (this.flying || this.movementInput.moveForward > 0.0F);
+	}
+
 	public void setHealth(int var1) {
 		int var2 = this.health - var1;
 		if(var2 <= 0) {
@@ -268,5 +289,12 @@
 		}
 
 		return false;
+	}
+
+	public float getFovBoost() {
+		float fovBoost = 1.0F;
+		if (this.flying) fovBoost *= 1.1F;
+		if (this.isRunning()) fovBoost *= 1.05F + this.energy / 200.0F;
+		return fovBoost;
 	}
 }
--- net/minecraft/game/world/block/FurnaceBlock.java
+++ net/minecraft/game/world/block/FurnaceBlock.java
@@ -7,12 +7,22 @@
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
 import net.minecraft.game.world.block.tileentity.FurnaceTileEntity;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
 import net.minecraft.util.MathHelper;
 
 public class FurnaceBlock extends ContainerBlock {
+	private static final int TEX_SIDE = TerrainLayout.texCoord("stone_util_side");
+	private static final int TEX_TOP = TerrainLayout.texCoord("stone_util_top");
+	private static final int TEX_FRONT = TerrainLayout.texCoord("furnace");
+	private static final int TEX_FRONT_ACTIVE = TerrainLayout.texCoord("furnace_lit");
+
+	public static final EnumProperty<Direction> DIRECTION = SharedProperties.DIRECTION;
+
 	private Random random = new Random();
 	private final boolean isActive;
 	private static boolean keepFurnaceInventory = false;
@@ -20,7 +30,11 @@
 	protected FurnaceBlock(int var1, boolean var2) {
 		super(var1, Material.stone);
 		this.isActive = var2;
-		this.textureIndex = 45;
+		this.textureIndex = TEX_SIDE;
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION);
 	}
 
 	public int idDropped(int var1, Random var2) {
@@ -60,13 +74,11 @@
 	}
 
 	public int getBlockTexture(BlockAccess var1, int var2, int var3, int var4, int var5) {
-		if(var5 == 1) {
-			return this.textureIndex + 17;
-		} else if(var5 == 0) {
-			return this.textureIndex + 17;
+		if(var5 < 2) {
+			return TEX_TOP;
 		} else {
 			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			return var5 != var6 ? this.textureIndex : (this.isActive ? this.textureIndex + 16 : this.textureIndex - 1);
+			return var5 != var6 ? TEX_SIDE : this.isActive ? TEX_FRONT_ACTIVE : TEX_FRONT;
 		}
 	}
 
@@ -96,7 +108,7 @@
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex + 17 : (var1 == 0 ? this.textureIndex + 17 : (var1 == 3 ? this.textureIndex - 1 : this.textureIndex));
+		return var1 < 2 ? TEX_TOP : var1 == 3 ? (this.isActive ? TEX_FRONT_ACTIVE : TEX_FRONT) : TEX_SIDE;
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, PlayerEntity var5) {
--- net/minecraft/client/effect/EntityDiggingFX.java
+++ net/minecraft/client/effect/EntityDiggingFX.java
@@ -3,6 +3,7 @@
 import net.minecraft.client.render.Tessellator;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.block.TerrainLayout;
 
 public class EntityDiggingFX extends EntityFX {
 	private Block field_4082_a;
@@ -12,6 +13,12 @@
 		super(var1, var2, var4, var6, var8, var10, var12);
 		this.field_4082_a = var14;
 		this.particleTextureIndex = var14.getBlockTextureFromSideAndMetadata(0, var16);
+		if (this.particleTextureIndex >= 1024) {
+			int[] tex = TerrainLayout.getMultiTexture(this.particleTextureIndex - 1024);
+			if (tex != null && tex.length > 0) {
+				this.particleTextureIndex = tex[0];
+			}
+		}
 		this.particleGravity = var14.particleGravity;
 		this.particleRed = this.particleGreen = this.particleBlue = 0.6F;
 		this.particleScale /= 2.0F;
@@ -35,10 +42,10 @@
 	}
 
 	public void renderParticle(Tessellator var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-		float var8 = ((float)(this.particleTextureIndex % 16) + this.particleTextureJitterX / 4.0F) / 16.0F;
-		float var9 = var8 + 0.999F / 64.0F;
-		float var10 = ((float)(this.particleTextureIndex / 16) + this.particleTextureJitterY / 4.0F) / 16.0F;
-		float var11 = var10 + 0.999F / 64.0F;
+		float var8 = ((float)(this.particleTextureIndex % 32) + this.particleTextureJitterX / 4.0F) / 32.0F;
+		float var9 = var8 + 0.999F / 128.0F;
+		float var10 = ((float)(this.particleTextureIndex / 32) + this.particleTextureJitterY / 4.0F) / 32.0F;
+		float var11 = var10 + 0.999F / 128.0F;
 		float var12 = 0.1F * this.particleScale;
 		float var13 = (float)(this.prevPosX + (this.posX - this.prevPosX) * (double)var2 - interpPosX);
 		float var14 = (float)(this.prevPosY + (this.posY - this.prevPosY) * (double)var2 - interpPosY);
--- net/minecraft/network/stats/StatFileWriter.java
+++ net/minecraft/network/stats/StatFileWriter.java
@@ -1,10 +1,10 @@
 package net.minecraft.network.stats;
 
-import argo.J_InvalidSyntaxException;
-import argo.J_JdomParser;
-import argo.J_JsonNode;
-import argo.J_JsonRootNode;
-import argo.J_JsonStringNode;
+import argo.saj.InvalidSyntaxException;
+import argo.jdom.JdomParser;
+import argo.jdom.JsonNode;
+import argo.jdom.JsonRootNode;
+import argo.jdom.JsonStringNode;
 import java.io.File;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -54,7 +54,7 @@
 	private void writeStatToMap(Map var1, StatBase var2, int var3) {
 		Integer var4 = (Integer)var1.get(var2);
 		int var5 = var4 == null ? 0 : var4.intValue();
-		var1.put(var2, Integer.valueOf(var5 + var3));
+		var1.put(var2, var5 + var3);
 	}
 
 	public Map func_27176_a() {
@@ -83,7 +83,7 @@
 				StatBase var3 = (StatBase)var2.next();
 				Integer var4 = (Integer)this.field_25101_b.get(var3);
 				int var5 = var4 == null ? 0 : var4.intValue();
-				this.field_25102_a.put(var3, Integer.valueOf(((Integer)var1.get(var3)).intValue() + var5));
+				this.field_25102_a.put(var3, ((Integer) var1.get(var3)).intValue() + var5);
 			}
 
 		}
@@ -108,33 +108,33 @@
 		try {
 			String var2 = "local";
 			StringBuilder var3 = new StringBuilder();
-			J_JsonRootNode var4 = (new J_JdomParser()).func_27367_a(var0);
-			List var5 = var4.func_27217_b(new Object[]{"stats-change"});
+			JsonRootNode var4 = (new JdomParser()).parse(var0);
+			List var5 = var4.getArrayNode("stats-change");
 			Iterator var6 = var5.iterator();
 
 			while(var6.hasNext()) {
-				J_JsonNode var7 = (J_JsonNode)var6.next();
+				JsonNode var7 = (JsonNode)var6.next();
 				Map var8 = var7.getFields();
 				Entry var9 = (Entry)var8.entrySet().iterator().next();
-				int var10 = Integer.parseInt(((J_JsonStringNode)var9.getKey()).getText());
-				int var11 = Integer.parseInt(((J_JsonNode)var9.getValue()).getText());
+				int var10 = Integer.parseInt(((JsonStringNode)var9.getKey()).getText());
+				int var11 = Integer.parseInt(((JsonNode)var9.getValue()).getText());
 				StatBase var12 = StatList.getStatFromId(var10);
 				if(var12 == null) {
 					System.out.println(var10 + " is not a valid stat");
 				} else {
 					var3.append(StatList.getStatFromId(var10).statGuid).append(",");
 					var3.append(var11).append(",");
-					var1.put(var12, Integer.valueOf(var11));
+					var1.put(var12, var11);
 				}
 			}
 
 			MD5String var14 = new MD5String(var2);
 			String var15 = var14.func_27369_a(var3.toString());
-			if(!var15.equals(var4.func_27213_a(new Object[]{"checksum"}))) {
+			if(!var15.equals(var4.getStringValue("checksum"))) {
 				System.out.println("CHECKSUM MISMATCH");
 				return null;
 			}
-		} catch (J_InvalidSyntaxException var13) {
+		} catch (InvalidSyntaxException var13) {
 			var13.printStackTrace();
 		}
 
--- argo/J_JsonNodeDoesNotMatchPathElementsException.java
+++ /dev/null
@@ -1,40 +1,0 @@
-package argo;
-
-public final class J_JsonNodeDoesNotMatchPathElementsException extends J_JsonNodeDoesNotMatchJsonNodeSelectorException {
-	private static final J_JsonFormatter field_27320_a = new J_CompactJsonFormatter();
-
-	static J_JsonNodeDoesNotMatchPathElementsException func_27319_a(J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, Object[] var1, J_JsonRootNode var2) {
-		return new J_JsonNodeDoesNotMatchPathElementsException(var0, var1, var2);
-	}
-
-	private J_JsonNodeDoesNotMatchPathElementsException(J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var1, Object[] var2, J_JsonRootNode var3) {
-		super(func_27318_b(var1, var2, var3));
-	}
-
-	private static String func_27318_b(J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, Object[] var1, J_JsonRootNode var2) {
-		return "Failed to find " + var0.field_27326_a.toString() + " at [" + J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException.func_27324_a(var0.field_27325_b) + "] while resolving [" + func_27317_a(var1) + "] in " + field_27320_a.func_27327_a(var2) + ".";
-	}
-
-	private static String func_27317_a(Object[] var0) {
-		StringBuilder var1 = new StringBuilder();
-		boolean var2 = true;
-		Object[] var3 = var0;
-		int var4 = var0.length;
-
-		for(int var5 = 0; var5 < var4; ++var5) {
-			Object var6 = var3[var5];
-			if(!var2) {
-				var1.append(".");
-			}
-
-			var2 = false;
-			if(var6 instanceof String) {
-				var1.append("\"").append(var6).append("\"");
-			} else {
-				var1.append(var6);
-			}
-		}
-
-		return var1.toString();
-	}
-}
--- /dev/null
+++ net/minecraft/game/world/biome/BiomeColorType.java
@@ -1,0 +1,7 @@
+package net.minecraft.game.world.biome;
+
+public enum BiomeColorType {
+	GRASS,
+	FOLIAGE,
+	SKY
+}
--- /dev/null
+++ argo/jdom/JsonObject.java
@@ -1,0 +1,48 @@
+package argo.jdom;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+final class JsonObject extends JsonRootNode {
+	private final Map<JsonStringNode, JsonNode> fields;
+
+	JsonObject(Map<JsonStringNode, JsonNode> var1) {
+		this.fields = new HashMap<>(var1);
+	}
+
+	public Map<JsonStringNode, JsonNode> getFields() {
+		return new HashMap<>(this.fields);
+	}
+
+	public JsonNodeType getType() {
+		return JsonNodeType.OBJECT;
+	}
+
+	public String getText() {
+		throw new IllegalStateException("Attempt to get text on a JsonNode without text.");
+	}
+
+	public List<JsonNode> getElements() {
+		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
+	}
+
+	public boolean equals(Object var1) {
+		if(this == var1) {
+			return true;
+		} else if(var1 != null && this.getClass() == var1.getClass()) {
+			JsonObject var2 = (JsonObject)var1;
+			return this.fields.equals(var2.fields);
+		} else {
+			return false;
+		}
+	}
+
+	public int hashCode() {
+		return this.fields.hashCode();
+	}
+
+	public String toString() {
+		return "JsonObject fields:[" + this.fields + "]";
+	}
+}
--- net/minecraft/client/gui/component/GuiSettingsSlider.java
+++ net/minecraft/client/gui/component/GuiSettingsSlider.java
@@ -10,7 +10,7 @@
 	private Option idFloat = null;
 
 	public GuiSettingsSlider(int var1, int var2, int var3, Option var4, String var5, float var6) {
-		super(var1, var2, var3, 150, 20, var5);
+		super(var1, var2, var3, 140, 20, var5);
 		this.idFloat = var4;
 		this.sliderValue = var6;
 	}
@@ -21,8 +21,12 @@
 
 	protected void mouseDragged(Minecraft var1, int var2, int var3) {
 		if(this.visible) {
+			int sx = this.getScaledX();
+			int sy = this.getScaledY();
+			int sw = this.getScaledWidth();
+
 			if(this.dragging) {
-				this.sliderValue = (float)(var2 - (this.xPosition + 4)) / (float)(this.width - 8);
+				this.sliderValue = (float)(var2 - (sx + 4)) / (float)(sw - 8);
 				if(this.sliderValue < 0.0F) {
 					this.sliderValue = 0.0F;
 				}
@@ -36,14 +40,16 @@
 			}
 
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-			this.drawTexturedRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)), this.yPosition, 0, 66, 4, 20);
-			this.drawTexturedRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)) + 4, this.yPosition, 196, 66, 4, 20);
+			this.drawTexturedRect(sx + (int)(this.sliderValue * (float)(sw - 8)), sy, 0, 66, 4, 20);
+			this.drawTexturedRect(sx + (int)(this.sliderValue * (float)(sw - 8)) + 4, sy, 196, 66, 4, 20);
 		}
 	}
 
 	public boolean mousePressed(Minecraft var1, int var2, int var3) {
 		if(super.mousePressed(var1, var2, var3)) {
-			this.sliderValue = (float)(var2 - (this.xPosition + 4)) / (float)(this.width - 8);
+			int sx = this.getScaledX();
+			int sw = this.getScaledWidth();
+			this.sliderValue = (float)(var2 - (sx + 4)) / (float)(sw - 8);
 			if(this.sliderValue < 0.0F) {
 				this.sliderValue = 0.0F;
 			}
--- net/minecraft/client/render/WorldRenderer.java
+++ net/minecraft/client/render/WorldRenderer.java
@@ -1,11 +1,14 @@
 package net.minecraft.client.render;
 
+import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
+
+import net.mine_diver.smoothbeta.client.render.*;
 import net.minecraft.client.ImageBufferDownload;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.effect.EntityBubbleFX;
@@ -38,11 +41,9 @@
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.util.MathHelper;
-import org.lwjgl.opengl.ARBOcclusionQuery;
-import org.lwjgl.opengl.GL11;
-import org.lwjgl.opengl.GL15;
+import org.lwjgl.opengl.*;
 
-public class WorldRenderer implements WorldAccess {
+public class WorldRenderer implements WorldAccess, SmoothWorldRenderer {
 	public List tileEntities = new ArrayList();
 	private World worldObj;
 	private TextureRegistry textureRegistry;
@@ -72,7 +73,7 @@
 	private int countEntitiesTotal;
 	private int countEntitiesRendered;
 	private int countEntitiesHidden;
-	int[] dummyBuf50k = new int['\uc350'];
+	int[] dummyBuf50k = new int[0];
 	IntBuffer occlusionResult = GLAllocation.createDirectIntBuffer(64);
 	private int renderersLoaded;
 	private int renderersBeingClipped;
@@ -81,7 +82,7 @@
 	private int renderersSkippingRenderPass;
 	private int worldRenderersCheckIndex;
 	private List glRenderLists = new ArrayList();
-	private RenderList[] allRenderLists = new RenderList[]{new RenderList(), new RenderList(), new RenderList(), new RenderList()};
+	private RenderList[] allRenderLists = new RenderList[]{new RenderRegion(this), new RenderRegion(this), new RenderRegion(this), new RenderRegion(this)};
 	int dummyInt0 = 0;
 	int glDummyList = GLAllocation.generateDisplayLists(1);
 	double prevSortX = -9999.0D;
@@ -89,6 +90,14 @@
 	double prevSortZ = -9999.0D;
 	public float damagePartialTime;
 	int frustrumCheckOffset = 0;
+	private VboPool smoothbeta_vboPool;
+	private final FloatBuffer
+            smoothbeta_modelViewMatrix = GLAllocation.createDirectFloatBuffer(16),
+            smoothbeta_projectionMatrix = GLAllocation.createDirectFloatBuffer(16);
+
+	public VboPool smoothbeta_getTerrainVboPool() {
+        return smoothbeta_vboPool;
+    }
 
 	public WorldRenderer(Minecraft var1, TextureRegistry var2) {
 		this.mc = var1;
@@ -134,7 +143,7 @@
 		GL11.glEndList();
 		this.glSkyList2 = this.starGLCallList + 2;
 		GL11.glNewList(this.glSkyList2, GL11.GL_COMPILE);
-		var5 = -16.0F;
+		var5 = 0.0F;
 		var4.startDrawingQuads();
 
 		for(var8 = -var6 * var7; var8 <= var6 * var7; var8 += var6) {
@@ -216,7 +225,10 @@
 	}
 
 	public void loadRenderers() {
-		Block.leaves.setGraphicsLevel(this.mc.gameSettings.fancyGraphics);
+		if (smoothbeta_vboPool != null)
+            smoothbeta_vboPool.deleteGlBuffers();
+        smoothbeta_vboPool = new VboPool(VertexFormats.POSITION_TEXTURE_COLOR_NORMAL);
+		Block.leaves.setGraphicsLevel(this.mc.gameSettings.graphicsLevel);
 		this.renderDistance = this.mc.gameSettings.renderDistance;
 		int var1;
 		if(this.worldRenderers != null) {
@@ -225,14 +237,11 @@
 			}
 		}
 
-		var1 = 64 << 3 - this.renderDistance;
-		if(var1 > 400) {
-			var1 = 400;
-		}
-
-		this.renderChunksWide = var1 / 16 + 1;
-		this.renderChunksTall = 8;
-		this.renderChunksDeep = var1 / 16 + 1;
+		var1 = this.renderDistance * 2 + 1;
+		if (var1 > 64) var1 = 64;
+		this.renderChunksWide = var1;
+		this.renderChunksTall = var1;
+		this.renderChunksDeep = var1;
 		this.worldRenderers = new ChunkRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
 		this.sortedWorldRenderers = new ChunkRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
 		int var2 = 0;
@@ -316,14 +325,6 @@
 				var7 = (Entity)var5.get(var6);
 				if(var7.isInRangeToRenderVec3D(var1) && (var7.ignoreFrustumCheck || var2.isBoundingBoxInFrustum(var7.boundingBox)) && (var7 != this.mc.renderViewEntity || this.mc.gameSettings.thirdPersonView || this.mc.renderViewEntity.isPlayerSleeping())) {
 					int var8 = MathHelper.floor(var7.posY);
-					if(var8 < 0) {
-						var8 = 0;
-					}
-
-					if(var8 >= 128) {
-						var8 = 127;
-					}
-
 					if(this.worldObj.blockExists(MathHelper.floor(var7.posX), var8, MathHelper.floor(var7.posZ))) {
 						++this.countEntitiesRendered;
 						RenderManager.instance.renderEntity(var7, var3);
@@ -395,6 +396,14 @@
 
 				for(int var12 = 0; var12 < this.renderChunksTall; ++var12) {
 					int var13 = var12 * 16;
+					int var13a = var13 + var5 - var2;
+					if (var13a < 0) {
+						var13a -= var4 - 1;
+					}
+
+					var13a /= var4;
+					var13 -= var13a * var4;
+
 					if(var13 < this.minBlockY) {
 						this.minBlockY = var13;
 					}
@@ -611,7 +620,7 @@
 				this.allRenderLists[var17].func_861_a(var16.posXMinus, var16.posYMinus, var16.posZMinus, var20, var10, var12);
 			}
 
-			this.allRenderLists[var17].func_858_a(var16.getGLCallListForPass(var3));
+			((RenderRegion) this.allRenderLists[var17]).addBuffer(((SmoothChunkRenderer) var16).smoothbeta_getBuffer(var3));
 		}
 
 		this.renderAllRenderLists(var3, var4);
@@ -619,10 +628,41 @@
 	}
 
 	public void renderAllRenderLists(int var1, double var2) {
+		Shader shader = Shaders.getTerrainShader();
+
+        shader.addSampler("Sampler0", 0);
+
+        GL11.glGetFloat(GL11.GL_MODELVIEW_MATRIX, (FloatBuffer) smoothbeta_modelViewMatrix.clear());
+        shader.modelViewMat.set((FloatBuffer) smoothbeta_modelViewMatrix.position(0));
+
+        GL11.glGetFloat(GL11.GL_PROJECTION_MATRIX, (FloatBuffer) smoothbeta_projectionMatrix.clear());
+        shader.projectionMat.set((FloatBuffer) smoothbeta_projectionMatrix.position(0));
+
+		int fog;
+		switch (GL11.glGetInteger(GL11.GL_FOG_MODE)) {
+			case GL11.GL_EXP: fog = 0; break;
+			case GL11.GL_EXP2: fog = 1; break;
+			case GL11.GL_LINEAR: fog = 2; break;
+			default: throw new IllegalStateException("Unexpected value: " + GL11.glGetInteger(GL11.GL_FOG_MODE));
+        }
+        shader.fogMode.set(fog);
+
+        shader.bind();
+
 		for(int var4 = 0; var4 < this.allRenderLists.length; ++var4) {
 			this.allRenderLists[var4].func_860_a();
 		}
 
+		Shaders.getTerrainShader().unbind();
+
+        GL20.glDisableVertexAttribArray(0); // pos
+        GL20.glDisableVertexAttribArray(1); // texture
+        GL20.glDisableVertexAttribArray(2); // color
+        GL20.glDisableVertexAttribArray(3); // normal
+
+        GL30.glBindVertexArray(0);
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
+        GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, 0);
 	}
 
 	public void updateClouds() {
@@ -747,7 +787,10 @@
 			}
 
 			GL11.glDisable(GL11.GL_TEXTURE_2D);
+//			float py = ((float)MathHelper.lerp(this.mc.thePlayer.lastTickPosY, this.mc.thePlayer.posY, var1) - 64.0F) / 4.0F;
+			GL11.glTranslatef(0.0F, -16.0F, 0.0F);
 			GL11.glCallList(this.glSkyList2);
+			GL11.glTranslatef(0.0F, 16.0F, 0.0F);
 			GL11.glEnable(GL11.GL_TEXTURE_2D);
 			GL11.glDepthMask(true);
 		}
@@ -755,8 +798,8 @@
 
 	public void renderClouds(float var1) {
 		if(!this.mc.theWorld.dimension.isNether) {
-			if(this.mc.gameSettings.fancyGraphics) {
-				this.renderCloudsFancy(var1);
+			if(this.mc.gameSettings.graphicsLevel > 0) {
+				this.renderCloudsFancy(var1, false);
 			} else {
 				GL11.glDisable(GL11.GL_CULL_FACE);
 				float var2 = (float)(this.mc.renderViewEntity.lastTickPosY + (this.mc.renderViewEntity.posY - this.mc.renderViewEntity.lastTickPosY) * (double)var1);
@@ -814,15 +857,17 @@
 		return false;
 	}
 
-	public void renderCloudsFancy(float var1) {
+	public void renderCloudsFancy(float var1, boolean topLayer) {
 		GL11.glDisable(GL11.GL_CULL_FACE);
 		float var2 = (float)(this.mc.renderViewEntity.lastTickPosY + (this.mc.renderViewEntity.posY - this.mc.renderViewEntity.lastTickPosY) * (double)var1);
 		Tessellator var3 = Tessellator.instance;
-		float var4 = 12.0F;
-		float var5 = 4.0F;
-		double var6 = (this.mc.renderViewEntity.prevPosX + (this.mc.renderViewEntity.posX - this.mc.renderViewEntity.prevPosX) * (double)var1 + (double)(((float)this.cloudOffsetX + var1) * 0.03F)) / (double)var4;
+		float var4 = topLayer ? 24.0F : 12.0F;
+		float var5 = topLayer ? 8.0F : 4.0F;
+		float alpha = topLayer ? 0.4F : 0.8F;
+		double var6 = (this.mc.renderViewEntity.prevPosX + (this.mc.renderViewEntity.posX - this.mc.renderViewEntity.prevPosX) * (double)var1 + (Minecraft.PANORAMA_MODE ? 0 : (double)(((float)this.cloudOffsetX + var1)) * 0.03F)) / (double)var4;
 		double var8 = (this.mc.renderViewEntity.prevPosZ + (this.mc.renderViewEntity.posZ - this.mc.renderViewEntity.prevPosZ) * (double)var1) / (double)var4 + (double)0.33F;
-		float var10 = this.worldObj.dimension.getCloudHeight() - var2 + 0.33F;
+		if (topLayer) var8 += 128.0D;
+		float var10 = this.worldObj.dimension.getCloudHeight() - var2 + 0.33F + (topLayer ? 64.0F : 0.0F);
 		int var11 = MathHelper.floor(var6 / 2048.0D);
 		int var12 = MathHelper.floor(var8 / 2048.0D);
 		var6 -= (double)(var11 * 2048);
@@ -879,7 +924,7 @@
 					float var30 = var28 - var20;
 					float var31 = var29 - var21;
 					if(var10 > -var5 - 1.0F) {
-						var3.setColorRGBA_F(var14 * 0.7F, var15 * 0.7F, var16 * 0.7F, 0.8F);
+						var3.setColorRGBA_F(var14 * 0.7F, var15 * 0.7F, var16 * 0.7F, alpha);
 						var3.setNormal(0.0F, -1.0F, 0.0F);
 						var3.addVertexWithUV((double)(var30 + 0.0F), (double)(var10 + 0.0F), (double)(var31 + (float)var22), (double)((var28 + 0.0F) * var19 + var17), (double)((var29 + (float)var22) * var19 + var18));
 						var3.addVertexWithUV((double)(var30 + (float)var22), (double)(var10 + 0.0F), (double)(var31 + (float)var22), (double)((var28 + (float)var22) * var19 + var17), (double)((var29 + (float)var22) * var19 + var18));
@@ -888,7 +933,7 @@
 					}
 
 					if(var10 <= var5 + 1.0F) {
-						var3.setColorRGBA_F(var14, var15, var16, 0.8F);
+						var3.setColorRGBA_F(var14, var15, var16, alpha);
 						var3.setNormal(0.0F, 1.0F, 0.0F);
 						var3.addVertexWithUV((double)(var30 + 0.0F), (double)(var10 + var5 - var24), (double)(var31 + (float)var22), (double)((var28 + 0.0F) * var19 + var17), (double)((var29 + (float)var22) * var19 + var18));
 						var3.addVertexWithUV((double)(var30 + (float)var22), (double)(var10 + var5 - var24), (double)(var31 + (float)var22), (double)((var28 + (float)var22) * var19 + var17), (double)((var29 + (float)var22) * var19 + var18));
@@ -896,7 +941,7 @@
 						var3.addVertexWithUV((double)(var30 + 0.0F), (double)(var10 + var5 - var24), (double)(var31 + 0.0F), (double)((var28 + 0.0F) * var19 + var17), (double)((var29 + 0.0F) * var19 + var18));
 					}
 
-					var3.setColorRGBA_F(var14 * 0.9F, var15 * 0.9F, var16 * 0.9F, 0.8F);
+					var3.setColorRGBA_F(var14 * 0.9F, var15 * 0.9F, var16 * 0.9F, alpha);
 					int var32;
 					if(var26 > -1) {
 						var3.setNormal(-1.0F, 0.0F, 0.0F);
@@ -920,7 +965,7 @@
 						}
 					}
 
-					var3.setColorRGBA_F(var14 * 0.8F, var15 * 0.8F, var16 * 0.8F, 0.8F);
+					var3.setColorRGBA_F(var14 * 0.8F, var15 * 0.8F, var16 * 0.8F, alpha);
 					if(var27 > -1) {
 						var3.setNormal(0.0F, 0.0F, -1.0F);
 
@@ -951,6 +996,11 @@
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		GL11.glDisable(GL11.GL_BLEND);
 		GL11.glEnable(GL11.GL_CULL_FACE);
+
+		if (!topLayer && this.mc.gameSettings.graphicsLevel > 1) {
+			GL11.glScalef(1.0F / var4, 1.0F, 1.0F / var4);
+			this.renderCloudsFancy(var1, true);
+		}
 	}
 
 	public boolean updateRenderers(LivingEntity var1, boolean var2) {
@@ -994,6 +1044,8 @@
 			ChunkRenderer var11;
 			int var12;
 			int var13;
+			int chunksToRender = 2;
+			int renderedChunk = 0;
 			label169:
 			for(var10 = 0; var10 < var8; ++var10) {
 				var11 = (ChunkRenderer)this.worldRenderersToUpdate.get(var10);
@@ -1011,9 +1063,15 @@
 
 						while(true) {
 							--var13;
+							renderedChunk++;
 							if(var13 == 0) {
 								var6[var12] = var11;
-								continue label169;
+								if (renderedChunk == chunksToRender || true) {
+									renderedChunk = 0;
+									continue label169;
+								} else {
+									break;
+								}
 							}
 
 							var6[var13 - 1] = var6[var13];
@@ -1071,8 +1129,9 @@
 					boolean var15 = false;
 
 					for(int var16 = 0; var16 < var4 && !var15; ++var16) {
-						if(var14 == var6[var16]) {
+						if (var14 == var6[var16]) {
 							var15 = true;
+							break;
 						}
 					}
 
@@ -1127,7 +1186,7 @@
 				var6.startDrawingQuads();
 				var6.setTranslationD(-var10, -var12, -var14);
 				var6.disableColor();
-				this.globalRenderBlocks.renderBlockUsingTexture(var9, var2.blockX, var2.blockY, var2.blockZ, 240 + (int)(this.damagePartialTime * 10.0F));
+				this.globalRenderBlocks.renderBlockUsingTexture(var9, var2.blockX, var2.blockY, var2.blockZ, 992 + (int)(this.damagePartialTime * 10.0F));
 				var6.draw();
 				var6.setTranslationD(0.0D, 0.0D, 0.0D);
 				GL11.glDisable(GL11.GL_ALPHA_TEST);
@@ -1348,7 +1407,6 @@
 	}
 
 	public void obtainEntitySkin(Entity var1) {
-		var1.updateCloak();
 		if(var1.skinUrl != null) {
 			this.textureRegistry.obtainImageData(var1.skinUrl, new ImageBufferDownload());
 		}
@@ -1446,5 +1504,9 @@
 			this.mc.effectRenderer.addBlockDestroyEffects(var3, var4, var5, var6 & 255, var6 >> 8 & 255);
 		}
 
+	}
+
+	public int getQueuedChunkUpdates() {
+		return this.worldRenderersToUpdate.size();
 	}
 }
--- net/minecraft/game/world/chunk/Chunk.java
+++ net/minecraft/game/world/chunk/Chunk.java
@@ -1,15 +1,15 @@
 package net.minecraft.game.world.chunk;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
+import java.util.*;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.LightType;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.game.world.biome.BiomeSource;
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.block.ContainerBlock;
 import net.minecraft.game.world.block.tileentity.TileEntity;
@@ -18,27 +18,34 @@
 
 public class Chunk {
 	public static boolean isLit;
+	private byte[] blockBiomeArray;
 	public byte[] blocks;
 	public boolean isChunkLoaded;
 	public World worldObj;
 	public NibbleArray data;
 	public NibbleArray skylightMap;
 	public NibbleArray blocklightMap;
-	public byte[] heightMap;
+	public int[] heightMap;
 	public int lowestBlockHeight;
 	public final int xPosition;
 	public final int zPosition;
-	public Map chunkTileEntityMap;
-	public List[] entities;
+	public Map<ChunkPosition, TileEntity> chunkTileEntityMap;
+	public Int2ObjectMap<Set<Entity>> entities = new Int2ObjectOpenHashMap<>();
 	public boolean isTerrainPopulated;
 	public boolean isModified;
 	public boolean neverSave;
 	public boolean hasEntities;
 	public long lastSaveTime;
+	public Int2ObjectMap<ChunkSection> sections = new Int2ObjectOpenHashMap<>();
+	private int cachedSectionLevel;
+	private ChunkSection cachedSection;
+	private int minLevel;
+	private int maxLevel;
+	public boolean blockSkylightRefresh;
 
 	public Chunk(World var1, int var2, int var3) {
+		this.blockBiomeArray = new byte[256];
 		this.chunkTileEntityMap = new HashMap();
-		this.entities = new List[8];
 		this.isTerrainPopulated = false;
 		this.isModified = false;
 		this.hasEntities = false;
@@ -46,20 +53,98 @@
 		this.worldObj = var1;
 		this.xPosition = var2;
 		this.zPosition = var3;
-		this.heightMap = new byte[256];
-
-		for(int var4 = 0; var4 < this.entities.length; ++var4) {
-			this.entities[var4] = new ArrayList();
-		}
-
+		this.heightMap = new int[256];
+
+		Arrays.fill(this.blockBiomeArray, (byte) - 1);
 	}
 
 	public Chunk(World var1, byte[] var2, int var3, int var4) {
-		this(var1, var3, var4);
-		this.blocks = var2;
-		this.data = new NibbleArray(var2.length);
-		this.skylightMap = new NibbleArray(var2.length);
-		this.blocklightMap = new NibbleArray(var2.length);
+		this(var1, var2, var3, var4, 0);
+	}
+
+	public Chunk(World world, byte[] blocks, int xPos, int zPos, int yOffset) {
+		this(world, xPos, zPos);
+		this.blocks = new byte[0];
+		this.data = new NibbleArray(0);
+		this.skylightMap = new NibbleArray(0);
+		this.blocklightMap = new NibbleArray(0);
+
+		if (blocks != null) {
+			int height = blocks.length / 256;
+			for (int y = height - 1; y >= 0; y--) {
+				for (int x = 0; x < 16; x++) {
+					for (int z = 0; z < 16; z++) {
+						byte block = blocks[y << 8 | z << 4 | x];
+						if (block != 0) {
+							int sectionY = (y >> 4) + yOffset;
+							ChunkSection section = this.getSection(sectionY);
+							if (section == null) {
+								section = this.addSection(sectionY);
+							}
+
+							section.setBlock(x, y & 15, z, block & 0xFF);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public ChunkSection getSection(int level) {
+		if (level != this.cachedSectionLevel || this.cachedSection == null) {
+			this.cachedSectionLevel = level;
+			this.cachedSection = this.sections.get(level);
+		}
+		return this.cachedSection;
+	}
+
+	public ChunkSection addSection(int level) {
+		return this.addSection(level, new ChunkSection());
+	}
+
+	public ChunkSection addSection(int level, ChunkSection section) {
+		boolean refreshSkylight = false;
+		if (this.sections.isEmpty()) {
+			this.minLevel = this.maxLevel = level;
+		} else {
+			if (level < this.minLevel) {
+				this.minLevel = level;
+			}
+			if (level > this.maxLevel) {
+				this.maxLevel = level;
+				refreshSkylight = !this.blockSkylightRefresh && !this.worldObj.dimension.hasNoSky;
+			}
+		}
+
+		this.sections.put(level, section);
+		if (refreshSkylight) {
+			this.initLightingForRealNotJustHeightmap();
+		}
+		return section;
+	}
+
+	public int getMinLevel() {
+		return this.minLevel;
+	}
+
+	public int getMaxLevel() {
+		return this.maxLevel;
+	}
+
+	public int getMinY() {
+		return this.minLevel << 4;
+	}
+
+	public int getMaxY() {
+		return (this.maxLevel << 4) + 15;
+	}
+
+	private Set<Entity> getEntitySet(int level) {
+		Set<Entity> list = this.entities.get(level);
+		if (list == null) {
+			this.entities.put(level, list = new HashSet<>());
+		}
+		return list;
 	}
 
 	public boolean isAtLocation(int var1, int var2) {
@@ -67,23 +152,50 @@
 	}
 
 	public int getHeightValue(int var1, int var2) {
-		return this.heightMap[var2 << 4 | var1] & 255;
+		return this.heightMap[var2 << 4 | var1];
 	}
 
 	public void doNothing1() {
 	}
 
+    public void initLightingForRealNotJustHeightmap() {
+        this.worldObj.blockLight.initBlockLight(this.xPosition, this.zPosition);
+
+        if (!this.worldObj.dimension.isNether) {
+            this.worldObj.skyLight.initSkylight(this.xPosition, this.zPosition);
+        }
+    }
+
+    public void updateLight(int localX, int worldY, int localZ) {
+        int worldX = localX | (this.xPosition << 4);
+        int worldZ = localZ | (this.zPosition << 4);
+
+        this.worldObj.blockLight.checkBlockEmittance(worldX, worldY, worldZ);
+        if (!this.worldObj.dimension.hasNoSky) {
+            this.worldObj.skyLight.checkSkyEmittance(worldX, worldY, worldZ);
+        }
+    }
+
 	public void generateHeightMap() {
-		int var1 = 127;
+		int minHeight = this.minLevel << 4;
+		int maxHeight = (this.maxLevel << 4) + 15;
+		int var1 = maxHeight;
 
 		for(int var2 = 0; var2 < 16; ++var2) {
 			for(int var3 = 0; var3 < 16; ++var3) {
-				int var4 = 127;
+				int var4 = maxHeight + 1;
 
-				for(int var5 = var2 << 11 | var3 << 7; var4 > 0 && Block.lightOpacity[this.blocks[var5 + var4 - 1] & 255] == 0; --var4) {
+				int lastLevel = var4 - 1 >> 4;
+				ChunkSection section = this.getSection(lastLevel);
+				while (var4 > minHeight && (section == null || Block.lightOpacity[section.getBlock(var2, (var4 - 1) & 15, var3)] == 0)) {
+					--var4;
+					if ((var4 - 1) >> 4 != lastLevel) {
+						lastLevel = (var4 - 1) >> 4;
+						section = this.getSection(lastLevel);
+					}
 				}
 
-				this.heightMap[var3 << 4 | var2] = (byte)var4;
+				this.heightMap[var3 << 4 | var2] = var4;
 				if(var4 < var1) {
 					var1 = var4;
 				}
@@ -95,47 +207,38 @@
 	}
 
 	public void generateSkylightMap() {
-		int var1 = 127;
+		int minHeight = this.minLevel << 4;
+		int maxHeight = (this.maxLevel << 4) + 15;
+		int var1 = maxHeight;
 
 		int var2;
 		int var3;
 		for(var2 = 0; var2 < 16; ++var2) {
 			for(var3 = 0; var3 < 16; ++var3) {
-				int var4 = 127;
+				int var4 = maxHeight + 1;
 
-				int var5;
-				for(var5 = var2 << 11 | var3 << 7; var4 > 0 && Block.lightOpacity[this.blocks[var5 + var4 - 1] & 255] == 0; --var4) {
+				int lastLevel = var4 - 1 >> 4;
+				ChunkSection section = this.getSection(lastLevel);
+				while (var4 > minHeight && (section == null || Block.lightOpacity[section.getBlock(var2, (var4 - 1) & 15, var3)] == 0)) {
+					--var4;
+					if ((var4 - 1) >> 4 != lastLevel) {
+						lastLevel = (var4 - 1) >> 4;
+						section = this.getSection(lastLevel);
+					}
 				}
 
-				this.heightMap[var3 << 4 | var2] = (byte)var4;
+				this.heightMap[var3 << 4 | var2] = var4;
 				if(var4 < var1) {
 					var1 = var4;
 				}
 
 				if(!this.worldObj.dimension.hasNoSky) {
-					int var6 = 15;
-					int var7 = 127;
-
-					do {
-						var6 -= Block.lightOpacity[this.blocks[var5 + var7] & 255];
-						if(var6 > 0) {
-							this.skylightMap.setNibble(var2, var7, var3, var6);
-						}
-
-						--var7;
-					} while(var7 > 0 && var6 > 0);
+					// Handled by Starlight
 				}
 			}
 		}
 
 		this.lowestBlockHeight = var1;
-
-		for(var2 = 0; var2 < 16; ++var2) {
-			for(var3 = 0; var3 < 16; ++var3) {
-				this.updateSkylight_do(var2, var3);
-			}
-		}
-
 		this.isModified = true;
 	}
 
@@ -165,30 +268,30 @@
 	}
 
 	private void relightBlock(int var1, int var2, int var3) {
-		int var4 = this.heightMap[var3 << 4 | var1] & 255;
+		int var4 = this.heightMap[var3 << 4 | var1];
 		int var5 = var4;
 		if(var2 > var4) {
 			var5 = var2;
 		}
 
-		for(int var6 = var1 << 11 | var3 << 7; var5 > 0 && Block.lightOpacity[this.blocks[var6 + var5 - 1] & 255] == 0; --var5) {
+		for(; var5 > this.minLevel * 16 && Block.lightOpacity[this.getBlockID(var1, var5 - 1, var3)] == 0; --var5) {
 		}
 
 		if(var5 != var4) {
 			this.worldObj.markBlocksDirtyVertical(var1, var3, var5, var4);
-			this.heightMap[var3 << 4 | var1] = (byte)var5;
+			this.heightMap[var3 << 4 | var1] = var5;
 			int var7;
 			int var8;
 			int var9;
 			if(var5 < this.lowestBlockHeight) {
 				this.lowestBlockHeight = var5;
 			} else {
-				var7 = 127;
+				var7 = this.maxLevel * 16 - 1;
 
 				for(var8 = 0; var8 < 16; ++var8) {
 					for(var9 = 0; var9 < 16; ++var9) {
-						if((this.heightMap[var9 << 4 | var8] & 255) < var7) {
-							var7 = this.heightMap[var9 << 4 | var8] & 255;
+						if(this.heightMap[var9 << 4 | var8] < var7) {
+							var7 = this.heightMap[var9 << 4 | var8];
 						}
 					}
 				}
@@ -196,67 +299,38 @@
 				this.lowestBlockHeight = var7;
 			}
 
-			var7 = this.xPosition * 16 + var1;
-			var8 = this.zPosition * 16 + var3;
-			if(var5 < var4) {
-				for(var9 = var5; var9 < var4; ++var9) {
-					this.skylightMap.setNibble(var1, var9, var3, 15);
-				}
-			} else {
-				this.worldObj.scheduleLightingUpdate(LightType.SKY, var7, var4, var8, var7, var5, var8);
-
-				for(var9 = var4; var9 < var5; ++var9) {
-					this.skylightMap.setNibble(var1, var9, var3, 0);
-				}
-			}
-
-			var9 = 15;
-
-			int var10;
-			for(var10 = var5; var5 > 0 && var9 > 0; this.skylightMap.setNibble(var1, var5, var3, var9)) {
-				--var5;
-				int var11 = Block.lightOpacity[this.getBlockID(var1, var5, var3)];
-				if(var11 == 0) {
-					var11 = 1;
-				}
-
-				var9 -= var11;
-				if(var9 < 0) {
-					var9 = 0;
-				}
-			}
-
-			while(var5 > 0 && Block.lightOpacity[this.getBlockID(var1, var5 - 1, var3)] == 0) {
-				--var5;
-			}
-
-			if(var5 != var10) {
-				this.worldObj.scheduleLightingUpdate(LightType.SKY, var7 - 1, var5, var8 - 1, var7 + 1, var10, var8 + 1);
-			}
+			// Handled by Starlight
 
 			this.isModified = true;
 		}
 	}
 
 	public int getBlockID(int var1, int var2, int var3) {
-		return this.blocks[var1 << 11 | var3 << 7 | var2] & 255;
+		ChunkSection section = this.getSection(var2 >> 4);
+		if (section == null) return 0;
+		return section.getBlock(var1, var2 & 15, var3);
 	}
 
 	public boolean setBlockAndMetadata(int var1, int var2, int var3, int var4, int var5) {
+		ChunkSection section = this.getSection(var2 >> 4);
+		if (section == null) {
+			if (var4 == 0) return false;
+			section = this.addSection(var2 >> 4);
+		}
 		byte var6 = (byte)var4;
-		int var7 = this.heightMap[var3 << 4 | var1] & 255;
-		int var8 = this.blocks[var1 << 11 | var3 << 7 | var2] & 255;
-		if(var8 == var4 && this.data.getNibble(var1, var2, var3) == var5) {
+		int var7 = this.heightMap[var3 << 4 | var1];
+		int var8 = section.getBlock(var1, var2 & 15, var3);
+		if(var8 == var4 && section.getMetadata(var1, var2 & 15, var3) == var5) {
 			return false;
 		} else {
 			int var9 = this.xPosition * 16 + var1;
 			int var10 = this.zPosition * 16 + var3;
-			this.blocks[var1 << 11 | var3 << 7 | var2] = (byte)(var6 & 255);
+			section.setBlock(var1, var2 & 15, var3, var4);
 			if(var8 != 0 && !this.worldObj.remoteWorld) {
 				Block.blocksList[var8].onBlockRemoval(this.worldObj, var9, var2, var10);
 			}
+			section.setMetadata(var1, var2 & 15, var3, var5);
 
-			this.data.setNibble(var1, var2, var3, var5);
 			if(!this.worldObj.dimension.hasNoSky) {
 				if(Block.lightOpacity[var6 & 255] != 0) {
 					if(var2 >= var7) {
@@ -265,13 +339,9 @@
 				} else if(var2 == var7 - 1) {
 					this.relightBlock(var1, var2, var3);
 				}
-
-				this.worldObj.scheduleLightingUpdate(LightType.SKY, var9, var2, var10, var9, var2, var10);
 			}
 
-			this.worldObj.scheduleLightingUpdate(LightType.BLOCK, var9, var2, var10, var9, var2, var10);
-			this.updateSkylight_do(var1, var3);
-			this.data.setNibble(var1, var2, var3, var5);
+			this.updateLight(var1, var2, var3);
 			if(var4 != 0) {
 				Block.blocksList[var4].onBlockAdded(this.worldObj, var9, var2, var10);
 			}
@@ -282,20 +352,25 @@
 	}
 
 	public boolean setBlock(int var1, int var2, int var3, int var4) {
+		ChunkSection section = this.getSection(var2 >> 4);
+		if (section == null) {
+			if (var4 == 0) return false;
+			section = this.addSection(var2 >> 4);
+		}
 		byte var5 = (byte)var4;
-		int var6 = this.heightMap[var3 << 4 | var1] & 255;
-		int var7 = this.blocks[var1 << 11 | var3 << 7 | var2] & 255;
+		int var6 = this.heightMap[var3 << 4 | var1];
+		int var7 = section.getBlock(var1, var2 & 15, var3);
 		if(var7 == var4) {
 			return false;
 		} else {
 			int var8 = this.xPosition * 16 + var1;
 			int var9 = this.zPosition * 16 + var3;
-			this.blocks[var1 << 11 | var3 << 7 | var2] = (byte)(var5 & 255);
+			section.setBlock(var1, var2 & 15, var3, var4);
 			if(var7 != 0) {
 				Block.blocksList[var7].onBlockRemoval(this.worldObj, var8, var2, var9);
 			}
+			section.setMetadata(var1, var2 & 15, var3, 0);
 
-			this.data.setNibble(var1, var2, var3, 0);
 			if(Block.lightOpacity[var5 & 255] != 0) {
 				if(var2 >= var6) {
 					this.relightBlock(var1, var2 + 1, var3);
@@ -304,9 +379,7 @@
 				this.relightBlock(var1, var2, var3);
 			}
 
-			this.worldObj.scheduleLightingUpdate(LightType.SKY, var8, var2, var9, var8, var2, var9);
-			this.worldObj.scheduleLightingUpdate(LightType.BLOCK, var8, var2, var9, var8, var2, var9);
-			this.updateSkylight_do(var1, var3);
+			this.updateLight(var1, var2, var3);
 			if(var4 != 0 && !this.worldObj.remoteWorld) {
 				Block.blocksList[var4].onBlockAdded(this.worldObj, var8, var2, var9);
 			}
@@ -316,41 +389,86 @@
 		}
 	}
 
+	public void setBlockRaw(int x, int y, int z, int block) {
+		ChunkSection section = this.getSection(y >> 4);
+		if (section == null) {
+			if (block == 0) return;
+			section = this.addSection(y >> 4);
+		}
+		section.setBlock(x, y & 15, z, block);
+	}
+
 	public int getBlockMetadata(int var1, int var2, int var3) {
-		return this.data.getNibble(var1, var2, var3);
+		ChunkSection section = this.getSection(var2 >> 4);
+		if (section == null) return 0;
+		return section.getMetadata(var1, var2 & 15, var3);
 	}
 
 	public void setBlockMetadata(int var1, int var2, int var3, int var4) {
 		this.isModified = true;
-		this.data.setNibble(var1, var2, var3, var4);
+		ChunkSection section = this.getSection(var2 >> 4);
+		if (section == null) {
+			section = this.addSection(var2 >> 4);
+		}
+		section.setMetadata(var1, var2 & 15, var3, var4);
 	}
 
 	public int getSavedLightValue(LightType var1, int var2, int var3, int var4) {
-		return var1 == LightType.SKY ? this.skylightMap.getNibble(var2, var3, var4) : (var1 == LightType.BLOCK ? this.blocklightMap.getNibble(var2, var3, var4) : 0);
+		int level = var3 >> 4;
+		ChunkSection section = this.getSection(level);
+		while (section == null && level <= this.maxLevel) {
+			level++;
+			var3 = level << 4;
+			section = this.getSection(level);
+		}
+		if (section == null) return var3 >> 4 < this.minLevel ? 0 : var1.defaultValue;
+		return var1 == LightType.SKY ? section.getSkyLight(var2, var3 & 15, var4) : (var1 == LightType.BLOCK ? section.getBlockLight(var2, var3 & 15, var4) : var1.defaultValue);
 	}
 
 	public void setLightValue(LightType var1, int var2, int var3, int var4, int var5) {
+		ChunkSection section = this.getSection(var3 >> 4);
+		if (section == null) {
+			if (this.worldObj.dimension.hasNoSky && var1 == LightType.SKY) {
+				return;
+			}
+			section = this.addSection(var3 >> 4);
+			if (!this.worldObj.dimension.hasNoSky && !this.worldObj.remoteWorld) {
+				this.initLightingForRealNotJustHeightmap();
+			}
+		}
+
 		this.isModified = true;
 		if(var1 == LightType.SKY) {
-			this.skylightMap.setNibble(var2, var3, var4, var5);
+			section.setSkyLight(var2, var3 & 15, var4, var5);
 		} else {
 			if(var1 != LightType.BLOCK) {
 				return;
 			}
 
-			this.blocklightMap.setNibble(var2, var3, var4, var5);
+			section.setBlockLight(var2, var3 & 15, var4, var5);
 		}
 
 	}
 
 	public int getBlockLightValue(int var1, int var2, int var3, int var4) {
-		int var5 = this.skylightMap.getNibble(var1, var2, var3);
+		int level = var2 >> 4;
+		ChunkSection section = this.getSection(level);
+		while (section == null && level <= this.maxLevel) {
+			level++;
+			var2 = level << 4;
+			section = this.getSection(level);
+		}
+		if (section == null) {
+			return level >= this.minLevel && !this.worldObj.dimension.hasNoSky ? Math.max(LightType.SKY.defaultValue - var4, 0) : 0;
+		}
+
+		int var5 = this.worldObj.dimension.hasNoSky ? 0 : section.getSkyLight(var1, var2 & 15, var3);
 		if(var5 > 0) {
 			isLit = true;
 		}
 
 		var5 -= var4;
-		int var6 = this.blocklightMap.getNibble(var1, var2, var3);
+		int var6 = section.getBlockLight(var1, var2 & 15, var3);
 		if(var6 > var5) {
 			var5 = var6;
 		}
@@ -368,19 +486,11 @@
 		}
 
 		int var4 = MathHelper.floor(var1.posY / 16.0D);
-		if(var4 < 0) {
-			var4 = 0;
-		}
-
-		if(var4 >= this.entities.length) {
-			var4 = this.entities.length - 1;
-		}
-
 		var1.addedToChunk = true;
 		var1.chunkCoordX = this.xPosition;
 		var1.chunkCoordY = var4;
 		var1.chunkCoordZ = this.zPosition;
-		this.entities[var4].add(var1);
+		this.getEntitySet(var4).add(var1);
 	}
 
 	public void removeEntity(Entity var1) {
@@ -388,19 +498,14 @@
 	}
 
 	public void removeEntityAtIndex(Entity var1, int var2) {
-		if(var2 < 0) {
-			var2 = 0;
-		}
-
-		if(var2 >= this.entities.length) {
-			var2 = this.entities.length - 1;
-		}
-
-		this.entities[var2].remove(var1);
+		Set<Entity> entitySet = this.entities.get(var2);
+		if (entitySet != null) {
+			entitySet.remove(var1);
+		}
 	}
 
 	public boolean canBlockSeeTheSky(int var1, int var2, int var3) {
-		return var2 >= (this.heightMap[var3 << 4 | var1] & 255);
+		return var2 >= this.heightMap[var3 << 4 | var1];
 	}
 
 	public TileEntity getChunkBlockTileEntity(int var1, int var2, int var3) {
@@ -465,8 +570,8 @@
 		this.isChunkLoaded = true;
 		this.worldObj.addTileEntities(this.chunkTileEntityMap.values());
 
-		for(int var1 = 0; var1 < this.entities.length; ++var1) {
-			this.worldObj.addLoadedEntities(this.entities[var1]);
+		for (Set<Entity> entitySet : this.entities.values()) {
+			this.worldObj.addLoadedEntities(entitySet);
 		}
 
 	}
@@ -480,8 +585,8 @@
 			var2.invalidate();
 		}
 
-		for(int var3 = 0; var3 < this.entities.length; ++var3) {
-			this.worldObj.addUnloadedEntities(this.entities[var3]);
+		for (Set<Entity> entitySet : this.entities.values()) {
+			this.worldObj.addUnloadedEntities(entitySet);
 		}
 
 	}
@@ -493,21 +598,14 @@
 	public void getEntitiesWithinAABBForEntity(Entity var1, AxisAlignedBB var2, List var3) {
 		int var4 = MathHelper.floor((var2.minY - 2.0D) / 16.0D);
 		int var5 = MathHelper.floor((var2.maxY + 2.0D) / 16.0D);
-		if(var4 < 0) {
-			var4 = 0;
-		}
-
-		if(var5 >= this.entities.length) {
-			var5 = this.entities.length - 1;
-		}
 
 		for(int var6 = var4; var6 <= var5; ++var6) {
-			List var7 = this.entities[var6];
-
-			for(int var8 = 0; var8 < var7.size(); ++var8) {
-				Entity var9 = (Entity)var7.get(var8);
-				if(var9 != var1 && var9.boundingBox.intersectsWith(var2)) {
-					var3.add(var9);
+			Set<Entity> var7 = this.entities.get(var6);
+			if (var7 != null) {
+				for(Entity var9 : var7) {
+					if(var9 != var1 && var9.boundingBox.intersectsWith(var2)) {
+						var3.add(var9);
+					}
 				}
 			}
 		}
@@ -517,21 +615,14 @@
 	public void getEntitiesOfTypeWithinAABB(Class var1, AxisAlignedBB var2, List var3) {
 		int var4 = MathHelper.floor((var2.minY - 2.0D) / 16.0D);
 		int var5 = MathHelper.floor((var2.maxY + 2.0D) / 16.0D);
-		if(var4 < 0) {
-			var4 = 0;
-		}
-
-		if(var5 >= this.entities.length) {
-			var5 = this.entities.length - 1;
-		}
 
 		for(int var6 = var4; var6 <= var5; ++var6) {
-			List var7 = this.entities[var6];
-
-			for(int var8 = 0; var8 < var7.size(); ++var8) {
-				Entity var9 = (Entity)var7.get(var8);
-				if(var1.isAssignableFrom(var9.getClass()) && var9.boundingBox.intersectsWith(var2)) {
-					var3.add(var9);
+			Set<Entity> var7 = this.entities.get(var6);
+			if (var7 != null) {
+				for(Entity var9 : var7) {
+					if(var1.isAssignableFrom(var9.getClass()) && var9.boundingBox.intersectsWith(var2)) {
+						var3.add(var9);
+					}
 				}
 			}
 		}
@@ -668,6 +759,34 @@
 	}
 
 	public void updateBlockMapData() {
-		ChunkBlockMap.setBlockData(this.blocks);
+//		ChunkBlockMap.setBlockData(this.blocks);
+	}
+
+	public String getSectionInfo() {
+		return "Min: " + this.minLevel + ", Max: " + this.maxLevel + ", Count: " + this.sections.size();
+	}
+
+	public Biome getBiome(int x, int z, BiomeSource biomeSource) {
+		int i = blockBiomeArray[x << 4 | z] & 0xff;
+
+		if (i == 255) {
+			Biome biomegenbase = biomeSource.getBiomeGenAt((xPosition << 4) + x, (zPosition << 4) + z);
+			i = biomegenbase.id;
+			blockBiomeArray[x << 4 | z] = (byte)(i & 0xff);
+		}
+
+		if (Biome.biomeIndex[i] == null) {
+			return Biome.plains;
+		} else {
+			return Biome.biomeIndex[i];
+		}
+	}
+
+	public byte[] getBiomeArray() {
+		return blockBiomeArray;
+	}
+
+	public void setBiomeArray(byte[] biomeArray) {
+		blockBiomeArray = biomeArray;
 	}
 }
--- net/minecraft/client/render/color/ColorizerFoliage.java
+++ net/minecraft/client/render/color/ColorizerFoliage.java
@@ -15,14 +15,26 @@
 	}
 
 	public static int getFoliageColorPine() {
-		return 6396257;
-	}
-
-	public static int getFoliageColorBirch() {
-		return 8431445;
+		return 0x2ac163;
+	}
+
+	public static int getFoliageColorMaple() {
+		return 0xfa5324;
+	}
+
+	public static int getFoliageColorBloomingMaple() {
+		return 0xff77da;
+	}
+
+	public static int getFoliageColorMahogany() {
+		return 0xd5fa2c;
+	}
+
+	public static int getFoliageColorWillow() {
+		return 0x6ede2a;
 	}
 
 	public static int func_31073_c() {
-		return 4764952;
+		return 0x55ff3f;
 	}
 }
--- net/minecraft/game/world/WorldAccess.java
+++ net/minecraft/game/world/WorldAccess.java
@@ -2,6 +2,7 @@
 
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.world.block.properties.Property;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 
 public interface WorldAccess {
--- net/minecraft/network/NetworkAcceptThread.java
+++ net/minecraft/network/NetworkAcceptThread.java
@@ -25,10 +25,10 @@
 				if(var2 != null) {
 					InetAddress var3 = var2.getInetAddress();
 					if(var1.containsKey(var3) && !"127.0.0.1".equals(var3.getHostAddress()) && System.currentTimeMillis() - ((Long)var1.get(var3)).longValue() < 5000L) {
-						var1.put(var3, Long.valueOf(System.currentTimeMillis()));
+						var1.put(var3, System.currentTimeMillis());
 						var2.close();
 					} else {
-						var1.put(var3, Long.valueOf(System.currentTimeMillis()));
+						var1.put(var3, System.currentTimeMillis());
 						NetLoginHandler var4 = new NetLoginHandler(this.mcServer, var2, "Connection #" + NetworkListenThread.func_712_b(this.field_985_b));
 						NetworkListenThread.func_716_a(this.field_985_b, var4);
 					}
--- argo/J_ChainedFunctor.java
+++ /dev/null
@@ -1,39 +1,0 @@
-package argo;
-
-final class J_ChainedFunctor implements J_Functor {
-	private final J_JsonNodeSelector field_27062_a;
-	private final J_JsonNodeSelector field_27061_b;
-
-	J_ChainedFunctor(J_JsonNodeSelector var1, J_JsonNodeSelector var2) {
-		this.field_27062_a = var1;
-		this.field_27061_b = var2;
-	}
-
-	public boolean func_27058_a(Object var1) {
-		return this.field_27062_a.func_27356_a(var1) && this.field_27061_b.func_27356_a(this.field_27062_a.func_27357_b(var1));
-	}
-
-	public Object func_27059_b(Object var1) {
-		Object var2;
-		try {
-			var2 = this.field_27062_a.func_27357_b(var1);
-		} catch (J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var6) {
-			throw J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException.func_27321_b(var6, this.field_27062_a);
-		}
-
-		try {
-			Object var3 = this.field_27061_b.func_27357_b(var2);
-			return var3;
-		} catch (J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var5) {
-			throw J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException.func_27323_a(var5, this.field_27062_a);
-		}
-	}
-
-	public String func_27060_a() {
-		return this.field_27061_b.func_27358_a();
-	}
-
-	public String toString() {
-		return this.field_27062_a.toString() + ", with " + this.field_27061_b.toString();
-	}
-}
--- net/minecraft/client/gui/SelectWorldScreen.java
+++ net/minecraft/client/gui/SelectWorldScreen.java
@@ -4,9 +4,12 @@
 import java.text.SimpleDateFormat;
 import java.util.Collections;
 import java.util.List;
+
+import net.minecraft.client.controller.CreativePlayerController;
 import net.minecraft.client.controller.SurvivalPlayerController;
 import net.minecraft.client.gui.component.GuiButton;
 import net.minecraft.client.gui.component.GuiYesNo;
+import net.minecraft.game.world.NewWorldInfo;
 import net.minecraft.game.world.save.SaveFormat;
 import net.minecraft.game.world.save.SaveFormatComparator;
 import net.minecraft.util.MathHelper;
@@ -40,6 +43,7 @@
 		this.worldSlotContainer = new WorldSlotGui(this);
 		this.worldSlotContainer.registerScrollButtons(this.controlList, 4, 5);
 		this.initButtons();
+		this.initialized = false;
 	}
 
 	private void loadSaves() {
@@ -108,13 +112,14 @@
 		this.mc.displayGuiScreen((GuiScreen)null);
 		if(!this.selected) {
 			this.selected = true;
-			this.mc.playerController = new SurvivalPlayerController(this.mc);
+			boolean creative = ((SaveFormatComparator)this.saveList.get(var1)).isCreative();
+			this.mc.playerController = creative ? new CreativePlayerController(this.mc) : new SurvivalPlayerController(this.mc);
 			String var2 = this.getSaveFileName(var1);
 			if(var2 == null) {
 				var2 = "World" + var1;
 			}
 
-			this.mc.startWorld(var2, this.getSaveName(var1), 0L);
+			this.mc.startWorld(var2, new NewWorldInfo(this.getSaveName(var1)));
 			this.mc.displayGuiScreen((GuiScreen)null);
 		}
 	}
--- argo/J_JsonConstants.java
+++ /dev/null
@@ -1,31 +1,0 @@
-package argo;
-
-import java.util.List;
-import java.util.Map;
-
-final class J_JsonConstants extends J_JsonNode {
-	static final J_JsonConstants j_null = new J_JsonConstants(EnumJsonNodeType.NULL);
-	static final J_JsonConstants j_true = new J_JsonConstants(EnumJsonNodeType.TRUE);
-	static final J_JsonConstants j_false = new J_JsonConstants(EnumJsonNodeType.FALSE);
-	private final EnumJsonNodeType nodeType;
-
-	private J_JsonConstants(EnumJsonNodeType var1) {
-		this.nodeType = var1;
-	}
-
-	public EnumJsonNodeType func_27218_a() {
-		return this.nodeType;
-	}
-
-	public String getText() {
-		throw new IllegalStateException("Attempt to get text on a JsonNode without text.");
-	}
-
-	public Map getFields() {
-		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
-	}
-
-	public List getElements() {
-		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
-	}
-}
--- /dev/null
+++ argo/jdom/JsonNumberNodeBuilder.java
@@ -1,0 +1,13 @@
+package argo.jdom;
+
+final class JsonNumberNodeBuilder implements JsonNodeBuilder {
+	private final JsonNode field_27239_a;
+
+	JsonNumberNodeBuilder(String var1) {
+		this.field_27239_a = JsonNodeFactories.aJsonNumber(var1);
+	}
+
+	public JsonNode buildNode() {
+		return this.field_27239_a;
+	}
+}
--- com/mojang/nbt/LongTag.java
+++ com/mojang/nbt/LongTag.java
@@ -29,4 +29,8 @@
 	public String toString() {
 		return "" + this.longValue;
 	}
+
+	public NBTBaseTag copy() {
+		return new LongTag(longValue).setKey(this.getKey());
+	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerGetColor.java
@@ -1,0 +1,44 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.game.world.biome.BiomeColorType;
+import net.minecraft.util.IntArray2D;
+
+public class LayerGetColor extends Layer {
+	private final BiomeColorType type;
+	private final World world;
+	private final int zoom;
+	private IntArray2D lazyBiomeArray;
+
+	public LayerGetColor(Layer parent, World world, int zoom, BiomeColorType type) {
+		super(0L, parent);
+		this.type = type;
+		this.world = world;
+		this.zoom = zoom;
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		this.lazyBiomeArray = null;
+		return this.forEach(x, z, width, length, (i, ox, oz) -> {
+			Biome biome = null;
+			int wx = (ox + x) << this.zoom;
+			int wz = (oz + z) << this.zoom;
+			if (this.world != null && this.world.chunkSaved(wx >> 4, wz >> 4)) {
+				biome = this.world.getBiomeAt(wx, wz);
+			}
+
+			if (biome == null) {
+				if (this.lazyBiomeArray == null) {
+					this.lazyBiomeArray = this.parent.getCachedData(x, z, width, length);
+				}
+				biome = Biome.biomeIndex[this.lazyBiomeArray.get(ox, oz)];
+			}
+
+			if (this.type == BiomeColorType.FOLIAGE) return biome.getFoliageColor();
+			if (this.type == BiomeColorType.SKY) return biome.getSkyColor();
+			if (this.type == BiomeColorType.GRASS) return biome.getGrassColor();
+			throw new RuntimeException("Invalid color type " + this.type + "!");
+		});
+	}
+}
--- net/minecraft/game/item/WoolItem.java
+++ net/minecraft/game/item/WoolItem.java
@@ -11,7 +11,7 @@
 	}
 
 	public int getTextureFromDamage(int var1) {
-		return Block.wool.getBlockTextureFromSideAndMetadata(2, WoolBlock.funkyMetaStuffA(var1));
+		return Block.wool.getBlockTextureFromSideAndMetadata(2, var1);
 	}
 
 	public int getPlacedBlockMetadata(int var1) {
@@ -19,6 +19,6 @@
 	}
 
 	public String getNameFromStack(ItemStack var1) {
-		return super.getName() + "." + DyeItem.dyeNames[WoolBlock.funkyMetaStuffA(var1.getItemDamage())];
+		return super.getName() + "." + DyeItem.dyeNames[var1.getItemDamage()];
 	}
 }
--- net/minecraft/client/gui/container/EditSignScreen.java
+++ net/minecraft/client/gui/container/EditSignScreen.java
@@ -69,7 +69,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 40, 16777215);
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)(this.width / 2), 0.0F, 50.0F);
--- /dev/null
+++ net/minecraft/game/world/biome/FreshwaterForestBiome.java
@@ -1,0 +1,33 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.feature.Feature;
+import net.minecraft.game.world.terrain.feature.TreeFeature;
+import net.minecraft.game.world.terrain.feature.WillowTreeFeature;
+
+import java.util.Random;
+
+public class FreshwaterForestBiome extends Biome {
+	public FreshwaterForestBiome(int i) {
+		super(i);
+		this.removeBeach();
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.heightOffset(0.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return super.buildBoostedNoiseSettings()
+				.heightOffset(10.0D);
+	}
+
+	public Feature getRandomTreeFeature(Random var1) {
+		return var1.nextInt(5) == 0 ? new WillowTreeFeature() : new TreeFeature();
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return Math.max(treeBonus + treeNoise, 0) + 5;
+	}
+}
--- /dev/null
+++ net/minecraft/game/item/ContainerCreative.java
@@ -1,0 +1,64 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.entity.player.InventoryPlayer;
+import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.item.slot.Slot;
+import net.minecraft.game.world.block.Block;
+
+public class ContainerCreative extends Container {
+	public InventoryPlayer inventoryPlayer;
+	public InventoryReadonly inventory;
+
+	public ContainerCreative(InventoryPlayer inventoryPlayer, InventoryReadonly inventory) {
+		this.inventoryPlayer = inventoryPlayer;
+		this.inventory = inventory;
+	}
+
+	public void setupItems(int row) {
+		this.inventorySlots.clear();
+		for (int i = row * 8; i < 64 + row * 8; i++) {
+			this.addSlot(new Slot(this.inventory, i, ((i - row * 8) % 8) * 18 + 8,
+					((i - row * 8) / 8) * 18 + 18));
+		}
+		for (int i = 0; i < 9; i++) {
+			this.addSlot(new Slot(this.inventoryPlayer, i, 8 + i * 18, 166));
+		}
+	}
+
+	public void setupBlocks(int row) {
+		this.inventorySlots.clear();
+		for (int i = row * 8; i < 64 + row * 8; i++) {
+			boolean invalid = false;
+
+			checkBlock: {
+				ItemStack itemStack = this.inventory.getStackInSlot(i);
+				if (itemStack == null
+						|| itemStack.id <= 0
+						|| itemStack.id >= 10000) {
+					invalid = true;
+					break checkBlock;
+				}
+
+				Item item = itemStack.getItem();
+				if (!(item instanceof BlockItem)) {
+					invalid = true;
+					break checkBlock;
+				}
+
+				Block block = Block.blocksList[item.itemID];
+				if (!block.isOpaqueCube()) {
+					invalid = true;
+					break checkBlock;
+				}
+			}
+
+			int var3 = ((i - row * 8) % 8) * 18 + 8;
+			int var4 = ((i - row * 8) / 8) * 18 + 18;
+			this.addSlot(new Slot(this.inventory, i, var3, var4));
+		}
+	}
+
+	public boolean isUsableByPlayer(PlayerEntity var1) {
+		return true;
+	}
+}
--- /dev/null
+++ argo/jdom/JsonConstants.java
@@ -1,0 +1,31 @@
+package argo.jdom;
+
+import java.util.List;
+import java.util.Map;
+
+final class JsonConstants extends JsonNode {
+	static final JsonConstants NULL = new JsonConstants(JsonNodeType.NULL);
+	static final JsonConstants TRUE = new JsonConstants(JsonNodeType.TRUE);
+	static final JsonConstants FALSE = new JsonConstants(JsonNodeType.FALSE);
+	private final JsonNodeType jsonNodeType;
+
+	private JsonConstants(JsonNodeType var1) {
+		this.jsonNodeType = var1;
+	}
+
+	public JsonNodeType getType() {
+		return this.jsonNodeType;
+	}
+
+	public String getText() {
+		throw new IllegalStateException("Attempt to get text on a JsonNode without text.");
+	}
+
+	public Map<JsonStringNode, JsonNode> getFields() {
+		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
+	}
+
+	public List<JsonNode> getElements() {
+		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerFillEdge.java
@@ -1,0 +1,18 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.IntArray2D;
+
+public class LayerFillEdge extends Layer {
+	public static final int EDGE_QUALITY = 1000;
+
+	private final int distance;
+
+	public LayerFillEdge(Layer parent, int distance) {
+		super(0L, parent);
+		this.distance = distance;
+	}
+
+	protected IntArray2D getData(int x, int z, int width, int length) {
+		return forEach(x, z, width, length, i -> i == 0 ? EDGE_QUALITY : Math.min(i * EDGE_QUALITY / this.distance, EDGE_QUALITY));
+	}
+}
--- argo/J_JdomParser.java
+++ /dev/null
@@ -1,22 +1,0 @@
-package argo;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-
-public final class J_JdomParser {
-	public J_JsonRootNode func_27366_a(Reader var1) throws J_InvalidSyntaxException, IOException {
-		J_JsonListenerToJdomAdapter var2 = new J_JsonListenerToJdomAdapter();
-		(new J_SajParser()).func_27463_a(var1, var2);
-		return var2.func_27208_a();
-	}
-
-	public J_JsonRootNode func_27367_a(String var1) throws J_InvalidSyntaxException {
-		try {
-			J_JsonRootNode var2 = this.func_27366_a(new StringReader(var1));
-			return var2;
-		} catch (IOException var4) {
-			throw new RuntimeException("Coding failure in Argo:  StringWriter gave an IOException", var4);
-		}
-	}
-}
--- net/minecraft/network/NetHandler.java
+++ net/minecraft/network/NetHandler.java
@@ -53,6 +53,8 @@
 import net.minecraft.network.packet.Packet9Respawn;
 
 public abstract class NetHandler {
+	public static final int PROTOCOL_VERSION = 810300000;
+
 	public abstract boolean isServerHandler();
 
 	public void handleMapChunk(Packet51MapChunk var1) {
--- net/minecraft/game/entity/vehicle/BoatEntity.java
+++ net/minecraft/game/entity/vehicle/BoatEntity.java
@@ -80,15 +80,7 @@
 					this.riddenByEntity.mountEntity(this);
 				}
 
-				int var3;
-				for(var3 = 0; var3 < 3; ++var3) {
-					this.dropItemWithOffset(Block.planks.blockID, 1, 0.0F);
-				}
-
-				for(var3 = 0; var3 < 2; ++var3) {
-					this.dropItemWithOffset(Item.stick.itemID, 1, 0.0F);
-				}
-
+				this.dropItemWithOffset(Item.boat.itemID, 1, 0);
 				this.setEntityDead();
 			}
 
@@ -252,20 +244,7 @@
 				}
 			}
 
-			if(this.isCollidedHorizontally && var6 > 0.15D) {
-				if(!this.worldObj.remoteWorld) {
-					this.setEntityDead();
-
-					int var22;
-					for(var22 = 0; var22 < 3; ++var22) {
-						this.dropItemWithOffset(Block.planks.blockID, 1, 0.0F);
-					}
-
-					for(var22 = 0; var22 < 2; ++var22) {
-						this.dropItemWithOffset(Item.stick.itemID, 1, 0.0F);
-					}
-				}
-			} else {
+			if(!this.isCollidedHorizontally || var6 < 0.15D) {
 				this.motionX *= (double)0.99F;
 				this.motionY *= (double)0.95F;
 				this.motionZ *= (double)0.99F;
--- net/minecraft/game/item/HoeItem.java
+++ net/minecraft/game/item/HoeItem.java
@@ -4,9 +4,9 @@
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.block.Block;
 
-public class HoeItem extends Item {
+public class HoeItem extends ToolItem {
 	public HoeItem(int var1, ToolMaterial var2) {
-		super(var1);
+		super(var1, 1, var2.getMaxUses(), var2.getEfficiencyOnProperMaterial(), var2.getHarvestLevel(), ToolType.HOE);
 		this.maxStackSize = 1;
 		this.setMaxDamage(var2.getMaxUses());
 	}
@@ -18,7 +18,7 @@
 			return false;
 		} else {
 			Block var10 = Block.farmland;
-			var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var10.stepSound.baseStepSoundDir(), (var10.stepSound.getVolume() + 1.0F) / 2.0F, var10.stepSound.getPitch() * 0.8F);
+			var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var10.stepSound.baseSteppySoundDir(), (var10.stepSound.getVolume() + 1.0F) / 2.0F, var10.stepSound.getPitch() * 0.8F);
 			if(var3.remoteWorld) {
 				return true;
 			} else {
--- net/minecraft/game/item/PickaxeItem.java
+++ net/minecraft/game/item/PickaxeItem.java
@@ -1,16 +1,7 @@
 package net.minecraft.game.item;
 
-import net.minecraft.game.world.block.Block;
-import net.minecraft.game.world.material.Material;
-
 public class PickaxeItem extends ToolItem {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.cobblestone, Block.doubleStoneSlab, Block.stoneSlab, Block.stone, Block.sandstone, Block.mossyCobblestone, Block.ironOre, Block.ironBlock, Block.coalOre, Block.goldBlock, Block.goldOre, Block.diamondOre, Block.diamondBlock, Block.ice, Block.netherrack, Block.lapisOre, Block.lapisBlock};
-
 	protected PickaxeItem(int var1, ToolMaterial var2) {
-		super(var1, 2, var2, blocksEffectiveAgainst);
-	}
-
-	public boolean canHarvestBlock(Block var1) {
-		return var1 == Block.obsidian ? this.toolMaterial.getHarvestLevel() == 3 : (var1 != Block.diamondBlock && var1 != Block.diamondOre ? (var1 != Block.goldBlock && var1 != Block.goldOre ? (var1 != Block.ironBlock && var1 != Block.ironOre ? (var1 != Block.lapisBlock && var1 != Block.lapisOre ? (var1 != Block.redstoneOre && var1 != Block.glowingRedstoneOre ? (var1.material == Material.stone ? true : var1.material == Material.iron) : this.toolMaterial.getHarvestLevel() >= 2) : this.toolMaterial.getHarvestLevel() >= 1) : this.toolMaterial.getHarvestLevel() >= 1) : this.toolMaterial.getHarvestLevel() >= 2) : this.toolMaterial.getHarvestLevel() >= 2);
+		super(var1, 2, var2, ToolType.PICKAXE);
 	}
 }
--- argo/J_ArrayNodeContainer.java
+++ /dev/null
@@ -1,19 +1,0 @@
-package argo;
-
-class J_ArrayNodeContainer implements J_NodeContainer {
-	final J_JsonArrayNodeBuilder field_27294_a;
-	final J_JsonListenerToJdomAdapter field_27293_b;
-
-	J_ArrayNodeContainer(J_JsonListenerToJdomAdapter var1, J_JsonArrayNodeBuilder var2) {
-		this.field_27293_b = var1;
-		this.field_27294_a = var2;
-	}
-
-	public void func_27290_a(J_JsonNodeBuilder var1) {
-		this.field_27294_a.func_27240_a(var1);
-	}
-
-	public void func_27289_a(J_JsonFieldBuilder var1) {
-		throw new RuntimeException("Coding failure in Argo:  Attempt to add a field to an array.");
-	}
-}
--- /dev/null
+++ net/minecraft/game/world/biome/BadlandsBiome.java
@@ -1,0 +1,109 @@
+package net.minecraft.game.world.biome;
+
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+import net.minecraft.util.MathHelper;
+
+import java.util.Random;
+
+public class BadlandsBiome extends Biome {
+	protected PerlinNoiseOctaves badlandsNoise;
+	protected PerlinNoiseOctaves hoodooNoise;
+	protected PerlinNoiseOctaves grassNoise;
+
+	private static final int[] clayColors = {
+			0,
+			1,
+			1,
+			1,
+			1,
+			1,
+			4,
+			7,
+			8,
+			14,
+			15,
+	};
+	private final Int2IntMap clayColorCache = new Int2IntOpenHashMap();
+
+	public BadlandsBiome(int i) {
+		super(i);
+		this.topBlock = (byte)Block.redSand.blockID;
+		this.fillerBlock = (byte)Block.hardenedClay.blockID;
+		this.fillerMeta = 1;
+		this.removeBeach();
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return treeBonus + treeNoise / 2 + 3;
+	}
+
+	public int getDeadBushCount() {
+		return 2;
+	}
+
+	public int getCactusCount() {
+		return 10;
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(25.0D)
+				.heightOffset(10.0D)
+				.noiseUnderDamp(2.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings()
+				.heightOffset(60.0D);
+	}
+
+	public NoiseSettings getNoiseSettings(int x, int z, double boost, double ocean, double edge) {
+		boost = (boost - 0.5D) * 10.0D;
+		boost = MathHelper.clamp(boost, 0.0D, 1.0D);
+		if (boost == 0.0D) {
+			double hoodoo = this.hoodooNoise.generateNoiseNormalized2D(x * 0.25D, z * 0.25D);
+			hoodoo = (hoodoo - 0.5D) * 20.0D;
+			hoodoo = MathHelper.clamp(hoodoo, 0.0D, 1.0D);
+			boost += hoodoo;
+		}
+		return super.getNoiseSettings(x, z, boost, ocean, edge);
+	}
+
+	protected void initializeNoise(Random random) {
+		this.badlandsNoise = new PerlinNoiseOctaves(random, 1);
+		this.hoodooNoise = new PerlinNoiseOctaves(random, 4);
+		this.grassNoise = new PerlinNoiseOctaves(random, 4);
+		this.clayColorCache.clear();
+	}
+
+	private int getClayColor(int y) {
+		return this.clayColorCache.computeIfAbsent(y, k -> {
+			double index = this.badlandsNoise.generateNoise3D(0.0D, y * 0.5D, 0.0D);
+			return clayColors[Math.floorMod((int)(index * 10000.0D), clayColors.length)];
+		});
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		int wx = chunk.xPosition * 16 + x;
+		int wz = chunk.zPosition * 16 + z;
+
+		this.topBlock = surfaceHeight > 116 + random.nextInt(4) && this.grassNoise.generateNoiseNormalized2D(wx * 0.02D, wz * 0.02D) + random.nextDouble() * 0.1D > 0.3D
+				? (byte)Block.grass.blockID : (byte)Block.redSand.blockID;
+
+		super.buildSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+
+		int clayHeight = 82;
+		for (int y = surfaceHeight; y > chunk.getMinY(); y--) {
+			int block = chunk.getBlockID(x, y, z);
+			if (y > clayHeight && (block == this.stoneBlock || block == Block.redSand.blockID || block == Block.hardenedClay.blockID)) {
+				chunk.setBlockRaw(x, y, z, Block.hardenedClay.blockID);
+				chunk.setBlockMetadata(x, y, z, this.getClayColor(y));
+			}
+		}
+	}
+}
--- net/minecraft/game/world/terrain/generate/TerrainGenerator.java
+++ net/minecraft/game/world/terrain/generate/TerrainGenerator.java
@@ -2,11 +2,13 @@
 
 import java.util.Random;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.game.world.chunk.ChunkProvider;
 
 public class TerrainGenerator {
 	protected int range = 8;
 	protected Random rand = new Random();
+	protected World worldObj;
 
 	public void generate(ChunkProvider var1, World var2, int var3, int var4, byte[] var5) {
 		int var6 = this.range;
@@ -23,6 +25,25 @@
 
 	}
 
+	public void generate(ChunkProvider var1, World var2, int var3, int var4, Chunk var5) {
+		int var6 = this.range;
+		this.worldObj = var2;
+		this.rand.setSeed(var2.getRandomSeed());
+		long var7 = this.rand.nextLong() / 2L * 2L + 1L;
+		long var9 = this.rand.nextLong() / 2L * 2L + 1L;
+
+		for(int var11 = var3 - var6; var11 <= var3 + var6; ++var11) {
+			for(int var12 = var4 - var6; var12 <= var4 + var6; ++var12) {
+				this.rand.setSeed((long)var11 * var7 + (long)var12 * var9 ^ var2.getRandomSeed());
+				this.generateRecursive(var2, var11, var12, var3, var4, var5);
+			}
+		}
+
+	}
+
 	protected void generateRecursive(World var1, int var2, int var3, int var4, int var5, byte[] var6) {
+	}
+
+	protected void generateRecursive(World var1, int var2, int var3, int var4, int var5, Chunk var6) {
 	}
 }
--- net/minecraft/client/ScreenShotHelper.java
+++ net/minecraft/client/ScreenShotHelper.java
@@ -20,7 +20,7 @@
 		try {
 			File var3 = new File(var0, "screenshots");
 			var3.mkdir();
-			if(buffer == null || buffer.capacity() < var1 * var2) {
+			if(buffer == null || buffer.capacity() < var1 * var2 * 3) {
 				buffer = BufferUtils.createByteBuffer(var1 * var2 * 3);
 			}
 
@@ -34,7 +34,7 @@
 			buffer.clear();
 			GL11.glReadPixels(0, 0, var1, var2, GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)buffer);
 			buffer.clear();
-			String var4 = "" + dateFormat.format(new Date());
+			String var4 = dateFormat.format(new Date());
 			int var6 = 1;
 
 			while(true) {
--- /dev/null
+++ net/minecraft/game/world/block/HardenedClayBlock.java
@@ -1,0 +1,49 @@
+package net.minecraft.game.world.block;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.WoolItem;
+import net.minecraft.game.world.BlockAccess;
+import net.minecraft.game.world.material.Material;
+
+public class HardenedClayBlock extends Block {
+	public static final int[] clayColors = {
+			0xffc9ab, // White
+			0xae5f2c, // Orange
+			0xb55499, // Magenta
+			0x63b0cc, // Light Blue
+			0xc09e39, // Yellow
+			0x5aad31, // Lime
+			0xd988bb, // Pink
+			0x614738, // Gray
+			0xa07d6a, // Light Gray
+			0x24616d, // Cyan
+			0x7744af, // Purple
+			0x324577, // Blue
+			0x683019, // Brown
+			0x406721, // Green
+			0xce593f, // Red
+			0x382b25, // Black
+	};
+
+	protected HardenedClayBlock(int var1, int var2, Material var3) {
+		super(var1, var2, var3);
+	}
+
+	protected Item getItem() {
+		return new WoolItem(this.blockID - 256).setName("hardenedClay");
+	}
+
+	public int getInventoryColor(int var1) {
+		if (var1 < 0 || var1 > 15) var1 = 0;
+		return clayColors[var1];
+	}
+
+	public int getColorMultiplier(BlockAccess var1, int var2, int var3, int var4) {
+		int meta = var1.getBlockMetadata(var2, var3, var4);
+		return clayColors[meta];
+	}
+
+	protected int damageDropped(int var1) {
+		return var1;
+	}
+}
--- net/minecraft/game/world/block/MovingPistonBlock.java
+++ net/minecraft/game/world/block/MovingPistonBlock.java
@@ -5,16 +5,27 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
 import net.minecraft.game.world.block.tileentity.PistonTileEntity;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
 
 public class MovingPistonBlock extends ContainerBlock {
+	public static final EnumProperty<Direction> DIRECTION = SharedProperties.DIRECTION;
+	public static final BooleanProperty STICKY = new BooleanProperty("sticky");
+
 	public MovingPistonBlock(int var1) {
 		super(var1, Material.piston);
 		this.setHardness(-1.0F);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, STICKY);
+	}
+
 	protected TileEntity getTileEntity() {
 		return null;
 	}
@@ -80,7 +91,7 @@
 
 	}
 
-	public static TileEntity getTileEntity(int var0, int var1, int var2, boolean var3, boolean var4) {
+	public static TileEntity getTileEntity(int var0, int var1, Direction var2, boolean var3, boolean var4) {
 		return new PistonTileEntity(var0, var1, var2, var3, var4);
 	}
 
@@ -112,29 +123,29 @@
 				var7 = 1.0F - var7;
 			}
 
-			int var8 = var5.getOrientation();
-			this.minX = var6.minX - (double)((float)Direction.faceToX[var8] * var7);
-			this.minY = var6.minY - (double)((float)Direction.faceToY[var8] * var7);
-			this.minZ = var6.minZ - (double)((float)Direction.faceToZ[var8] * var7);
-			this.maxX = var6.maxX - (double)((float)Direction.faceToX[var8] * var7);
-			this.maxY = var6.maxY - (double)((float)Direction.faceToY[var8] * var7);
-			this.maxZ = var6.maxZ - (double)((float)Direction.faceToZ[var8] * var7);
+			Direction var8 = var5.getOrientation();
+			this.minX = var6.minX - (double)((float)var8.X * var7);
+			this.minY = var6.minY - (double)((float)var8.Y * var7);
+			this.minZ = var6.minZ - (double)((float)var8.Z * var7);
+			this.maxX = var6.maxX - (double)((float)var8.X * var7);
+			this.maxY = var6.maxY - (double)((float)var8.Y * var7);
+			this.maxZ = var6.maxZ - (double)((float)var8.Z * var7);
 		}
 
 	}
 
-	public AxisAlignedBB getPushBounds(World var1, int var2, int var3, int var4, int var5, float var6, int var7) {
+	public AxisAlignedBB getPushBounds(World var1, int var2, int var3, int var4, int var5, float var6, Direction var7) {
 		if(var5 != 0 && var5 != this.blockID) {
 			AxisAlignedBB var8 = Block.blocksList[var5].getCollisionBoundingBoxFromPool(var1, var2, var3, var4);
 			if(var8 == null) {
 				return null;
 			} else {
-				var8.minX -= (double)((float)Direction.faceToX[var7] * var6);
-				var8.maxX -= (double)((float)Direction.faceToX[var7] * var6);
-				var8.minY -= (double)((float)Direction.faceToY[var7] * var6);
-				var8.maxY -= (double)((float)Direction.faceToY[var7] * var6);
-				var8.minZ -= (double)((float)Direction.faceToZ[var7] * var6);
-				var8.maxZ -= (double)((float)Direction.faceToZ[var7] * var6);
+				var8.minX -= (double)((float)var7.X * var6);
+				var8.maxX -= (double)((float)var7.X * var6);
+				var8.minY -= (double)((float)var7.Y * var6);
+				var8.maxY -= (double)((float)var7.Y * var6);
+				var8.minZ -= (double)((float)var7.Z * var6);
+				var8.maxZ -= (double)((float)var7.Z * var6);
 				return var8;
 			}
 		} else {
--- net/minecraft/game/item/FoodItem.java
+++ net/minecraft/game/item/FoodItem.java
@@ -3,6 +3,10 @@
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.world.World;
 
+import java.util.List;
+
+import static net.minecraft.util.StringTranslate.i18nf;
+
 public class FoodItem extends Item {
 	private int healAmount;
 	private boolean isWolfsFavoriteMeat;
@@ -26,5 +30,10 @@
 
 	public boolean getIsWolfsFavoriteMeat() {
 		return this.isWolfsFavoriteMeat;
+	}
+
+	public void buildTooltipFromStack(ItemStack var1, List<String> tooltip) {
+		super.buildTooltipFromStack(var1, tooltip);
+		tooltip.add(i18nf("tooltip.heal", this.healAmount));
 	}
 }
--- net/minecraft/client/render/texture/TextureFlamesFX.java
+++ net/minecraft/client/render/texture/TextureFlamesFX.java
@@ -7,7 +7,7 @@
 	protected float[] field_1132_h = new float[320];
 
 	public TextureFlamesFX(int var1) {
-		super(Block.fire.textureIndex + var1 * 16);
+		super(Block.fire.textureIndex + var1 * 32);
 	}
 
 	public void onTick() {
--- net/minecraft/network/packet/Packet51MapChunk.java
+++ net/minecraft/network/packet/Packet51MapChunk.java
@@ -3,21 +3,24 @@
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.util.zip.DataFormatException;
 import java.util.zip.Deflater;
 import java.util.zip.Inflater;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.chunk.ChunkSection;
 import net.minecraft.network.NetHandler;
 
 public class Packet51MapChunk extends Packet {
 	public int xPosition;
-	public int yPosition;
 	public int zPosition;
-	public int xSize;
-	public int ySize;
-	public int zSize;
-	public byte[] chunk;
-	private int chunkSize;
+	public byte[] data;
+	public boolean includeInitialize;
+	private int sectionCount;
+	private int dataSize;
 
 	public Packet51MapChunk() {
 		this.isChunkDataPacket = true;
@@ -25,20 +28,18 @@
 
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.xPosition = var1.readInt();
-		this.yPosition = var1.readShort();
 		this.zPosition = var1.readInt();
-		this.xSize = var1.read() + 1;
-		this.ySize = var1.read() + 1;
-		this.zSize = var1.read() + 1;
-		this.chunkSize = var1.readInt();
-		byte[] var2 = new byte[this.chunkSize];
-		var1.readFully(var2);
-		this.chunk = new byte[this.xSize * this.ySize * this.zSize * 5 / 2];
+		this.includeInitialize = var1.readBoolean();
+		this.sectionCount = var1.readInt();
+		this.dataSize = var1.readInt();
+		byte[] compressedData = new byte[this.dataSize];
+		var1.readFully(compressedData);
+		this.data = new byte[this.sectionCount * ChunkSection.PACKED_DATA_SIZE + (includeInitialize ? 256 : 0)];
 		Inflater var3 = new Inflater();
-		var3.setInput(var2);
+		var3.setInput(compressedData, 0, this.dataSize);
 
 		try {
-			var3.inflate(this.chunk);
+			var3.inflate(this.data);
 		} catch (DataFormatException var8) {
 			throw new IOException("Bad compressed data format");
 		} finally {
@@ -49,13 +50,11 @@
 
 	public void writePacketData(DataOutputStream var1) throws IOException {
 		var1.writeInt(this.xPosition);
-		var1.writeShort(this.yPosition);
 		var1.writeInt(this.zPosition);
-		var1.write(this.xSize - 1);
-		var1.write(this.ySize - 1);
-		var1.write(this.zSize - 1);
-		var1.writeInt(this.chunkSize);
-		var1.write(this.chunk, 0, this.chunkSize);
+		var1.writeBoolean(this.includeInitialize);
+		var1.writeInt(this.sectionCount);
+		var1.writeInt(this.dataSize);
+		var1.write(this.data, 0, this.dataSize);
 	}
 
 	public void processPacket(NetHandler var1) {
@@ -63,28 +62,35 @@
 	}
 
 	public int getPacketSize() {
-		return 17 + this.chunkSize;
+		return 17 + this.dataSize;
 	}
 
-	public Packet51MapChunk(int var1, int var2, int var3, int var4, int var5, int var6, World var7) {
+	public Packet51MapChunk(int x, int z, boolean init, World world) {
+		Chunk chunk = world.getChunkFromChunkCoords(x, z);
+
 		this.isChunkDataPacket = true;
-		this.xPosition = var1;
-		this.yPosition = var2;
-		this.zPosition = var3;
-		this.xSize = var4;
-		this.ySize = var5;
-		this.zSize = var6;
-		byte[] var8 = var7.getChunkData(var1, var2, var3, var4, var5, var6);
+		this.xPosition = x;
+		this.zPosition = z;
+		this.includeInitialize = init;
+		this.sectionCount = chunk.sections.size();
+
+		byte[] uncompressedData = new byte[this.sectionCount * ChunkSection.PACKED_DATA_SIZE + (init ? 256 : 0)];
+		int offset = 0;
+		for (Int2ObjectMap.Entry<ChunkSection> section : chunk.sections.int2ObjectEntrySet()) {
+			ByteBuffer.wrap(uncompressedData, offset, 4).putInt(section.getIntKey());
+			section.getValue().writeBytes(uncompressedData, offset + 4);
+			offset += ChunkSection.PACKED_DATA_SIZE;
+		}
+
+		if (init) {
+			System.arraycopy(chunk.getBiomeArray(), 0, uncompressedData, offset, 256);
+		}
+
 		Deflater var9 = new Deflater(-1);
-
-		try {
-			var9.setInput(var8);
-			var9.finish();
-			this.chunk = new byte[var4 * var5 * var6 * 5 / 2];
-			this.chunkSize = var9.deflate(this.chunk);
-		} finally {
-			var9.end();
-		}
-
+		var9.setInput(uncompressedData);
+		var9.finish();
+		this.data = new byte[this.sectionCount * ChunkSection.PACKED_DATA_SIZE + (init ? 256 : 0)];
+		this.dataSize = var9.deflate(this.data);
+		var9.end();
 	}
 }
--- net/minecraft/game/item/recipe/RecipesCrafting.java
+++ net/minecraft/game/item/recipe/RecipesCrafting.java
@@ -5,9 +5,9 @@
 
 public class RecipesCrafting {
 	public void addRecipes(CraftingManager var1) {
-		var1.addRecipe(new ItemStack(Block.chest), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.planks});
-		var1.addRecipe(new ItemStack(Block.furnace), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.cobblestone});
-		var1.addRecipe(new ItemStack(Block.workbench), new Object[]{"##", "##", Character.valueOf('#'), Block.planks});
-		var1.addRecipe(new ItemStack(Block.sandstone), new Object[]{"##", "##", Character.valueOf('#'), Block.sand});
+		var1.addRecipe(new ItemStack(Block.chest), "###", "# #", "###", '#', Block.planks);
+		var1.addRecipe(new ItemStack(Block.furnace), "###", "# #", "###", '#', Block.cobblestone);
+		var1.addRecipe(new ItemStack(Block.workbench), "##", "##", '#', Block.planks);
+		var1.addRecipe(new ItemStack(Block.sandstone), "##", "##", '#', Block.sand);
 	}
 }
--- net/minecraft/game/entity/animal/CowEntity.java
+++ net/minecraft/game/entity/animal/CowEntity.java
@@ -37,10 +37,6 @@
 		return 0.4F;
 	}
 
-	protected int getDropItemId() {
-		return Item.leather.itemID;
-	}
-
 	public boolean onInteract(PlayerEntity var1) {
 		ItemStack var2 = var1.inventory.getCurrentItem();
 		if(var2 != null && var2.id == Item.emptyBucket.itemID) {
--- net/minecraft/game/world/chunk/loader/region/RegionFileCache.java
+++ net/minecraft/game/world/chunk/loader/region/RegionFileCache.java
@@ -71,4 +71,9 @@
 		RegionFile var3 = getFile(var0, var1, var2);
 		return var3.getChunkDataOutputStream(var1 & 31, var2 & 31);
 	}
+
+	public static boolean chunkExists(File var0, int var1, int var2) {
+		RegionFile var3 = getFile(var0, var1, var2);
+		return var3.chunkDataExists(var1 & 31, var2 & 31);
+	}
 }
--- argo/J_ObjectNodeContainer.java
+++ /dev/null
@@ -1,19 +1,0 @@
-package argo;
-
-class J_ObjectNodeContainer implements J_NodeContainer {
-	final J_JsonObjectNodeBuilder field_27296_a;
-	final J_JsonListenerToJdomAdapter field_27295_b;
-
-	J_ObjectNodeContainer(J_JsonListenerToJdomAdapter var1, J_JsonObjectNodeBuilder var2) {
-		this.field_27295_b = var1;
-		this.field_27296_a = var2;
-	}
-
-	public void func_27290_a(J_JsonNodeBuilder var1) {
-		throw new RuntimeException("Coding failure in Argo:  Attempt to add a node to an object.");
-	}
-
-	public void func_27289_a(J_JsonFieldBuilder var1) {
-		this.field_27296_a.func_27237_a(var1);
-	}
-}
--- /dev/null
+++ net/minecraft/game/world/chunk/ChunkSection.java
@@ -1,0 +1,130 @@
+package net.minecraft.game.world.chunk;
+
+import com.mojang.nbt.CompoundTag;
+import net.minecraft.game.world.LightType;
+import net.minecraft.util.HalfByteArray3D;
+
+public class ChunkSection {
+	public static final int PACKED_DATA_SIZE = 4 + 4096 + 4096 + 4096;
+
+	private final byte[] blocks;
+	private final byte[] metadata;
+	private final byte[] light;
+	private final HalfByteArray3D accessibleBlockLight;
+	private final HalfByteArray3D accessibleSkyLight;
+	private int blockCount;
+
+	public ChunkSection() {
+		this(new byte[4096], new byte[4096], new byte[4096]);
+	}
+
+	public ChunkSection(byte[] blocks, byte[] metadata, byte[] light) {
+		this.blocks = blocks;
+		this.metadata = metadata;
+		this.light = light;
+		this.accessibleBlockLight = new HalfByteArray3D(light, false, 16, 16, 16);
+		this.accessibleSkyLight = new HalfByteArray3D(light, true, 16, 16, 16);
+	}
+
+	public int getBlock(int x, int y, int z) {
+		return this.blocks[getIndex(x, y, z)] & 0xFF;
+	}
+
+	public void setBlock(int x, int y, int z, int block) {
+		int i = getIndex(x, y, z);
+		byte prevBlock = this.blocks[i];
+		this.blocks[i] = (byte) block;
+		if (block != 0) {
+			if (prevBlock == 0) this.blockCount++;
+		} else if (prevBlock != 0) this.blockCount--;
+	}
+
+	public int getMetadata(int x, int y, int z) {
+		return this.metadata[getIndex(x, y, z)] & 0xFF;
+	}
+
+	public void setMetadata(int x, int y, int z, int metadata) {
+		this.metadata[getIndex(x, y, z)] = (byte) metadata;
+	}
+
+	public int getSkyLight(int x, int y, int z) {
+		return (this.light[getIndex(x, y, z)] & 0xF0) >> 4;
+	}
+
+	public void setSkyLight(int x, int y, int z, int skyLight) {
+		int i = getIndex(x, y, z);
+		this.light[i] = (byte) (this.light[i] & 0xF | (skyLight & 0xF) << 4);
+	}
+
+	public HalfByteArray3D getSkyLightArray() {
+		return this.accessibleSkyLight;
+	}
+
+	public int getBlockLight(int x, int y, int z) {
+		return this.light[getIndex(x, y, z)] & 0xF;
+	}
+
+	public void setBlockLight(int x, int y, int z, int blockLight) {
+		int i = getIndex(x, y, z);
+		this.light[i] = (byte) (this.light[i] & 0xF0 | blockLight & 0xF);
+	}
+
+	public HalfByteArray3D getBlockLightArray() {
+		return this.accessibleBlockLight;
+	}
+
+	public int getSavedLightValue(LightType lightType, int x, int y, int z) {
+		return lightType == LightType.BLOCK ? this.getBlockLight(x, y, z) : this.getSkyLight(x, y, z);
+	}
+
+	public void setLightValue(LightType lightType, int x, int y, int z, int light) {
+		if (lightType == LightType.BLOCK) this.setBlockLight(x, y, z, light);
+		else this.setSkyLight(x, y, z, light);
+	}
+
+	public static int getIndex(int x, int y, int z) {
+		return y << 8 | z << 4 | x;
+	}
+
+	public CompoundTag toNBT(int level) {
+		CompoundTag compound = new CompoundTag();
+		compound.setInteger("Level", level);
+		compound.setByteArray("Blocks", this.blocks);
+		compound.setByteArray("Metadata", this.metadata);
+		compound.setByteArray("Light", this.light);
+		compound.setInteger("BlockCount", this.blockCount);
+		return compound;
+	}
+
+	public boolean isEmpty() {
+		return this.blockCount <= 0;
+	}
+
+	public static ChunkSection fromNBT(CompoundTag compound) {
+		ChunkSection section = new ChunkSection(compound.getByteArray("Blocks"), compound.getByteArray("Metadata"), compound.getByteArray("Light"));
+		section.blockCount = compound.getInteger("BlockCount");
+		return section;
+	}
+
+	public void writeBytes(byte[] array, int offset) {
+		System.arraycopy(this.blocks, 0, array, offset, this.blocks.length);
+		offset += this.blocks.length;
+		System.arraycopy(this.metadata, 0, array, offset, this.metadata.length);
+		offset += this.metadata.length;
+		System.arraycopy(this.light, 0, array, offset, this.light.length);
+	}
+
+	public static ChunkSection fromBytes(byte[] bytes, int offset) {
+		byte[] blocks = new byte[4096];
+		byte[] metadata = new byte[4096];
+		byte[] light = new byte[4096];
+
+		System.arraycopy(bytes, offset, blocks, 0, blocks.length);
+		offset += blocks.length;
+		System.arraycopy(bytes, offset, metadata, 0, metadata.length);
+		offset += metadata.length;
+		System.arraycopy(bytes, offset, light, 0, light.length);
+
+		return new ChunkSection(blocks, metadata, light);
+	}
+}
--- net/minecraft/game/item/DyeItem.java
+++ net/minecraft/game/item/DyeItem.java
@@ -10,7 +10,7 @@
 import net.minecraft.game.world.block.WoolBlock;
 
 public class DyeItem extends Item {
-	public static final String[] dyeNames = new String[]{"black", "red", "green", "brown", "blue", "purple", "cyan", "silver", "gray", "pink", "lime", "yellow", "lightBlue", "magenta", "orange", "white"};
+	public static final String[] dyeNames = new String[]{"white", "orange", "magenta", "light_blue", "yellow", "lime", "pink", "gray", "light_gray", "cyan", "purple", "blue", "brown", "green", "red", "black"};
 	public static final int[] dyeColors = new int[]{1973019, 11743532, 3887386, 5320730, 2437522, 8073150, 2651799, 2651799, 4408131, 14188952, 4312372, 14602026, 6719955, 12801229, 15435844, 15790320};
 
 	public DyeItem(int var1) {
@@ -20,7 +20,7 @@
 	}
 
 	public int getTextureFromDamage(int var1) {
-		return this.textureIndex + var1 % 8 * 16 + var1 / 8;
+		return this.textureIndex + var1 * 32;
 	}
 
 	public String getNameFromStack(ItemStack var1) {
@@ -28,7 +28,7 @@
 	}
 
 	public boolean onItemUse(ItemStack var1, PlayerEntity var2, World var3, int var4, int var5, int var6, int var7) {
-		if(var1.getItemDamage() == 15) {
+		if(var1.getItemDamage() == 0) {
 			int var8 = var3.getBlockId(var4, var5, var6);
 			if(var8 == Block.sapling.blockID) {
 				if(!var3.remoteWorld) {
@@ -53,7 +53,7 @@
 					--var1.count;
 
 					label53:
-					for(int var9 = 0; var9 < 128; ++var9) {
+					for(int var9 = 0; var9 < 16; ++var9) {
 						int var10 = var4;
 						int var11 = var5 + 1;
 						int var12 = var6;
@@ -68,9 +68,7 @@
 						}
 
 						if(var3.getBlockId(var10, var11, var12) == 0) {
-							if(random.nextInt(10) != 0) {
-								var3.setBlockAndMetadataWithNotify(var10, var11, var12, Block.tallGrass.blockID, 1);
-							} else if(random.nextInt(3) != 0) {
+							if(random.nextInt(3) != 0) {
 								var3.setBlockWithNotify(var10, var11, var12, Block.flower.blockID);
 							} else {
 								var3.setBlockWithNotify(var10, var11, var12, Block.rose.blockID);
@@ -89,7 +87,7 @@
 	public void saddleEntity(ItemStack var1, LivingEntity var2) {
 		if(var2 instanceof SheepEntity) {
 			SheepEntity var3 = (SheepEntity)var2;
-			int var4 = WoolBlock.funkyMetaStuffA(var1.getItemDamage());
+			int var4 = var1.getItemDamage();
 			if(!var3.getSheared() && var3.getFleeceColor() != var4) {
 				var3.setFleeceColor(var4);
 				--var1.count;
--- /dev/null
+++ net/minecraft/client/gui/CreditsScreen.java
@@ -1,0 +1,66 @@
+package net.minecraft.client.gui;
+
+import net.minecraft.client.Minecraft;
+import org.lwjgl.opengl.GL11;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+
+public class CreditsScreen extends GuiScreen {
+	private final List<String> lines = new ArrayList<>();
+	private int updateCounter;
+
+	public CreditsScreen() {
+		try {
+			BufferedReader creditsReader = new BufferedReader(
+					new InputStreamReader(
+							Objects.requireNonNull(
+									CreditsScreen.class.getResourceAsStream(
+											"/title/credits.txt"))));
+			String line;
+
+			while ((line = creditsReader.readLine()) != null) {
+				lines.add(line.replace("%version%", Minecraft.SHORT_VERSION));
+			}
+		} catch (IOException e) {
+			System.err.println("Failed to read credits!");
+			e.printStackTrace();
+		}
+	}
+
+	protected void keyTyped(char var1, int var2) {
+		this.mc.displayGuiScreen(null);
+	}
+
+	protected void mouseClicked(int var1, int var2, int var3) {
+		this.mc.displayGuiScreen(null);
+	}
+
+	public void updateScreen() {
+		this.updateCounter++;
+		ScaledResolution res = new ScaledResolution(this.mc.gameSettings, this.mc.displayWidth, this.mc.displayHeight);
+
+		if ((this.height + this.lines.size() * 10 - this.updateCounter) * res.scaleFactor < 0) {
+			this.mc.displayGuiScreen(null);
+		}
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		super.drawScreen(var1, var2, var3);
+		float progress = this.updateCounter + var3;
+
+		this.drawDefaultBackground(var3);
+
+		GL11.glTranslatef(0.0F, -progress, 0.0F);
+		int y = 0;
+		for (String line : this.lines) {
+			this.drawCenteredString(this.fontRenderer, line, this.width / 2, this.height + y, 0xFFFFFF);
+			y += 10;
+		}
+		GL11.glTranslatef(0.0F, progress, 0.0F);
+	}
+}
--- net/minecraft/game/world/block/WoolBlock.java
+++ net/minecraft/game/world/block/WoolBlock.java
@@ -1,19 +1,22 @@
 package net.minecraft.game.world.block;
 
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.WoolItem;
 import net.minecraft.game.world.material.Material;
 
 public class WoolBlock extends Block {
+	private static final int[] TEX_TYPES = TerrainLayout.varyingTexCoord("wool", 16);
+
 	public WoolBlock() {
-		super(35, 64, Material.cloth);
+		super(35, TEX_TYPES[0], Material.cloth);
+	}
+
+	protected Item getItem() {
+		return new WoolItem(this.blockID - 256).setName("cloth");
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		if(var2 == 0) {
-			return this.textureIndex;
-		} else {
-			var2 = ~(var2 & 15);
-			return 113 + ((var2 & 8) >> 3) + (var2 & 7) * 16;
-		}
+		return TEX_TYPES[var2];
 	}
 
 	protected int damageDropped(int var1) {
--- /dev/null
+++ net/minecraft/game/world/NewWorldInfo.java
@@ -1,0 +1,21 @@
+package net.minecraft.game.world;
+
+public class NewWorldInfo {
+	public final String name;
+	public final long seed;
+	public final boolean creative;
+
+	public NewWorldInfo(String name) {
+		this(name, 0L);
+	}
+
+	public NewWorldInfo(String name, long seed) {
+		this(name, seed, false);
+	}
+
+	public NewWorldInfo(String name, long seed, boolean creative) {
+		this.name = name;
+		this.seed = seed;
+		this.creative = creative;
+	}
+}
--- net/minecraft/client/model/SpiderModel.java
+++ net/minecraft/client/model/SpiderModel.java
@@ -99,20 +99,20 @@
 		float var16 = Math.abs(MathHelper.sin(var1 * 0.6662F + (float)Math.PI * 0.5F) * 0.4F) * var2;
 		float var17 = Math.abs(MathHelper.sin(var1 * 0.6662F + (float)Math.PI * 3.0F / 2.0F) * 0.4F) * var2;
 		this.spiderLeg1.rotateAngleY += var10;
-		this.spiderLeg2.rotateAngleY += -var10;
+		this.spiderLeg2.rotateAngleY -= var10;
 		this.spiderLeg3.rotateAngleY += var11;
-		this.spiderLeg4.rotateAngleY += -var11;
+		this.spiderLeg4.rotateAngleY -= var11;
 		this.spiderLeg5.rotateAngleY += var12;
-		this.spiderLeg6.rotateAngleY += -var12;
+		this.spiderLeg6.rotateAngleY -= var12;
 		this.spiderLeg7.rotateAngleY += var13;
-		this.spiderLeg8.rotateAngleY += -var13;
+		this.spiderLeg8.rotateAngleY -= var13;
 		this.spiderLeg1.rotateAngleZ += var14;
-		this.spiderLeg2.rotateAngleZ += -var14;
+		this.spiderLeg2.rotateAngleZ -= var14;
 		this.spiderLeg3.rotateAngleZ += var15;
-		this.spiderLeg4.rotateAngleZ += -var15;
+		this.spiderLeg4.rotateAngleZ -= var15;
 		this.spiderLeg5.rotateAngleZ += var16;
-		this.spiderLeg6.rotateAngleZ += -var16;
+		this.spiderLeg6.rotateAngleZ -= var16;
 		this.spiderLeg7.rotateAngleZ += var17;
-		this.spiderLeg8.rotateAngleZ += -var17;
+		this.spiderLeg8.rotateAngleZ -= var17;
 	}
 }
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/ShaderInfo.java
@@ -1,0 +1,47 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import net.mine_diver.smoothbeta.client.render.gl.GlBlendState;
+
+public class ShaderInfo {
+	public final String vertex;
+	public final String fragment;
+	public final String[] attributes;
+	public final Sampler[] samplers;
+	public final Uniform[] uniforms;
+	public final GlBlendState blendState;
+	public final VertexFormat vertexFormat;
+
+	public ShaderInfo(String vertex, String fragment, String[] attributes, Sampler[] samplers, Uniform[] uniforms, GlBlendState blendState, VertexFormat vertexFormat) {
+		this.vertex = vertex;
+		this.fragment = fragment;
+		this.attributes = attributes;
+		this.samplers = samplers;
+		this.uniforms = uniforms;
+		this.blendState = blendState;
+		this.vertexFormat = vertexFormat;
+	}
+
+	public static class Sampler {
+		public final String name;
+		public final String file;
+
+		public Sampler(String name, String file) {
+			this.name = name;
+			this.file = file;
+		}
+	}
+
+	public static class Uniform {
+		public final String name;
+		public final String type;
+		public final int count;
+		public final float[] values;
+
+		public Uniform(String name, String type, int count, float[] values) {
+			this.name = name;
+			this.type = type;
+			this.count = count;
+			this.values = values;
+		}
+	}
+}
--- net/minecraft/network/NetLoginHandler.java
+++ net/minecraft/network/NetLoginHandler.java
@@ -71,8 +71,8 @@
 
 	public void handleLogin(Packet1Login var1) {
 		this.username = var1.username;
-		if(var1.protocolVersion != 14) {
-			if(var1.protocolVersion > 14) {
+		if(var1.protocolVersion != PROTOCOL_VERSION) {
+			if(var1.protocolVersion > PROTOCOL_VERSION) {
 				this.kickUser("Outdated server!");
 			} else {
 				this.kickUser("Outdated client!");
@@ -97,10 +97,10 @@
 			WorldServer var3 = this.mcServer.getWorldManager(var2.dimension);
 			BlockPos var4 = var3.getSpawnPoint();
 			NetServerHandler var5 = new NetServerHandler(this.mcServer, this.netManager, var2);
-			var5.sendPacket(new Packet1Login("", var2.entityId, var3.getRandomSeed(), (byte)var3.dimension.worldType));
+			var5.sendPacket(new Packet1Login("", var2.entityId, (byte)var3.dimension.worldType));
 			var5.sendPacket(new Packet6SpawnPosition(var4.x, var4.y, var4.z));
 			this.mcServer.configManager.func_28170_a(var2, var3);
-			this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("\u00a7e" + var2.username + " joined the game."));
+			this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("§e" + var2.username + " joined the game."));
 			this.mcServer.configManager.playerLoggedIn(var2);
 			var5.teleportTo(var2.posX, var2.posY, var2.posZ, var2.rotationYaw, var2.rotationPitch);
 			this.mcServer.networkServer.addPlayer(var5);
--- /dev/null
+++ net/minecraft/game/world/block/properties/StringProperty.java
@@ -1,0 +1,46 @@
+package net.minecraft.game.world.block.properties;
+
+import net.minecraft.util.MathHelper;
+
+public class StringProperty implements Property<String> {
+	private final String name;
+	private final int size;
+	private final String[] values;
+
+	public StringProperty(String name, String... values) {
+		this(name, MathHelper.intBits(values.length), values);
+	}
+
+	public StringProperty(String name, int size, String... values) {
+		Property.checkBounds(size, MathHelper.intBits(values.length - 1));
+		this.name = name;
+		this.size = size;
+		this.values = values;
+	}
+
+	public String getValue(int metadataSlice) {
+		return metadataSlice >= 0 && metadataSlice < this.values.length
+				? this.values[metadataSlice] : String.valueOf(metadataSlice);
+	}
+
+	public int getIntValue(String value) {
+		for (int i = 0; i < this.values.length; i++) {
+			if (this.values[i].equals(value)) {
+				return i;
+			}
+		}
+		return 0;
+	}
+
+	public String toString(String value) {
+		return value;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public int getSize() {
+		return this.size;
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/PlainsBiome.java
@@ -1,0 +1,19 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.terrain.NoiseSettings;
+
+public class PlainsBiome extends Biome {
+	protected PlainsBiome(int id) {
+		super(id);
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(12.0D, 24.0D)
+				.noiseUnderDamp(1.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings();
+	}
+}
--- net/minecraft/server/MinecraftServer.java
+++ net/minecraft/server/MinecraftServer.java
@@ -7,16 +7,19 @@
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.stats.StatList;
 import net.minecraft.game.world.BlockPos;
+import net.minecraft.game.world.NewWorldInfo;
 import net.minecraft.game.world.save.SaveConverterMcRegion;
 import net.minecraft.game.world.save.SaveFormat;
 import net.minecraft.game.world.save.SaveOldDir;
@@ -34,7 +37,7 @@
 
 public class MinecraftServer implements Runnable, ICommandListener {
 	public static Logger logger = Logger.getLogger("Minecraft");
-	public static HashMap field_6037_b = new HashMap();
+	public static Object2IntMap<String> field_6037_b = new Object2IntOpenHashMap<>();
 	public NetworkListenThread networkServer;
 	public PropertyManager propertyManagerObj;
 	public WorldServer[] worldMngr;
@@ -114,31 +117,33 @@
 				var9 = (long)var8.hashCode();
 			}
 		}
+		boolean var10 = this.propertyManagerObj.getBooleanProperty("creative", false);
 
 		logger.info("Preparing level \"" + var7 + "\"");
-		this.initWorld(new SaveConverterMcRegion(new File(".")), var7, var9);
+		this.initWorld(new SaveConverterMcRegion(new File(".")), new NewWorldInfo(var7, var9, var10));
 		logger.info("Done (" + (System.nanoTime() - var5) + "ns)! For help, type \"help\" or \"?\"");
 		return true;
 	}
 
-	private void initWorld(SaveFormat var1, String var2, long var3) {
-		if(var1.isOldMapFormat(var2)) {
+	private void initWorld(SaveFormat var1, NewWorldInfo var2) {
+		if(var1.isOldMapFormat(var2.name)) {
 			logger.info("Converting map!");
-			var1.convertMapFormat(var2, new ConvertProgressUpdater(this));
+			var1.convertMapFormat(var2.name, new ConvertProgressUpdater(this));
 		}
 
 		this.worldMngr = new WorldServer[2];
-		SaveOldDir var5 = new SaveOldDir(new File("."), var2, true);
+		SaveOldDir var5 = new SaveOldDir(new File("."), var2.name, true);
 
 		for(int var6 = 0; var6 < this.worldMngr.length; ++var6) {
 			if(var6 == 0) {
-				this.worldMngr[var6] = new WorldServer(this, var5, var2, var6 == 0 ? 0 : -1, var3);
+				this.worldMngr[var6] = new WorldServer(this, var5, 0, var2);
 			} else {
-				this.worldMngr[var6] = new WorldServerMulti(this, var5, var2, var6 == 0 ? 0 : -1, var3, this.worldMngr[0]);
+				this.worldMngr[var6] = new WorldServerMulti(this, var5, -1, var2, this.worldMngr[0]);
 			}
 
 			this.worldMngr[var6].addWorldAccess(new WorldManager(this, this.worldMngr[var6]));
 			this.worldMngr[var6].difficultySetting = this.propertyManagerObj.getBooleanProperty("spawn-monsters", true) ? 1 : 0;
+			this.worldMngr[var6].simulationDistance = this.propertyManagerObj.getIntProperty("simulation-distance", 8);
 			this.worldMngr[var6].setAllowedSpawnTypes(this.propertyManagerObj.getBooleanProperty("spawn-monsters", true), this.spawnPeacefulMobs);
 			this.configManager.setPlayerManager(this.worldMngr);
 		}
@@ -288,14 +293,14 @@
 	}
 
 	private void doTick() {
-		ArrayList var1 = new ArrayList();
-		Iterator var2 = field_6037_b.keySet().iterator();
+		List<String> var1 = new ArrayList();
+		Iterator<String> var2 = field_6037_b.keySet().iterator();
 
 		while(var2.hasNext()) {
-			String var3 = (String)var2.next();
-			int var4 = ((Integer)field_6037_b.get(var3)).intValue();
+			String var3 = var2.next();
+			int var4 = field_6037_b.getInt(var3);
 			if(var4 > 0) {
-				field_6037_b.put(var3, Integer.valueOf(var4 - 1));
+				field_6037_b.put(var3, var4 - 1);
 			} else {
 				var1.add(var3);
 			}
@@ -303,7 +308,7 @@
 
 		int var6;
 		for(var6 = 0; var6 < var1.size(); ++var6) {
-			field_6037_b.remove(var1.get(var6));
+			field_6037_b.removeInt(var1.get(var6));
 		}
 
 		AxisAlignedBB.resetBoundingBoxPool();
--- net/minecraft/game/world/block/MushroomBlock.java
+++ net/minecraft/game/world/block/MushroomBlock.java
@@ -32,6 +32,6 @@
 	}
 
 	public boolean canBlockStay(World var1, int var2, int var3, int var4) {
-		return var3 >= 0 && var3 < 128 ? var1.getFullBlockLightValue(var2, var3, var4) < 13 && this.canThisPlantGrowOnThisBlockID(var1.getBlockId(var2, var3 - 1, var4)) : false;
+		return var1.getFullBlockLightValue(var2, var3, var4) < 13 && this.canThisPlantGrowOnThisBlockID(var1.getBlockId(var2, var3 - 1, var4));
 	}
 }
--- net/minecraft/network/NetServerHandler.java
+++ net/minecraft/network/NetServerHandler.java
@@ -1,9 +1,10 @@
 package net.minecraft.network;
 
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
 import java.util.logging.Logger;
+
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.player.InventoryPlayer;
 import net.minecraft.game.item.ItemStack;
@@ -53,7 +54,7 @@
 	private double lastPosY;
 	private double lastPosZ;
 	private boolean hasMoved = true;
-	private Map field_10_k = new HashMap();
+	private Int2IntMap field_10_k = new Int2IntOpenHashMap();
 
 	public NetServerHandler(MinecraftServer var1, NetworkManager var2, ServerPlayerEntity var3) {
 		this.mcServer = var1;
@@ -76,7 +77,7 @@
 		this.playerEntity.func_30002_A();
 		this.sendPacket(new Packet255KickDisconnect(var1));
 		this.netManager.serverShutdown();
-		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("\u00a7e" + this.playerEntity.username + " left the game."));
+		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("§e" + this.playerEntity.username + " left the game."));
 		this.mcServer.configManager.playerLoggedOut(this.playerEntity);
 		this.connectionClosed = true;
 	}
@@ -390,7 +391,7 @@
 
 	public void handleErrorMessage(String var1, Object[] var2) {
 		logger.info(this.playerEntity.username + " lost connection: " + var1);
-		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("\u00a7e" + this.playerEntity.username + " left the game."));
+		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("§e" + this.playerEntity.username + " left the game."));
 		this.mcServer.configManager.playerLoggedOut(this.playerEntity);
 		this.connectionClosed = true;
 	}
@@ -450,10 +451,10 @@
 			if(var2.length >= 3) {
 				var1 = var1.substring(var1.indexOf(" ")).trim();
 				var1 = var1.substring(var1.indexOf(" ")).trim();
-				var1 = "\u00a77" + this.playerEntity.username + " whispers " + var1;
+				var1 = "§7" + this.playerEntity.username + " whispers " + var1;
 				logger.info(var1 + " to " + var2[1]);
 				if(!this.mcServer.configManager.sendPacketToPlayer(var2[1], new Packet3Chat(var1))) {
-					this.sendPacket(new Packet3Chat("\u00a7cThere\'s no player by that name online."));
+					this.sendPacket(new Packet3Chat("§cThere\'s no player by that name online."));
 				}
 			}
 		} else {
@@ -490,7 +491,7 @@
 	}
 
 	public void handleKickDisconnect(Packet255KickDisconnect var1) {
-		this.netManager.networkShutdown("disconnect.quitting", new Object[0]);
+		this.netManager.networkShutdown("disconnect.quitting");
 	}
 
 	public int getNumChunkDataPackets() {
@@ -498,7 +499,7 @@
 	}
 
 	public void log(String var1) {
-		this.sendPacket(new Packet3Chat("\u00a77" + var1));
+		this.sendPacket(new Packet3Chat("§7" + var1));
 	}
 
 	public String getUsername() {
@@ -538,7 +539,7 @@
 				this.playerEntity.updateHeldItem();
 				this.playerEntity.isChangingQuantityOnly = false;
 			} else {
-				this.field_10_k.put(Integer.valueOf(this.playerEntity.craftingInventory.windowId), Short.valueOf(var1.action));
+				this.field_10_k.put(this.playerEntity.craftingInventory.windowId, var1.action & 0xFFFF);
 				this.playerEntity.playerNetServerHandler.sendPacket(new Packet106Transaction(var1.windowId, var1.action, false));
 				this.playerEntity.craftingInventory.setCanCraft(this.playerEntity, false);
 				ArrayList var3 = new ArrayList();
@@ -554,8 +555,8 @@
 	}
 
 	public void handleTransaction(Packet106Transaction var1) {
-		Short var2 = (Short)this.field_10_k.get(Integer.valueOf(this.playerEntity.craftingInventory.windowId));
-		if(var2 != null && var1.shortWindowId == var2.shortValue() && this.playerEntity.craftingInventory.windowId == var1.windowId && !this.playerEntity.craftingInventory.getCanCraft(this.playerEntity)) {
+		int var2 = this.field_10_k.get(this.playerEntity.craftingInventory.windowId);
+		if(var2 != 0 && var1.shortWindowId == var2 && this.playerEntity.craftingInventory.windowId == var1.windowId && !this.playerEntity.craftingInventory.getCanCraft(this.playerEntity)) {
 			this.playerEntity.craftingInventory.setCanCraft(this.playerEntity, true);
 		}
 
@@ -598,9 +599,7 @@
 				var6 = var1.zPosition;
 				SignTileEntity var7 = (SignTileEntity)var3;
 
-				for(int var8 = 0; var8 < 4; ++var8) {
-					var7.signText[var8] = var1.signLines[var8];
-				}
+				System.arraycopy(var1.signLines, 0, var7.signText, 0, 4);
 
 				var7.setEditable(false);
 				var7.onChanged();
--- net/minecraft/game/world/terrain/SkyChunkProvider.java
+++ net/minecraft/game/world/terrain/SkyChunkProvider.java
@@ -38,7 +38,7 @@
 	private double[] sandNoiseArray = new double[256];
 	private double[] gravelNoiseArray = new double[256];
 	private double[] erosionNoiseArray = new double[256];
-	private TerrainGenerator caves = new TerrainGenCaves();
+	private TerrainGenerator caves = new TerrainGenCaves(1, 128);
 	private Biome[] biomesForGeneration;
 	double[] selectionNoiseArray;
 	double[] minBaseNoiseArray;
@@ -68,41 +68,44 @@
 		int var9 = var6 + 1;
 		this.noiseArray = this.initializeNoiseField(this.noiseArray, var1 * var6, 0, var2 * var6, var7, var8, var9);
 
-		for(int var10 = 0; var10 < var6; ++var10) {
-			for(int var11 = 0; var11 < var6; ++var11) {
-				for(int var12 = 0; var12 < 32; ++var12) {
+		for(int xS = 0; xS < var6; ++xS) {
+			for(int zS = 0; zS < var6; ++zS) {
+				for(int yS = 0; yS < 32; ++yS) {
 					double var13 = 0.25D;
-					double var15 = this.noiseArray[((var10 + 0) * var9 + var11 + 0) * var8 + var12 + 0];
-					double var17 = this.noiseArray[((var10 + 0) * var9 + var11 + 1) * var8 + var12 + 0];
-					double var19 = this.noiseArray[((var10 + 1) * var9 + var11 + 0) * var8 + var12 + 0];
-					double var21 = this.noiseArray[((var10 + 1) * var9 + var11 + 1) * var8 + var12 + 0];
-					double var23 = (this.noiseArray[((var10 + 0) * var9 + var11 + 0) * var8 + var12 + 1] - var15) * var13;
-					double var25 = (this.noiseArray[((var10 + 0) * var9 + var11 + 1) * var8 + var12 + 1] - var17) * var13;
-					double var27 = (this.noiseArray[((var10 + 1) * var9 + var11 + 0) * var8 + var12 + 1] - var19) * var13;
-					double var29 = (this.noiseArray[((var10 + 1) * var9 + var11 + 1) * var8 + var12 + 1] - var21) * var13;
+					double var15 = this.noiseArray[((xS + 0) * var9 + zS + 0) * var8 + yS + 0];
+					double var17 = this.noiseArray[((xS + 0) * var9 + zS + 1) * var8 + yS + 0];
+					double var19 = this.noiseArray[((xS + 1) * var9 + zS + 0) * var8 + yS + 0];
+					double var21 = this.noiseArray[((xS + 1) * var9 + zS + 1) * var8 + yS + 0];
+					double var23 = (this.noiseArray[((xS + 0) * var9 + zS + 0) * var8 + yS + 1] - var15) * var13;
+					double var25 = (this.noiseArray[((xS + 0) * var9 + zS + 1) * var8 + yS + 1] - var17) * var13;
+					double var27 = (this.noiseArray[((xS + 1) * var9 + zS + 0) * var8 + yS + 1] - var19) * var13;
+					double var29 = (this.noiseArray[((xS + 1) * var9 + zS + 1) * var8 + yS + 1] - var21) * var13;
 
-					for(int var31 = 0; var31 < 4; ++var31) {
+					for(int yI = 0; yI < 4; ++yI) {
 						double var32 = 0.125D;
 						double var34 = var15;
 						double var36 = var17;
 						double var38 = (var19 - var15) * var32;
 						double var40 = (var21 - var17) * var32;
 
-						for(int var42 = 0; var42 < 8; ++var42) {
-							int var43 = var42 + var10 * 8 << 11 | 0 + var11 * 8 << 7 | var12 * 4 + var31;
-							short var44 = 128;
+						for(int xI = 0; xI < 8; ++xI) {
 							double var45 = 0.125D;
 							double var47 = var34;
 							double var49 = (var36 - var34) * var45;
 
-							for(int var51 = 0; var51 < 8; ++var51) {
+							for(int zI = 0; zI < 8; ++zI) {
+								int x = xS << 3 | xI;
+								int y = yS << 2 | yI;
+								int z = zS << 3 | zI;
+
+								int index = y << 8 | z << 4 | x;
+
 								int var52 = 0;
 								if(var47 > 0.0D) {
 									var52 = Block.stone.blockID;
 								}
 
-								var3[var43] = (byte)var52;
-								var43 += var44;
+								var3[index] = (byte)var52;
 								var47 += var49;
 							}
 
@@ -123,21 +126,21 @@
 
 	public void generateSurface(int var1, int var2, byte[] var3, Biome[] var4) {
 		double var5 = 1.0D / 32.0D;
-		this.sandNoiseArray = this.beachNoise.generateNoiseArray3D(this.sandNoiseArray, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var5, var5, 1.0D);
+		this.sandNoiseArray = this.beachNoise.generateNoiseArray3D(this.sandNoiseArray, (double)(var1 * 16), 0.0D, (double)(var2 * 16), 16, 1, 16, var5, 1.0D, var5);
 		this.gravelNoiseArray = this.beachNoise.generateNoiseArray3D(this.gravelNoiseArray, (double)(var1 * 16), 109.0134D, (double)(var2 * 16), 16, 1, 16, var5, 1.0D, var5);
-		this.erosionNoiseArray = this.erosionNoise.generateNoiseArray3D(this.erosionNoiseArray, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var5 * 2.0D, var5 * 2.0D, var5 * 2.0D);
+		this.erosionNoiseArray = this.erosionNoise.generateNoiseArray3D(this.erosionNoiseArray, (double)(var1 * 16), 0.0D, (double)(var2 * 16), 16, 1, 16, var5 * 2.0D, var5 * 2.0D, var5 * 2.0D);
 
-		for(int var7 = 0; var7 < 16; ++var7) {
-			for(int var8 = 0; var8 < 16; ++var8) {
-				Biome var9 = var4[var7 + var8 * 16];
-				int var10 = (int)(this.erosionNoiseArray[var7 + var8 * 16] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);
+		for(int z = 0; z < 16; ++z) {
+			for(int x = 0; x < 16; ++x) {
+				Biome var9 = var4[x << 4 | z];
+				int var10 = (int)(this.erosionNoiseArray[x << 4 | z] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);
 				int var11 = -1;
 				byte var12 = var9.topBlock;
 				byte var13 = var9.fillerBlock;
 
-				for(int var14 = 127; var14 >= 0; --var14) {
-					int var15 = (var8 * 16 + var7) * 128 + var14;
-					byte var16 = var3[var15];
+				for(int y = 127; y >= 0; --y) {
+					int index = y << 8 | z << 4 | x;
+					byte var16 = var3[index];
 					if(var16 == 0) {
 						var11 = -1;
 					} else if(var16 == Block.stone.blockID) {
@@ -148,14 +151,14 @@
 							}
 
 							var11 = var10;
-							if(var14 >= 0) {
-								var3[var15] = var12;
+							if(y >= 0) {
+								var3[index] = var12;
 							} else {
-								var3[var15] = var13;
+								var3[index] = var13;
 							}
 						} else if(var11 > 0) {
 							--var11;
-							var3[var15] = var13;
+							var3[index] = var13;
 							if(var11 == 0 && var13 == Block.sand.blockID) {
 								var11 = this.rand.nextInt(4);
 								var13 = (byte)Block.sandstone.blockID;
@@ -175,12 +178,18 @@
 	public Chunk provideChunk(int var1, int var2) {
 		this.rand.setSeed((long)var1 * 341873128712L + (long)var2 * 132897987541L);
 		byte[] var3 = new byte[-Short.MIN_VALUE];
-		Chunk var4 = new Chunk(this.worldObj, var3, var1, var2);
 		this.biomesForGeneration = this.worldObj.getBiomeSource().loadBlockGeneratorData(this.biomesForGeneration, var1 * 16, var2 * 16, 16, 16);
-		double[] var5 = this.worldObj.getBiomeSource().temperature;
-		this.generateTerrain(var1, var2, var3, this.biomesForGeneration, var5);
+		this.generateTerrain(var1, var2, var3, this.biomesForGeneration, null);
 		this.generateSurface(var1, var2, var3, this.biomesForGeneration);
 		this.caves.generate(this, this.worldObj, var1, var2, var3);
+		Chunk var4 = new Chunk(this.worldObj, var3, var1, var2);
+
+		byte[] biomes = var4.getBiomeArray();
+
+		for (int i = 0; i < biomes.length; i++) {
+			biomes[i] = (byte)biomesForGeneration[i].id;
+		}
+
 		var4.generateSkylightMap();
 		return var4;
 	}
@@ -192,8 +201,6 @@
 
 		double var8 = 684.412D;
 		double var10 = 684.412D;
-		double[] var12 = this.worldObj.getBiomeSource().temperature;
-		double[] var13 = this.worldObj.getBiomeSource().humidity;
 		this.landNoiseArray = this.landNoise.generateNoiseArray2D(this.landNoiseArray, var2, var4, var5, var7, 1.121D, 1.121D, 0.5D);
 		this.depthNoiseArray = this.depthNoise.generateNoiseArray2D(this.depthNoiseArray, var2, var4, var5, var7, 200.0D, 200.0D, 0.5D);
 		var8 *= 2.0D;
@@ -209,45 +216,10 @@
 
 			for(int var19 = 0; var19 < var7; ++var19) {
 				int var20 = var19 * var16 + var16 / 2;
-				double var21 = var12[var18 * 16 + var20];
-				double var23 = var13[var18 * 16 + var20] * var21;
-				double var25 = 1.0D - var23;
-				var25 *= var25;
-				var25 *= var25;
-				var25 = 1.0D - var25;
-				double var27 = (this.landNoiseArray[var15] + 256.0D) / 512.0D;
-				var27 *= var25;
-				if(var27 > 1.0D) {
-					var27 = 1.0D;
-				}
-
-				double var29 = this.depthNoiseArray[var15] / 8000.0D;
-				if(var29 < 0.0D) {
-					var29 = -var29 * 0.3D;
-				}
-
-				var29 = var29 * 3.0D - 2.0D;
-				if(var29 > 1.0D) {
-					var29 = 1.0D;
-				}
-
-				var29 /= 8.0D;
-				var29 = 0.0D;
-				if(var27 < 0.0D) {
-					var27 = 0.0D;
-				}
-
-				var27 += 0.5D;
-				var29 = var29 * (double)var6 / 16.0D;
 				++var15;
-				double var31 = (double)var6 / 2.0D;
 
 				for(int var33 = 0; var33 < var6; ++var33) {
 					double var34 = 0.0D;
-					double var36 = ((double)var33 - var31) * 8.0D / var27;
-					if(var36 < 0.0D) {
-						var36 *= -1.0D;
-					}
 
 					double var38 = this.minBaseNoiseArray[var14] / 512.0D;
 					double var40 = this.maxBaseNoiseArray[var14] / 512.0D;
@@ -291,7 +263,7 @@
 		SandBlock.fallInstantly = true;
 		int var4 = var2 * 16;
 		int var5 = var3 * 16;
-		Biome var6 = this.worldObj.getBiomeSource().getBiomeGenAt(var4 + 16, var5 + 16);
+		Biome var6 = this.worldObj.getBiomeAt(var4 + 16, var5 + 16);
 		this.rand.setSeed(this.worldObj.getRandomSeed());
 		long var7 = this.rand.nextLong() / 2L * 2L + 1L;
 		long var9 = this.rand.nextLong() / 2L * 2L + 1L;
@@ -394,34 +366,6 @@
 			++var14;
 		}
 
-		if(var6 == Biome.forest) {
-			var14 += var13 + 5;
-		}
-
-		if(var6 == Biome.rainforest) {
-			var14 += var13 + 5;
-		}
-
-		if(var6 == Biome.seasonalForest) {
-			var14 += var13 + 2;
-		}
-
-		if(var6 == Biome.taiga) {
-			var14 += var13 + 5;
-		}
-
-		if(var6 == Biome.desert) {
-			var14 -= 20;
-		}
-
-		if(var6 == Biome.tundra) {
-			var14 -= 20;
-		}
-
-		if(var6 == Biome.plains) {
-			var14 -= 20;
-		}
-
 		int var17;
 		for(var15 = 0; var15 < var14; ++var15) {
 			var16 = var4 + this.rand.nextInt(16) + 8;
@@ -475,9 +419,6 @@
 		}
 
 		var15 = 0;
-		if(var6 == Biome.desert) {
-			var15 += 10;
-		}
 
 		int var19;
 		for(var16 = 0; var16 < var15; ++var16) {
@@ -501,15 +442,11 @@
 			(new LiquidsFeature(Block.flowingLava.blockID)).generate(this.worldObj, this.rand, var17, var23, var19);
 		}
 
-		this.generatedTemperatures = this.worldObj.getBiomeSource().getTemperatures(this.generatedTemperatures, var4 + 8, var5 + 8, 16, 16);
-
 		for(var16 = var4 + 8; var16 < var4 + 8 + 16; ++var16) {
 			for(var17 = var5 + 8; var17 < var5 + 8 + 16; ++var17) {
-				var23 = var16 - (var4 + 8);
-				var19 = var17 - (var5 + 8);
 				int var20 = this.worldObj.getTopSolidOrLiquidBlock(var16, var17);
-				double var21 = this.generatedTemperatures[var23 * 16 + var19] - (double)(var20 - 64) / 64.0D * 0.3D;
-				if(var21 < 0.5D && var20 > 0 && var20 < 128 && this.worldObj.isAirBlock(var16, var20, var17) && this.worldObj.getBlockMaterial(var16, var20 - 1, var17).getIsSolid() && this.worldObj.getBlockMaterial(var16, var20 - 1, var17) != Material.ice) {
+				double var21 = 0.5D - (double)(var20 - 64) / 64.0D * 0.3D;
+				if(var21 < 0.5D && this.worldObj.isAirBlock(var16, var20, var17) && this.worldObj.getBlockMaterial(var16, var20 - 1, var17).getIsSolid() && this.worldObj.getBlockMaterial(var16, var20 - 1, var17) != Material.ice) {
 					this.worldObj.setBlockWithNotify(var16, var20, var17, Block.snowLayer.blockID);
 				}
 			}
--- net/minecraft/client/ThreadCheckHasPaid.java
+++ net/minecraft/client/ThreadCheckHasPaid.java
@@ -1,8 +1,5 @@
 package net.minecraft.client;
 
-import java.net.HttpURLConnection;
-import java.net.URL;
-
 public class ThreadCheckHasPaid extends Thread {
 	final Minecraft field_28146_a;
 
@@ -11,17 +8,5 @@
 	}
 
 	public void run() {
-		try {
-			HttpURLConnection var1 = (HttpURLConnection)(new URL("https://login.minecraft.net/session?name=" + this.field_28146_a.session.username + "&session=" + this.field_28146_a.session.sessionId)).openConnection();
-			var1.connect();
-			if(var1.getResponseCode() == 400) {
-				Minecraft.hasPaidCheckTime = System.currentTimeMillis();
-			}
-
-			var1.disconnect();
-		} catch (Exception var2) {
-			var2.printStackTrace();
-		}
-
 	}
 }
--- /dev/null
+++ com/mojang/nbt/ShortArrayTag.java
@@ -1,0 +1,50 @@
+package com.mojang.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+public class ShortArrayTag extends NBTBaseTag {
+	public short[] shortArray;
+
+	public ShortArrayTag() {
+	}
+
+	public ShortArrayTag(short[] var1) {
+		this.shortArray = var1;
+	}
+
+	protected void writeTagContents(DataOutput var1) throws IOException {
+		var1.writeInt(this.shortArray.length);
+		ByteBuffer buffer = ByteBuffer.allocate(this.shortArray.length * 2);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asShortBuffer().put(this.shortArray);
+		byte[] bytes = buffer.array();
+		var1.write(bytes);
+	}
+
+	protected void readTagContents(DataInput var1) throws IOException {
+		int var2 = var1.readInt();
+		this.shortArray = new short[var2];
+		byte[] byteArray = new byte[var2 * 2];
+		var1.readFully(byteArray);
+		ByteBuffer buffer = ByteBuffer.wrap(byteArray);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asShortBuffer().get(this.shortArray);
+	}
+
+	public byte getType() {
+		return (byte)13;
+	}
+
+	public String toString() {
+		return "[" + this.shortArray.length + " shorts]";
+	}
+
+	public NBTBaseTag copy() {
+		return new ShortArrayTag(Arrays.copyOf(this.shortArray, this.shortArray.length)).setKey(this.getKey());
+	}
+}
--- argo/J_JsonObjectNodeBuilder.java
+++ /dev/null
@@ -1,25 +1,0 @@
-package argo;
-
-import java.util.LinkedList;
-import java.util.List;
-
-public final class J_JsonObjectNodeBuilder implements J_JsonNodeBuilder {
-	private final List field_27238_a = new LinkedList();
-
-	public J_JsonObjectNodeBuilder func_27237_a(J_JsonFieldBuilder var1) {
-		this.field_27238_a.add(var1);
-		return this;
-	}
-
-	public J_JsonRootNode func_27235_a() {
-		return J_JsonNodeFactories.func_27312_a(new J_JsonObjectNodeList(this));
-	}
-
-	public J_JsonNode func_27234_b() {
-		return this.func_27235_a();
-	}
-
-	static List func_27236_a(J_JsonObjectNodeBuilder var0) {
-		return var0.field_27238_a;
-	}
-}
--- net/minecraft/game/world/block/ButtonBlock.java
+++ net/minecraft/game/world/block/ButtonBlock.java
@@ -5,12 +5,22 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.StringProperty;
 import net.minecraft.game.world.material.Material;
 
 public class ButtonBlock extends Block {
+	public static final StringProperty DIRECTION = new StringProperty("direction", 3, "none", "west", "east", "north", "south");
+	public static final BooleanProperty PRESSED = new BooleanProperty("pressed");
+
 	protected ButtonBlock(int var1, int var2) {
 		super(var1, var2, Material.circuits);
 		this.setTickOnLoad(true);
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, PRESSED);
 	}
 
 	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
--- net/minecraft/game/item/ShovelItem.java
+++ net/minecraft/game/item/ShovelItem.java
@@ -3,13 +3,11 @@
 import net.minecraft.game.world.block.Block;
 
 public class ShovelItem extends ToolItem {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.grass, Block.dirt, Block.sand, Block.gravel, Block.snowLayer, Block.snow, Block.clayBlock, Block.farmland};
-
 	public ShovelItem(int var1, ToolMaterial var2) {
-		super(var1, 1, var2, blocksEffectiveAgainst);
+		super(var1, 1, var2, ToolType.SHOVEL);
 	}
 
 	public boolean canHarvestBlock(Block var1) {
-		return var1 == Block.snowLayer ? true : var1 == Block.snow;
+		return super.canHarvestBlock(var1) || var1 == Block.snowLayer || var1 == Block.snow;
 	}
 }
--- net/minecraft/util/MCHash.java
+++ net/minecraft/util/MCHash.java
@@ -1,5 +1,7 @@
 package net.minecraft.util;
 
+import java.util.Arrays;
+
 public class MCHash {
 	private transient MCHashEntry[] slots = new MCHashEntry[16];
 	private transient int count;
@@ -129,9 +131,7 @@
 		++this.versionStamp;
 		MCHashEntry[] var1 = this.slots;
 
-		for(int var2 = 0; var2 < var1.length; ++var2) {
-			var1[var2] = null;
-		}
+		Arrays.fill(var1, null);
 
 		this.count = 0;
 	}
--- /dev/null
+++ net/minecraft/game/world/block/properties/PropertyList.java
@@ -1,0 +1,88 @@
+package net.minecraft.game.world.block.properties;
+
+import java.util.HashMap;
+import java.util.Map;
+
+// TODO: Make every block make use of properties instead of directly manipulating metadata
+
+public class PropertyList {
+	public static final int MAX_BITS = 8;
+	public static final PropertyList EMPTY = new PropertyList();
+
+	private final Map<Property<?>, PropertyField> propertyFields = new HashMap<>();
+	private final Property<?>[] properties;
+
+	public PropertyList(Property<?>... properties) {
+		this.properties = properties;
+		int offset = 0;
+
+		for (int i = 0; i < properties.length; i++) {
+			Property<?> property = properties[i];
+			if (this.propertyFields.containsKey(property)) {
+				throw new IllegalArgumentException("Duplicate property " + property.getName());
+			}
+
+			int size = i == properties.length - 1 && property.supportDynamicSize()
+					? MAX_BITS - offset : property.getSize();
+			if (size <= 0) {
+				size += MAX_BITS;
+			}
+
+			if (size < 1) {
+				throw new IllegalArgumentException("Property size is too small");
+			} else if (offset + size > MAX_BITS) {
+				throw new IllegalArgumentException("Property size is too big");
+			}
+
+			if (!(property instanceof PropertyPadding)) {
+				this.propertyFields.put(property, new PropertyField(offset, size));
+			}
+			offset += size;
+		}
+	}
+
+	// Blame Java generics for this mess
+	// Project Valhalla, please bless us?
+
+	public <T> T get(int metadata, Property<T> property) {
+		PropertyField propertyField = propertyFields.get(property);
+		return propertyField != null ? property.getValue(propertyField.getMetadataSlice(metadata)) : null;
+	}
+
+	public int getInt(int metadata, Property<?> property) {
+		PropertyField propertyField = propertyFields.get(property);
+		return propertyField != null ? propertyField.getMetadataSlice(metadata) : 0;
+	}
+
+	public boolean getBoolean(int metadata, Property<?> property) {
+		PropertyField propertyField = propertyFields.get(property);
+		return propertyField != null && propertyField.getMetadataSlice(metadata) != 0;
+	}
+
+	public <T> int set(int metadata, Property<T> property, T value) {
+		PropertyField propertyField = propertyFields.get(property);
+		if (propertyField == null) return metadata;
+		return propertyField.modifyMetadataSlice(metadata, property.getIntValue(value));
+	}
+
+	public int set(int metadata, Property<?> property, int value) {
+		PropertyField propertyField = propertyFields.get(property);
+		if (propertyField == null) return metadata;
+		return propertyField.modifyMetadataSlice(metadata, value);
+	}
+
+	public int set(int metadata, Property<?> property, boolean value) {
+		PropertyField propertyField = propertyFields.get(property);
+		if (propertyField == null) return metadata;
+		return propertyField.modifyMetadataSlice(metadata, value ? 1 : 0);
+	}
+
+	public String[] getDebugInfo(int metadata) {
+		String[] lines = new String[this.properties.length];
+		for (int i = 0; i < this.properties.length; i++) {
+			Property<?> property = this.properties[i];
+			lines[i] = "§f" + property.getName() + "§7=§e" + property.toString(propertyFields.get(property).getMetadataSlice(metadata));
+		}
+		return lines;
+	}
+}
--- net/minecraft/client/gui/CreateWorldScreen.java
+++ net/minecraft/client/gui/CreateWorldScreen.java
@@ -1,21 +1,28 @@
 package net.minecraft.client.gui;
 
 import java.util.Random;
+
+import net.minecraft.client.controller.CreativePlayerController;
 import net.minecraft.client.controller.SurvivalPlayerController;
 import net.minecraft.client.gui.component.GuiButton;
 import net.minecraft.client.gui.component.GuiTextField;
+import net.minecraft.game.world.NewWorldInfo;
 import net.minecraft.game.world.save.SaveFormat;
 import net.minecraft.util.ChatAllowedCharacters;
 import net.minecraft.util.MathHelper;
 import net.minecraft.util.StringTranslate;
 import org.lwjgl.input.Keyboard;
 
+import static net.minecraft.util.StringTranslate.i18n;
+
 public class CreateWorldScreen extends GuiScreen {
 	private GuiScreen field_22131_a;
 	private GuiTextField textboxWorldName;
 	private GuiTextField textboxSeed;
 	private String folderName;
 	private boolean createClicked;
+	private boolean creative;
+	private boolean experimentalGen;
 
 	public CreateWorldScreen(GuiScreen var1) {
 		this.field_22131_a = var1;
@@ -30,12 +37,13 @@
 		StringTranslate var1 = StringTranslate.getInstance();
 		Keyboard.enableRepeatEvents(true);
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 96 + 12, var1.translateKey("selectWorld.create")));
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 120 + 12, var1.translateKey("gui.cancel")));
-		this.textboxWorldName = new GuiTextField(this, this.fontRenderer, this.width / 2 - 100, 60, 200, 20, var1.translateKey("selectWorld.newWorld"));
+		this.controlList.add(new GuiButton(0, -100, 108, i18n("selectWorld.create")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(1, -100, 132, i18n("gui.cancel")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(this.textboxWorldName = (GuiTextField) new GuiTextField(this, this.fontRenderer, -100, 60, 200, 20, i18n("selectWorld.newWorld")).alignedAt(0.5F, 0.0F));
 		this.textboxWorldName.isFocused = true;
 		this.textboxWorldName.setMaxStringLength(32);
-		this.textboxSeed = new GuiTextField(this, this.fontRenderer, this.width / 2 - 100, 116, 200, 20, "");
+		this.controlList.add(this.textboxSeed = (GuiTextField) new GuiTextField(this, this.fontRenderer, -100, 84, 200, 20, "").alignedAt(0.5F, 0.0F));
+		this.controlList.add(new GuiButton(2, -100, 108, "").alignedAt(0.5F, 0.0F));
 		this.func_22129_j();
 	}
 
@@ -54,6 +62,9 @@
 		}
 
 		this.folderName = generateUnusedFolderName(this.mc.getSaveLoader(), this.folderName);
+
+		this.controlList.get(4).displayString = i18n("selectWorld.gameMode").replace("$",
+				i18n("selectWorld.gameMode." + (this.creative ? "creative" : "survival")));
 	}
 
 	public static String generateUnusedFolderName(SaveFormat var0, String var1) {
@@ -92,9 +103,15 @@
 					}
 				}
 
-				this.mc.playerController = new SurvivalPlayerController(this.mc);
-				this.mc.startWorld(this.folderName, this.textboxWorldName.getText(), var2);
+				this.mc.playerController = this.creative ? new CreativePlayerController(this.mc) : new SurvivalPlayerController(this.mc);
+				this.mc.startWorld(this.folderName, new NewWorldInfo(this.textboxWorldName.getText(), var2, this.creative));
 				this.mc.displayGuiScreen((GuiScreen)null);
+			} else if(var1.id == 2) {
+				this.creative = !this.creative;
+				this.func_22129_j();
+			} else if(var1.id == 3) {
+				this.experimentalGen = !this.experimentalGen;
+				this.func_22129_j();
 			}
 
 		}
@@ -115,22 +132,12 @@
 		this.func_22129_j();
 	}
 
-	protected void mouseClicked(int var1, int var2, int var3) {
-		super.mouseClicked(var1, var2, var3);
-		this.textboxWorldName.mouseClicked(var1, var2, var3);
-		this.textboxSeed.mouseClicked(var1, var2, var3);
-	}
-
 	public void drawScreen(int var1, int var2, float var3) {
 		StringTranslate var4 = StringTranslate.getInstance();
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, var4.translateKey("selectWorld.create"), this.width / 2, this.height / 4 - 60 + 20, 16777215);
-		this.drawString(this.fontRenderer, var4.translateKey("selectWorld.enterName"), this.width / 2 - 100, 47, 10526880);
-		this.drawString(this.fontRenderer, var4.translateKey("selectWorld.resultFolder") + " " + this.folderName, this.width / 2 - 100, 85, 10526880);
-		this.drawString(this.fontRenderer, var4.translateKey("selectWorld.enterSeed"), this.width / 2 - 100, 104, 10526880);
-		this.drawString(this.fontRenderer, var4.translateKey("selectWorld.seedInfo"), this.width / 2 - 100, 140, 10526880);
-		this.textboxWorldName.drawTextBox();
-		this.textboxSeed.drawTextBox();
+		this.drawStringRight(this.fontRenderer, var4.translateKey("selectWorld.enterName"), this.width / 2 - 108, 66, 10526880);
+		this.drawStringRight(this.fontRenderer, var4.translateKey("selectWorld.enterSeed"), this.width / 2 - 108, 90, 10526880);
 		super.drawScreen(var1, var2, var3);
 	}
 
--- net/minecraft/game/world/chunk/loader/region/RegionFile.java
+++ net/minecraft/game/world/chunk/loader/region/RegionFile.java
@@ -56,11 +56,11 @@
 
 			int var3;
 			for(var3 = 0; var3 < var2; ++var3) {
-				this.sectorFree.add(Boolean.valueOf(true));
+				this.sectorFree.add(Boolean.TRUE);
 			}
 
-			this.sectorFree.set(0, Boolean.valueOf(false));
-			this.sectorFree.set(1, Boolean.valueOf(false));
+			this.sectorFree.set(0, Boolean.FALSE);
+			this.sectorFree.set(1, Boolean.FALSE);
 			this.dataFile.seek(0L);
 
 			int var4;
@@ -69,7 +69,7 @@
 				this.offsets[var3] = var4;
 				if(var4 != 0 && (var4 >> 8) + (var4 & 255) <= this.sectorFree.size()) {
 					for(int var5 = 0; var5 < (var4 & 255); ++var5) {
-						this.sectorFree.set((var4 >> 8) + var5, Boolean.valueOf(false));
+						this.sectorFree.set((var4 >> 8) + var5, Boolean.FALSE);
 					}
 				}
 			}
@@ -162,6 +162,45 @@
 		return this.outOfBounds(var1, var2) ? null : new DataOutputStream(new DeflaterOutputStream(new RegionFileChunkBuffer(this, var1, var2)));
 	}
 
+	public synchronized boolean chunkDataExists(int var1, int var2) {
+		if(this.outOfBounds(var1, var2)) {
+			this.debugln("READ", var1, var2, "out of bounds");
+			return false;
+		} else {
+			try {
+				int var3 = this.getOffset(var1, var2);
+				if(var3 == 0) {
+					return false;
+				}
+
+				int var4 = var3 >> 8;
+				int var5 = var3 & 255;
+				if(var4 + var5 > this.sectorFree.size()) {
+					this.debugln("READ", var1, var2, "invalid sector");
+					return false;
+				}
+
+				this.dataFile.seek((long)(var4 * 4096L));
+				int var6 = this.dataFile.readInt();
+				if(var6 > 4096 * var5) {
+					this.debugln("READ", var1, var2, "invalid length: " + var6 + " > 4096 * " + var5);
+					return false;
+				}
+
+				byte var7 = this.dataFile.readByte();
+				if(var7 == 1 || var7 == 2) {
+					return true;
+				}
+
+				this.debugln("READ", var1, var2, "unknown version " + var7);
+				return false;
+			} catch (IOException var10) {
+				this.debugln("READ", var1, var2, "exception");
+				return false;
+			}
+		}
+	}
+
 	protected synchronized void write(int var1, int var2, byte[] var3, int var4) {
 		try {
 			int var5 = this.getOffset(var1, var2);
@@ -178,10 +217,10 @@
 			} else {
 				int var9;
 				for(var9 = 0; var9 < var7; ++var9) {
-					this.sectorFree.set(var6 + var9, Boolean.valueOf(true));
+					this.sectorFree.set(var6 + var9, Boolean.TRUE);
 				}
 
-				var9 = this.sectorFree.indexOf(Boolean.valueOf(true));
+				var9 = this.sectorFree.indexOf(Boolean.TRUE);
 				int var10 = 0;
 				int var11;
 				if(var9 != -1) {
@@ -209,7 +248,7 @@
 					this.setOffset(var1, var2, var9 << 8 | var8);
 
 					for(var11 = 0; var11 < var8; ++var11) {
-						this.sectorFree.set(var6 + var11, Boolean.valueOf(false));
+						this.sectorFree.set(var6 + var11, Boolean.FALSE);
 					}
 
 					this.write(var6, var3, var4);
@@ -220,7 +259,7 @@
 
 					for(var11 = 0; var11 < var8; ++var11) {
 						this.dataFile.write(emptySector);
-						this.sectorFree.add(Boolean.valueOf(false));
+						this.sectorFree.add(Boolean.FALSE);
 					}
 
 					this.sizeDelta += 4096 * var8;
--- /dev/null
+++ net/mine_diver/smoothbeta/util/StringHelper.java
@@ -1,0 +1,84 @@
+package net.mine_diver.smoothbeta.util;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class StringHelper {
+    private static final Pattern FORMATTING_CODE = Pattern.compile("(?i)\\u00A7[0-9A-FK-OR]");
+    private static final Pattern LINE_BREAK = Pattern.compile("\\r\\n|\\v");
+    private static final Pattern ENDS_WITH_LINE_BREAK = Pattern.compile("(?:\\r\\n|\\v)$");
+
+    /**
+     * {@return the length of the {@code tick} in the MM:SS format, where
+     * the MM is the minutes and SS is the seconds (optionally zero-padded)}
+     */
+    public static String formatTicks(int ticks) {
+        int i = ticks / 20;
+        int j = i / 60;
+        if ((i %= 60) < 10) {
+            return j + ":0" + i;
+        }
+        return j + ":" + i;
+    }
+
+    /**
+     * {@return the {@code text} with all formatting codes removed}
+     * 
+     * <p>A formatting code is the character {@code §} followed by
+     * a numeric character or a letter A to F, K to O, or R.
+     */
+    public static String stripTextFormat(String text) {
+        return FORMATTING_CODE.matcher(text).replaceAll("");
+    }
+
+    /**
+     * {@return true if {@code text} is {@code null} or empty, false otherwise}
+     */
+    public static boolean isEmpty(String text) {
+        return text == null || text.isEmpty();
+    }
+
+    /**
+     * {@return {@code text} truncated to at most {@code maxLength} characters,
+     * optionally with ellipsis}
+     */
+    public static String truncate(String text, int maxLength, boolean addEllipsis) {
+        if (text.length() <= maxLength) {
+            return text;
+        }
+        if (addEllipsis && maxLength > 3) {
+            return text.substring(0, maxLength - 3) + "...";
+        }
+        return text.substring(0, maxLength);
+    }
+
+    /**
+     * {@return the number of linebreaks in {@code text}}
+     * 
+     * <p>A linebreak is either a CRLF sequence or a vertical tab (U+000B).
+     */
+    public static int countLines(String text) {
+        if (text.isEmpty()) {
+            return 0;
+        }
+        Matcher matcher = LINE_BREAK.matcher(text);
+        int i = 1;
+        while (matcher.find()) {
+            ++i;
+        }
+        return i;
+    }
+
+    /**
+     * {@return true if {@code text} ends with a linebreak, false otherwise}
+     * 
+     * <p>A linebreak is either a CRLF sequence or a vertical tab (U+000B).
+     */
+    public static boolean endsWithLineBreak(String text) {
+        return ENDS_WITH_LINE_BREAK.matcher(text).find();
+    }
+
+    public static boolean isBlank(String text) {
+        return isEmpty(text) || text.chars().allMatch(Character::isWhitespace);
+    }
+}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/ShaderParseException.java
@@ -1,0 +1,76 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class ShaderParseException extends IOException {
+	private final List<JsonStackTrace> traces = new ArrayList<>();
+	private final String message;
+
+	public ShaderParseException(String message) {
+		this.traces.add(new JsonStackTrace());
+		this.message = message;
+	}
+
+	public ShaderParseException(String message, Throwable cause) {
+		super(cause);
+		this.traces.add(new JsonStackTrace());
+		this.message = message;
+	}
+
+	public void addFaultyElement(String jsonKey) {
+		this.traces.get(0).add(jsonKey);
+	}
+
+	public void addFaultyFile(String path) {
+		this.traces.get(0).fileName = path;
+		this.traces.add(0, new JsonStackTrace());
+	}
+
+	public String getMessage() {
+		return "Invalid " + this.traces.get(this.traces.size() - 1) + ": " + this.message;
+	}
+
+	public static ShaderParseException wrap(Exception cause) {
+		if (cause instanceof ShaderParseException) {
+			return (ShaderParseException)cause;
+		} else {
+			String string = cause.getMessage();
+			if (cause instanceof FileNotFoundException) {
+				string = "File not found";
+			}
+
+			return new ShaderParseException(string, cause);
+		}
+	}
+
+	public static class JsonStackTrace {
+		String fileName;
+		private final List<String> faultyElements = new ArrayList<>();
+
+		JsonStackTrace() {}
+
+		void add(String element) {
+			this.faultyElements.add(0, element);
+		}
+
+		public String joinStackTrace() {
+			return String.join("->", this.faultyElements);
+		}
+
+		public String toString() {
+			if (this.fileName != null) {
+				if (this.faultyElements.isEmpty()) {
+					return this.fileName;
+				} else {
+					String var10000 = this.fileName;
+					return var10000 + " " + this.joinStackTrace();
+				}
+			} else {
+				return this.faultyElements.isEmpty() ? "(Unknown file)" : "(Unknown file) " + this.joinStackTrace();
+			}
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/client/gui/component/GuiSliderGeneric.java
@@ -1,0 +1,142 @@
+package net.minecraft.client.gui.component;
+
+import net.minecraft.client.Minecraft;
+
+import org.lwjgl.opengl.GL11;
+
+public class GuiSliderGeneric extends GuiButton {
+	public final String label;
+	public float multiplier;
+	public float sliderValue;
+	public boolean round;
+	public boolean dragging;
+	public boolean vertical;
+	public boolean hideBg;
+
+	public GuiSliderGeneric(int id, int x, int y, int w, int h, String label, float defaultValue, float multiplier) {
+		super(id, x, y, w, h, label);
+		this.buttonWidth = w;
+		this.buttonHeight = h;
+		this.label = label;
+		this.multiplier = multiplier;
+		this.sliderValue = defaultValue;
+		this.displayString = this.getDisplayString();
+	}
+
+	protected int getHoverState(boolean var1) {
+		return 0;
+	}
+
+	public float getValue() {
+		float value = this.sliderValue * this.multiplier;
+		if (round) {
+			value = (int) value;
+		}
+		return value;
+	}
+
+	public String getDisplayString() {
+		if (this.label == null) {
+			return "";
+		}
+
+		float value = getValue();
+		if (round) {
+			if (this.multiplier == 1.0F) {
+				return this.label + ": " + (int) value;
+			} else {
+				return this.label + ": " + (int) value + " / " + (int)this.multiplier;
+			}
+		} else {
+			if (this.multiplier == 1.0F) {
+				return this.label + ": " + value;
+			} else {
+				return this.label + ": " + value + " / " + this.multiplier;
+			}
+		}
+	}
+
+	protected void mouseDragged(Minecraft var1, int var2, int var3) {
+		if(this.visible) {
+			if(this.dragging) {
+				this.sliderValue = this.vertical
+						? (float)(var3 - (this.yPosition + 4)) / (float)(this.buttonHeight - 8)
+						: (float)(var2 - (this.xPosition + 4)) / (float)(this.buttonWidth - 8);
+				if(this.sliderValue < 0.0F) {
+					this.sliderValue = 0.0F;
+				}
+
+				if(this.sliderValue > 1.0F) {
+					this.sliderValue = 1.0F;
+				}
+
+				this.displayString = this.getDisplayString();
+			}
+
+
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			if (this.vertical) {
+				this.drawTexturedRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.buttonHeight - 8)), 18, 112, this.buttonWidth, 4);
+				this.drawTexturedRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.buttonHeight - 8)) + 4, 18, 252, this.buttonWidth, 4);
+			} else {
+				this.drawTexturedRect(this.xPosition + (int)(this.sliderValue * (float)(this.buttonWidth - 8)), this.yPosition, 0, 66, 4, this.buttonHeight);
+				this.drawTexturedRect(this.xPosition + (int)(this.sliderValue * (float)(this.buttonWidth - 8)) + 4, this.yPosition, 196, 66, 4, this.buttonHeight);
+			}
+		}
+	}
+
+	public boolean mousePressed(Minecraft var1, int var2, int var3) {
+		if(super.mousePressed(var1, var2, var3)) {
+			this.sliderValue = this.vertical
+					? (float)(var2 - (this.yPosition + 4)) / (float)(this.buttonHeight - 8)
+					: (float)(var2 - (this.xPosition + 4)) / (float)(this.buttonWidth - 8);
+
+			if(this.sliderValue < 0.0F) {
+				this.sliderValue = 0.0F;
+			}
+
+			if(this.sliderValue > 1.0F) {
+				this.sliderValue = 1.0F;
+			}
+
+			this.dragging = true;
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public void mouseReleased(int var1, int var2) {
+		this.dragging = false;
+	}
+
+	public void mouseScrolled(float delta) {
+		if (this.multiplier == 0.0F) return;
+
+		this.sliderValue -= delta / 120.0F / this.multiplier;
+
+		if(this.sliderValue < 0.0F) {
+			this.sliderValue = 0.0F;
+		}
+
+		if(this.sliderValue > 1.0F) {
+			this.sliderValue = 1.0F;
+		}
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
+		if (!this.vertical) {
+			super.drawButton(var1, var2, var3);
+		}
+
+		if (this.visible) {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.textureRegistry.getTexture("/gui/gui.png"));
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			if (!this.hideBg) {
+				this.drawTexturedRect(this.xPosition, this.yPosition, 0, 112, this.buttonWidth, this.buttonHeight / 2);
+				this.drawTexturedRect(this.xPosition, this.yPosition + this.buttonHeight / 2, 0, 256 - this.buttonHeight / 2, this.buttonWidth, this.buttonHeight / 2);
+			}
+			this.mouseDragged(var1, var2, var3);
+		}
+	}
+}
--- net/minecraft/network/packet/Packet52MultiBlockChange.java
+++ net/minecraft/network/packet/Packet52MultiBlockChange.java
@@ -10,7 +10,7 @@
 public class Packet52MultiBlockChange extends Packet {
 	public int xPosition;
 	public int zPosition;
-	public short[] coordinateArray;
+	public int[] coordinateArray;
 	public byte[] typeArray;
 	public byte[] metadataArray;
 	public int size;
@@ -23,12 +23,12 @@
 		this.xPosition = var1.readInt();
 		this.zPosition = var1.readInt();
 		this.size = var1.readShort() & '\uffff';
-		this.coordinateArray = new short[this.size];
+		this.coordinateArray = new int[this.size];
 		this.typeArray = new byte[this.size];
 		this.metadataArray = new byte[this.size];
 
 		for(int var2 = 0; var2 < this.size; ++var2) {
-			this.coordinateArray[var2] = var1.readShort();
+			this.coordinateArray[var2] = var1.readInt();
 		}
 
 		var1.readFully(this.typeArray);
@@ -41,7 +41,7 @@
 		var1.writeShort((short)this.size);
 
 		for(int var2 = 0; var2 < this.size; ++var2) {
-			var1.writeShort(this.coordinateArray[var2]);
+			var1.writeInt(this.coordinateArray[var2]);
 		}
 
 		var1.write(this.typeArray);
@@ -56,20 +56,20 @@
 		return 10 + this.size * 4;
 	}
 
-	public Packet52MultiBlockChange(int var1, int var2, short[] var3, int var4, World var5) {
+	public Packet52MultiBlockChange(int var1, int var2, int[] var3, int var4, World var5) {
 		this.isChunkDataPacket = true;
 		this.xPosition = var1;
 		this.zPosition = var2;
 		this.size = var4;
-		this.coordinateArray = new short[var4];
+		this.coordinateArray = new int[var4];
 		this.typeArray = new byte[var4];
 		this.metadataArray = new byte[var4];
 		Chunk var6 = var5.getChunkFromChunkCoords(var1, var2);
 
 		for(int var7 = 0; var7 < var4; ++var7) {
-			int var8 = var3[var7] >> 12 & 15;
-			int var9 = var3[var7] >> 8 & 15;
-			int var10 = var3[var7] & 255;
+			int var8 = var3[var7] >>> 4 & 15;
+			int var9 = var3[var7] & 15;
+			int var10 = (var3[var7] >>> 8) - (1 << 23);
 			this.coordinateArray[var7] = var3[var7];
 			this.typeArray[var7] = (byte)var6.getBlockID(var8, var10, var9);
 			this.metadataArray[var7] = (byte)var6.getBlockMetadata(var8, var10, var9);
--- net/minecraft/game/world/block/CactusBlock.java
+++ net/minecraft/game/world/block/CactusBlock.java
@@ -4,9 +4,16 @@
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.IntProperty;
 import net.minecraft.game.world.material.Material;
 
 public class CactusBlock extends Block {
+	private static final int TEX_TOP = TerrainLayout.texCoord("cactus_top");
+	private static final int TEX_SIDE = TerrainLayout.texCoord("cactus_side");
+	private static final int TEX_BOTTOM = TerrainLayout.texCoord("cactus_bottom");
+
+	public static final IntProperty AGE = new IntProperty("age");
+
 	protected CactusBlock(int var1, int var2) {
 		super(var1, var2, Material.cactus);
 		this.setTickOnLoad(true);
@@ -19,12 +26,12 @@
 			}
 
 			if(var6 < 3) {
-				int var7 = var1.getBlockMetadata(var2, var3, var4);
+				int var7 = var1.getBlockIntProperty(var2, var3, var4, AGE);
 				if(var7 == 15) {
 					var1.setBlockWithNotify(var2, var3 + 1, var4, this.blockID);
-					var1.setBlockMetadataWithNotify(var2, var3, var4, 0);
+					var1.setBlockPropertyWithNotify(var2, var3, var4, AGE, 0);
 				} else {
-					var1.setBlockMetadataWithNotify(var2, var3, var4, var7 + 1);
+					var1.setBlockPropertyWithNotify(var2, var3, var4, AGE, var7 + 1);
 				}
 			}
 		}
@@ -42,7 +49,7 @@
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex - 1 : (var1 == 0 ? this.textureIndex + 1 : this.textureIndex);
+		return var1 == 1 ? TEX_TOP : var1 == 0 ? TEX_BOTTOM : TEX_SIDE;
 	}
 
 	public boolean renderAsNormalBlock() {
--- /dev/null
+++ com/mojang/nbt/LongArrayTag.java
@@ -1,0 +1,50 @@
+package com.mojang.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+public class LongArrayTag extends NBTBaseTag {
+	public long[] longArray;
+
+	public LongArrayTag() {
+	}
+
+	public LongArrayTag(long[] var1) {
+		this.longArray = var1;
+	}
+
+	protected void writeTagContents(DataOutput var1) throws IOException {
+		var1.writeInt(this.longArray.length);
+		ByteBuffer buffer = ByteBuffer.allocate(this.longArray.length * 8);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asLongBuffer().put(this.longArray);
+		byte[] bytes = buffer.array();
+		var1.write(bytes);
+	}
+
+	protected void readTagContents(DataInput var1) throws IOException {
+		int var2 = var1.readInt();
+		this.longArray = new long[var2];
+		byte[] byteArray = new byte[var2 * 8];
+		var1.readFully(byteArray);
+		ByteBuffer buffer = ByteBuffer.wrap(byteArray);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asLongBuffer().get(this.longArray);
+	}
+
+	public byte getType() {
+		return (byte)12;
+	}
+
+	public String toString() {
+		return "[" + this.longArray.length + " longs]";
+	}
+
+	public NBTBaseTag copy() {
+		return new LongArrayTag(Arrays.copyOf(this.longArray, this.longArray.length)).setKey(this.getKey());
+	}
+}
--- net/minecraft/game/stats/achievement/AchievementMap.java
+++ net/minecraft/game/stats/achievement/AchievementMap.java
@@ -22,7 +22,7 @@
 
 				String[] var3 = var2.split(",");
 				int var4 = Integer.parseInt(var3[0]);
-				this.guidMap.put(Integer.valueOf(var4), var3[1]);
+				this.guidMap.put(var4, var3[1]);
 			}
 		} catch (Exception var5) {
 			var5.printStackTrace();
@@ -31,6 +31,6 @@
 	}
 
 	public static String getGuid(int var0) {
-		return (String)instance.guidMap.get(Integer.valueOf(var0));
+		return (String)instance.guidMap.get(var0);
 	}
 }
--- com/mojang/nbt/StringTag.java
+++ com/mojang/nbt/StringTag.java
@@ -30,6 +30,10 @@
 	}
 
 	public String toString() {
-		return "" + this.stringValue;
+		return this.stringValue;
+	}
+
+	public NBTBaseTag copy() {
+		return new StringTag(this.stringValue).setKey(this.getKey());
 	}
 }
--- net/minecraft/server/player/ItemInWorldManager.java
+++ net/minecraft/server/player/ItemInWorldManager.java
@@ -135,6 +135,6 @@
 
 	public boolean activeBlockOrUseItem(PlayerEntity var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7) {
 		int var8 = var2.getBlockId(var4, var5, var6);
-		return var8 > 0 && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1) ? true : (var3 == null ? false : var3.useItem(var1, var2, var4, var5, var6, var7));
+		return var8 > 0 && !var1.isSneaking() && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1) ? true : (var3 == null ? false : var3.useItem(var1, var2, var4, var5, var6, var7));
 	}
 }
--- net/minecraft/client/render/Tessellator.java
+++ net/minecraft/client/render/Tessellator.java
@@ -4,12 +4,15 @@
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
+
+import net.mine_diver.smoothbeta.client.render.SmoothChunkRenderer;
+import net.mine_diver.smoothbeta.client.render.SmoothTessellator;
 import org.lwjgl.opengl.ARBVertexBufferObject;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL15;
 import org.lwjgl.opengl.GLContext;
 
-public class Tessellator {
+public class Tessellator implements SmoothTessellator {
 	private static boolean convertQuadsToTriangles = true;
 	private static boolean tryVBO = false;
 	private ByteBuffer byteBuffer;
@@ -38,6 +41,25 @@
 	private int vboIndex = 0;
 	private int vboCount = 10;
 	private int bufferSize;
+    private boolean smoothbeta_renderingTerrain;
+    private SmoothChunkRenderer smoothbeta_chunkRenderer;
+
+	@Override
+	public void smoothbeta_startRenderingTerrain(SmoothChunkRenderer chunkRenderer) {
+        smoothbeta_renderingTerrain = true;
+        smoothbeta_chunkRenderer = chunkRenderer;
+    }
+
+	@Override
+	public void smoothbeta_stopRenderingTerrain() {
+        smoothbeta_renderingTerrain = false;
+        smoothbeta_chunkRenderer = null;
+    }
+
+	@Override
+    public boolean smoothbeta_isRenderingTerrain() {
+        return smoothbeta_renderingTerrain;
+    }
 
 	private Tessellator(int var1) {
 		this.bufferSize = var1;
@@ -63,6 +85,11 @@
 				this.intBuffer.put(this.rawBuffer, 0, this.rawBufferIndex);
 				this.byteBuffer.position(0);
 				this.byteBuffer.limit(this.rawBufferIndex * 4);
+				if (smoothbeta_renderingTerrain) {
+					smoothbeta_chunkRenderer.smoothbeta_getCurrentBuffer().upload(byteBuffer);
+					this.reset();
+					return;
+				}
 				if(this.useVBO) {
 					this.vboIndex = (this.vboIndex + 1) % this.vboCount;
 					ARBVertexBufferObject.glBindBufferARB(GL15.GL_ARRAY_BUFFER, this.vertexBuffers.get(this.vboIndex));
@@ -228,7 +255,7 @@
 
 	public void addVertex(double var1, double var3, double var5) {
 		++this.addedVertices;
-		if(this.drawMode == 7 && convertQuadsToTriangles && this.addedVertices % 4 == 0) {
+		if(this.drawMode == (smoothbeta_renderingTerrain ? -1 : 7) && convertQuadsToTriangles && this.addedVertices % 4 == 0) {
 			for(int var7 = 0; var7 < 2; ++var7) {
 				int var8 = 8 * (3 - var7);
 				if(this.hasTexture) {
@@ -264,7 +291,7 @@
 		this.rawBuffer[this.rawBufferIndex + 0] = Float.floatToRawIntBits((float)(var1 + this.xOffset));
 		this.rawBuffer[this.rawBufferIndex + 1] = Float.floatToRawIntBits((float)(var3 + this.yOffset));
 		this.rawBuffer[this.rawBufferIndex + 2] = Float.floatToRawIntBits((float)(var5 + this.zOffset));
-		this.rawBufferIndex += 8;
+		this.rawBufferIndex += smoothbeta_renderingTerrain ? 7 : 8;
 		++this.vertexCount;
 		if(this.vertexCount % 4 == 0 && this.rawBufferIndex >= this.bufferSize - 32) {
 			this.draw();
--- net/minecraft/game/world/biome/RainforestBiome.java
+++ net/minecraft/game/world/biome/RainforestBiome.java
@@ -1,12 +1,40 @@
 package net.minecraft.game.world.biome;
 
-import java.util.Random;
-import net.minecraft.game.world.terrain.feature.BigTreeFeature;
+import net.minecraft.game.world.terrain.NoiseSettings;
 import net.minecraft.game.world.terrain.feature.Feature;
-import net.minecraft.game.world.terrain.feature.TreeFeature;
+import net.minecraft.game.world.terrain.feature.MahoganyTreeFeature;
+import net.minecraft.game.world.terrain.feature.WillowTreeFeature;
+
+import java.util.Random;
 
 public class RainforestBiome extends Biome {
+	public RainforestBiome(int i) {
+		super(i);
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(40.0D, 80.0D)
+				.heightOffset(5.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings()
+				.noiseStretch(80.0D, 160.0D)
+				.heightOffset(20.0D);
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return 12;
+	}
+
 	public Feature getRandomTreeFeature(Random var1) {
-		return (Feature)(var1.nextInt(3) == 0 ? new BigTreeFeature() : new TreeFeature());
+		return var1.nextInt(6) == 0 ? new WillowTreeFeature(4, var1.nextInt(2) == 0 ? 68 : 4) : new MahoganyTreeFeature(true);
+	}
+
+	public Feature modifyGrownTree(Feature var1, Random var2) {
+		if (var1 instanceof MahoganyTreeFeature) var1 = new MahoganyTreeFeature(true);
+		if (var1 instanceof WillowTreeFeature && var2.nextInt(2) == 0) var1 = new WillowTreeFeature(4, 68);
+		return super.modifyGrownTree(var1, var2);
 	}
 }
--- net/minecraft/game/item/AltBlockItem.java
+++ net/minecraft/game/item/AltBlockItem.java
@@ -49,7 +49,7 @@
 				if(var3.setBlockWithNotify(var4, var5, var6, this.block)) {
 					Block.blocksList[this.block].onBlockPlaced(var3, var4, var5, var6, var7);
 					Block.blocksList[this.block].onBlockPlacedBy(var3, var4, var5, var6, var2);
-					var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var8.stepSound.baseStepSoundDir(), (var8.stepSound.getVolume() + 1.0F) / 2.0F, var8.stepSound.getPitch() * 0.8F);
+					var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var8.stepSound.baseSteppySoundDir(), (var8.stepSound.getVolume() + 1.0F) / 2.0F, var8.stepSound.getPitch() * 0.8F);
 					--var1.count;
 				}
 			}
--- argo/J_CompactJsonFormatter.java
+++ /dev/null
@@ -1,84 +1,0 @@
-package argo;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.Iterator;
-import java.util.TreeSet;
-
-public final class J_CompactJsonFormatter implements J_JsonFormatter {
-	public String func_27327_a(J_JsonRootNode var1) {
-		StringWriter var2 = new StringWriter();
-
-		try {
-			this.func_27329_a(var1, var2);
-		} catch (IOException var4) {
-			throw new RuntimeException("Coding failure in Argo:  StringWriter gave an IOException", var4);
-		}
-
-		return var2.toString();
-	}
-
-	public void func_27329_a(J_JsonRootNode var1, Writer var2) throws IOException {
-		this.func_27328_a(var1, var2);
-	}
-
-	private void func_27328_a(J_JsonNode var1, Writer var2) throws IOException {
-		boolean var3 = true;
-		Iterator var4;
-		switch(EnumJsonNodeTypeMappingHelper.field_27341_a[var1.func_27218_a().ordinal()]) {
-		case 1:
-			var2.append('[');
-			var4 = var1.getElements().iterator();
-
-			while(var4.hasNext()) {
-				J_JsonNode var6 = (J_JsonNode)var4.next();
-				if(!var3) {
-					var2.append(',');
-				}
-
-				var3 = false;
-				this.func_27328_a(var6, var2);
-			}
-
-			var2.append(']');
-			break;
-		case 2:
-			var2.append('{');
-			var4 = (new TreeSet(var1.getFields().keySet())).iterator();
-
-			while(var4.hasNext()) {
-				J_JsonStringNode var5 = (J_JsonStringNode)var4.next();
-				if(!var3) {
-					var2.append(',');
-				}
-
-				var3 = false;
-				this.func_27328_a(var5, var2);
-				var2.append(':');
-				this.func_27328_a((J_JsonNode)var1.getFields().get(var5), var2);
-			}
-
-			var2.append('}');
-			break;
-		case 3:
-			var2.append('\"').append((new J_JsonEscapedString(var1.getText())).toString()).append('\"');
-			break;
-		case 4:
-			var2.append(var1.getText());
-			break;
-		case 5:
-			var2.append("false");
-			break;
-		case 6:
-			var2.append("true");
-			break;
-		case 7:
-			var2.append("null");
-			break;
-		default:
-			throw new RuntimeException("Coding failure in Argo:  Attempt to format a JsonNode of unknown type [" + var1.func_27218_a() + "];");
-		}
-
-	}
-}
--- net/minecraft/game/item/recipe/RecipesIngots.java
+++ net/minecraft/game/item/recipe/RecipesIngots.java
@@ -11,8 +11,8 @@
 		for(int var2 = 0; var2 < this.recipeItems.length; ++var2) {
 			Block var3 = (Block)this.recipeItems[var2][0];
 			ItemStack var4 = (ItemStack)this.recipeItems[var2][1];
-			var1.addRecipe(new ItemStack(var3), new Object[]{"###", "###", "###", Character.valueOf('#'), var4});
-			var1.addRecipe(var4, new Object[]{"#", Character.valueOf('#'), var3});
+			var1.addRecipe(new ItemStack(var3), "###", "###", "###", '#', var4);
+			var1.addRecipe(var4, "#", '#', var3);
 		}
 
 	}
--- net/minecraft/client/gui/GuiScreen.java
+++ net/minecraft/client/gui/GuiScreen.java
@@ -5,27 +5,35 @@
 import java.awt.datatransfer.Transferable;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Random;
+
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.component.GuiButton;
 import net.minecraft.client.render.Tessellator;
+import net.minecraft.util.MathHelper;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.util.glu.GLU;
 
 public class GuiScreen extends Gui {
 	protected Minecraft mc;
 	public int width;
 	public int height;
-	protected List controlList = new ArrayList();
+	protected List<GuiButton> controlList = new ArrayList<>();
 	public boolean field_948_f = false;
 	protected FontRenderer fontRenderer;
 	public ParticleRenderer field_25091_h;
 	private GuiButton selectedButton = null;
+	protected boolean initialized;
+	public static final int panoramaCount = 8;
+	public static int panoramaCounter = new Random().nextInt(65536);
+	private static int panoramaType = new Random().nextInt(panoramaCount);
 
 	public void drawScreen(int var1, int var2, float var3) {
 		for(int var4 = 0; var4 < this.controlList.size(); ++var4) {
 			GuiButton var5 = (GuiButton)this.controlList.get(var4);
-			var5.drawButton(this.mc, var1, var2);
+			var5.drawRecursive(this.mc, var1, var2);
 		}
 
 	}
@@ -55,7 +63,8 @@
 		if(var3 == 0) {
 			for(int var4 = 0; var4 < this.controlList.size(); ++var4) {
 				GuiButton var5 = (GuiButton)this.controlList.get(var4);
-				if(var5.mousePressed(this.mc, var1, var2)) {
+				var5 = var5.mousePressedRecursive(this.mc, var1, var2);
+				if(var5 != null) {
 					this.selectedButton = var5;
 					this.mc.sndManager.playSoundFX("random.click", 1.0F, 1.0F);
 					this.actionPerformed(var5);
@@ -82,8 +91,11 @@
 		this.fontRenderer = var1.fontRenderer;
 		this.width = var2;
 		this.height = var3;
-		this.controlList.clear();
-		this.initGui();
+		if (!this.initialized) {
+			this.controlList.clear();
+			this.initialized = true;
+			this.initGui();
+		}
 	}
 
 	public void initGui() {
@@ -113,6 +125,13 @@
 			this.mouseMovedOrUp(var1, var2, Mouse.getEventButton());
 		}
 
+		if(Mouse.getEventDWheel() != 0) {
+			this.mouseScrolled(Mouse.getEventDWheel());
+		}
+
+	}
+
+	protected void mouseScrolled(int delta) {
 	}
 
 	public void handleKeyboardInput() {
@@ -133,24 +152,27 @@
 	public void onGuiClosed() {
 	}
 
-	public void drawDefaultBackground() {
-		this.drawWorldBackground(0);
+	public void drawDefaultBackground(float var3) {
+		this.drawWorldBackground(0, var3);
 	}
 
-	public void drawWorldBackground(int var1) {
+	public void drawWorldBackground(int var1, float var3) {
 		if(this.mc.theWorld != null) {
 			this.drawGradientRect(0, 0, this.width, this.height, -1072689136, -804253680);
 		} else {
-			this.drawBackground(var1);
+			this.drawBackground(var1, var3);
 		}
 
 	}
 
-	public void drawBackground(int var1) {
-		GL11.glDisable(GL11.GL_LIGHTING);
-		GL11.glDisable(GL11.GL_FOG);
-		Tessellator var2 = Tessellator.instance;
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/gui/background.png"));
+	public void drawBackground(int var1, float var3) {
+		func_35356_c(var3);
+		/*
+ 		GL11.glDisable(GL11.GL_LIGHTING);
+ 		GL11.glDisable(GL11.GL_FOG);
+ 		Tessellator var2 = Tessellator.instance;
+-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
++		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/bg" + bgType + ".png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		float var3 = 32.0F;
 		var2.startDrawingQuads();
@@ -160,6 +182,92 @@
 		var2.addVertexWithUV((double)this.width, 0.0D, 0.0D, (double)((float)this.width / var3), (double)(0 + var1));
 		var2.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, (double)(0 + var1));
 		var2.draw();
+		*/
+	}
+
+	private void func_35355_b(float var3) {
+		Tessellator var4 = Tessellator.instance;
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+		GL11.glLoadIdentity();
+		GLU.gluPerspective(90.0F, (float) this.width / this.height, 0.05F, 10.0F);
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPushMatrix();
+		GL11.glLoadIdentity();
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glDisable(GL11.GL_ALPHA_TEST);
+		GL11.glDisable(GL11.GL_CULL_FACE);
+		GL11.glDepthMask(false);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		byte var5 = 8;
+
+		for(int var6 = 0; var6 < var5 * var5; ++var6) {
+			GL11.glPushMatrix();
+			float var7 = ((float)(var6 % var5) / (float)var5 - 0.5F) / 64.0F;
+			float var8 = ((float)(var6 / var5) / (float)var5 - 0.5F) / 64.0F;
+			float var9 = 0.0F;
+			GL11.glTranslatef(var7, var8, var9);
+			GL11.glRotatef(-MathHelper.sin(((float)panoramaCounter + var3) / 400.0F) * 25.0F + 20.0F, 1.0F, 0.0F, 0.0F);
+			GL11.glRotatef(-((float)panoramaCounter + var3) * 0.1F, 0.0F, 1.0F, 0.0F);
+
+			for(int var10 = 0; var10 < 6; ++var10) {
+				GL11.glPushMatrix();
+				if(var10 == 1) {
+					GL11.glRotatef(90.0F, 0.0F, 1.0F, 0.0F);
+				}
+
+				if(var10 == 2) {
+					GL11.glRotatef(180.0F, 0.0F, 1.0F, 0.0F);
+				}
+
+				if(var10 == 3) {
+					GL11.glRotatef(-90.0F, 0.0F, 1.0F, 0.0F);
+				}
+
+				if(var10 == 4) {
+					GL11.glRotatef(90.0F, 1.0F, 0.0F, 0.0F);
+				}
+
+				if(var10 == 5) {
+					GL11.glRotatef(-90.0F, 1.0F, 0.0F, 0.0F);
+				}
+
+				GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/title/bg/" + panoramaType + "/panorama" + var10 + ".png"));
+				var4.startDrawingQuads();
+				var4.setColorRGBA_I(16777215, 255 / (var6 + 1));
+				var4.addVertexWithUV(-1.0D, -1.0D, 1.0D, 0.0D, 0.0D);
+				var4.addVertexWithUV(1.0D, -1.0D, 1.0D, 1.0D, 0.0D);
+				var4.addVertexWithUV(1.0D, 1.0D, 1.0D, 1.0D, 1.0D);
+				var4.addVertexWithUV(-1.0D, 1.0D, 1.0D, 0.0D, 1.0D);
+				var4.draw();
+				GL11.glPopMatrix();
+			}
+
+			GL11.glPopMatrix();
+			GL11.glColorMask(true, true, true, false);
+		}
+
+		var4.setTranslationD(0.0D, 0.0D, 0.0D);
+		GL11.glColorMask(true, true, true, true);
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPopMatrix();
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+		GL11.glDepthMask(true);
+		GL11.glEnable(GL11.GL_CULL_FACE);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glEnable(GL11.GL_DEPTH_TEST);
+	}
+
+	private void func_35356_c(float var3) {
+		this.func_35355_b(var3);
+		GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+		Tessellator var4 = Tessellator.instance;
+		var4.startDrawingQuads();
+		var4.setColorRGBA_F(1.0F, 1.0F, 1.0F, 1.0F);
+		var4.draw();
 	}
 
 	public boolean doesGuiPauseGame() {
--- argo/J_NodeContainer.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package argo;
-
-interface J_NodeContainer {
-	void func_27290_a(J_JsonNodeBuilder var1);
-
-	void func_27289_a(J_JsonFieldBuilder var1);
-}
--- net/minecraft/client/gui/ConnectionFailedScreen.java
+++ net/minecraft/client/gui/ConnectionFailedScreen.java
@@ -27,7 +27,7 @@
 	public void initGui() {
 		StringTranslate var1 = StringTranslate.getInstance();
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 120 + 12, var1.translateKey("gui.toMenu")));
+		this.controlList.add(new GuiButton(0, -100, 132, var1.translateKey("gui.toMenu")).alignedAt(0.5F, 0.25F));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -38,7 +38,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.errorMessage, this.width / 2, this.height / 2 - 50, 16777215);
 		this.drawCenteredString(this.fontRenderer, this.errorDetail, this.width / 2, this.height / 2 - 10, 16777215);
 		super.drawScreen(var1, var2, var3);
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/VertexFormat.java
@@ -1,0 +1,113 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import org.lwjgl.opengl.GL11;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+public class VertexFormat {
+    private final Map<String, VertexFormatElement> elementMap;
+    private final int vertexSizeByte;
+
+    public VertexFormat(Map<String, VertexFormatElement> elementMap) {
+        this.elementMap = elementMap;
+        int i = 0;
+        for (VertexFormatElement vertexFormatElement : elementMap.values())
+            i += vertexFormatElement.getByteLength();
+        this.vertexSizeByte = i;
+    }
+
+    public String toString() {
+        return "format: " + this.elementMap.size() + " elements: " + this.elementMap.entrySet().stream().map(Object::toString).collect(Collectors.joining(" "));
+    }
+
+    public int getVertexSizeByte() {
+        return this.vertexSizeByte;
+    }
+
+    public List<String> getAttributeNames() {
+        return Collections.unmodifiableList(new ArrayList<>(this.elementMap.keySet()));
+    }
+
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || this.getClass() != o.getClass()) {
+            return false;
+        }
+        VertexFormat vertexFormat = (VertexFormat)o;
+        if (this.vertexSizeByte != vertexFormat.vertexSizeByte) {
+            return false;
+        }
+        return this.elementMap.equals(vertexFormat.elementMap);
+    }
+
+    public int hashCode() {
+        return this.elementMap.hashCode();
+    }
+
+    public enum DrawMode {
+        LINES(4, 2, 2, false),
+        LINE_STRIP(5, 2, 1, true),
+        DEBUG_LINES(1, 2, 2, false),
+        DEBUG_LINE_STRIP(3, 2, 1, true),
+        TRIANGLES(4, 3, 3, false),
+        TRIANGLE_STRIP(5, 3, 1, true),
+        TRIANGLE_FAN(6, 3, 1, true),
+        QUADS(4, 4, 4, false);
+
+        public final int glMode;
+        public final int firstVertexCount;
+        public final int additionalVertexCount;
+        public final boolean shareVertices;
+
+        DrawMode(int glMode, int firstVertexCount, int additionalVertexCount, boolean shareVertices) {
+            this.glMode = glMode;
+            this.firstVertexCount = firstVertexCount;
+            this.additionalVertexCount = additionalVertexCount;
+            this.shareVertices = shareVertices;
+        }
+
+        public int getIndexCount(int vertexCount) {
+            switch (this) {
+                case LINE_STRIP:
+                case DEBUG_LINES:
+                case DEBUG_LINE_STRIP:
+                case TRIANGLES:
+                case TRIANGLE_STRIP:
+                case TRIANGLE_FAN: return vertexCount;
+                case LINES:
+                case QUADS: return vertexCount / 4 * 6;
+            }
+            return 0;
+        }
+    }
+
+    public enum IndexType {
+        BYTE(GL11.GL_UNSIGNED_BYTE, 1),
+        SHORT(GL11.GL_UNSIGNED_SHORT, 2),
+        INT(GL11.GL_UNSIGNED_INT, 4);
+
+        public final int glType;
+        public final int size;
+
+        IndexType(int glType, int size) {
+            this.glType = glType;
+            this.size = size;
+        }
+
+        public static IndexType smallestFor(int indexCount) {
+            if ((indexCount & 0xFFFF0000) != 0) {
+                return INT;
+            }
+            if ((indexCount & 0xFF00) != 0) {
+                return SHORT;
+            }
+            return BYTE;
+        }
+    }
+}
--- argo/J_JsonNodeFactories.java
+++ /dev/null
@@ -1,38 +1,0 @@
-package argo;
-
-import java.util.Arrays;
-import java.util.Map;
-
-public final class J_JsonNodeFactories {
-	public static J_JsonNode func_27310_a() {
-		return J_JsonConstants.j_null;
-	}
-
-	public static J_JsonNode func_27313_b() {
-		return J_JsonConstants.j_true;
-	}
-
-	public static J_JsonNode func_27314_c() {
-		return J_JsonConstants.j_false;
-	}
-
-	public static J_JsonStringNode func_27316_a(String var0) {
-		return new J_JsonStringNode(var0);
-	}
-
-	public static J_JsonNode func_27311_b(String var0) {
-		return new J_JsonNumberNode(var0);
-	}
-
-	public static J_JsonRootNode func_27309_a(Iterable var0) {
-		return new J_JsonArray(var0);
-	}
-
-	public static J_JsonRootNode func_27315_a(J_JsonNode... var0) {
-		return func_27309_a(Arrays.asList(var0));
-	}
-
-	public static J_JsonRootNode func_27312_a(Map var0) {
-		return new J_JsonObject(var0);
-	}
-}
--- /dev/null
+++ net/minecraft/game/world/block/TerrainLayout.java
@@ -1,0 +1,92 @@
+package net.minecraft.game.world.block;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.IntStream;
+
+public final class TerrainLayout {
+	private static final Object2IntMap<String> TERRAIN_SLOTS = new Object2IntOpenHashMap<>();
+	private static final List<int[]> MULTI_TEXTURES = new ArrayList<>();
+	public static final int MISSING_TEXTURE = 10 + 31 * 32;
+
+	private TerrainLayout() {
+	}
+
+	public static int texCoord(String id) {
+		return TERRAIN_SLOTS.getOrDefault(id, MISSING_TEXTURE);
+	}
+
+	public static int[] texCoordArray(String... variants) {
+		return Arrays.stream(variants).mapToInt(TerrainLayout::texCoord).toArray();
+	}
+
+	public static int[] varyingTexCoord(String base, String... variants) {
+		return Arrays.stream(variants).map(v -> v + "_" + base).mapToInt(TerrainLayout::texCoord).toArray();
+	}
+
+	public static int[] varyingTexCoord(String base, int count) {
+		return IntStream.range(0, count).mapToObj(i -> base + "_" + i).mapToInt(TerrainLayout::texCoord).toArray();
+	}
+
+	public static int combine(int... textures) {
+		int index = MULTI_TEXTURES.indexOf(textures);
+		if (!MULTI_TEXTURES.contains(textures)) {
+			MULTI_TEXTURES.add(textures);
+			index = MULTI_TEXTURES.size() - 1;
+		}
+		return index + 1024;
+	}
+
+	public static int[] getMultiTexture(int key) {
+		return key >= 0 && key < MULTI_TEXTURES.size() ? MULTI_TEXTURES.get(key) : null;
+	}
+
+	static {
+		int lineNumber = 0;
+		try {
+			int x = 0;
+			int y = 0;
+
+			BufferedReader layoutReader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(TerrainLayout.class.getResourceAsStream("/terrain-layout.txt"))));
+			String line;
+			while ((line = layoutReader.readLine()) != null) {
+				if (line.isEmpty() || line.startsWith("#")) continue;
+				String[] kv = line.split("=");
+				String key = kv[0].trim();
+				String[] coord = kv[1].split(",");
+				String coordX = coord[0].trim();
+				String coordY = coord[1].trim();
+
+				if (coordX.startsWith("+")) {
+					x += coordX.length();
+				} else if (coordX.startsWith("-")) {
+					x -= coordX.length();
+				} else if (!coordX.equals("\"")) {
+					x = Integer.parseInt(coordX);
+				}
+
+				if (coordY.startsWith("+")) {
+					y += coordY.length();
+				} else if (coordY.startsWith("-")) {
+					y -= coordY.length();
+				} else if (!coordY.equals("\"")) {
+					y = Integer.parseInt(coordY);
+				}
+
+				TERRAIN_SLOTS.put(key, x + y * 32);
+				lineNumber++;
+			}
+		} catch (IOException | NumberFormatException | ArrayIndexOutOfBoundsException | NullPointerException e) {
+			System.err.println("Failed to load terrain layout at line " + lineNumber + "!");
+			e.printStackTrace();
+		}
+	}
+}
--- argo/J_JsonNumberNode.java
+++ /dev/null
@@ -1,55 +1,0 @@
-package argo;
-
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-final class J_JsonNumberNode extends J_JsonNode {
-	private static final Pattern field_27226_a = Pattern.compile("(-?)(0|([1-9]([0-9]*)))(\\.[0-9]+)?((e|E)(\\+|-)?[0-9]+)?");
-	private final String field_27225_b;
-
-	J_JsonNumberNode(String var1) {
-		if(var1 == null) {
-			throw new NullPointerException("Attempt to construct a JsonNumber with a null value.");
-		} else if(!field_27226_a.matcher(var1).matches()) {
-			throw new IllegalArgumentException("Attempt to construct a JsonNumber with a String [" + var1 + "] that does not match the JSON number specification.");
-		} else {
-			this.field_27225_b = var1;
-		}
-	}
-
-	public EnumJsonNodeType func_27218_a() {
-		return EnumJsonNodeType.NUMBER;
-	}
-
-	public String getText() {
-		return this.field_27225_b;
-	}
-
-	public Map getFields() {
-		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
-	}
-
-	public List getElements() {
-		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
-	}
-
-	public boolean equals(Object var1) {
-		if(this == var1) {
-			return true;
-		} else if(var1 != null && this.getClass() == var1.getClass()) {
-			J_JsonNumberNode var2 = (J_JsonNumberNode)var1;
-			return this.field_27225_b.equals(var2.field_27225_b);
-		} else {
-			return false;
-		}
-	}
-
-	public int hashCode() {
-		return this.field_27225_b.hashCode();
-	}
-
-	public String toString() {
-		return "JsonNumberNode value:[" + this.field_27225_b + "]";
-	}
-}
--- /dev/null
+++ net/minecraft/client/player/ThreadGetSkin.java
@@ -1,0 +1,131 @@
+package net.minecraft.client.player;
+
+import argo.jdom.*;
+import net.minecraft.game.entity.player.PlayerEntity;
+
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.charset.StandardCharsets;
+import java.util.Base64;
+import java.util.List;
+import java.util.Map;
+
+public class ThreadGetSkin extends Thread {
+    private String playerName = "missingno";
+    private PlayerEntity player = null;
+    private String decodedJSON;
+
+    public ThreadGetSkin() {
+        this.setName("Skin getting thread");
+        this.setDaemon(true);
+    }
+
+    public ThreadGetSkin(PlayerEntity player) {
+        this();
+        this.player = player;
+        this.playerName = player.username;
+    }
+
+    @Override
+    public void run() {
+        try {
+            //get uuid of player
+            URL nameToUUIDUrl = new URL("https://api.mojang.com/users/profiles/minecraft/" + playerName);
+            HttpURLConnection connection = (HttpURLConnection) nameToUUIDUrl.openConnection();
+            connection.setDoInput(true);
+            connection.setDoOutput(false);
+            connection.connect();
+
+            //check if server responded with HTTP 200, if not then throw exception.
+            if (connection.getResponseCode() != 200) {
+                throw new Exception("Failed to get UUID: Server responded with non-200 HTTP code.");
+            }
+
+            InputStream is = connection.getInputStream();
+
+            byte[] out = new byte[is.available()];
+            is.read(out, 0, is.available());
+            String s = new String(out, StandardCharsets.UTF_8);
+
+            JsonRootNode jsonParser = new JdomParser().parse(s);
+            String UUID = jsonParser.getStringValue("id");
+
+            //get profile json
+            URL profileURL = new URL("https://sessionserver.mojang.com/session/minecraft/profile/" + UUID);
+            connection = (HttpURLConnection) profileURL.openConnection();
+            connection.setDoInput(true);
+            connection.setDoOutput(false);
+            connection.connect();
+
+            //check if server responded with HTTP 200, if not then throw exception.
+            if (connection.getResponseCode() != 200) {
+                throw new Exception("Failed to get skin: Server responded with non-200 HTTP code.");
+            }
+
+            is = connection.getInputStream();
+
+            out = new byte[is.available()];
+            is.read(out, 0, is.available());
+            s = new String(out, StandardCharsets.UTF_8);
+
+            //parse the profile json and decode the skin json
+            jsonParser = new JdomParser().parse(s);
+            List<JsonNode> propertyArray = jsonParser.getArrayNode("properties");
+            for (JsonNode node : propertyArray) {
+                final Map<JsonStringNode, JsonNode> jsonNodeMap = node.getFields();
+                for (Map.Entry<JsonStringNode, JsonNode> stringNode : jsonNodeMap.entrySet()) {
+                    String key = stringNode.getKey().getStringValue();
+                    String value = stringNode.getValue().getStringValue();
+
+                    if (key.equals("value")) {
+                        decodedJSON = new String(Base64.getDecoder().decode(value), StandardCharsets.UTF_8);
+                    }
+                }
+            }
+
+            //begin parsing skin json
+            jsonParser = new JdomParser().parse(decodedJSON);
+
+            try {
+                //get skin and cape url alongside model type
+                String skinURL = "";
+                String capeURL = "";
+                String modelType = "";
+
+                //this is terrible, but i can't do anything about that
+                try {
+                    skinURL = jsonParser.getStringValue("textures", "SKIN", "url");
+                } catch (ClassCastException | JsonNodeDoesNotMatchPathElementsException cce) {
+                    //do nothing since we don't want the game to crash and/or print an annoying error into the console just because someone has a steve model or doesn't have a cape.
+                }
+
+                try {
+                    capeURL = jsonParser.getStringValue("textures", "CAPE", "url");
+                } catch (ClassCastException | JsonNodeDoesNotMatchPathElementsException cce) {
+                    //ditto
+                }
+
+                try {
+                    modelType = jsonParser.getStringValue("textures", "SKIN", "metadata", "model");
+                } catch (ClassCastException | JsonNodeDoesNotMatchPathElementsException cce) {
+                    //ditto
+                }
+
+                //set skin and cape urls
+                if (!skinURL.isEmpty()) player.skinUrl = skinURL;
+                if (!capeURL.isEmpty()) player.cloakUrl = capeURL;
+
+                //set model type of player
+                if (modelType.equals("slim")) player.isSlim = true;
+                if (player != null) player.isSkinFound = true;
+
+                player.worldObj.obtainEntitySkin(player);
+            } catch (NullPointerException npe) {
+                //ditto to the cce exception
+            }
+        } catch (Exception t) {
+            new RuntimeException("Failed to get skin!", t).printStackTrace();
+        }
+    }
+}
--- net/minecraft/game/world/WorldInfo.java
+++ net/minecraft/game/world/WorldInfo.java
@@ -20,6 +20,7 @@
 	private int rainTime;
 	private boolean thundering;
 	private int thunderTime;
+	private boolean creative;
 
 	public WorldInfo(CompoundTag var1) {
 		this.randomSeed = var1.getLong("RandomSeed");
@@ -35,6 +36,7 @@
 		this.raining = var1.getBoolean("raining");
 		this.thunderTime = var1.getInteger("thunderTime");
 		this.thundering = var1.getBoolean("thundering");
+		this.creative = var1.getBoolean("Creative");
 		if(var1.hasKey("Player")) {
 			this.playerTag = var1.getCompoundTag("Player");
 			this.dimension = this.playerTag.getInteger("Dimension");
@@ -47,6 +49,12 @@
 		this.levelName = var3;
 	}
 
+	public WorldInfo(NewWorldInfo var1) {
+		this.levelName = var1.name;
+		this.randomSeed = var1.seed;
+		this.creative = var1.creative;
+	}
+
 	public WorldInfo(WorldInfo var1) {
 		this.randomSeed = var1.randomSeed;
 		this.spawnX = var1.spawnX;
@@ -63,6 +71,7 @@
 		this.raining = var1.raining;
 		this.thunderTime = var1.thunderTime;
 		this.thundering = var1.thundering;
+		this.creative = var1.creative;
 	}
 
 	public CompoundTag getNBTTagCompound() {
@@ -102,6 +111,7 @@
 		var1.setBoolean("raining", this.raining);
 		var1.setInteger("thunderTime", this.thunderTime);
 		var1.setBoolean("thundering", this.thundering);
+		var1.setBoolean("Creative", this.creative);
 		if(var2 != null) {
 			var1.setCompoundTag("Player", var2);
 		}
@@ -220,5 +230,13 @@
 
 	public void setRainTime(int var1) {
 		this.rainTime = var1;
+	}
+
+	public boolean isCreative() {
+		return this.creative;
+	}
+
+	public void setCreative(boolean creative) {
+		this.creative = creative;
 	}
 }
--- net/minecraft/client/world/WorldClient.java
+++ net/minecraft/client/world/WorldClient.java
@@ -2,29 +2,33 @@
 
 import java.util.HashSet;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.Set;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.world.BlockPos;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.WorldAccess;
+import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.game.world.chunk.ChunkProvider;
 import net.minecraft.game.world.chunk.ChunkProviderClient;
 import net.minecraft.game.world.dimension.Dimension;
 import net.minecraft.game.world.save.SaveHandlerMP;
 import net.minecraft.network.NetClientHandler;
 import net.minecraft.network.packet.Packet255KickDisconnect;
-import net.minecraft.util.MCHash;
 
 public class WorldClient extends World {
-	private LinkedList field_1057_z = new LinkedList();
+	private List<BlockRange> field_1057_z = new LinkedList<>();
 	private NetClientHandler sendQueue;
 	private ChunkProviderClient field_20915_C;
-	private MCHash field_1055_D = new MCHash();
-	private Set field_20914_E = new HashSet();
-	private Set field_1053_F = new HashSet();
+	private Int2ObjectMap<Entity> field_1055_D = new Int2ObjectOpenHashMap<>();
+	private Set<Entity> field_20914_E = new HashSet<>();
+	private Set<Entity> field_1053_F = new HashSet<>();
 
-	public WorldClient(NetClientHandler var1, long var2, int var4) {
-		super(new SaveHandlerMP(), "MpServer", Dimension.getProviderForDimension(var4), var2);
+	public WorldClient(NetClientHandler var1, int var4) {
+		super(new SaveHandlerMP(), "MpServer", Dimension.getProviderForDimension(var4), 0);
 		this.sendQueue = var1;
 		this.setSpawnPoint(new BlockPos(8, 64, 8));
 		this.mapStorage = var1.field_28118_b;
@@ -43,7 +47,7 @@
 		}
 
 		for(var2 = 0; var2 < 10 && !this.field_1053_F.isEmpty(); ++var2) {
-			Entity var3 = (Entity)this.field_1053_F.iterator().next();
+			Entity var3 = this.field_1053_F.iterator().next();
 			if(!this.loadedEntityList.contains(var3)) {
 				this.entityJoinedWorld(var3);
 			}
@@ -52,7 +56,7 @@
 		this.sendQueue.processReadPackets();
 
 		for(var2 = 0; var2 < this.field_1057_z.size(); ++var2) {
-			BlockRange var4 = (BlockRange)this.field_1057_z.get(var2);
+			BlockRange var4 = this.field_1057_z.get(var2);
 			if(--var4.field_1206_d == 0) {
 				super.setBlockAndMetadata(var4.field_1202_a, var4.field_1201_b, var4.field_1207_c, var4.field_1205_e, var4.field_1204_f);
 				super.markBlockNeedsUpdate(var4.field_1202_a, var4.field_1201_b, var4.field_1207_c);
@@ -64,7 +68,7 @@
 
 	public void func_711_c(int var1, int var2, int var3, int var4, int var5, int var6) {
 		for(int var7 = 0; var7 < this.field_1057_z.size(); ++var7) {
-			BlockRange var8 = (BlockRange)this.field_1057_z.get(var7);
+			BlockRange var8 = this.field_1057_z.get(var7);
 			if(var8.field_1202_a >= var1 && var8.field_1201_b >= var2 && var8.field_1207_c >= var3 && var8.field_1202_a <= var4 && var8.field_1201_b <= var5 && var8.field_1207_c <= var6) {
 				this.field_1057_z.remove(var7--);
 			}
@@ -95,13 +99,10 @@
 		if(var3) {
 			this.field_20915_C.prepareChunk(var1, var2);
 		} else {
+			Chunk prevChunk = this.field_20915_C.provideChunk(var1, var2);
 			this.field_20915_C.func_539_c(var1, var2);
-		}
-
-		if(!var3) {
-			this.markBlocksDirty(var1 * 16, 0, var2 * 16, var1 * 16 + 15, 128, var2 * 16 + 15);
-		}
-
+			this.markBlocksDirty(var1 * 16, prevChunk.getMinLevel() << 4, var2 * 16, var1 * 16 + 15, (prevChunk.getMaxLevel() << 4) + 15, var2 * 16 + 15);
+		}
 	}
 
 	public boolean entityJoinedWorld(Entity var1) {
@@ -119,11 +120,9 @@
 		this.field_20914_E.remove(var1);
 	}
 
-	protected void obtainEntitySkin(Entity var1) {
+	public void obtainEntitySkin(Entity var1) {
 		super.obtainEntitySkin(var1);
-		if(this.field_1053_F.contains(var1)) {
-			this.field_1053_F.remove(var1);
-		}
+		this.field_1053_F.remove(var1);
 
 	}
 
@@ -147,15 +146,15 @@
 			this.field_1053_F.add(var2);
 		}
 
-		this.field_1055_D.addKey(var1, var2);
+		this.field_1055_D.put(var1, var2);
 	}
 
 	public Entity func_709_b(int var1) {
-		return (Entity)this.field_1055_D.lookup(var1);
+		return this.field_1055_D.get(var1);
 	}
 
 	public Entity removeEntityFromWorld(int var1) {
-		Entity var2 = (Entity)this.field_1055_D.removeObject(var1);
+		Entity var2 = this.field_1055_D.remove(var1);
 		if(var2 != null) {
 			this.field_20914_E.remove(var2);
 			this.setEntityDead(var2);
--- net/minecraft/game/world/block/StepSound.java
+++ net/minecraft/game/world/block/StepSound.java
@@ -23,7 +23,7 @@
 		return "step." + this.id;
 	}
 
-	public String baseStepSoundDir() {
+	public String baseSteppySoundDir() {
 		return "step." + this.id;
 	}
 }
--- /dev/null
+++ argo/jdom/JsonNodeDoesNotMatchChainedJsonNodeSelectorException.java
@@ -1,0 +1,48 @@
+package argo.jdom;
+
+import java.util.LinkedList;
+import java.util.List;
+
+public final class JsonNodeDoesNotMatchChainedJsonNodeSelectorException extends JsonNodeDoesNotMatchJsonNodeSelectorException {
+	final Functor failedNode;
+	final List<JsonNodeSelector> failPath;
+
+	static JsonNodeDoesNotMatchJsonNodeSelectorException func_27322_a(Functor var0) {
+		return new JsonNodeDoesNotMatchChainedJsonNodeSelectorException(var0, new LinkedList<>());
+	}
+
+	static JsonNodeDoesNotMatchJsonNodeSelectorException func_27323_a(JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, JsonNodeSelector var1) {
+		LinkedList<JsonNodeSelector> var2 = new LinkedList<>(var0.failPath);
+		var2.add(var1);
+		return new JsonNodeDoesNotMatchChainedJsonNodeSelectorException(var0.failedNode, var2);
+	}
+
+	static JsonNodeDoesNotMatchJsonNodeSelectorException func_27321_b(JsonNodeDoesNotMatchChainedJsonNodeSelectorException var0, JsonNodeSelector var1) {
+		LinkedList<JsonNodeSelector> var2 = new LinkedList<>();
+		var2.add(var1);
+		return new JsonNodeDoesNotMatchChainedJsonNodeSelectorException(var0.failedNode, var2);
+	}
+
+	private JsonNodeDoesNotMatchChainedJsonNodeSelectorException(Functor var1, List<JsonNodeSelector> var2) {
+		super("Failed to match any JSON node at [" + getShortFormFailPath(var2) + "]");
+		this.failedNode = var1;
+		this.failPath = var2;
+	}
+
+	static String getShortFormFailPath(List<JsonNodeSelector> var0) {
+		StringBuilder var1 = new StringBuilder();
+
+		for(int var2 = var0.size() - 1; var2 >= 0; --var2) {
+			var1.append(var0.get(var2).shortForm());
+			if(var2 != 0) {
+				var1.append(".");
+			}
+		}
+
+		return var1.toString();
+	}
+
+	public String toString() {
+		return "JsonNodeDoesNotMatchJsonNodeSelectorException{failedNode=" + this.failedNode + ", failPath=" + this.failPath + '}';
+	}
+}
--- /dev/null
+++ argo/jdom/JsonListenerToJdomAdapter.java
@@ -1,0 +1,144 @@
+package argo.jdom;
+
+import argo.saj.JsonListener;
+
+import java.util.Stack;
+
+final class JsonListenerToJdomAdapter implements JsonListener {
+	private final Stack<NodeContainer> stack = new Stack<>();
+	private JsonNodeBuilder root;
+
+	JsonRootNode getDocument() {
+		return (JsonRootNode)this.root.buildNode();
+	}
+
+	public void startDocument() {
+	}
+
+	public void endDocument() {
+	}
+
+	public void startArray() {
+		JsonArrayNodeBuilder var1 = JsonNodeBuilders.anArrayBuilder();
+		this.addRootNode(var1);
+		this.stack.push(new Array(this, var1));
+	}
+
+	public void endArray() {
+		this.stack.pop();
+	}
+
+	public void startObject() {
+		JsonObjectNodeBuilder var1 = JsonNodeBuilders.anObjectBuilder();
+		this.addRootNode(var1);
+		this.stack.push(new ObjectNode(this, var1));
+	}
+
+	public void endObject() {
+		this.stack.pop();
+	}
+
+	public void startField(String var1) {
+		JsonFieldBuilder var2 = JsonFieldBuilder.aJsonFieldBuilder().withKey(JsonNodeBuilders.aStringBuilder(var1));
+		this.stack.peek().addField(var2);
+		this.stack.push(new Field(this, var2));
+	}
+
+	public void endField() {
+		this.stack.pop();
+	}
+
+	public void numberValue(String var1) {
+		this.addValue(JsonNodeBuilders.aNumberBuilder(var1));
+	}
+
+	public void trueValue() {
+		this.addValue(JsonNodeBuilders.aTrueBuilder());
+	}
+
+	public void stringValue(String var1) {
+		this.addValue(JsonNodeBuilders.aStringBuilder(var1));
+	}
+
+	public void falseValue() {
+		this.addValue(JsonNodeBuilders.aFalseBuilder());
+	}
+
+	public void nullValue() {
+		this.addValue(JsonNodeBuilders.aNullBuilder());
+	}
+
+	private void addRootNode(JsonNodeBuilder var1) {
+		if(this.root == null) {
+			this.root = var1;
+		} else {
+			this.addValue(var1);
+		}
+
+	}
+
+	private void addValue(JsonNodeBuilder var1) {
+		this.stack.peek().addNode(var1);
+	}
+
+	interface NodeContainer {
+		void addNode(JsonNodeBuilder var1);
+
+		void addField(JsonFieldBuilder var1);
+	}
+
+	static class Array implements NodeContainer {
+		final JsonArrayNodeBuilder nodeBuilder;
+
+		final JsonListenerToJdomAdapter listenerToJdomAdapter;
+
+		Array(JsonListenerToJdomAdapter var1, JsonArrayNodeBuilder var2) {
+			this.listenerToJdomAdapter = var1;
+			this.nodeBuilder = var2;
+		}
+
+		public void addNode(JsonNodeBuilder var1) {
+			this.nodeBuilder.withElement(var1);
+		}
+		public void addField(JsonFieldBuilder var1) {
+			throw new RuntimeException("Coding failure in Argo:  Attempt to add a field to an array.");
+		}
+
+	}
+	static class Field implements NodeContainer {
+		final JsonFieldBuilder fieldBuilder;
+
+		final JsonListenerToJdomAdapter listenerToJdomAdapter;
+
+		Field(JsonListenerToJdomAdapter var1, JsonFieldBuilder var2) {
+			this.listenerToJdomAdapter = var1;
+			this.fieldBuilder = var2;
+		}
+
+		public void addNode(JsonNodeBuilder var1) {
+			this.fieldBuilder.withValue(var1);
+		}
+		public void addField(JsonFieldBuilder var1) {
+			throw new RuntimeException("Coding failure in Argo:  Attempt to add a field to a field.");
+		}
+
+	}
+
+	static class ObjectNode implements NodeContainer {
+		final JsonObjectNodeBuilder nodeBuilder;
+		final JsonListenerToJdomAdapter listenerToJdomAdapter;
+
+		ObjectNode(JsonListenerToJdomAdapter var1, JsonObjectNodeBuilder var2) {
+			this.listenerToJdomAdapter = var1;
+			this.nodeBuilder = var2;
+		}
+
+		public void addNode(JsonNodeBuilder var1) {
+			throw new RuntimeException("Coding failure in Argo:  Attempt to add a node to an object.");
+		}
+
+		public void addField(JsonFieldBuilder var1) {
+			this.nodeBuilder.withFieldBuilder(var1);
+		}
+	}
+}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/GlShader.java
@@ -1,0 +1,11 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+public interface GlShader {
+	int getProgramRef();
+
+	Program getVertexShader();
+
+	Program getFragmentShader();
+
+	void attachReferencedShaders();
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerFuzzyZoom.java
@@ -1,0 +1,17 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.MathHelper;
+
+public class LayerFuzzyZoom extends LayerZoomBase {
+	public LayerFuzzyZoom(long seed, Layer parent) {
+		super(seed, parent);
+	}
+
+	protected int interpolate(int a, int b) {
+		return (int)(MathHelper.lerp(a, b, this.nextInt(10000) / 10000.0D));
+	}
+
+	protected int interpolate(int a, int b, int c, int d) {
+		return (int)(MathHelper.lerp(a, b, c, d, this.nextInt(10000) / 10000.0D, this.nextInt(10000) / 10000.0D));
+	}
+}
--- net/minecraft/game/item/LeavesItem.java
+++ net/minecraft/game/item/LeavesItem.java
@@ -2,8 +2,9 @@
 
 import net.minecraft.client.render.color.ColorizerFoliage;
 import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.block.LeavesBlock;
 
-public class LeavesItem extends BlockItem {
+public class LeavesItem extends SubtypedItem {
 	public LeavesItem(int var1) {
 		super(var1);
 		this.setMaxDamage(0);
@@ -11,14 +12,23 @@
 	}
 
 	public int getPlacedBlockMetadata(int var1) {
-		return var1 | 8;
-	}
-
-	public int getTextureFromDamage(int var1) {
-		return Block.leaves.getBlockTextureFromSideAndMetadata(0, var1);
+		return var1 | 128;
 	}
 
 	public int getColorFromDamage(int var1) {
-		return (var1 & 1) == 1 ? ColorizerFoliage.getFoliageColorPine() : ((var1 & 2) == 2 ? ColorizerFoliage.getFoliageColorBirch() : ColorizerFoliage.func_31073_c());
+		var1 = Block.leaves.properties.getInt(var1, LeavesBlock.TYPE);
+		return var1 == 1 ? ColorizerFoliage.getFoliageColorPine()
+				: var1 == 2 ? ColorizerFoliage.getFoliageColorMaple()
+				: var1 == 3 ? ColorizerFoliage.getFoliageColorMahogany()
+				: var1 == 4 ? ColorizerFoliage.getFoliageColorWillow()
+				: ColorizerFoliage.func_31073_c();
+	}
+
+	public String getNameFromStack(ItemStack var1) {
+		String name = super.getName() + "." + Block.leaves.properties.getInt(var1.getItemDamage(), LeavesBlock.TYPE);
+		if (Block.leaves.properties.getBoolean(var1.getItemDamage(), LeavesBlock.BLOOMING)) {
+			name += ".blooming";
+		}
+		return name;
 	}
 }
--- net/minecraft/client/render/texture/TextureCompassFX.java
+++ net/minecraft/client/render/texture/TextureCompassFX.java
@@ -20,8 +20,8 @@
 
 		try {
 			BufferedImage var2 = ImageIO.read(Minecraft.class.getResource("/gui/items.png"));
-			int var3 = this.iconIndex % 16 * 16;
-			int var4 = this.iconIndex / 16 * 16;
+			int var3 = this.iconIndex % 32 * 16;
+			int var4 = this.iconIndex / 32 * 16;
 			var2.getRGB(var3, var4, 16, 16, this.compassIconImageData, 0, 16);
 		} catch (IOException var5) {
 			var5.printStackTrace();
--- argo/J_JsonStringNodeSelector.java
+++ /dev/null
@@ -1,27 +1,0 @@
-package argo;
-
-final class J_JsonStringNodeSelector extends J_LeafFunctor {
-	public boolean func_27072_a(J_JsonNode var1) {
-		return EnumJsonNodeType.STRING == var1.func_27218_a();
-	}
-
-	public String func_27060_a() {
-		return "A short form string";
-	}
-
-	public String func_27073_b(J_JsonNode var1) {
-		return var1.getText();
-	}
-
-	public String toString() {
-		return "a value that is a string";
-	}
-
-	public Object func_27063_c(Object var1) {
-		return this.func_27073_b((J_JsonNode)var1);
-	}
-
-	public boolean func_27058_a(Object var1) {
-		return this.func_27072_a((J_JsonNode)var1);
-	}
-}
--- /dev/null
+++ argo/jdom/JsonNumberNode.java
@@ -1,0 +1,55 @@
+package argo.jdom;
+
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+final class JsonNumberNode extends JsonNode {
+	private static final Pattern PATTERN = Pattern.compile("(-?)(0|([1-9]([0-9]*)))(\\.[0-9]+)?((e|E)(\\+|-)?[0-9]+)?");
+	private final String value;
+
+	JsonNumberNode(String var1) {
+		if(var1 == null) {
+			throw new NullPointerException("Attempt to construct a JsonNumber with a null value.");
+		} else if(!PATTERN.matcher(var1).matches()) {
+			throw new IllegalArgumentException("Attempt to construct a JsonNumber with a String [" + var1 + "] that does not match the JSON number specification.");
+		} else {
+			this.value = var1;
+		}
+	}
+
+	public JsonNodeType getType() {
+		return JsonNodeType.NUMBER;
+	}
+
+	public String getText() {
+		return this.value;
+	}
+
+	public Map getFields() {
+		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
+	}
+
+	public List getElements() {
+		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
+	}
+
+	public boolean equals(Object var1) {
+		if(this == var1) {
+			return true;
+		} else if(var1 != null && this.getClass() == var1.getClass()) {
+			JsonNumberNode var2 = (JsonNumberNode)var1;
+			return this.value.equals(var2.value);
+		} else {
+			return false;
+		}
+	}
+
+	public int hashCode() {
+		return this.value.hashCode();
+	}
+
+	public String toString() {
+		return "JsonNumberNode value:[" + this.value + "]";
+	}
+}
--- net/minecraft/client/gui/AchievementScreen.java
+++ net/minecraft/client/gui/AchievementScreen.java
@@ -42,8 +42,7 @@
 	}
 
 	public void initGui() {
-		this.controlList.clear();
-		this.controlList.add(new GuiOptionsButton(1, this.width / 2 + 24, this.height / 2 + 74, 80, 20, StatCollector.translateToLocal("gui.done")));
+		this.controlList.add(new GuiOptionsButton(1, 24, 74, 80, 20, StatCollector.translateToLocal("gui.done")).alignedAt(0.5F, 0.5F));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -104,7 +103,7 @@
 			this.field_27122_w = 0;
 		}
 
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.func_27109_b(var1, var2, var3);
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glDisable(GL11.GL_DEPTH_TEST);
@@ -203,7 +202,7 @@
 					var26 = Block.bedrock.textureIndex;
 				}
 
-				this.drawTexturedRect(var10 + var24 * 16 - var14, var11 + var22 * 16 - var15, var26 % 16 << 4, var26 >> 4 << 4, 16, 16);
+				this.drawTexturedRect(var10 + var24 * 16 - var14, var11 + var22 * 16 - var15, var26 % 32 << 4, var26 >> 5 << 4, 16, 16, 512, 512);
 			}
 		}
 
@@ -327,7 +326,7 @@
 				}
 			} else {
 				var34 = Math.max(this.fontRenderer.getStringWidth(var31), 120);
-				String var39 = StatCollector.translateToLocalFormatted("achievement.requires", new Object[]{var27.parentAchievement.statName});
+				String var39 = StatCollector.translateToLocalFormatted("achievement.requires", var27.parentAchievement.statName);
 				var38 = this.fontRenderer.func_27277_a(var39, var34);
 				this.drawGradientRect(var17 - 3, var33 - 3, var17 + var34 + 3, var33 + var38 + 12 + 3, -1073741824, -1073741824);
 				this.fontRenderer.func_27278_a(var39, var17, var33 + 12, var34, -9416624);
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/GlProgramManager.java
@@ -1,0 +1,34 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import org.lwjgl.opengl.GL20;
+
+import java.io.IOException;
+
+public class GlProgramManager {
+	public static void useProgram(int program) {
+		GL20.glUseProgram(program);
+	}
+
+	public static void deleteProgram(GlShader shader) {
+		shader.getFragmentShader().release();
+		shader.getVertexShader().release();
+		GL20.glDeleteProgram(shader.getProgramRef());
+	}
+
+	public static int createProgram() throws IOException {
+		int i = GL20.glCreateProgram();
+		if (i <= 0) throw new IOException("Could not create shader program (returned program ID " + i + ")");
+		else return i;
+	}
+
+	public static void linkProgram(GlShader shader) {
+		shader.attachReferencedShaders();
+		GL20.glLinkProgram(shader.getProgramRef());
+		int i = GL20.glGetProgrami(shader.getProgramRef(), GL20.GL_LINK_STATUS);
+		if (i == 0) {
+			System.err.printf("Error encountered when linking program containing VS %s and FS %s. Log output:%n", shader.getVertexShader().getName(), shader.getFragmentShader().getName());
+			System.err.println(GL20.glGetProgramInfoLog(shader.getProgramRef(), 0x8000));
+		}
+
+	}
+}
--- net/minecraft/client/gui/MultiplayerSleepingScreen.java
+++ net/minecraft/client/gui/MultiplayerSleepingScreen.java
@@ -11,7 +11,7 @@
 	public void initGui() {
 		Keyboard.enableRepeatEvents(true);
 		StringTranslate var1 = StringTranslate.getInstance();
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height - 40, var1.translateKey("multiplayer.stopSleeping")));
+		this.controlList.add(new GuiButton(1, -100, -40, var1.translateKey("multiplayer.stopSleeping")).alignedAt(0.5F, 1.0F));
 	}
 
 	public void onGuiClosed() {
--- com/mojang/nbt/ByteTag.java
+++ com/mojang/nbt/ByteTag.java
@@ -29,4 +29,8 @@
 	public String toString() {
 		return "" + this.byteValue;
 	}
+
+	public NBTBaseTag copy() {
+		return new ByteTag(this.byteValue).setKey(this.getKey());
+	}
 }
--- net/minecraft/game/world/terrain/feature/LakeFeature.java
+++ net/minecraft/game/world/terrain/feature/LakeFeature.java
@@ -19,6 +19,10 @@
 		for(var5 -= 8; var4 > 0 && var1.isAirBlock(var3, var4, var5); --var4) {
 		}
 
+		if (var1.getBlockId(var3, var4, var5) == Block.ice.blockID) {
+			return false;
+		}
+
 		var4 -= 4;
 		boolean[] var6 = new boolean[2048];
 		int var7 = var2.nextInt(4) + 4;
--- net/minecraft/client/player/MovementInputFromOptions.java
+++ net/minecraft/client/player/MovementInputFromOptions.java
@@ -37,6 +37,10 @@
 			var3 = 5;
 		}
 
+		if(var1 == this.gameSettings.keyBindRun.keyCode) {
+			var3 = 6;
+		}
+
 		if(var3 >= 0) {
 			this.movementKeyStates[var3] = var2;
 		}
@@ -71,6 +75,7 @@
 
 		this.jump = this.movementKeyStates[4];
 		this.sneak = this.movementKeyStates[5];
+		this.run = this.movementKeyStates[6];
 		if(this.sneak) {
 			this.moveStrafe = (float)((double)this.moveStrafe * 0.3D);
 			this.moveForward = (float)((double)this.moveForward * 0.3D);
--- com/mojang/nbt/ListTag.java
+++ com/mojang/nbt/ListTag.java
@@ -5,6 +5,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.stream.Collectors;
 
 public class ListTag extends NBTBaseTag {
 	private List tagList = new ArrayList();
@@ -44,7 +45,7 @@
 	}
 
 	public String toString() {
-		return "" + this.tagList.size() + " entries of type " + NBTBaseTag.getTagName(this.tagType);
+		return this.tagList.size() + " entries of type " + NBTBaseTag.getTagName(this.tagType);
 	}
 
 	public void setTag(NBTBaseTag var1) {
@@ -58,5 +59,13 @@
 
 	public int tagCount() {
 		return this.tagList.size();
+	}
+
+	@SuppressWarnings({"unchecked", "rawtypes"})
+	public NBTBaseTag copy() {
+		List list = (List)this.tagList.stream().map(x -> ((NBTBaseTag)x).copy()).collect(Collectors.toList());
+		ListTag tag = new ListTag();
+		tag.tagList = list;
+		return tag.setKey(this.getKey());
 	}
 }
--- /dev/null
+++ argo/jdom/LeafFunctor.java
@@ -1,0 +1,13 @@
+package argo.jdom;
+
+abstract class LeafFunctor implements Functor {
+	public final Object applyTo(Object var1) {
+		if(!this.matchesNode(var1)) {
+			throw JsonNodeDoesNotMatchChainedJsonNodeSelectorException.func_27322_a(this);
+		} else {
+			return this.typeSafeApplyTo(var1);
+		}
+	}
+
+	protected abstract Object typeSafeApplyTo(Object var1);
+}
--- argo/J_JsonNode.java
+++ /dev/null
@@ -1,30 +1,0 @@
-package argo;
-
-import java.util.List;
-import java.util.Map;
-
-public abstract class J_JsonNode {
-	public abstract EnumJsonNodeType func_27218_a();
-
-	public abstract String getText();
-
-	public abstract Map getFields();
-
-	public abstract List getElements();
-
-	public final String func_27213_a(Object... var1) {
-		return (String)this.func_27219_a(J_JsonNodeSelectors.func_27349_a(var1), this, var1);
-	}
-
-	public final List func_27217_b(Object... var1) {
-		return (List)this.func_27219_a(J_JsonNodeSelectors.func_27346_b(var1), this, var1);
-	}
-
-	private Object func_27219_a(J_JsonNodeSelector var1, J_JsonNode var2, Object[] var3) {
-		try {
-			return var1.func_27357_b(var2);
-		} catch (J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException var5) {
-			throw J_JsonNodeDoesNotMatchPathElementsException.func_27319_a(var5, var3, J_JsonNodeFactories.func_27315_a(new J_JsonNode[]{var2}));
-		}
-	}
-}
--- /dev/null
+++ net/minecraft/game/world/biome/OceanBiome.java
@@ -1,0 +1,36 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
+
+import java.util.Random;
+
+public class OceanBiome extends Biome {
+	public OceanBiome(int i) {
+		super(i);
+		this.topBlock = (byte)Block.sand.blockID;
+		this.fillerBlock = (byte)Block.sand.blockID;
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.heightOffset(-16.0D)
+				.noiseStretch(4.0D, 8.0D)
+				.noiseUnderDamp(4.0D);
+	}
+
+	public NoiseSettings getNoiseSettings(int x, int z, double boost, double ocean, double edge) {
+		ocean = Math.max(ocean, -0.5D) * 2.0D;
+		return new NoiseSettings.Builder(super.getNoiseSettings(x, z, boost, ocean, edge))
+				.heightOffset(ocean * 32.0D - 1.0D)
+				.noiseStretch(12.0D * -ocean, 16.0D * -ocean)
+				.build();
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		int sandOffset = seaLevel + 2 + random.nextInt(3);
+		this.topBlock = this.fillerBlock = surfaceHeight < sandOffset ? (byte)Block.sand.blockID : (byte)Block.stone.blockID;
+		super.buildSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+	}
+}
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/VertexBuffer.java
@@ -1,0 +1,23 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import net.mine_diver.smoothbeta.client.render.VboPool;
+import net.mine_diver.smoothbeta.client.render.VertexFormat;
+
+import java.nio.ByteBuffer;
+
+public class VertexBuffer {
+    private final VboPool pool;
+    private final VboPool.Pos poolPos = new VboPool.Pos();
+
+    public VertexBuffer(VboPool pool) {
+        this.pool = pool;
+    }
+
+    public void upload(ByteBuffer buffer) {
+        pool.bufferData(buffer, poolPos);
+    }
+
+    public void uploadToPool() {
+        pool.upload(VertexFormat.DrawMode.QUADS, poolPos);
+    }
+}
--- argo/J_JsonObject.java
+++ /dev/null
@@ -1,48 +1,0 @@
-package argo;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-final class J_JsonObject extends J_JsonRootNode {
-	private final Map field_27222_a;
-
-	J_JsonObject(Map var1) {
-		this.field_27222_a = new HashMap(var1);
-	}
-
-	public Map getFields() {
-		return new HashMap(this.field_27222_a);
-	}
-
-	public EnumJsonNodeType func_27218_a() {
-		return EnumJsonNodeType.OBJECT;
-	}
-
-	public String getText() {
-		throw new IllegalStateException("Attempt to get text on a JsonNode without text.");
-	}
-
-	public List getElements() {
-		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
-	}
-
-	public boolean equals(Object var1) {
-		if(this == var1) {
-			return true;
-		} else if(var1 != null && this.getClass() == var1.getClass()) {
-			J_JsonObject var2 = (J_JsonObject)var1;
-			return this.field_27222_a.equals(var2.field_27222_a);
-		} else {
-			return false;
-		}
-	}
-
-	public int hashCode() {
-		return this.field_27222_a.hashCode();
-	}
-
-	public String toString() {
-		return "JsonObject fields:[" + this.field_27222_a + "]";
-	}
-}
--- net/minecraft/client/render/entity/RenderItem.java
+++ net/minecraft/client/render/entity/RenderItem.java
@@ -52,9 +52,6 @@
 			GL11.glRotatef(var12, 0.0F, 1.0F, 0.0F);
 			this.loadTexture("/terrain.png");
 			float var28 = 0.25F;
-			if(!Block.blocksList[var10.id].renderAsNormalBlock() && var10.id != Block.stoneSlab.blockID && Block.blocksList[var10.id].getRenderType() != 16) {
-				var28 = 0.5F;
-			}
 
 			GL11.glScalef(var28, var28, var28);
 
@@ -80,10 +77,10 @@
 			}
 
 			Tessellator var15 = Tessellator.instance;
-			var16 = (float)(var14 % 16 * 16 + 0) / 256.0F;
-			var17 = (float)(var14 % 16 * 16 + 16) / 256.0F;
-			var18 = (float)(var14 / 16 * 16 + 0) / 256.0F;
-			float var19 = (float)(var14 / 16 * 16 + 16) / 256.0F;
+			var16 = (float)(var14 % 32 * 16 + 0) / 512.0F;
+			var17 = (float)(var14 % 32 * 16 + 16) / 512.0F;
+			var18 = (float)(var14 / 32 * 16 + 0) / 512.0F;
+			float var19 = (float)(var14 / 32 * 16 + 16) / 512.0F;
 			float var20 = 1.0F;
 			float var21 = 0.5F;
 			float var22 = 0.25F;
@@ -166,7 +163,7 @@
 				GL11.glColor4f(var9, var10, var11, 1.0F);
 			}
 
-			this.renderTexturedQuad(var6, var7, var5 % 16 * 16, var5 / 16 * 16, 16, 16);
+			this.renderTexturedQuad(var6, var7, var5 % 32 * 16, var5 / 32 * 16, 16, 16, 512, 512);
 			GL11.glEnable(GL11.GL_LIGHTING);
 		}
 
@@ -223,8 +220,21 @@
 
 	public void renderTexturedQuad(int var1, int var2, int var3, int var4, int var5, int var6) {
 		float var7 = 0.0F;
-		float var8 = 0.00390625F;
-		float var9 = 0.00390625F;
+		float var8 = 1 / 256F;
+		float var9 = 1 / 256F;
+		Tessellator var10 = Tessellator.instance;
+		var10.startDrawingQuads();
+		var10.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), (double)var7, (double)((float)(var3 + 0) * var8), (double)((float)(var4 + var6) * var9));
+		var10.addVertexWithUV((double)(var1 + var5), (double)(var2 + var6), (double)var7, (double)((float)(var3 + var5) * var8), (double)((float)(var4 + var6) * var9));
+		var10.addVertexWithUV((double)(var1 + var5), (double)(var2 + 0), (double)var7, (double)((float)(var3 + var5) * var8), (double)((float)(var4 + 0) * var9));
+		var10.addVertexWithUV((double)(var1 + 0), (double)(var2 + 0), (double)var7, (double)((float)(var3 + 0) * var8), (double)((float)(var4 + 0) * var9));
+		var10.draw();
+	}
+
+	public void renderTexturedQuad(int var1, int var2, int var3, int var4, int var5, int var6, float width, float height) {
+		float var7 = 0.0F;
+		float var8 = 1 / width;
+		float var9 = 1 / height;
 		Tessellator var10 = Tessellator.instance;
 		var10.startDrawingQuads();
 		var10.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), (double)var7, (double)((float)(var3 + 0) * var8), (double)((float)(var4 + var6) * var9));
--- net/minecraft/game/world/path/Pathfinder.java
+++ net/minecraft/game/world/path/Pathfinder.java
@@ -1,17 +1,18 @@
 package net.minecraft.game.world.path;
 
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.block.DoorBlock;
 import net.minecraft.game.world.material.Material;
-import net.minecraft.util.MCHash;
 import net.minecraft.util.MathHelper;
 
 public class Pathfinder {
 	private BlockAccess worldMap;
 	private Path path = new Path();
-	private MCHash pointMap = new MCHash();
+	private Int2ObjectMap<PathPoint> pointMap = new Int2ObjectOpenHashMap<>();
 	private PathPoint[] pathOptions = new PathPoint[32];
 
 	public Pathfinder(BlockAccess var1) {
@@ -28,7 +29,7 @@
 
 	private PathEntity createEntityPathTo(Entity var1, double var2, double var4, double var6, float var8) {
 		this.path.clearPath();
-		this.pointMap.clearMap();
+		this.pointMap.clear();
 		PathPoint var9 = this.openPoint(MathHelper.floor(var1.boundingBox.minX), MathHelper.floor(var1.boundingBox.minY), MathHelper.floor(var1.boundingBox.minZ));
 		PathPoint var10 = this.openPoint(MathHelper.floor(var2 - (double)(var1.width / 2.0F)), MathHelper.floor(var4), MathHelper.floor(var6 - (double)(var1.width / 2.0F)));
 		PathPoint var11 = new PathPoint(MathHelper.floor(var1.width + 1.0F), MathHelper.floor(var1.height + 1.0F), MathHelper.floor(var1.width + 1.0F));
@@ -153,10 +154,10 @@
 
 	private final PathPoint openPoint(int var1, int var2, int var3) {
 		int var4 = PathPoint.getHash(var1, var2, var3);
-		PathPoint var5 = (PathPoint)this.pointMap.lookup(var4);
+		PathPoint var5 = this.pointMap.get(var4);
 		if(var5 == null) {
 			var5 = new PathPoint(var1, var2, var3);
-			this.pointMap.addKey(var4, var5);
+			this.pointMap.put(var4, var5);
 		}
 
 		return var5;
--- net/minecraft/client/gui/ConflictWarningScreen.java
+++ net/minecraft/client/gui/ConflictWarningScreen.java
@@ -11,7 +11,7 @@
 
 	public void initGui() {
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 120 + 12, "Back to title screen"));
+		this.controlList.add(new GuiButton(0, -100, 132, "Back to title screen").alignedAt(0.5F, 0.25F));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -24,7 +24,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, "Level save conflict", this.width / 2, this.height / 4 - 60 + 20, 16777215);
 		this.drawString(this.fontRenderer, "Minecraft detected a conflict in the level save data.", this.width / 2 - 140, this.height / 4 - 60 + 60 + 0, 10526880);
 		this.drawString(this.fontRenderer, "This could be caused by two copies of the game", this.width / 2 - 140, this.height / 4 - 60 + 60 + 18, 10526880);
--- net/minecraft/game/item/ShearsItem.java
+++ net/minecraft/game/item/ShearsItem.java
@@ -23,6 +23,6 @@
 	}
 
 	public float getStrengthAgainstBlock(ItemStack var1, Block var2) {
-		return var2.blockID != Block.web.blockID && var2.blockID != Block.leaves.blockID ? (var2.blockID == Block.wool.blockID ? 5.0F : super.getStrengthAgainstBlock(var1, var2)) : 15.0F;
+		return var2 == Block.wool ? 5.0F : var2.effectiveTool == ToolType.SHEARS ? 15.0F : super.getStrengthAgainstBlock(var1, var2);
 	}
 }
--- net/minecraft/server/player/PlayerManager.java
+++ net/minecraft/server/player/PlayerManager.java
@@ -2,12 +2,16 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.game.world.chunk.ChunkCoordIntPair;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.world.WorldServer;
 
 public class PlayerManager {
 	public List players = new ArrayList();
-	private PlayerHash playerInstances = new PlayerHash();
+	private Long2ObjectMap<PlayerInstance> playerInstances = new Long2ObjectOpenHashMap<>();
 	private List playerInstancesToUpdate = new ArrayList();
 	private MinecraftServer mcServer;
 	private int field_28110_e;
@@ -39,11 +43,11 @@
 	}
 
 	private PlayerInstance getPlayerInstance(int var1, int var2, boolean var3) {
-		long var4 = (long)var1 + 2147483647L | (long)var2 + 2147483647L << 32;
-		PlayerInstance var6 = (PlayerInstance)this.playerInstances.getValueByKey(var4);
+		long var4 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		PlayerInstance var6 = this.playerInstances.get(var4);
 		if(var6 == null && var3) {
 			var6 = new PlayerInstance(this, var1, var2);
-			this.playerInstances.add(var4, var6);
+			this.playerInstances.put(var4, var6);
 		}
 
 		return var6;
@@ -153,7 +157,7 @@
 		return this.playerViewRadius * 16 - 16;
 	}
 
-	static PlayerHash getPlayerInstances(PlayerManager var0) {
+	static Long2ObjectMap<PlayerInstance> getPlayerInstances(PlayerManager var0) {
 		return var0.playerInstances;
 	}
 
--- net/minecraft/client/gui/MultiplayerScreen.java
+++ net/minecraft/client/gui/MultiplayerScreen.java
@@ -21,11 +21,11 @@
 		StringTranslate var1 = StringTranslate.getInstance();
 		Keyboard.enableRepeatEvents(true);
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 96 + 12, var1.translateKey("multiplayer.connect")));
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 120 + 12, var1.translateKey("gui.cancel")));
+		this.controlList.add(new GuiButton(0, -100, 108, var1.translateKey("multiplayer.connect")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(1, -100, 132, var1.translateKey("gui.cancel")).alignedAt(0.5F, 0.25F));
 		String var2 = this.mc.gameSettings.lastServer.replaceAll("_", ":");
 		((GuiButton)this.controlList.get(0)).enabled = var2.length() > 0;
-		this.field_22111_h = new GuiTextField(this, this.fontRenderer, this.width / 2 - 100, this.height / 4 - 10 + 50 + 18, 200, 20, var2);
+		this.controlList.add(this.field_22111_h = (GuiTextField) new GuiTextField(this, this.fontRenderer, -100, 58, 200, 20, var2).alignedAt(0.5F, 0.25F));
 		this.field_22111_h.isFocused = true;
 		this.field_22111_h.setMaxStringLength(128);
 	}
@@ -86,17 +86,15 @@
 
 	protected void mouseClicked(int var1, int var2, int var3) {
 		super.mouseClicked(var1, var2, var3);
-		this.field_22111_h.mouseClicked(var1, var2, var3);
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
 		StringTranslate var4 = StringTranslate.getInstance();
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, var4.translateKey("multiplayer.title"), this.width / 2, this.height / 4 - 60 + 20, 16777215);
 		this.drawString(this.fontRenderer, var4.translateKey("multiplayer.info1"), this.width / 2 - 140, this.height / 4 - 60 + 60 + 0, 10526880);
 		this.drawString(this.fontRenderer, var4.translateKey("multiplayer.info2"), this.width / 2 - 140, this.height / 4 - 60 + 60 + 9, 10526880);
 		this.drawString(this.fontRenderer, var4.translateKey("multiplayer.ipinfo"), this.width / 2 - 140, this.height / 4 - 60 + 60 + 36, 10526880);
-		this.field_22111_h.drawTextBox();
 		super.drawScreen(var1, var2, var3);
 	}
 }
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/RenderRegion.java
@@ -1,0 +1,44 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import net.mine_diver.smoothbeta.client.render.gl.GlUniform;
+import net.mine_diver.smoothbeta.client.render.gl.VertexBuffer;
+import net.minecraft.client.render.RenderList;
+import net.minecraft.client.render.WorldRenderer;
+
+import java.nio.IntBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+public class RenderRegion extends RenderList {
+    private final SmoothWorldRenderer stationWorldRenderer;
+    private final List<VertexBuffer> buffers = new ArrayList<>();
+
+    public RenderRegion(WorldRenderer worldRenderer) {
+        this.field_1236_g = IntBuffer.allocate(0);
+        stationWorldRenderer = ((SmoothWorldRenderer) worldRenderer);
+    }
+
+    public void func_861_a(int i, int j, int k, double d, double e, double f) {
+        super.func_861_a(i, j, k, d, e, f);
+        buffers.clear();
+    }
+
+    public void func_858_a(int i) {
+        throw new UnsupportedOperationException("Call lists can't be added to VBO regions!");
+    }
+
+    public void addBuffer(VertexBuffer buffer) {
+        buffers.add(buffer);
+    }
+
+    public void func_860_a() {
+        if (!this.field_1235_h || buffers.isEmpty()) return;
+        Shader shader = Shaders.getTerrainShader();
+        GlUniform chunkOffset = shader.chunkOffset;
+        chunkOffset.set((float) (this.field_1242_a - this.field_1239_d), (float) (this.field_1241_b - this.field_1238_e), (float) (this.field_1240_c - this.field_1237_f));
+        chunkOffset.upload();
+        for (VertexBuffer vertexBuffer : buffers) vertexBuffer.uploadToPool();
+        stationWorldRenderer.smoothbeta_getTerrainVboPool().drawAll();
+        chunkOffset.set(0.0F, 0.0F, 0.0F);
+    }
+}
--- /dev/null
+++ argo/jdom/JsonFieldBuilder.java
@@ -1,0 +1,28 @@
+package argo.jdom;
+
+final class JsonFieldBuilder {
+	private JsonNodeBuilder key;
+	private JsonNodeBuilder valueBuilder;
+
+	static JsonFieldBuilder aJsonFieldBuilder() {
+		return new JsonFieldBuilder();
+	}
+
+	JsonFieldBuilder withKey(JsonNodeBuilder var1) {
+		this.key = var1;
+		return this;
+	}
+
+	JsonFieldBuilder withValue(JsonNodeBuilder var1) {
+		this.valueBuilder = var1;
+		return this;
+	}
+
+	JsonStringNode func_27303_b() {
+		return (JsonStringNode)this.key.buildNode();
+	}
+
+	JsonNode buildValue() {
+		return this.valueBuilder.buildNode();
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerClimaticBiomes.java
@@ -1,0 +1,64 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.game.world.terrain.noise.SimplexNoiseOctaves;
+import net.minecraft.util.DoubleArray2D;
+import net.minecraft.util.IntArray2D;
+import net.minecraft.util.MathHelper;
+
+import java.util.Random;
+
+public class LayerClimaticBiomes extends Layer {
+	private SimplexNoiseOctaves temperatureNoise;
+	private SimplexNoiseOctaves humidityNoise;
+	private final double temperatureScale = 6.0D;
+	private final double humidityScale = 8.0D;
+
+	public LayerClimaticBiomes(long seed) {
+		super(seed);
+	}
+
+	public void setWorldSeed(long seed) {
+		super.setWorldSeed(seed);
+		Random random = new Random(this.getWorldSeed());
+		this.temperatureNoise = new SimplexNoiseOctaves(random, 6);
+		this.humidityNoise = new SimplexNoiseOctaves(random, 6);
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		DoubleArray2D temperature = new DoubleArray2D(width + 2, length + 2);
+		DoubleArray2D humidity = new DoubleArray2D(width + 2, length + 2);
+		this.temperatureNoise.generateNoiseArray2D(temperature.getArray(),
+				x - 1, z - 1, width + 2, length + 2, this.temperatureScale, this.temperatureScale, 0.5D, 0.75D);
+		this.humidityNoise.generateNoiseArray2D(humidity.getArray(),
+				x - 1, z - 1, width + 2, length + 2, this.humidityScale, this.humidityScale, 0.5D);
+
+		return this.forEach(x, z, width, length, (i, ox, oz) -> {
+			double t = 0.0D;
+			for (int ax = ox; ax <= ox + 2; ax++) {
+				for (int az = oz; az <= oz + 2; az++) {
+					t += this.remapTemperature(temperature.get(ax, az));
+				}
+			}
+			t /= 9.0D;
+
+			double h = this.remapHumidity(humidity.get(ox + 1, oz + 1));
+
+			int it = MathHelper.clamp((int)Math.round(t), 0, 4);
+			int ih = MathHelper.clamp((int)Math.round(h), 0, 4);
+
+			Biome[] biomes = Biome.climateZones[it * 5 + ih];
+			return biomes[this.nextInt(biomes.length)].id;
+		});
+	}
+
+	private double remapTemperature(double t) {
+		t = Math.pow(Math.abs(t), 1.5D) * Math.signum(t);
+		t += 2.0D;
+		return t;
+	}
+
+	private double remapHumidity(double h) {
+		return h / 6.0D + 2.0D;
+	}
+}
--- net/minecraft/game/entity/monster/GhastEntity.java
+++ net/minecraft/game/entity/monster/GhastEntity.java
@@ -3,7 +3,6 @@
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.FlyingEntity;
 import net.minecraft.game.entity.projectile.FireballEntity;
-import net.minecraft.game.item.Item;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.world.World;
@@ -28,7 +27,7 @@
 
 	protected void entityInit() {
 		super.entityInit();
-		this.properties.addProperty(16, Byte.valueOf((byte)0));
+		this.properties.addProperty(16, (byte) 0);
 	}
 
 	public void onUpdate() {
@@ -115,7 +114,7 @@
 			byte var21 = this.properties.getByte(16);
 			byte var12 = (byte)(this.attackCounter > 10 ? 1 : 0);
 			if(var21 != var12) {
-				this.properties.updateProperty(16, Byte.valueOf(var12));
+				this.properties.updateProperty(16, var12);
 			}
 		}
 
@@ -147,10 +146,6 @@
 
 	protected String getDeathSound() {
 		return "mob.ghast.death";
-	}
-
-	protected int getDropItemId() {
-		return Item.gunpowder.itemID;
 	}
 
 	protected float getSoundVolume() {
--- net/minecraft/client/gui/ControlsScreen.java
+++ net/minecraft/client/gui/ControlsScreen.java
@@ -22,13 +22,11 @@
 
 	public void initGui() {
 		StringTranslate var1 = StringTranslate.getInstance();
-		int var2 = this.func_20080_j();
-
 		for(int var3 = 0; var3 < this.options.keyBindings.length; ++var3) {
-			this.controlList.add(new GuiOptionsButton(var3, var2 + var3 % 2 * 160, this.height / 6 + 24 * (var3 >> 1), 70, 20, this.options.getOptionDisplayString(var3)));
+			this.controlList.add(new GuiOptionsButton(var3, -155 + var3 % 2 * 160, 24 * (var3 >> 1), 70, 20, this.options.getOptionDisplayString(var3)).alignedAt(0.5F, 1.0F / 6.0F));
 		}
 
-		this.controlList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 168, var1.translateKey("gui.done")));
+		this.controlList.add(new GuiButton(200, -100, 168, var1.translateKey("gui.done")).alignedAt(0.5F, 1.0F / 6.0F));
 		this.screenTitle = var1.translateKey("controls.title");
 	}
 
@@ -58,7 +56,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 20, 16777215);
 		int var4 = this.func_20080_j();
 
--- net/minecraft/client/ThreadDownloadResources.java
+++ net/minecraft/client/ThreadDownloadResources.java
@@ -14,6 +14,7 @@
 import org.w3c.dom.NodeList;
 
 public class ThreadDownloadResources extends Thread {
+	private static final String MODERN_RESOURCES_URL = "https://resources.download.minecraft.net/";
 	public File resourcesFolder;
 	private Minecraft mc;
 	private boolean closing = false;
@@ -30,28 +31,19 @@
 
 	public void run() {
 		try {
-			URL var1 = new URL("http://s3.amazonaws.com/MinecraftResources/");
-			DocumentBuilderFactory var2 = DocumentBuilderFactory.newInstance();
-			DocumentBuilder var3 = var2.newDocumentBuilder();
-			Document var4 = var3.parse(var1.openStream());
-			NodeList var5 = var4.getElementsByTagName("Contents");
-
-			for(int var6 = 0; var6 < 2; ++var6) {
-				for(int var7 = 0; var7 < var5.getLength(); ++var7) {
-					Node var8 = var5.item(var7);
-					if(var8.getNodeType() == 1) {
-						Element var9 = (Element)var8;
-						String var10 = ((Element)var9.getElementsByTagName("Key").item(0)).getChildNodes().item(0).getNodeValue();
-						long var11 = Long.parseLong(((Element)var9.getElementsByTagName("Size").item(0)).getChildNodes().item(0).getNodeValue());
-						if(var11 > 0L) {
-							this.downloadAndInstallResource(var1, var10, var11, var6);
-							if(this.closing) {
-								return;
-							}
-						}
-					}
-				}
-			}
+			this.downloadAllResources(new URL("http://betacraft.uk:11705/MinecraftResources/"));
+
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "c1/c157c56846f0e50620f808fecd9d069423dd6c41"), "dvmusic/menu/mutation.ogg", 1744657, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "78/783ddccf4681a0c50d3e651f4e6ac27a0f4ea76f"), "dvmusic/menu/moogcity2.ogg", 1809290, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "87/87722a59c8d488370f3d430cd4c97a3161081785"), "dvmusic/menu/beginning2.ogg", 1724614, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "15/15f38314274e759c44f50ac641d11bde12474a25"), "dvmusic/menu/floatingtrees.ogg", 2017245, 2);
+
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "3f/3fe4c878450d4dc2bf3ac304e547f20d4efabad8"), "dvmusic/creative/biomefest.ogg", 4271435, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "59/591f41a2c5f53bcc60d7ded982fe29e76223a8ca"), "dvmusic/creative/blindspots.ogg", 3704574, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "4f/4f8c3f9b4f290f63c78bf3bbaad16906a3ccff29"), "dvmusic/creative/hauntmuskie.ogg", 3834148, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "46/4664de25eb2bfc88ebbd638cfae6934dd968ceaa"), "dvmusic/creative/ariamath.ogg", 3668042, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "45/45cb6cbbff2d7fc1daefbd85b031fd9dcfc70e7b"), "dvmusic/creative/dreiton.ogg", 5532231, 2);
+			this.downloadAndInstallResource(new URL(MODERN_RESOURCES_URL + "62/6254527d626a2c7d80901cc2e62dce3ba4bd81f6"), "dvmusic/creative/taswell.ogg", 5468843, 2);
 		} catch (Exception var13) {
 			this.loadResource(this.resourcesFolder, "");
 			var13.printStackTrace();
@@ -59,6 +51,30 @@
 
 	}
 
+	private void downloadAllResources(URL var1) throws Exception {
+		DocumentBuilderFactory var2 = DocumentBuilderFactory.newInstance();
+		DocumentBuilder var3 = var2.newDocumentBuilder();
+		Document var4 = var3.parse(var1.openStream());
+		NodeList var5 = var4.getElementsByTagName("Contents");
+
+		for(int var6 = 0; var6 < 2; ++var6) {
+			for(int var7 = 0; var7 < var5.getLength(); ++var7) {
+				Node var8 = var5.item(var7);
+				if(var8.getNodeType() == 1) {
+					Element var9 = (Element)var8;
+					String var10 = ((Element)var9.getElementsByTagName("Key").item(0)).getChildNodes().item(0).getNodeValue();
+					long var11 = Long.parseLong(((Element)var9.getElementsByTagName("Size").item(0)).getChildNodes().item(0).getNodeValue());
+					if(var11 > 0L) {
+						this.downloadAndInstallResource(var1, var10, var11, var6);
+						if(this.closing) {
+							return;
+						}
+					}
+				}
+			}
+		}
+	}
+
 	public void reloadResources() {
 		this.loadResource(this.resourcesFolder, "");
 	}
@@ -85,7 +101,7 @@
 			int var6 = var2.indexOf("/");
 			String var7 = var2.substring(0, var6);
 			if(!var7.equals("sound") && !var7.equals("newsound")) {
-				if(var5 != 1) {
+				if(var5 != 1 && var5 != 2) {
 					return;
 				}
 			} else if(var5 != 0) {
@@ -96,7 +112,7 @@
 			if(!var8.exists() || var8.length() != var3) {
 				var8.getParentFile().mkdirs();
 				String var9 = var2.replaceAll(" ", "%20");
-				this.downloadResource(new URL(var1, var9), var8, var3);
+				this.downloadResource(var5 == 2 ? var1 : new URL(var1, var9), var8, var3);
 				if(this.closing) {
 					return;
 				}
--- com/mojang/nbt/CompoundTag.java
+++ com/mojang/nbt/CompoundTag.java
@@ -3,10 +3,9 @@
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 public class CompoundTag extends NBTBaseTag {
 	private Map tagMap = new HashMap();
@@ -79,6 +78,18 @@
 		this.tagMap.put(var1, (new ByteArrayTag(var2)).setKey(var1));
 	}
 
+	public void setShortArray(String var1, short[] var2) {
+		this.tagMap.put(var1, (new ShortArrayTag(var2)).setKey(var1));
+	}
+
+	public void setIntArray(String var1, int[] var2) {
+		this.tagMap.put(var1, (new IntArrayTag(var2)).setKey(var1));
+	}
+
+	public void setLongArray(String var1, long[] var2) {
+		this.tagMap.put(var1, (new LongArrayTag(var2)).setKey(var1));
+	}
+
 	public void setCompoundTag(String var1, CompoundTag var2) {
 		this.tagMap.put(var1, var2.setKey(var1));
 	}
@@ -91,6 +102,10 @@
 		return this.tagMap.containsKey(var1);
 	}
 
+	public NBTBaseTag getTag(String var1) {
+		return (NBTBaseTag)this.tagMap.get(var1);
+	}
+
 	public byte getByte(String var1) {
 		return !this.tagMap.containsKey(var1) ? 0 : ((ByteTag)this.tagMap.get(var1)).byteValue;
 	}
@@ -123,6 +138,18 @@
 		return !this.tagMap.containsKey(var1) ? new byte[0] : ((ByteArrayTag)this.tagMap.get(var1)).byteArray;
 	}
 
+	public short[] getShortArray(String var1) {
+		return !this.tagMap.containsKey(var1) ? new short[0] : ((ShortArrayTag)this.tagMap.get(var1)).shortArray;
+	}
+
+	public int[] getIntArray(String var1) {
+		return !this.tagMap.containsKey(var1) ? new int[0] : ((IntArrayTag)this.tagMap.get(var1)).intArray;
+	}
+
+	public long[] getLongArray(String var1) {
+		return !this.tagMap.containsKey(var1) ? new long[0] : ((LongArrayTag)this.tagMap.get(var1)).longArray;
+	}
+
 	public CompoundTag getCompoundTag(String var1) {
 		return !this.tagMap.containsKey(var1) ? new CompoundTag() : (CompoundTag)this.tagMap.get(var1);
 	}
@@ -136,6 +163,15 @@
 	}
 
 	public String toString() {
-		return "" + this.tagMap.size() + " entries";
+		return this.tagMap.size() + " entries";
+	}
+
+	@SuppressWarnings("unchecked")
+	public CompoundTag copy() {
+		CompoundTag compound = new CompoundTag();
+		compound.tagMap = ((Stream<Map.Entry<String, NBTBaseTag>>)this.tagMap.entrySet().stream())
+				.map(x -> new AbstractMap.SimpleImmutableEntry<>(x.getKey(), x.getValue().copy()))
+				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+		return (CompoundTag)compound.setKey(this.getKey());
 	}
 }
--- net/minecraft/game/world/terrain/noise/PerlinNoise.java
+++ net/minecraft/game/world/terrain/noise/PerlinNoise.java
@@ -1,5 +1,7 @@
 package net.minecraft.game.world.terrain.noise;
 
+import net.minecraft.util.MathHelper;
+
 import java.util.Random;
 
 public class PerlinNoise extends NoiseGenerator {
@@ -67,6 +69,24 @@
 		int var29 = this.permutations[var28] + var18;
 		int var30 = this.permutations[var28 + 1] + var18;
 		return this.lerp(var23, this.lerp(var21, this.lerp(var19, this.grad(this.permutations[var26], var7, var9, var11), this.grad(this.permutations[var29], var7 - 1.0D, var9, var11)), this.lerp(var19, this.grad(this.permutations[var27], var7, var9 - 1.0D, var11), this.grad(this.permutations[var30], var7 - 1.0D, var9 - 1.0D, var11))), this.lerp(var21, this.lerp(var19, this.grad(this.permutations[var26 + 1], var7, var9, var11 - 1.0D), this.grad(this.permutations[var29 + 1], var7 - 1.0D, var9, var11 - 1.0D)), this.lerp(var19, this.grad(this.permutations[var27 + 1], var7, var9 - 1.0D, var11 - 1.0D), this.grad(this.permutations[var30 + 1], var7 - 1.0D, var9 - 1.0D, var11 - 1.0D))));
+	}
+	public double generateNoise3DAlt(double var1, double var3, double var5) {
+		int var2 = MathHelper.floor(var1) & 255;
+		int var21 = MathHelper.floor(var3) & 255;
+		int var4 = MathHelper.floor(var5) & 255;
+		double var6 = var1 - MathHelper.floor(var1);
+		double var8 = var3 - MathHelper.floor(var3);
+		double var10 = var5 - MathHelper.floor(var5);
+		double var15 = var6 * var6 * var6 * (var6 * (var6 * 6.0D - 15.0D) + 10.0D);
+		double var17 = var8 * var8 * var8 * (var8 * (var8 * 6.0D - 15.0D) + 10.0D);
+		double var19 = var10 * var10 * var10 * (var10 * (var10 * 6.0D - 15.0D) + 10.0D);
+		int var0 = this.permutations[var2] + var21;
+		int var12 = this.permutations[var0] + var4;
+		var0 = this.permutations[var0 + 1] + var4;
+		var2 = this.permutations[var2 + 1] + var21;
+		var21 = this.permutations[var2] + var4;
+		var2 = this.permutations[var2 + 1] + var4;
+		return lerp(var19, lerp(var17, lerp(var15, grad(this.permutations[var12], var6, var8, var10), grad(this.permutations[var21], var6 - 1.0D, var8, var10)), lerp(var15, grad(this.permutations[var0], var6, var8 - 1.0D, var10), grad(this.permutations[var2], var6 - 1.0D, var8 - 1.0D, var10))), lerp(var17, lerp(var15, grad(this.permutations[var12 + 1], var6, var8, var10 - 1.0D), grad(this.permutations[var21 + 1], var6 - 1.0D, var8, var10 - 1.0D)), lerp(var15, grad(this.permutations[var0 + 1], var6, var8 - 1.0D, var10 - 1.0D), grad(this.permutations[var2 + 1], var6 - 1.0D, var8 - 1.0D, var10 - 1.0D))));
 	}
 
 	public final double lerp(double var1, double var3, double var5) {
--- /dev/null
+++ net/minecraft/game/item/EmptyMapItem.java
@@ -1,0 +1,35 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.map.MapData;
+
+public class EmptyMapItem extends BaseMapItem {
+    protected EmptyMapItem(int par1) {
+        super(par1);
+    }
+
+    public ItemStack onItemRightClick(ItemStack var1, World var2, PlayerEntity var3) {
+        ItemStack var4 = new ItemStack(Item.map, 1, var2.getUniqueDataId("map"));
+        String var5 = "map_" + var4.getItemDamage();
+        MapData var6 = new MapData(var5);
+        var2.setItemData(var5, var6);
+        var6.scale = 3;
+        int var7 = 128 * (1 << var6.scale);
+        var6.xCenter = (int) (Math.round(var3.posX / (double) var7) * (long) var7);
+        var6.zCenter = (int) (Math.round(var3.posZ / (double) var7) * (long) var7);
+        var6.dimension = (byte) var2.dimension.worldType;
+        var6.markDirty();
+        --var1.count;
+
+        if (var1.count <= 0) {
+            return var4;
+        } else {
+            if (!var3.inventory.addItemStackToInventory(var4.copy())) {
+                var3.dropPlayerItem(var4);
+            }
+
+            return var1;
+        }
+    }
+}
--- net/minecraft/game/world/chunk/ChunkProviderClient.java
+++ net/minecraft/game/world/chunk/ChunkProviderClient.java
@@ -1,16 +1,16 @@
 package net.minecraft.game.world.chunk;
 
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import net.minecraft.game.world.World;
 import net.minecraft.util.ProgressUpdate;
 
 public class ChunkProviderClient implements ChunkProvider {
 	private Chunk blankChunk;
-	private Map chunkMapping = new HashMap();
+	private Long2ObjectMap<Chunk> chunkMapping = new Long2ObjectOpenHashMap();
 	private List field_889_c = new ArrayList();
 	private World worldObj;
 
@@ -20,13 +20,8 @@
 	}
 
 	public boolean chunkExists(int var1, int var2) {
-		if(this != null) {
-			return true;
-		} else {
-			ChunkCoordIntPair var3 = new ChunkCoordIntPair(var1, var2);
-			return this.chunkMapping.containsKey(var3);
-		}
-	}
+        return true;
+    }
 
 	public void func_539_c(int var1, int var2) {
 		Chunk var3 = this.provideChunk(var1, var2);
@@ -34,23 +29,20 @@
 			var3.onChunkUnload();
 		}
 
-		this.chunkMapping.remove(new ChunkCoordIntPair(var1, var2));
+		this.chunkMapping.remove(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
 		this.field_889_c.remove(var3);
 	}
 
 	public Chunk prepareChunk(int var1, int var2) {
-		ChunkCoordIntPair var3 = new ChunkCoordIntPair(var1, var2);
-		byte[] var4 = new byte[-Short.MIN_VALUE];
-		Chunk var5 = new Chunk(this.worldObj, var4, var1, var2);
-		Arrays.fill(var5.skylightMap.data, (byte)-1);
-		this.chunkMapping.put(var3, var5);
+		Chunk var5 = new Chunk(this.worldObj, null, var1, var2);
+		this.chunkMapping.put(ChunkCoordIntPair.chunkXZ2Int(var1, var2), var5);
 		var5.isChunkLoaded = true;
 		return var5;
 	}
 
 	public Chunk provideChunk(int var1, int var2) {
-		ChunkCoordIntPair var3 = new ChunkCoordIntPair(var1, var2);
-		Chunk var4 = (Chunk)this.chunkMapping.get(var3);
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		Chunk var4 = this.chunkMapping.get(var3);
 		return var4 == null ? this.blankChunk : var4;
 	}
 
--- net/minecraft/game/world/block/tileentity/SignTileEntity.java
+++ net/minecraft/game/world/block/tileentity/SignTileEntity.java
@@ -33,9 +33,7 @@
 	public Packet getDescriptionPacket() {
 		String[] var1 = new String[4];
 
-		for(int var2 = 0; var2 < 4; ++var2) {
-			var1[var2] = this.signText[var2];
-		}
+		System.arraycopy(this.signText, 0, var1, 0, 4);
 
 		return new Packet130UpdateSign(this.xCoord, this.yCoord, this.zCoord, var1);
 	}
--- net/minecraft/client/gui/component/GuiButton.java
+++ net/minecraft/client/gui/component/GuiButton.java
@@ -5,33 +5,117 @@
 import net.minecraft.client.gui.Gui;
 import org.lwjgl.opengl.GL11;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class GuiButton extends Gui {
-	protected int width;
-	protected int height;
+	protected final List<GuiButton> controls = new ArrayList<>();
+	protected GuiButton container;
+	public int id = -1;
 	public int xPosition;
 	public int yPosition;
+	public int buttonWidth;
+	public int buttonHeight;
+	public float alignX;
+	public float alignY;
+	public float alignWidth;
+	public float alignHeight;
 	public String displayString;
-	public int id;
-	public boolean enabled;
-	public boolean visible;
+	public boolean enabled = true;
+	public boolean visible = true;
+
+	public GuiButton() {
+	}
+
+	public GuiButton(int var1, String var2) {
+		this.id = var1;
+		this.displayString = var2;
+	}
 
 	public GuiButton(int var1, int var2, int var3, String var4) {
 		this(var1, var2, var3, 200, 20, var4);
 	}
 
 	public GuiButton(int var1, int var2, int var3, int var4, int var5, String var6) {
-		this.width = 200;
-		this.height = 20;
-		this.enabled = true;
-		this.visible = true;
 		this.id = var1;
 		this.xPosition = var2;
 		this.yPosition = var3;
-		this.width = var4;
-		this.height = var5;
+		this.buttonWidth = var4;
+		this.buttonHeight = var5;
 		this.displayString = var6;
 	}
 
+	public GuiButton at(int x, int y) {
+		this.xPosition = x;
+		this.yPosition = y;
+		return this;
+	}
+
+	public GuiButton size(int width, int height) {
+		this.buttonWidth = width;
+		this.buttonHeight = height;
+		return this;
+	}
+
+	public GuiButton alignedAt(float alignX, float alignY) {
+		this.alignX = alignX;
+		this.alignY = alignY;
+		return this;
+	}
+
+	public GuiButton alignedSize(float alignWidth, float alignHeight) {
+		this.alignWidth = alignWidth;
+		this.alignHeight = alignHeight;
+		return this;
+	}
+
+	public GuiButton text(String displayString) {
+		this.displayString = displayString;
+		return this;
+	}
+
+	public int getScaledX() {
+		float offsetX = container != null ? container.getScaledX() : 0.0f;
+		float parentWidth = container != null ? container.getScaledWidth() : Minecraft.getScaledResolution().getScaledWidth();
+		return (int)(xPosition + offsetX + parentWidth * alignX);
+	}
+
+	public int getScaledY() {
+		float offsetY = container != null ? container.getScaledY() : 0.0f;
+		float parentHeight = container != null ? container.getScaledHeight() : Minecraft.getScaledResolution().getScaledHeight();
+		return (int)(yPosition + offsetY + parentHeight * alignY);
+	}
+
+	public int getScaledWidth() {
+		float parentWidth = container != null ? container.getScaledWidth() : Minecraft.getScaledResolution().getScaledWidth();
+		return (int)(buttonWidth + parentWidth * alignWidth);
+	}
+
+	public int getScaledHeight() {
+		float parentHeight = container != null ? container.getScaledHeight() : Minecraft.getScaledResolution().getScaledHeight();
+		return (int)(buttonHeight + parentHeight * alignHeight);
+	}
+
+	public boolean intersects(int x, int y) {
+		int sx = this.getScaledX();
+		int sy = this.getScaledY();
+		int sw = this.getScaledWidth();
+		int sh = this.getScaledHeight();
+
+		return x >= sx && x < sx + sw
+				&& y >= sy && y < sy + sh;
+	}
+
+	public GuiButton addControl(GuiButton control) {
+		controls.add(control);
+		control.container = this;
+		return control;
+	}
+
+	public void clearControls() {
+		controls.clear();
+	}
+
 	protected int getHoverState(boolean var1) {
 		byte var2 = 1;
 		if(!this.enabled) {
@@ -43,22 +127,34 @@
 		return var2;
 	}
 
+	public final void drawRecursive(Minecraft var1, int var2, int var3) {
+		this.drawButton(var1, var2, var3);
+		for (GuiButton control : this.controls) {
+			control.drawRecursive(var1, var2, var3);
+		}
+	}
+
 	public void drawButton(Minecraft var1, int var2, int var3) {
 		if(this.visible) {
+			int sx = this.getScaledX();
+			int sy = this.getScaledY();
+			int sw = this.getScaledWidth();
+			int sh = this.getScaledHeight();
+
 			FontRenderer var4 = var1.fontRenderer;
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.textureRegistry.getTexture("/gui/gui.png"));
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-			boolean var5 = var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
+			boolean var5 = this.intersects(var2, var3);
 			int var6 = this.getHoverState(var5);
-			this.drawTexturedRect(this.xPosition, this.yPosition, 0, 46 + var6 * 20, this.width / 2, this.height);
-			this.drawTexturedRect(this.xPosition + this.width / 2, this.yPosition, 200 - this.width / 2, 46 + var6 * 20, this.width / 2, this.height);
+			this.drawTexturedRect(sx, sy, 0, 46 + var6 * 20, sw / 2, sh);
+			this.drawTexturedRect(sx + sw / 2, sy, 200 - sw / 2, 46 + var6 * 20, sw / 2, sh);
 			this.mouseDragged(var1, var2, var3);
 			if(!this.enabled) {
-				this.drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, -6250336);
+				this.drawCenteredString(var4, this.displayString, sx + sw / 2, sy + (sh - 8) / 2, -6250336);
 			} else if(var5) {
-				this.drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, 16777120);
+				this.drawCenteredString(var4, this.displayString, sx + sw / 2, sy + (sh - 8) / 2, 16777120);
 			} else {
-				this.drawCenteredString(var4, this.displayString, this.xPosition + this.width / 2, this.yPosition + (this.height - 8) / 2, 14737632);
+				this.drawCenteredString(var4, this.displayString, sx + sw / 2, sy + (sh - 8) / 2, 14737632);
 			}
 
 		}
@@ -70,7 +166,18 @@
 	public void mouseReleased(int var1, int var2) {
 	}
 
+	public final GuiButton mousePressedRecursive(Minecraft var1, int var2, int var3) {
+		for (GuiButton control : this.controls) {
+			GuiButton result = control.mousePressedRecursive(var1, var2, var3);
+			if (result != null) {
+				return result;
+			}
+		}
+
+		return this.mousePressed(var1, var2, var3) ? this : null;
+	}
+
 	public boolean mousePressed(Minecraft var1, int var2, int var3) {
-		return this.enabled && var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
+		return this.enabled && this.controls.isEmpty() && this.intersects(var2, var3);
 	}
 }
--- /dev/null
+++ com/mojang/nbt/IntArrayTag.java
@@ -1,0 +1,50 @@
+package com.mojang.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+public class IntArrayTag extends NBTBaseTag {
+	public int[] intArray;
+
+	public IntArrayTag() {
+	}
+
+	public IntArrayTag(int[] var1) {
+		this.intArray = var1;
+	}
+
+	protected void writeTagContents(DataOutput var1) throws IOException {
+		var1.writeInt(this.intArray.length);
+		ByteBuffer buffer = ByteBuffer.allocate(this.intArray.length * 4);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().put(this.intArray);
+		byte[] bytes = buffer.array();
+		var1.write(bytes);
+	}
+
+	protected void readTagContents(DataInput var1) throws IOException {
+		int var2 = var1.readInt();
+		this.intArray = new int[var2];
+		byte[] byteArray = new byte[var2 * 4];
+		var1.readFully(byteArray);
+		ByteBuffer buffer = ByteBuffer.wrap(byteArray);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().get(this.intArray);
+	}
+
+	public byte getType() {
+		return (byte)11;
+	}
+
+	public String toString() {
+		return "[" + this.intArray.length + " ints]";
+	}
+
+	public NBTBaseTag copy() {
+		return new IntArrayTag(Arrays.copyOf(this.intArray, this.intArray.length)).setKey(this.getKey());
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/block/StairDirection.java
@@ -1,0 +1,112 @@
+package net.minecraft.game.world.block;
+
+public enum StairDirection {
+	EAST(1, 0, 0.5F, 0.0F),
+	WEST(-1, 0, 0.0F, 0.5F),
+	SOUTH(0, 1, 0.5F, 0.5F),
+	NORTH(0, -1, 0.0F, 0.0F);
+
+	private final int frontX, frontZ;
+	private final float stairMinX, stairMinZ;
+	private final boolean zDir;
+	private StairDirection perpLeft, perpRight;
+
+	StairDirection(int backX, int backZ, float stairMinX, float stairMinZ) {
+		this.frontX = -backX;
+		this.frontZ = -backZ;
+		this.stairMinX = stairMinX;
+		this.stairMinZ = stairMinZ;
+		this.zDir = backZ != 0;
+	}
+
+	public int getFrontX() {
+		return this.frontX;
+	}
+
+	public int getFrontZ() {
+		return this.frontZ;
+	}
+
+	public int getBackX() {
+		return -this.frontX;
+	}
+
+	public int getBackZ() {
+		return -this.frontZ;
+	}
+
+	public int getLeftX() {
+		return this.frontZ;
+	}
+
+	public int getLeftZ() {
+		return this.frontX;
+	}
+
+	public int getRightX() {
+		return -this.frontZ;
+	}
+
+	public int getRightZ() {
+		return -this.frontX;
+	}
+
+	public float getStairMinX() {
+		return !isZ() ? stairMinX : 0.0F;
+	}
+
+	public float getStairMinZ() {
+		return isZ() ? stairMinZ : 0.0F;
+	}
+
+	public float getStairMaxX() {
+		return getStairMinX() + (isZ() ? 1.0F : 0.5F);
+	}
+
+	public float getStairMaxZ() {
+		return getStairMinZ() + (isZ() ? 0.5F : 1.0F);
+	}
+
+	public float getInnerStairMinX() {
+		return stairMinX;
+	}
+
+	public float getInnerStairMinZ() {
+		return stairMinZ;
+	}
+
+	public float getInnerStairMaxX() {
+		return stairMinX + 0.5F;
+	}
+
+	public float getInnerStairMaxZ() {
+		return stairMinZ + 0.5F;
+	}
+
+	public boolean isZ() {
+		return zDir;
+	}
+
+	public StairDirection getPerpLeft() {
+		return perpLeft;
+	}
+
+	public StairDirection getPerpRight() {
+		return perpRight;
+	}
+
+	public StairDirection getBehind() {
+		return perpRight.perpRight;
+	}
+
+	public String toString() {
+		return super.toString().toLowerCase();
+	}
+
+	static {
+		EAST.perpLeft = WEST.perpRight = NORTH;
+		EAST.perpRight = WEST.perpLeft = SOUTH;
+		NORTH.perpLeft = SOUTH.perpRight = WEST;
+		NORTH.perpRight = SOUTH.perpLeft = EAST;
+	}
+}
--- net/minecraft/game/world/block/DispenserBlock.java
+++ net/minecraft/game/world/block/DispenserBlock.java
@@ -11,17 +11,30 @@
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
 import net.minecraft.game.world.block.tileentity.DispenserTileEntity;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
 import net.minecraft.util.MathHelper;
 
 public class DispenserBlock extends ContainerBlock {
+	private static final int TEX_SIDE = TerrainLayout.texCoord("stone_util_side");
+	private static final int TEX_TOP = TerrainLayout.texCoord("stone_util_top");
+	private static final int TEX_FRONT = TerrainLayout.texCoord("dispenser");
+
+	public static final EnumProperty<Direction> DIRECTION = SharedProperties.DIRECTION;
+
 	private Random random = new Random();
 
 	protected DispenserBlock(int var1) {
 		super(var1, Material.stone);
-		this.textureIndex = 45;
+		this.textureIndex = TEX_SIDE;
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION);
 	}
 
 	public int tickRate() {
@@ -65,18 +78,16 @@
 	}
 
 	public int getBlockTexture(BlockAccess var1, int var2, int var3, int var4, int var5) {
-		if(var5 == 1) {
-			return this.textureIndex + 17;
-		} else if(var5 == 0) {
-			return this.textureIndex + 17;
+		if(var5 < 2) {
+			return TEX_TOP;
 		} else {
 			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			return var5 != var6 ? this.textureIndex : this.textureIndex + 1;
+			return var5 != var6 ? TEX_SIDE : TEX_FRONT;
 		}
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex + 17 : (var1 == 0 ? this.textureIndex + 17 : (var1 == 3 ? this.textureIndex + 1 : this.textureIndex));
+		return var1 < 2 ? TEX_TOP : var1 == 3 ? TEX_FRONT : TEX_SIDE;
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, PlayerEntity var5) {
--- net/minecraft/client/gui/MainMenuScreen.java
+++ net/minecraft/client/gui/MainMenuScreen.java
@@ -7,8 +7,13 @@
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Random;
+
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.component.GuiButton;
+import net.minecraft.client.gui.component.GuiTransparentButton;
 import net.minecraft.client.render.Tessellator;
+import net.minecraft.client.sound.SoundManager;
+import net.minecraft.game.world.chunk.loader.region.RegionFileCache;
 import net.minecraft.util.MathHelper;
 import net.minecraft.util.StringTranslate;
 import org.lwjgl.opengl.GL11;
@@ -44,35 +49,34 @@
 
 	public void updateScreen() {
 		++this.updateCounter;
+		this.mc.sndManager.playRandomMusicIfReady(SoundManager.MusicType.MENU);
 	}
 
 	protected void keyTyped(char var1, int var2) {
 	}
 
 	public void initGui() {
+		RegionFileCache.flushCache();
 		Calendar var1 = Calendar.getInstance();
 		var1.setTime(new Date());
-		if(var1.get(2) + 1 == 11 && var1.get(5) == 9) {
+		if(var1.get(Calendar.MONTH) + 1 == 11 && var1.get(Calendar.DATE) == 9) {
 			this.splashText = "Happy birthday, ez!";
-		} else if(var1.get(2) + 1 == 6 && var1.get(5) == 1) {
+		} else if(var1.get(Calendar.MONTH) + 1 == 6 && var1.get(Calendar.DATE) == 1) {
 			this.splashText = "Happy birthday, Notch!";
-		} else if(var1.get(2) + 1 == 12 && var1.get(5) == 24) {
+		} else if(var1.get(Calendar.MONTH) + 1 == 12 && var1.get(Calendar.DATE) == 24) {
 			this.splashText = "Merry X-mas!";
-		} else if(var1.get(2) + 1 == 1 && var1.get(5) == 1) {
+		} else if(var1.get(Calendar.MONTH) + 1 == 1 && var1.get(Calendar.DATE) == 1) {
 			this.splashText = "Happy new year!";
 		}
 
 		StringTranslate var2 = StringTranslate.getInstance();
-		int var4 = this.height / 4 + 48;
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, var4, var2.translateKey("menu.singleplayer")));
-		this.controlList.add(this.multiplayerButton = new GuiButton(2, this.width / 2 - 100, var4 + 24, var2.translateKey("menu.multiplayer")));
-		this.controlList.add(new GuiButton(3, this.width / 2 - 100, var4 + 48, var2.translateKey("menu.mods")));
-		if(this.mc.hideQuitButton) {
-			this.controlList.add(new GuiButton(0, this.width / 2 - 100, var4 + 72, var2.translateKey("menu.options")));
-		} else {
-			this.controlList.add(new GuiButton(0, this.width / 2 - 100, var4 + 72 + 12, 98, 20, var2.translateKey("menu.options")));
-			this.controlList.add(new GuiButton(4, this.width / 2 + 2, var4 + 72 + 12, 98, 20, var2.translateKey("menu.quit")));
-		}
+		int var4 = 48;
+		this.controlList.add(new GuiButton(1, -100, 48, var2.translateKey("menu.singleplayer")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(this.multiplayerButton = new GuiButton(2, -100, 48 + 24, var2.translateKey("menu.multiplayer")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(3, -100, 96, var2.translateKey("menu.mods")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(0, -100, 132, 98, 20, var2.translateKey("menu.options")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(4, 2, 132, 98, 20, var2.translateKey("menu.quit")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiTransparentButton(5, 2, -12, 100, 12, var2.translateKey("menu.credits")).alignedAt(0.0F, 1.0F));
 
 		if(this.mc.session == null) {
 			this.multiplayerButton.enabled = false;
@@ -101,18 +105,21 @@
 			this.mc.shutdown();
 		}
 
+		if(var1.id == 5) {
+			this.mc.displayGuiScreen(new CreditsScreen());
+		}
+
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		Tessellator var4 = Tessellator.instance;
 		short var5 = 274;
 		int var6 = this.width / 2 - var5 / 2;
 		byte var7 = 30;
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/title/mclogo.png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-		this.drawTexturedRect(var6 + 0, var7 + 0, 0, 0, 155, 44);
-		this.drawTexturedRect(var6 + 155, var7 + 0, 0, 45, 155, 44);
+		this.drawTexturedRect(var6, var7, 0, 0, 274, 44, 512, 64);
 		var4.setColorOpaque_I(16777215);
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)(this.width / 2 + 90), 70.0F, 0.0F);
@@ -122,7 +129,7 @@
 		GL11.glScalef(var8, var8, var8);
 		this.drawCenteredString(this.fontRenderer, this.splashText, 0, -8, 16776960);
 		GL11.glPopMatrix();
-		this.drawString(this.fontRenderer, "Minecraft Beta 1.7.3", 2, 2, 5263440);
+		this.drawString(this.fontRenderer, Minecraft.VERSION, 2, 2, 0xFFFFFF);
 		String var9 = "Copyright Mojang AB. Do not distribute.";
 		this.drawString(this.fontRenderer, var9, this.width - this.fontRenderer.getStringWidth(var9) - 2, this.height - 10, 16777215);
 		super.drawScreen(var1, var2, var3);
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerZoomBase.java
@@ -1,0 +1,51 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.IntArray2D;
+
+public abstract class LayerZoomBase extends Layer {
+	public LayerZoomBase(long seed, Layer parent) {
+		super(seed);
+		super.parent = parent;
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		int zoomedX = x >> 1;
+		int zoomedZ = z >> 1;
+		int zoomedWidth = (width >> 1) + 3;
+		int zoomedLength = (length >> 1) + 3;
+		int[] input = this.parent.getCachedData(zoomedX, zoomedZ, zoomedWidth, zoomedLength).toXFirst().getArray();
+		int[] zoom = new int[zoomedWidth * 2 * zoomedLength * 2];
+		int doubleWidth = zoomedWidth << 1;
+
+		for(int zz = 0; zz < zoomedLength - 1; ++zz) {
+			int doubleZ = zz << 1;
+			int i = doubleZ * doubleWidth;
+			int pointA = input[zz * zoomedWidth];
+			int pointB = input[(zz + 1) * zoomedWidth];
+
+			for(int xx = 0; xx < zoomedWidth - 1; ++xx) {
+				this.setChunkSeed((long) xx + zoomedX << 1, (long) zz + zoomedZ << 1);
+				int pointC = input[xx + 1 + zz * zoomedWidth];
+				int pointD = input[xx + 1 + (zz + 1) * zoomedWidth];
+				zoom[i] = pointA;
+				zoom[i++ + doubleWidth] = this.interpolate(pointA, pointB);
+				zoom[i] = this.interpolate(pointA, pointC);
+				zoom[i++ + doubleWidth] = this.interpolate(pointA, pointC, pointB, pointD);
+				pointA = pointC;
+				pointB = pointD;
+			}
+		}
+
+		int[] output = new int[width * length];
+
+		for(int zz = 0; zz < length; ++zz) {
+			System.arraycopy(zoom, (zz + (z & 1)) * (zoomedWidth << 1) + (x & 1), output, zz * width, width);
+		}
+
+		return IntArray2D.xFirst(output, width, length);
+	}
+
+	protected abstract int interpolate(int a, int b);
+
+	protected abstract int interpolate(int a, int b, int c, int d);
+}
--- net/minecraft/game/world/chunk/ChunkCache.java
+++ net/minecraft/game/world/chunk/ChunkCache.java
@@ -2,8 +2,10 @@
 
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.BiomeSource;
 import net.minecraft.game.world.biome.ClimaticBiomeSource;
 import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.block.properties.Property;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
 
@@ -30,19 +32,13 @@
 	}
 
 	public int getBlockId(int var1, int var2, int var3) {
-		if(var2 < 0) {
-			return 0;
-		} else if(var2 >= 128) {
-			return 0;
+		int var4 = (var1 >> 4) - this.chunkX;
+		int var5 = (var3 >> 4) - this.chunkZ;
+		if(var4 >= 0 && var4 < this.chunkArray.length && var5 >= 0 && var5 < this.chunkArray[var4].length) {
+			Chunk var6 = this.chunkArray[var4][var5];
+			return var6 == null ? 0 : var6.getBlockID(var1 & 15, var2, var3 & 15);
 		} else {
-			int var4 = (var1 >> 4) - this.chunkX;
-			int var5 = (var3 >> 4) - this.chunkZ;
-			if(var4 >= 0 && var4 < this.chunkArray.length && var5 >= 0 && var5 < this.chunkArray[var4].length) {
-				Chunk var6 = this.chunkArray[var4][var5];
-				return var6 == null ? 0 : var6.getBlockID(var1 & 15, var2, var3 & 15);
-			} else {
-				return 0;
-			}
+			return 0;
 		}
 	}
 
@@ -70,12 +66,12 @@
 	}
 
 	public int getLightValueExt(int var1, int var2, int var3, boolean var4) {
-		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
+		if(var1 >= -32000000 && var2 >= -32000000 && var3 >= -32000000 && var1 <= 32000000 && var2 <= 32000000 && var3 <= 32000000) {
 			int var5;
 			int var6;
 			if(var4) {
 				var5 = this.getBlockId(var1, var2, var3);
-				if(var5 == Block.stoneSlab.blockID || var5 == Block.farmland.blockID || var5 == Block.woodenStairs.blockID || var5 == Block.cobblestoneStairs.blockID) {
+				if(Block.specialLighting[var5]) {
 					var6 = this.getLightValueExt(var1, var2 + 1, var3, false);
 					int var7 = this.getLightValueExt(var1 + 1, var2, var3, false);
 					int var8 = this.getLightValueExt(var1 - 1, var2, var3, false);
@@ -101,53 +97,83 @@
 				}
 			}
 
-			if(var2 < 0) {
-				return 0;
-			} else if(var2 >= 128) {
-				var5 = 15 - this.worldObj.skylightSubtracted;
-				if(var5 < 0) {
-					var5 = 0;
-				}
-
-				return var5;
-			} else {
-				var5 = (var1 >> 4) - this.chunkX;
-				var6 = (var3 >> 4) - this.chunkZ;
-				return this.chunkArray[var5][var6].getBlockLightValue(var1 & 15, var2, var3 & 15, this.worldObj.skylightSubtracted);
-			}
+			var5 = (var1 >> 4) - this.chunkX;
+			var6 = (var3 >> 4) - this.chunkZ;
+			return this.chunkArray[var5][var6].getBlockLightValue(var1 & 15, var2, var3 & 15, this.worldObj.skylightSubtracted);
 		} else {
 			return 15;
 		}
 	}
 
 	public int getBlockMetadata(int var1, int var2, int var3) {
-		if(var2 < 0) {
-			return 0;
-		} else if(var2 >= 128) {
-			return 0;
-		} else {
-			int var4 = (var1 >> 4) - this.chunkX;
-			int var5 = (var3 >> 4) - this.chunkZ;
-			return this.chunkArray[var4][var5].getBlockMetadata(var1 & 15, var2, var3 & 15);
-		}
-	}
-
-	public Material getBlockMaterial(int var1, int var2, int var3) {
-		int var4 = this.getBlockId(var1, var2, var3);
-		return var4 == 0 ? Material.air : Block.blocksList[var4].material;
-	}
-
-	public ClimaticBiomeSource getBiomeSource() {
+		int var4 = (var1 >> 4) - this.chunkX;
+		int var5 = (var3 >> 4) - this.chunkZ;
+		return this.chunkArray[var4][var5].getBlockMetadata(var1 & 15, var2, var3 & 15);
+	}
+
+	public BiomeSource getBiomeSource() {
 		return this.worldObj.getBiomeSource();
 	}
 
-	public boolean isBlockOpaqueCube(int var1, int var2, int var3) {
-		Block var4 = Block.blocksList[this.getBlockId(var1, var2, var3)];
-		return var4 == null ? false : var4.isOpaqueCube();
-	}
-
 	public boolean isBlockNormalCube(int var1, int var2, int var3) {
 		Block var4 = Block.blocksList[this.getBlockId(var1, var2, var3)];
 		return var4 == null ? false : var4.material.getIsSolid() && var4.renderAsNormalBlock();
+	}
+
+	public <T> T getBlockProperty(int x, int y, int z, Property<T> property) {
+		int cx = (x >> 4) - this.chunkX;
+		int cz = (z >> 4) - this.chunkZ;
+		if (cx < 0 || cx >= this.chunkArray.length || cz < 0 || cz >= this.chunkArray[cx].length) return null;
+		Chunk chunk = this.chunkArray[cx][cz];
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return null;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return null;
+
+		int metadata = section.getMetadata(x, y, z);
+		return block.properties.get(metadata, property);
+	}
+
+	public int getBlockIntProperty(int x, int y, int z, Property<?> property) {
+		int cx = (x >> 4) - this.chunkX;
+		int cz = (z >> 4) - this.chunkZ;
+		if (cx < 0 || cx >= this.chunkArray.length || cz < 0 || cz >= this.chunkArray[cx].length) return 0;
+		Chunk chunk = this.chunkArray[cx][cz];
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return 0;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return 0;
+
+		int metadata = section.getMetadata(x, y, z);
+		return block.properties.getInt(metadata, property);
+	}
+
+	public boolean getBlockBooleanProperty(int x, int y, int z, Property<?> property) {
+		int cx = (x >> 4) - this.chunkX;
+		int cz = (z >> 4) - this.chunkZ;
+		if (cx < 0 || cx >= this.chunkArray.length || cz < 0 || cz >= this.chunkArray[cx].length) return false;
+		Chunk chunk = this.chunkArray[cx][cz];
+		x &= 15;
+		z &= 15;
+
+		ChunkSection section = chunk.getSection(y >> 4);
+		if (section == null) return false;
+		y &= 15;
+
+		Block block = Block.blocksList[section.getBlock(x, y, z)];
+		if (block == null) return false;
+
+		int metadata = section.getMetadata(x, y, z);
+		return block.properties.getBoolean(metadata, property);
 	}
 }
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/VboPool.java
@@ -1,0 +1,290 @@
+package net.mine_diver.smoothbeta.client.render;
+
+import net.mine_diver.smoothbeta.client.render.gl.GlStateManager;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.render.GLAllocation;
+import net.mine_diver.smoothbeta.util.LinkedListFromHell;
+import org.lwjgl.opengl.*;
+
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+public class VboPool implements AutoCloseable {
+    private static final Minecraft mc = Minecraft.getInstance();
+
+    private int vertexArrayId = GL30.glGenVertexArrays();
+    private int vertexBufferId = GL15.glGenBuffers();
+    private int capacity = 4096;
+    private int nextPos = 0;
+    private int size;
+    private final LinkedListFromHell<Pos> posList = new LinkedListFromHell<>();
+    private Pos compactPosLast = null;
+    private int curBaseInstance;
+
+    private IntBuffer bufferIndirect = GLAllocation.createDirectIntBuffer(this.capacity * 5);
+    private final int vertexBytes;
+    private VertexFormat.DrawMode drawMode = VertexFormat.DrawMode.QUADS;
+
+    public VboPool(VertexFormat format) {
+        vertexBytes = format.getVertexSizeByte();
+        this.bindBuffer();
+        long i = this.toBytes(this.capacity);
+        GL15.glBufferData(GL15.GL_ARRAY_BUFFER, i, GL15.GL_STATIC_DRAW);
+        this.unbindBuffer();
+    }
+
+    @Override
+    public void close() {
+        if (this.vertexBufferId > 0) {
+            GlStateManager._glDeleteBuffers(this.vertexBufferId);
+            this.vertexBufferId = 0;
+        }
+    }
+
+    public void bufferData(ByteBuffer data, Pos poolPos) {
+        if (this.vertexBufferId >= 0) {
+            int position = poolPos.getPosition();
+            int size = poolPos.getSize();
+            int bufferSize = this.toVertex(data.limit());
+
+            if (bufferSize <= 0) {
+                if (position >= 0) {
+                    poolPos.setPosition(-1);
+                    poolPos.setSize(0);
+                    this.posList.remove(poolPos.getNode());
+                    this.size -= size;
+                }
+            } else {
+                if (bufferSize > size) {
+                    poolPos.setPosition(this.nextPos);
+                    poolPos.setSize(bufferSize);
+                    this.nextPos += bufferSize;
+
+                    if (position >= 0) this.posList.remove(poolPos.getNode());
+
+                    this.posList.addLast(poolPos.getNode());
+                }
+
+                poolPos.setSize(bufferSize);
+                this.size += bufferSize - size;
+                this.checkVboSize(poolPos.getPositionNext());
+                long l = this.toBytes(poolPos.getPosition());
+                this.bindVertexArray();
+                this.bindBuffer();
+                GL15.glBufferSubData(GL15.GL_ARRAY_BUFFER, l, data);
+                this.unbindBuffer();
+                unbindVertexArray();
+
+                if (this.nextPos > this.size * 11 / 10) this.compactRanges();
+            }
+        }
+    }
+
+    private void compactRanges() {
+        if (!this.posList.isEmpty()) {
+            Pos vborange = this.compactPosLast;
+
+            if (vborange == null || !this.posList.contains(vborange.getNode()))
+                vborange = this.posList.getFirst().getItem();
+
+            int i;
+            Pos vborange1 = vborange.getPrev();
+
+            if (vborange1 == null) i = 0;
+            else i = vborange1.getPositionNext();
+
+            int j = 0;
+
+            while (vborange != null && j < 1) {
+                ++j;
+
+                if (vborange.getPosition() == i) {
+                    i += vborange.getSize();
+                    vborange = vborange.getNext();
+                } else {
+                    int k = vborange.getPosition() - i;
+
+                    if (vborange.getSize() <= k) {
+                        this.copyVboData(vborange.getPosition(), i, vborange.getSize());
+                        vborange.setPosition(i);
+                        i += vborange.getSize();
+                        vborange = vborange.getNext();
+                    } else {
+                        this.checkVboSize(this.nextPos + vborange.getSize());
+                        this.copyVboData(vborange.getPosition(), this.nextPos, vborange.getSize());
+                        vborange.setPosition(this.nextPos);
+                        this.nextPos += vborange.getSize();
+                        Pos vborange2 = vborange.getNext();
+                        this.posList.remove(vborange.getNode());
+                        this.posList.addLast(vborange.getNode());
+                        vborange = vborange2;
+                    }
+                }
+            }
+
+            if (vborange == null) this.nextPos = this.posList.getLast().getItem().getPositionNext();
+
+            this.compactPosLast = vborange;
+        }
+    }
+
+    private long toBytes(int vertex)
+    {
+        return (long)vertex * (long)this.vertexBytes;
+    }
+
+    private int toVertex(long bytes) {
+        return (int)(bytes / (long)this.vertexBytes);
+    }
+
+    private void checkVboSize(int sizeMin) {
+        if (this.capacity < sizeMin) this.expandVbo(sizeMin);
+    }
+
+    private void copyVboData(int posFrom, int posTo, int size) {
+        long i = this.toBytes(posFrom);
+        long j = this.toBytes(posTo);
+        long k = this.toBytes(size);
+        GL15.glBindBuffer(GL31.GL_COPY_READ_BUFFER, this.vertexBufferId);
+        GL15.glBindBuffer(GL31.GL_COPY_WRITE_BUFFER, this.vertexBufferId);
+        GL31.glCopyBufferSubData(GL31.GL_COPY_READ_BUFFER, GL31.GL_COPY_WRITE_BUFFER, i, j, k);
+        mc.checkGLError("Copy VBO range");
+        GL15.glBindBuffer(GL31.GL_COPY_READ_BUFFER, 0);
+        GL15.glBindBuffer(GL31.GL_COPY_WRITE_BUFFER, 0);
+    }
+
+    private void expandVbo(int sizeMin) {
+        int i;
+
+        i = this.capacity * 6 / 4;
+        while (i < sizeMin) i = i * 6 / 4;
+
+        long j = this.toBytes(this.capacity);
+        long k = this.toBytes(i);
+        int l = GL15.glGenBuffers();
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, l);
+        GL15.glBufferData(GL15.GL_ARRAY_BUFFER, k, GL15.GL_STATIC_DRAW);
+        mc.checkGLError("Expand VBO");
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
+        GL15.glBindBuffer(GL31.GL_COPY_READ_BUFFER, this.vertexBufferId);
+        GL15.glBindBuffer(GL31.GL_COPY_WRITE_BUFFER, l);
+        GL31.glCopyBufferSubData(GL31.GL_COPY_READ_BUFFER, GL31.GL_COPY_WRITE_BUFFER, 0L, 0L, j);
+        mc.checkGLError("Copy VBO: " + k);
+        GL15.glBindBuffer(GL31.GL_COPY_READ_BUFFER, 0);
+        GL15.glBindBuffer(GL31.GL_COPY_WRITE_BUFFER, 0);
+        GL15.glDeleteBuffers(this.vertexBufferId);
+        this.bufferIndirect = GLAllocation.createDirectIntBuffer(i * 5);
+        this.vertexBufferId = l;
+        this.capacity = i;
+    }
+
+    public void bindVertexArray() {
+        GL30.glBindVertexArray(this.vertexArrayId);
+    }
+
+    public void bindBuffer() {
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, this.vertexBufferId);
+    }
+
+    public void upload(VertexFormat.DrawMode drawMode, Pos range) {
+        if (this.drawMode != drawMode) {
+            if (this.bufferIndirect.position() > 0)
+                throw new IllegalArgumentException("Mixed region draw modes: " + this.drawMode + " != " + drawMode);
+
+            this.drawMode = drawMode;
+        }
+
+        this.bufferIndirect.put(drawMode.getIndexCount(range.getSize()));
+        bufferIndirect.put(1);
+        this.bufferIndirect.put(0);
+        bufferIndirect.put(range.getPosition());
+        bufferIndirect.put(curBaseInstance++);
+    }
+
+    public void drawAll() {
+        GL30.glBindVertexArray(this.vertexArrayId);
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, this.vertexBufferId);
+
+        GL20.glEnableVertexAttribArray(0);
+        GL20.glVertexAttribPointer(0, 3, GL11.GL_FLOAT, false, 28, 0);
+        GL20.glEnableVertexAttribArray(1);
+        GL20.glVertexAttribPointer(1, 2, GL11.GL_FLOAT, false, 28, 12);
+        GL20.glEnableVertexAttribArray(2);
+        GL20.glVertexAttribPointer(2, 4, GL11.GL_UNSIGNED_BYTE, true, 28, 20);
+        GL20.glEnableVertexAttribArray(3);
+        GL20.glVertexAttribPointer(3, 3, GL11.GL_BYTE, true, 28, 24);
+
+        IndexBuffer autostorageindexbuffer = IndexBuffer.getSequentialBuffer(this.drawMode);
+        VertexFormat.IndexType indextype = autostorageindexbuffer.getIndexType();
+        autostorageindexbuffer.bindAndGrow(nextPos / 4 * 6);
+        this.bufferIndirect.flip();
+        GL43.glMultiDrawElementsIndirect(this.drawMode.glMode, indextype.glType, this.bufferIndirect, bufferIndirect.limit() / 5, 0);
+        this.bufferIndirect.limit(this.bufferIndirect.capacity());
+
+        if (this.nextPos > this.size * 11 / 10) this.compactRanges();
+        curBaseInstance = 0;
+    }
+
+    public void unbindBuffer() {
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
+    }
+
+    public static void unbindVertexArray() {
+        GL30.glBindVertexArray(0);
+    }
+
+    public void deleteGlBuffers() {
+        if (this.vertexArrayId >= 0) {
+            GL30.glDeleteVertexArrays(this.vertexArrayId);
+            this.vertexArrayId = -1;
+        }
+        if (this.vertexBufferId >= 0) {
+            GlStateManager._glDeleteBuffers(this.vertexBufferId);
+            this.vertexBufferId = -1;
+        }
+    }
+
+    public static class Pos {
+        private int position = -1;
+        private int size = 0;
+        private final LinkedListFromHell.Node<Pos> node = new LinkedListFromHell.Node<>(this);
+
+        public int getPosition() {
+            return this.position;
+        }
+
+        public int getSize() {
+            return this.size;
+        }
+
+        public int getPositionNext() {
+            return this.position + this.size;
+        }
+
+        public void setPosition(int position) {
+            this.position = position;
+        }
+
+        public void setSize(int size) {
+            this.size = size;
+        }
+
+        public LinkedListFromHell.Node<Pos> getNode() {
+            return this.node;
+        }
+
+        public Pos getPrev() {
+            LinkedListFromHell.Node<Pos> node = this.node.getPrev();
+            return node == null ? null : node.getItem();
+        }
+
+        public Pos getNext() {
+            LinkedListFromHell.Node<Pos> node = this.node.getNext();
+            return node == null ? null : node.getItem();
+        }
+
+        public String toString() {
+            return this.position + "/" + this.size + "/" + (this.position + this.size);
+        }
+    }
+}
--- net/minecraft/game/item/Item.java
+++ net/minecraft/game/item/Item.java
@@ -1,5 +1,6 @@
 package net.minecraft.game.item;
 
+import java.util.List;
 import java.util.Random;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.LivingEntity;
@@ -10,6 +11,9 @@
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.material.Material;
 
+import static net.minecraft.util.StringTranslate.i18n;
+import static net.minecraft.util.StringTranslate.i18nf;
+
 public class Item {
 	protected static Random random = new Random();
 	public static Item[] itemsList = new Item[32000];
@@ -108,7 +112,7 @@
 	public static Item glowstoneDust = (new Item(92)).setTextureCoord(9, 4).setName("yellowDust");
 	public static Item rawFish = (new FoodItem(93, 2, false)).setTextureCoord(9, 5).setName("fishRaw");
 	public static Item cookedFish = (new FoodItem(94, 5, false)).setTextureCoord(10, 5).setName("fishCooked");
-	public static Item dye = (new DyeItem(95)).setTextureCoord(14, 4).setName("dyePowder");
+	public static Item dye = (new DyeItem(95)).setTextureCoord(31, 16).setName("dyePowder");
 	public static Item bone = (new Item(96)).setTextureCoord(12, 1).setName("bone").setToolGrip();
 	public static Item sugar = (new Item(97)).setTextureCoord(13, 0).setName("sugar").setToolGrip();
 	public static Item cake = (new AltBlockItem(98, Block.cake)).setMaxStackSize(1).setTextureCoord(13, 1).setName("cake");
@@ -117,8 +121,9 @@
 	public static Item cookie = (new CookieItem(101, 1, false, 8)).setTextureCoord(12, 5).setName("cookie");
 	public static MapItem map = (MapItem)(new MapItem(102)).setTextureCoord(12, 3).setName("map");
 	public static ShearsItem shears = (ShearsItem)(new ShearsItem(103)).setTextureCoord(13, 5).setName("shears");
-	public static Item disc13 = (new MusicDiscItem(2000, "13")).setTextureCoord(0, 15).setName("record");
-	public static Item discCat = (new MusicDiscItem(2001, "cat")).setTextureCoord(1, 15).setName("record");
+	public static EmptyMapItem emptyMap = (EmptyMapItem)(new EmptyMapItem(104)).setTextureCoord(13, 3).setName("emptyMap");
+	public static Item disc13 = (new MusicDiscItem(2000, "13")).setTextureCoord(0, 31).setName("record");
+	public static Item discCat = (new MusicDiscItem(2001, "cat")).setTextureCoord(1, 31).setName("record");
 	public final int itemID;
 	protected int maxStackSize = 64;
 	private int maxDamage = 0;
@@ -148,7 +153,7 @@
 	}
 
 	public Item setTextureCoord(int var1, int var2) {
-		this.textureIndex = var1 + var2 * 16;
+		this.textureIndex = var1 + var2 * 32;
 		return this;
 	}
 
@@ -245,6 +250,13 @@
 
 	public String getNameFromStack(ItemStack var1) {
 		return this.name;
+	}
+
+	public void buildTooltipFromStack(ItemStack var1, List<String> tooltip) {
+		tooltip.add(i18n(this.getNameFromStack(var1) + ".name"));
+		if (this.isDamagable()) {
+			tooltip.add(i18nf("tooltip.durability", this.maxDamage - var1.getItemDamage(), this.maxDamage));
+		}
 	}
 
 	public Item setCraftingResult(Item var1) {
--- net/minecraft/client/render/RenderManager.java
+++ net/minecraft/client/render/RenderManager.java
@@ -1,6 +1,6 @@
 package net.minecraft.client.render;
 
-import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.Map;
 import net.minecraft.client.GameSettings;
@@ -78,7 +78,7 @@
 import org.lwjgl.opengl.GL11;
 
 public class RenderManager {
-	private Map entityRenderMap = new HashMap();
+	private Map entityRenderMap = new IdentityHashMap();
 	public static RenderManager instance = new RenderManager();
 	private FontRenderer fontRenderer;
 	public static double renderPosX;
--- /dev/null
+++ net/minecraft/client/gui/component/GuiContainer.java
@@ -1,0 +1,12 @@
+package net.minecraft.client.gui.component;
+
+import net.minecraft.client.Minecraft;
+
+public class GuiContainer extends GuiButton {
+	public void drawButton(Minecraft var1, int var2, int var3) {
+	}
+
+	public boolean mousePressed(Minecraft var1, int var2, int var3) {
+		return false;
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/block/properties/EnumProperty.java
@@ -1,0 +1,52 @@
+package net.minecraft.game.world.block.properties;
+
+import net.minecraft.util.MathHelper;
+
+import java.util.Locale;
+
+public class EnumProperty<E extends Enum<E>> implements Property<E> {
+	private final String name;
+	private final int size;
+	private final E[] values;
+
+	public EnumProperty(Class<E> enumClass) {
+		this(enumClass.getSimpleName().toLowerCase(Locale.ENGLISH), enumClass);
+	}
+
+	public EnumProperty(String name, Class<E> enumClass) {
+		this(name, MathHelper.intBits(enumClass.getEnumConstants().length), enumClass.getEnumConstants());
+	}
+
+	public EnumProperty(String name, int size, Class<E> enumClass) {
+		this(name, size, enumClass.getEnumConstants());
+	}
+
+	@SafeVarargs
+	public EnumProperty(String name, int size, E... values) {
+		Property.checkBounds(size, MathHelper.intBits(values.length));
+		this.name = name;
+		this.size = size;
+		this.values = values;
+	}
+
+	public E getValue(int metadataSlice) {
+		return metadataSlice >= 0 && metadataSlice < this.values.length
+				? this.values[metadataSlice] : null;
+	}
+
+	public int getIntValue(E value) {
+		return value.ordinal();
+	}
+
+	public String toString(E value) {
+		return value != null ? value.toString().toLowerCase() : "unknown";
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public int getSize() {
+		return this.size;
+	}
+}
--- net/minecraft/game/entity/animal/SheepEntity.java
+++ net/minecraft/game/entity/animal/SheepEntity.java
@@ -21,24 +21,13 @@
 
 	protected void entityInit() {
 		super.entityInit();
-		this.properties.addProperty(16, new Byte((byte)0));
+		this.properties.addProperty(16, (byte) 0);
 	}
 
 	public boolean hurt(Entity var1, int var2) {
 		return super.hurt(var1, var2);
 	}
 
-	protected void dropFewItems() {
-		if(!this.getSheared()) {
-			this.entityDropItem(new ItemStack(Block.wool.blockID, 1, this.getFleeceColor()), 0.0F);
-		}
-
-	}
-
-	protected int getDropItemId() {
-		return Block.wool.blockID;
-	}
-
 	public boolean onInteract(PlayerEntity var1) {
 		ItemStack var2 = var1.inventory.getCurrentItem();
 		if(var2 != null && var2.id == Item.shears.itemID && !this.getSheared()) {
@@ -90,7 +79,7 @@
 
 	public void setFleeceColor(int var1) {
 		byte var2 = this.properties.getByte(16);
-		this.properties.updateProperty(16, Byte.valueOf((byte)(var2 & 240 | var1 & 15)));
+		this.properties.updateProperty(16, (byte) (var2 & 240 | var1 & 15));
 	}
 
 	public boolean getSheared() {
@@ -100,9 +89,9 @@
 	public void setSheared(boolean var1) {
 		byte var2 = this.properties.getByte(16);
 		if(var1) {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 | 16)));
+			this.properties.updateProperty(16, (byte) (var2 | 16));
 		} else {
-			this.properties.updateProperty(16, Byte.valueOf((byte)(var2 & -17)));
+			this.properties.updateProperty(16, (byte) (var2 & -17));
 		}
 
 	}
--- com/mojang/nbt/EndTag.java
+++ com/mojang/nbt/EndTag.java
@@ -18,4 +18,8 @@
 	public String toString() {
 		return "END";
 	}
+
+	public NBTBaseTag copy() {
+		return new EndTag().setKey(this.getKey());
+	}
 }
--- net/minecraft/client/render/entity/Render.java
+++ net/minecraft/client/render/entity/Render.java
@@ -42,12 +42,12 @@
 	private void renderEntityOnFire(Entity var1, double var2, double var4, double var6, float var8) {
 		GL11.glDisable(GL11.GL_LIGHTING);
 		int var9 = Block.fire.textureIndex;
-		int var10 = (var9 & 15) << 4;
-		int var11 = var9 & 240;
-		float var12 = (float)var10 / 256.0F;
-		float var13 = ((float)var10 + 15.99F) / 256.0F;
-		float var14 = (float)var11 / 256.0F;
-		float var15 = ((float)var11 + 15.99F) / 256.0F;
+		int var10 = (var9 & 31) << 4;
+		int var11 = (var9 & 992) >> 1;
+		float var12 = (float)var10 / 512.0F;
+		float var13 = ((float)var10 + 15.99F) / 512.0F;
+		float var14 = (float)var11 / 512.0F;
+		float var15 = ((float)var11 + 15.99F) / 512.0F;
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)var2, (float)var4, (float)var6);
 		float var16 = var1.width * 1.4F;
@@ -67,15 +67,15 @@
 
 		while(var20 > 0.0F) {
 			if(var23 % 2 == 0) {
-				var12 = (float)var10 / 256.0F;
-				var13 = ((float)var10 + 15.99F) / 256.0F;
-				var14 = (float)var11 / 256.0F;
-				var15 = ((float)var11 + 15.99F) / 256.0F;
+				var12 = (float)var10 / 512.0F;
+				var13 = ((float)var10 + 15.99F) / 512.0F;
+				var14 = (float)var11 / 512.0F;
+				var15 = ((float)var11 + 15.99F) / 512.0F;
 			} else {
-				var12 = (float)var10 / 256.0F;
-				var13 = ((float)var10 + 15.99F) / 256.0F;
-				var14 = (float)(var11 + 16) / 256.0F;
-				var15 = ((float)(var11 + 16) + 15.99F) / 256.0F;
+				var12 = (float)var10 / 512.0F;
+				var13 = ((float)var10 + 15.99F) / 512.0F;
+				var14 = (float)(var11 + 16) / 512.0F;
+				var15 = ((float)(var11 + 16) + 15.99F) / 512.0F;
 			}
 
 			if(var23 / 2 % 2 == 0) {
@@ -247,7 +247,7 @@
 	}
 
 	public void doRenderShadowAndFire(Entity var1, double var2, double var4, double var6, float var8, float var9) {
-		if(this.renderManager.options.fancyGraphics && this.shadowSize > 0.0F) {
+		if(this.renderManager.options.graphicsLevel > 0 && this.shadowSize > 0.0F) {
 			double var10 = this.renderManager.func_851_a(var1.posX, var1.posY, var1.posZ);
 			float var12 = (float)((1.0D - var10 / 256.0D) * (double)this.field_194_c);
 			if(var12 > 0.0F) {
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerSmoothZoom.java
@@ -1,0 +1,15 @@
+package net.minecraft.game.world.biome.layers;
+
+public class LayerSmoothZoom extends LayerZoomBase {
+	public LayerSmoothZoom(long seed, Layer parent) {
+		super(seed, parent);
+	}
+
+	protected int interpolate(int a, int b) {
+		return (a + b) / 2;
+	}
+
+	protected int interpolate(int a, int b, int c, int d) {
+		return (a + b + c + d) / 4;
+	}
+}
--- net/minecraft/game/world/chunk/loader/ChunkLoader.java
+++ net/minecraft/game/world/chunk/loader/ChunkLoader.java
@@ -7,6 +7,8 @@
 public interface ChunkLoader {
 	Chunk loadChunk(World var1, int var2, int var3) throws IOException;
 
+	boolean chunkExists(int var1, int var2);
+
 	void saveChunk(World var1, Chunk var2) throws IOException;
 
 	void saveExtraChunkData(World var1, Chunk var2) throws IOException;
--- /dev/null
+++ net/minecraft/game/world/block/properties/SharedProperties.java
@@ -1,0 +1,19 @@
+package net.minecraft.game.world.block.properties;
+
+import net.minecraft.game.world.block.Direction;
+
+public final class SharedProperties {
+	public static final String[] WOOD_NAMES = { "oak", "spruce", "maple", "mahogany", "willow" };
+	public static final EnumProperty<Direction> DIRECTION = new EnumProperty<>("direction", 3, Direction.class);
+
+	private SharedProperties() {
+	}
+
+	public static StringProperty woodProperty(String name) {
+		return new StringProperty(name, WOOD_NAMES);
+	}
+
+	public static StringProperty woodProperty(String name, int bits) {
+		return new StringProperty(name, bits, WOOD_NAMES);
+	}
+}
--- net/minecraft/game/world/terrain/noise/SimplexNoiseOctaves.java
+++ net/minecraft/game/world/terrain/noise/SimplexNoiseOctaves.java
@@ -1,5 +1,6 @@
 package net.minecraft.game.world.terrain.noise;
 
+import java.util.Arrays;
 import java.util.Random;
 
 public class SimplexNoiseOctaves extends NoiseGenerator {
@@ -24,9 +25,7 @@
 		var8 /= 1.5D;
 		var10 /= 1.5D;
 		if(var1 != null && var1.length >= var6 * var7) {
-			for(int var16 = 0; var16 < var1.length; ++var16) {
-				var1[var16] = 0.0D;
-			}
+			Arrays.fill(var1, 0.0D);
 		} else {
 			var1 = new double[var6 * var7];
 		}
--- argo/J_JsonArrayNodeSelector.java
+++ /dev/null
@@ -1,29 +1,0 @@
-package argo;
-
-import java.util.List;
-
-final class J_JsonArrayNodeSelector extends J_LeafFunctor {
-	public boolean func_27074_a(J_JsonNode var1) {
-		return EnumJsonNodeType.ARRAY == var1.func_27218_a();
-	}
-
-	public String func_27060_a() {
-		return "A short form array";
-	}
-
-	public List func_27075_b(J_JsonNode var1) {
-		return var1.getElements();
-	}
-
-	public String toString() {
-		return "an array";
-	}
-
-	public Object func_27063_c(Object var1) {
-		return this.func_27075_b((J_JsonNode)var1);
-	}
-
-	public boolean func_27058_a(Object var1) {
-		return this.func_27074_a((J_JsonNode)var1);
-	}
-}
--- /dev/null
+++ net/minecraft/game/entity/loot/ConditionalEntityLoot.java
@@ -1,0 +1,25 @@
+package net.minecraft.game.entity.loot;
+
+import net.minecraft.game.entity.LivingEntity;
+import net.minecraft.game.item.ItemStack;
+
+import java.util.Random;
+import java.util.function.Predicate;
+
+public class ConditionalEntityLoot implements EntityLootEntry {
+	public final Predicate<LivingEntity> condition;
+	public final EntityLootEntry onTrue;
+	public final EntityLootEntry onFalse;
+
+	public ConditionalEntityLoot(Predicate<LivingEntity> condition, EntityLootEntry onTrue, EntityLootEntry onFalse) {
+		this.condition = condition;
+		this.onTrue = onTrue;
+		this.onFalse = onFalse;
+	}
+
+	public ItemStack getItem(LivingEntity entity, Random random) {
+		EntityLootEntry loot = this.condition.test(entity) ? this.onTrue : this.onFalse;
+		if (loot == null) return null;
+		return loot.getItem(entity, random);
+	}
+}
--- /dev/null
+++ argo/jdom/JsonRootNode.java
@@ -1,0 +1,4 @@
+package argo.jdom;
+
+public abstract class JsonRootNode extends JsonNode {
+}
--- net/minecraft/game/world/block/Direction.java
+++ net/minecraft/game/world/block/Direction.java
@@ -1,8 +1,36 @@
 package net.minecraft.game.world.block;
 
-public class Direction {
-	public static final int[] oppositeFace = new int[]{1, 0, 3, 2, 5, 4};
-	public static final int[] faceToX = new int[]{0, 0, 0, 0, -1, 1};
-	public static final int[] faceToY = new int[]{-1, 1, 0, 0, 0, 0};
-	public static final int[] faceToZ = new int[]{0, 0, -1, 1, 0, 0};
+public enum Direction {
+	BOTTOM(0, -1, 0),
+	TOP(0, 1, 0),
+	NORTH(0, 0, -1),
+	SOUTH(0, 0, 1),
+	WEST(-1, 0, 0),
+	EAST(1, 0, 0);
+
+	static {
+		BOTTOM.opposite = TOP;
+		TOP.opposite = BOTTOM;
+		NORTH.opposite = SOUTH;
+		SOUTH.opposite = NORTH;
+		WEST.opposite = EAST;
+		EAST.opposite = WEST;
+	}
+
+	public final int X, Y, Z;
+	private Direction opposite;
+
+	Direction(int x, int y, int z) {
+		X = x;
+		Y = y;
+		Z = z;
+	}
+
+	public Direction getOpposite() {
+		return this.opposite;
+	}
+
+	public static Direction fromId(int id) {
+		return values()[id];
+	}
 }
--- /dev/null
+++ argo/saj/SajParser.java
@@ -1,0 +1,417 @@
+package argo.saj;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Arrays;
+
+public final class SajParser {
+	public void parse(Reader var1, JsonListener var2) throws InvalidSyntaxException, IOException {
+		PositionTrackingPushbackReader var3 = new PositionTrackingPushbackReader(var1);
+		char var4 = (char)var3.read();
+		switch(var4) {
+		case '[':
+			var3.unread(var4);
+			var2.startDocument();
+			this.objectString(var3, var2);
+			break;
+		case '{':
+			var3.unread(var4);
+			var2.startDocument();
+			this.arrayString(var3, var2);
+			break;
+		default:
+			throw new InvalidSyntaxException("Expected either [ or { but got [" + var4 + "].", var3);
+		}
+
+		int var5 = this.readNextNonWhitespaceChar(var3);
+		if(var5 != -1) {
+			throw new InvalidSyntaxException("Got unexpected trailing character [" + (char)var5 + "].", var3);
+		} else {
+			var2.endDocument();
+		}
+	}
+
+	private void objectString(PositionTrackingPushbackReader var1, JsonListener var2) throws InvalidSyntaxException, IOException {
+		char var3 = (char)this.readNextNonWhitespaceChar(var1);
+		if(var3 != 91) {
+			throw new InvalidSyntaxException("Expected object to start with [ but got [" + var3 + "].", var1);
+		} else {
+			var2.startArray();
+			char var4 = (char)this.readNextNonWhitespaceChar(var1);
+			var1.unread(var4);
+			if(var4 != 93) {
+				this.aJsonValue(var1, var2);
+			}
+
+			boolean var5 = false;
+
+			while(!var5) {
+				char var6 = (char)this.readNextNonWhitespaceChar(var1);
+				switch(var6) {
+				case ',':
+					this.aJsonValue(var1, var2);
+					break;
+				case ']':
+					var5 = true;
+					break;
+				default:
+					throw new InvalidSyntaxException("Expected either , or ] but got [" + var6 + "].", var1);
+				}
+			}
+
+			var2.endArray();
+		}
+	}
+
+	private void arrayString(PositionTrackingPushbackReader var1, JsonListener var2) throws InvalidSyntaxException, IOException {
+		char var3 = (char)this.readNextNonWhitespaceChar(var1);
+		if(var3 != 123) {
+			throw new InvalidSyntaxException("Expected object to start with { but got [" + var3 + "].", var1);
+		} else {
+			var2.startObject();
+			char var4 = (char)this.readNextNonWhitespaceChar(var1);
+			var1.unread(var4);
+			if(var4 != 125) {
+				this.aFieldToken(var1, var2);
+			}
+
+			boolean var5 = false;
+
+			while(!var5) {
+				char var6 = (char)this.readNextNonWhitespaceChar(var1);
+				switch(var6) {
+				case ',':
+					this.aFieldToken(var1, var2);
+					break;
+				case '}':
+					var5 = true;
+					break;
+				default:
+					throw new InvalidSyntaxException("Expected either , or } but got [" + var6 + "].", var1);
+				}
+			}
+
+			var2.endObject();
+		}
+	}
+
+	private void aFieldToken(PositionTrackingPushbackReader var1, JsonListener var2) throws InvalidSyntaxException, IOException {
+		char var3 = (char)this.readNextNonWhitespaceChar(var1);
+		if(34 != var3) {
+			throw new InvalidSyntaxException("Expected object identifier to begin with [\"] but got [" + var3 + "].", var1);
+		} else {
+			var1.unread(var3);
+			var2.startField(this.stringToken(var1));
+			char var4 = (char)this.readNextNonWhitespaceChar(var1);
+			if(var4 != 58) {
+				throw new InvalidSyntaxException("Expected object identifier to be followed by : but got [" + var4 + "].", var1);
+			} else {
+				this.aJsonValue(var1, var2);
+				var2.endField();
+			}
+		}
+	}
+
+	private void aJsonValue(PositionTrackingPushbackReader var1, JsonListener var2) throws InvalidSyntaxException, IOException {
+		char var3 = (char)this.readNextNonWhitespaceChar(var1);
+		switch(var3) {
+		case '\"':
+			var1.unread(var3);
+			var2.stringValue(this.stringToken(var1));
+			break;
+		case '-':
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			var1.unread(var3);
+			var2.numberValue(this.numberToken(var1));
+			break;
+		case '[':
+			var1.unread(var3);
+			this.objectString(var1, var2);
+			break;
+		case 'f':
+			char[] var6 = new char[4];
+			int var7 = var1.read(var6);
+			if(var7 != 4 || var6[0] != 97 || var6[1] != 108 || var6[2] != 115 || var6[3] != 101) {
+				var1.uncount(var6);
+				throw new InvalidSyntaxException("Expected \'f\' to be followed by [[a, l, s, e]], but got [" + Arrays.toString(var6) + "].", var1);
+			}
+
+			var2.falseValue();
+			break;
+		case 'n':
+			char[] var8 = new char[3];
+			int var9 = var1.read(var8);
+			if(var9 != 3 || var8[0] != 117 || var8[1] != 108 || var8[2] != 108) {
+				var1.uncount(var8);
+				throw new InvalidSyntaxException("Expected \'n\' to be followed by [[u, l, l]], but got [" + Arrays.toString(var8) + "].", var1);
+			}
+
+			var2.nullValue();
+			break;
+		case 't':
+			char[] var4 = new char[3];
+			int var5 = var1.read(var4);
+			if(var5 != 3 || var4[0] != 114 || var4[1] != 117 || var4[2] != 101) {
+				var1.uncount(var4);
+				throw new InvalidSyntaxException("Expected \'t\' to be followed by [[r, u, e]], but got [" + Arrays.toString(var4) + "].", var1);
+			}
+
+			var2.trueValue();
+			break;
+		case '{':
+			var1.unread(var3);
+			this.arrayString(var1, var2);
+			break;
+		default:
+			throw new InvalidSyntaxException("Invalid character at start of value [" + var3 + "].", var1);
+		}
+
+	}
+
+	private String numberToken(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		StringBuilder var2 = new StringBuilder();
+		char var3 = (char)var1.read();
+		if(45 == var3) {
+			var2.append('-');
+		} else {
+			var1.unread(var3);
+		}
+
+		var2.append(this.nonNegativeNumberToken(var1));
+		return var2.toString();
+	}
+
+	private String nonNegativeNumberToken(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		StringBuilder var2 = new StringBuilder();
+		char var3 = (char)var1.read();
+		if(48 == var3) {
+			var2.append('0');
+			var2.append(this.possibleFractionalComponent(var1));
+			var2.append(this.possibleExponent(var1));
+		} else {
+			var1.unread(var3);
+			var2.append(this.nonZeroDigitToken(var1));
+			var2.append(this.digitString(var1));
+			var2.append(this.possibleFractionalComponent(var1));
+			var2.append(this.possibleExponent(var1));
+		}
+
+		return var2.toString();
+	}
+
+	private char nonZeroDigitToken(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		char var3 = (char)var1.read();
+		switch(var3) {
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			return var3;
+		default:
+			throw new InvalidSyntaxException("Expected a digit 1 - 9 but got [" + var3 + "].", var1);
+		}
+	}
+
+	private char digitToken(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		char var3 = (char)var1.read();
+		switch(var3) {
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			return var3;
+		default:
+			throw new InvalidSyntaxException("Expected a digit 1 - 9 but got [" + var3 + "].", var1);
+		}
+	}
+
+	private String digitString(PositionTrackingPushbackReader var1) throws IOException {
+		StringBuilder var2 = new StringBuilder();
+		boolean var3 = false;
+
+		while(!var3) {
+			char var4 = (char)var1.read();
+			switch(var4) {
+			case '0':
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+			case '9':
+				var2.append(var4);
+				break;
+			default:
+				var3 = true;
+				var1.unread(var4);
+			}
+		}
+
+		return var2.toString();
+	}
+
+	private String possibleFractionalComponent(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		StringBuilder var2 = new StringBuilder();
+		char var3 = (char)var1.read();
+		if(var3 == 46) {
+			var2.append('.');
+			var2.append(this.digitToken(var1));
+			var2.append(this.digitString(var1));
+		} else {
+			var1.unread(var3);
+		}
+
+		return var2.toString();
+	}
+
+	private String possibleExponent(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		StringBuilder var2 = new StringBuilder();
+		char var3 = (char)var1.read();
+		if(var3 != 46 && var3 != 69) {
+			var1.unread(var3);
+		} else {
+			var2.append('E');
+			var2.append(this.possibleSign(var1));
+			var2.append(this.digitToken(var1));
+			var2.append(this.digitString(var1));
+		}
+
+		return var2.toString();
+	}
+
+	private String possibleSign(PositionTrackingPushbackReader var1) throws IOException {
+		StringBuilder var2 = new StringBuilder();
+		char var3 = (char)var1.read();
+		if(var3 != 43 && var3 != 45) {
+			var1.unread(var3);
+		} else {
+			var2.append(var3);
+		}
+
+		return var2.toString();
+	}
+
+	private String stringToken(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		StringBuilder var2 = new StringBuilder();
+		char var3 = (char)var1.read();
+		if(34 != var3) {
+			throw new InvalidSyntaxException("Expected [\"] but got [" + var3 + "].", var1);
+		} else {
+			boolean var4 = false;
+
+			while(!var4) {
+				char var5 = (char)var1.read();
+				switch(var5) {
+				case '\"':
+					var4 = true;
+					break;
+				case '\\':
+					char var6 = this.escapedStringChar(var1);
+					var2.append(var6);
+					break;
+				default:
+					var2.append(var5);
+				}
+			}
+
+			return var2.toString();
+		}
+	}
+
+	private char escapedStringChar(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		char var3 = (char)var1.read();
+		char var2;
+		switch(var3) {
+		case '\"':
+			var2 = 34;
+			break;
+		case '/':
+			var2 = 47;
+			break;
+		case '\\':
+			var2 = 92;
+			break;
+		case 'b':
+			var2 = 8;
+			break;
+		case 'f':
+			var2 = 12;
+			break;
+		case 'n':
+			var2 = 10;
+			break;
+		case 'r':
+			var2 = 13;
+			break;
+		case 't':
+			var2 = 9;
+			break;
+		case 'u':
+			var2 = (char)this.hexadecimalNumber(var1);
+			break;
+		default:
+			throw new InvalidSyntaxException("Unrecognised escape character [" + var3 + "].", var1);
+		}
+
+		return var2;
+	}
+
+	private int hexadecimalNumber(PositionTrackingPushbackReader var1) throws InvalidSyntaxException, IOException {
+		char[] var2 = new char[4];
+		int var3 = var1.read(var2);
+		if(var3 != 4) {
+			throw new InvalidSyntaxException("Expected a 4 digit hexidecimal number but got only [" + var3 + "], namely [" + String.valueOf(var2, 0, var3) + "].", var1);
+		} else {
+			try {
+				int var4 = Integer.parseInt(String.valueOf(var2), 16);
+				return var4;
+			} catch (NumberFormatException var6) {
+				var1.uncount(var2);
+				throw new InvalidSyntaxException("Unable to parse [" + String.valueOf(var2) + "] as a hexidecimal number.", var6, var1);
+			}
+		}
+	}
+
+	private int readNextNonWhitespaceChar(PositionTrackingPushbackReader var1) throws IOException {
+		boolean var3 = false;
+
+		int var2;
+		do {
+			var2 = var1.read();
+			switch(var2) {
+			case 9:
+			case 10:
+			case 13:
+			case 32:
+				break;
+			default:
+				var3 = true;
+			}
+		} while(!var3);
+
+		return var2;
+	}
+}
--- net/minecraft/game/world/save/SaveFormatOld.java
+++ net/minecraft/game/world/save/SaveFormatOld.java
@@ -32,7 +32,7 @@
 			String var3 = "World" + (var2 + 1);
 			WorldInfo var4 = this.getWorldInfo(var3);
 			if(var4 != null) {
-				var1.add(new SaveFormatComparator(var3, "", var4.getLastTimePlayed(), var4.getSizeOnDisk(), false));
+				var1.add(new SaveFormatComparator(var3, "", var4.getLastTimePlayed(), var4.getSizeOnDisk(), false, false));
 			}
 		}
 
--- argo/J_ThingWithPosition.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package argo;
-
-interface J_ThingWithPosition {
-	int func_27331_a();
-
-	int func_27330_b();
-}
--- /dev/null
+++ argo/jdom/JsonNodeBuilders.java
@@ -1,0 +1,50 @@
+package argo.jdom;
+
+public final class JsonNodeBuilders {
+	public static JsonNodeBuilder aNullBuilder() {
+		return new Null();
+	}
+
+	public static JsonNodeBuilder aTrueBuilder() {
+		return new True();
+	}
+
+	public static JsonNodeBuilder aFalseBuilder() {
+		return new False();
+	}
+
+	public static JsonNodeBuilder aNumberBuilder(String var0) {
+		return new JsonNumberNodeBuilder(var0);
+	}
+
+	public static JsonStringNodeBuilder aStringBuilder(String var0) {
+		return new JsonStringNodeBuilder(var0);
+	}
+
+	public static JsonObjectNodeBuilder anObjectBuilder() {
+		return new JsonObjectNodeBuilder();
+	}
+
+	public static JsonArrayNodeBuilder anArrayBuilder() {
+		return new JsonArrayNodeBuilder();
+	}
+
+
+	static final class True implements JsonNodeBuilder {
+		public JsonNode buildNode() {
+			return JsonNodeFactories.aJsonTrue();
+		}
+	}
+
+	static final class False implements JsonNodeBuilder {
+		public JsonNode buildNode() {
+			return JsonNodeFactories.aJsonFalse();
+		}
+	}
+
+	static final class Null implements JsonNodeBuilder {
+		public JsonNode buildNode() {
+			return JsonNodeFactories.aJsonNull();
+		}
+	}
+}
--- net/minecraft/client/Minecraft.java
+++ net/minecraft/client/Minecraft.java
@@ -1,56 +1,19 @@
 package net.minecraft.client;
 
-import java.awt.BorderLayout;
-import java.awt.Canvas;
-import java.awt.Color;
-import java.awt.Component;
-import java.awt.Frame;
-import java.awt.Graphics;
-import java.io.File;
 import net.minecraft.client.controller.CreativePlayerController;
 import net.minecraft.client.controller.PlayerController;
 import net.minecraft.client.effect.EffectRenderer;
-import net.minecraft.client.gui.AchievementOverlayGui;
-import net.minecraft.client.gui.ChatScreen;
-import net.minecraft.client.gui.ConflictWarningScreen;
-import net.minecraft.client.gui.ConnectingScreen;
-import net.minecraft.client.gui.ErrorScreen;
-import net.minecraft.client.gui.FontRenderer;
-import net.minecraft.client.gui.GameOverScreen;
-import net.minecraft.client.gui.GuiScreen;
-import net.minecraft.client.gui.IngameHud;
-import net.minecraft.client.gui.IngameMenuScreen;
-import net.minecraft.client.gui.MainMenuScreen;
-import net.minecraft.client.gui.MultiplayerSleepingScreen;
-import net.minecraft.client.gui.ScaledResolution;
-import net.minecraft.client.gui.UnusedErrorScreen;
+import net.minecraft.client.gui.*;
 import net.minecraft.client.gui.container.InventoryScreen;
 import net.minecraft.client.model.BipedModel;
 import net.minecraft.client.player.ClientNetPlayerEntity;
 import net.minecraft.client.player.ClientPlayerEntity;
 import net.minecraft.client.player.MovementInputFromOptions;
-import net.minecraft.client.render.ChunkRenderer;
-import net.minecraft.client.render.EntityRenderer;
-import net.minecraft.client.render.GLAllocation;
-import net.minecraft.client.render.ItemRenderer;
-import net.minecraft.client.render.OpenGlCapsChecker;
-import net.minecraft.client.render.RenderBlocks;
-import net.minecraft.client.render.RenderManager;
-import net.minecraft.client.render.Tessellator;
-import net.minecraft.client.render.TextureRegistry;
-import net.minecraft.client.render.WorldRenderer;
+import net.minecraft.client.render.*;
 import net.minecraft.client.render.color.ColorizerFoliage;
 import net.minecraft.client.render.color.ColorizerGrass;
 import net.minecraft.client.render.color.ColorizerWater;
-import net.minecraft.client.render.texture.TextureCompassFX;
-import net.minecraft.client.render.texture.TextureFlamesFX;
-import net.minecraft.client.render.texture.TextureLavaFX;
-import net.minecraft.client.render.texture.TextureLavaFlowFX;
-import net.minecraft.client.render.texture.TexturePackList;
-import net.minecraft.client.render.texture.TexturePortalFX;
-import net.minecraft.client.render.texture.TextureWatchFX;
-import net.minecraft.client.render.texture.TextureWaterFX;
-import net.minecraft.client.render.texture.TextureWaterFlowFX;
+import net.minecraft.client.render.texture.*;
 import net.minecraft.client.sound.SoundManager;
 import net.minecraft.game.MinecraftException;
 import net.minecraft.game.entity.LivingEntity;
@@ -61,14 +24,8 @@
 import net.minecraft.game.stats.StatList;
 import net.minecraft.game.stats.StatStringFormatKeyInv;
 import net.minecraft.game.stats.achievement.AchievementList;
-import net.minecraft.game.world.BlockPos;
-import net.minecraft.game.world.MovingObjectPosition;
-import net.minecraft.game.world.MovingObjectType;
-import net.minecraft.game.world.PortalGenerator;
-import net.minecraft.game.world.World;
+import net.minecraft.game.world.*;
 import net.minecraft.game.world.block.Block;
-import net.minecraft.game.world.chunk.ChunkProvider;
-import net.minecraft.game.world.chunk.ChunkProviderLoadOrGenerate;
 import net.minecraft.game.world.dimension.Dimension;
 import net.minecraft.game.world.save.SaveConverterMcRegion;
 import net.minecraft.game.world.save.SaveFormat;
@@ -83,10 +40,20 @@
 import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.DisplayMode;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.PixelFormat;
 import org.lwjgl.util.glu.GLU;
 
+import java.awt.*;
+import java.io.File;
+
 public abstract class Minecraft implements Runnable {
-	public static byte[] field_28006_b = new byte[10485760];
+	public static final String SHORT_VERSION = "24w04a";
+	public static final String VERSION = "Minecraft Diverge " + SHORT_VERSION;
+	public static final boolean DEBUG_MODE = true;
+	public static final boolean DEV_MODE = true;
+	public static final boolean PANORAMA_MODE = false;
+
+	public static byte[] field_28006_b = null;
 	private static Minecraft theMinecraft;
 	public PlayerController playerController;
 	private boolean fullscreen = false;
@@ -146,8 +113,14 @@
 	public boolean isRaining = false;
 	long systemTime = System.currentTimeMillis();
 	private int joinPlayerCounter = 0;
+	private ScaledResolution scaledResolution;
 
 	public Minecraft(Component var1, Canvas var2, MinecraftApplet var3, int var4, int var5, boolean var6) {
+		if ("betacraft.uk".equals(System.getProperty("http.proxyHost"))) {
+			System.setProperty("http.proxyHost", "");
+			System.setProperty("http.proxyPort", "");
+		}
+
 		StatList.initialize();
 		this.tempDisplayHeight = var5;
 		this.fullscreen = var6;
@@ -164,6 +137,10 @@
 		theMinecraft = this;
 	}
 
+	public static Minecraft getInstance() {
+		return theMinecraft;
+	}
+
 	public void onMinecraftCrash(UnexpectedThrowable var1) {
 		this.hasCrashed = true;
 		this.displayUnexpectedThrowable(var1);
@@ -201,10 +178,10 @@
 			Display.setDisplayMode(new DisplayMode(this.displayWidth, this.displayHeight));
 		}
 
-		Display.setTitle("Minecraft Minecraft Beta 1.7.3");
+		Display.setTitle("Minecraft " + VERSION);
 
 		try {
-			Display.create();
+			Display.create(new PixelFormat().withDepthBits(24));
 		} catch (LWJGLException var6) {
 			var6.printStackTrace();
 
@@ -414,7 +391,7 @@
 		}
 	}
 
-	private void checkGLError(String var1) {
+	public void checkGLError(String var1) {
 		int var2 = GL11.glGetError();
 		if(var2 != 0) {
 			String var3 = GLU.gluErrorString(var2);
@@ -483,6 +460,8 @@
 
 			while(this.running) {
 				try {
+					this.scaledResolution = new ScaledResolution(this.gameSettings, this.displayWidth, this.displayHeight);
+
 					if(this.mcApplet != null && !this.mcApplet.isActive()) {
 						break;
 					}
@@ -517,7 +496,7 @@
 
 					long var24 = System.nanoTime() - var23;
 					this.checkGLError("Pre render");
-					RenderBlocks.fancyGrass = this.gameSettings.fancyGraphics;
+					RenderBlocks.fancyGrass = this.gameSettings.graphicsLevel > 0;
 					this.sndManager.func_338_a(this.thePlayer, this.timer.renderPartialTicks);
 					GL11.glEnable(GL11.GL_TEXTURE_2D);
 					if(this.theWorld != null) {
@@ -544,8 +523,11 @@
 						if(this.fullscreen) {
 							this.toggleFullscreen();
 						}
+					}
 
-						Thread.sleep(10L);
+					Display.setVSyncEnabled(this.gameSettings.maxFps == 0);
+					if (this.gameSettings.maxFps > 0 && this.gameSettings.maxFps < 250) {
+						Display.sync(this.gameSettings.maxFps);
 					}
 
 					if(this.gameSettings.showDebugInfo) {
@@ -579,7 +561,7 @@
 					++var3;
 
 					for(this.isGamePaused = !this.isMultiplayerWorld() && this.currentScreen != null && this.currentScreen.doesGuiPauseGame(); System.currentTimeMillis() >= var1 + 1000L; var3 = 0) {
-						this.debug = var3 + " fps, " + ChunkRenderer.chunksUpdated + " chunk updates";
+						this.debug = var3 + " fps, " + ChunkRenderer.chunksUpdated + " chunk updates (" + this.worldRenderer.getQueuedChunkUpdates() + " queued)";
 						ChunkRenderer.chunksUpdated = 0;
 						var1 += 1000L;
 					}
@@ -606,7 +588,6 @@
 
 	public void func_28002_e() {
 		try {
-			field_28006_b = new byte[0];
 			this.worldRenderer.func_28137_f();
 		} catch (Throwable var4) {
 		}
@@ -712,6 +693,26 @@
 
 		var7.draw();
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+		long frameTime = frameTimes[numRecordedFrameTimes & frameTimes.length - 1];
+		String text = frameTime + "ns";
+		this.fontRenderer.drawString(text, frameTimes.length + 64 - this.fontRenderer.getStringWidth(text), this.displayHeight - 12, 0xFFFFFF);
+		text = String.format("%.2fms", frameTime / 1000000.0D);
+		this.fontRenderer.drawString(text, frameTimes.length + 64 - this.fontRenderer.getStringWidth(text), this.displayHeight - 24, 0xFFFFFF);
+		text = (int)(1 / (frameTime / 1000000000.0D)) + "fps";
+		this.fontRenderer.drawString(text, frameTimes.length + 64 - this.fontRenderer.getStringWidth(text), this.displayHeight - 36, 0xFFFFFF);
+
+		long averageFrameTime = 0;
+		for (int i = 0; i < frameTimes.length; i++) {
+			averageFrameTime += frameTimes[i];
+		}
+		averageFrameTime /= frameTimes.length;
+		text = "~" + averageFrameTime + "ns";
+		this.fontRenderer.drawString(text, frameTimes.length + 64 - this.fontRenderer.getStringWidth(text), this.displayHeight - 54, 0xFFFFFF);
+		text = String.format("~%.2fms", averageFrameTime / 1000000.0D);
+		this.fontRenderer.drawString(text, frameTimes.length + 64 - this.fontRenderer.getStringWidth(text), this.displayHeight - 66, 0xFFFFFF);
+		text = "~" + (int)(1 / (averageFrameTime / 1000000000.0D)) + "fps";
+		this.fontRenderer.drawString(text, frameTimes.length + 64 - this.fontRenderer.getStringWidth(text), this.displayHeight - 78, 0xFFFFFF);
 	}
 
 	public void shutdown() {
@@ -748,23 +749,21 @@
 	}
 
 	private void func_6254_a(int var1, boolean var2) {
-		if(!this.playerController.field_1064_b) {
-			if(!var2) {
-				this.leftClickCounter = 0;
-			}
-
-			if(var1 != 0 || this.leftClickCounter <= 0) {
-				if(var2 && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == MovingObjectType.BLOCK && var1 == 0) {
-					int var3 = this.objectMouseOver.blockX;
-					int var4 = this.objectMouseOver.blockY;
-					int var5 = this.objectMouseOver.blockZ;
-					this.playerController.sendBlockRemoving(var3, var4, var5, this.objectMouseOver.sideHit);
-					this.effectRenderer.addBlockHitEffects(var3, var4, var5, this.objectMouseOver.sideHit);
-				} else {
-					this.playerController.resetBlockRemoving();
-				}
-
-			}
+		if(!var2) {
+			this.leftClickCounter = 0;
+		}
+
+		if(var1 != 0 || this.leftClickCounter <= 0) {
+			if(var2 && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == MovingObjectType.BLOCK && var1 == 0) {
+				int var3 = this.objectMouseOver.blockX;
+				int var4 = this.objectMouseOver.blockY;
+				int var5 = this.objectMouseOver.blockZ;
+				this.playerController.sendBlockRemoving(var3, var4, var5, this.objectMouseOver.sideHit);
+				this.effectRenderer.addBlockHitEffects(var3, var4, var5, this.objectMouseOver.sideHit);
+			} else {
+				this.playerController.resetBlockRemoving();
+			}
+
 		}
 	}
 
@@ -777,7 +776,7 @@
 			boolean var2 = true;
 			if(this.objectMouseOver == null) {
 				if(var1 == 0 && !(this.playerController instanceof CreativePlayerController)) {
-					this.leftClickCounter = 10;
+//					this.leftClickCounter = 10;
 				}
 			} else if(this.objectMouseOver.typeOfHit == MovingObjectType.ENTITY) {
 				if(var1 == 0) {
@@ -868,6 +867,15 @@
 
 	}
 
+	public void onGuiScaleChanged() {
+		if(this.currentScreen != null) {
+			ScaledResolution var3 = new ScaledResolution(this.gameSettings, this.displayWidth, this.displayHeight);
+			int var4 = var3.getScaledWidth();
+			int var5 = var3.getScaledHeight();
+			this.currentScreen.setWorldAndResolution(this, var4, var5);
+		}
+	}
+
 	private void resize(int var1, int var2) {
 		if(var1 <= 0) {
 			var1 = 1;
@@ -879,12 +887,7 @@
 
 		this.displayWidth = var1;
 		this.displayHeight = var2;
-		if(this.currentScreen != null) {
-			ScaledResolution var3 = new ScaledResolution(this.gameSettings, var1, var2);
-			int var4 = var3.getScaledWidth();
-			int var5 = var3.getScaledHeight();
-			this.currentScreen.setWorldAndResolution(this, var4, var5);
-		}
+		this.onGuiScaleChanged();
 
 	}
 
@@ -908,28 +911,11 @@
 
 	}
 
-	private void func_28001_B() {
-		(new ThreadCheckHasPaid(this)).start();
-	}
-
 	public void runTick() {
-		if(this.ticksRan == 6000) {
-			this.func_28001_B();
-		}
-
 		this.statFileWriter.func_27178_d();
 		this.ingameGUI.updateTick();
 		this.entityRenderer.getMouseOver(1.0F);
 		int var3;
-		if(this.thePlayer != null) {
-			ChunkProvider var1 = this.theWorld.getChunkProvider();
-			if(var1 instanceof ChunkProviderLoadOrGenerate) {
-				ChunkProviderLoadOrGenerate var2 = (ChunkProviderLoadOrGenerate)var1;
-				var3 = MathHelper.floor((float)((int)this.thePlayer.posX)) >> 4;
-				int var4 = MathHelper.floor((float)((int)this.thePlayer.posZ)) >> 4;
-				var2.setCurrentChunkOver(var3, var4);
-			}
-		}
 
 		if(!this.isGamePaused && this.theWorld != null) {
 			this.playerController.updateController();
@@ -958,6 +944,7 @@
 		if(this.currentScreen != null) {
 			this.currentScreen.handleInput();
 			if(this.currentScreen != null) {
+				GuiScreen.panoramaCounter++;
 				this.currentScreen.field_25091_h.func_25088_a();
 				this.currentScreen.updateScreen();
 			}
@@ -1032,6 +1019,10 @@
 													this.displayGuiScreen(new InventoryScreen(this.thePlayer));
 												}
 
+												if(Keyboard.getEventKey() == this.gameSettings.keyBindCreative.keyCode && this.playerController instanceof CreativePlayerController) {
+													this.displayGuiScreen(new CreativeMenu(this.thePlayer.inventory, this));
+												}
+
 												if(Keyboard.getEventKey() == this.gameSettings.keyBindDrop.keyCode) {
 													this.thePlayer.dropCurrentItem();
 												}
@@ -1039,11 +1030,22 @@
 												if(this.isMultiplayerWorld() && Keyboard.getEventKey() == this.gameSettings.keyBindChat.keyCode) {
 													this.displayGuiScreen(new ChatScreen());
 												}
+
+												if (DEBUG_MODE) {
+													if(Keyboard.getEventKey() == Keyboard.KEY_X) {
+														this.thePlayer.noClip = !this.thePlayer.noClip;
+													}
+												}
 											}
 
 											for(int var6 = 0; var6 < 9; ++var6) {
 												if(Keyboard.getEventKey() == Keyboard.KEY_1 + var6) {
 													this.thePlayer.inventory.currentItem = var6;
+
+													if (PANORAMA_MODE) {
+														this.thePlayer.rotationYaw = var6 < 4 ? -180.0F + 90.0F * var6 : -180.0F;
+														this.thePlayer.rotationPitch = var6 == 4 ? -90.0F : var6 == 5 ? 90.0F : 0.0F;
+													}
 												}
 											}
 
@@ -1110,6 +1112,7 @@
 			}
 
 			this.theWorld.difficultySetting = this.gameSettings.difficulty;
+			this.theWorld.simulationDistance = this.gameSettings.simulationDistance;
 			if(this.theWorld.remoteWorld) {
 				this.theWorld.difficultySetting = 3;
 			}
@@ -1158,15 +1161,15 @@
 		return this.theWorld != null && this.theWorld.remoteWorld;
 	}
 
-	public void startWorld(String var1, String var2, long var3) {
+	public void startWorld(String var1, NewWorldInfo var3) {
 		this.changeWorld1((World)null);
 		System.gc();
 		if(this.saveLoader.isOldMapFormat(var1)) {
-			this.convertMapFormat(var1, var2);
+			this.convertMapFormat(var1, var3.name);
 		} else {
 			SaveHandler var5 = this.saveLoader.getSaveLoader(var1, false);
 			World var6 = null;
-			var6 = new World(var5, var2, var3);
+			var6 = new World(var5, var3);
 			if(var6.isNewWorld) {
 				this.statFileWriter.readStat(StatList.createWorldStat, 1);
 				this.statFileWriter.readStat(StatList.startGameStat, 1);
@@ -1284,14 +1287,6 @@
 				var1.emptyMethod1();
 			}
 
-			ChunkProvider var4 = var1.getChunkProvider();
-			if(var4 instanceof ChunkProviderLoadOrGenerate) {
-				ChunkProviderLoadOrGenerate var5 = (ChunkProviderLoadOrGenerate)var4;
-				int var6 = MathHelper.floor((float)((int)this.thePlayer.posX)) >> 4;
-				int var7 = MathHelper.floor((float)((int)this.thePlayer.posZ)) >> 4;
-				var5.setCurrentChunkOver(var6, var7);
-			}
-
 			var1.spawnPlayerWithLoadedChunks(this.thePlayer);
 			if(var1.isNewWorld) {
 				var1.saveWorldIndirectly(this.loadingScreen);
@@ -1310,7 +1305,7 @@
 		this.loadingScreen.printText("Converting World to " + this.saveLoader.getFormatName());
 		this.loadingScreen.displayLoadingString("This may take a while :)");
 		this.saveLoader.convertMapFormat(var1, this.loadingScreen);
-		this.startWorld(var1, var2, 0L);
+		this.startWorld(var1, new NewWorldInfo(var2));
 	}
 
 	private void func_6255_d(String var1) {
@@ -1320,18 +1315,12 @@
 		int var3 = 0;
 		int var4 = var2 * 2 / 16 + 1;
 		var4 *= var4;
-		ChunkProvider var5 = this.theWorld.getChunkProvider();
 		BlockPos var6 = this.theWorld.getSpawnPoint();
 		if(this.thePlayer != null) {
 			var6.x = (int)this.thePlayer.posX;
 			var6.z = (int)this.thePlayer.posZ;
 		}
 
-		if(var5 instanceof ChunkProviderLoadOrGenerate) {
-			ChunkProviderLoadOrGenerate var7 = (ChunkProviderLoadOrGenerate)var5;
-			var7.setCurrentChunkOver(var6.x >> 4, var6.z >> 4);
-		}
-
 		for(int var10 = -var2; var10 <= var2; var10 += 16) {
 			for(int var8 = -var2; var8 <= var2; var8 += 16) {
 				this.loadingScreen.setLoadingProgress(var3++ * 100 / var4);
@@ -1349,6 +1338,7 @@
 
 	public void installResource(String var1, File var2) {
 		int var3 = var1.indexOf("/");
+		if (var3 < 0) return;
 		String var4 = var1.substring(0, var3);
 		var1 = var1.substring(var3 + 1);
 		if(var4.equalsIgnoreCase("sound")) {
@@ -1358,9 +1348,20 @@
 		} else if(var4.equalsIgnoreCase("streaming")) {
 			this.sndManager.addStreaming(var1, var2);
 		} else if(var4.equalsIgnoreCase("music")) {
-			this.sndManager.addMusic(var1, var2);
+			SoundManager.MusicType.GAME.soundPool.addSound(var1, var2);
 		} else if(var4.equalsIgnoreCase("newmusic")) {
-			this.sndManager.addMusic(var1, var2);
+			SoundManager.MusicType.GAME.soundPool.addSound(var1, var2);
+		} else if(var4.equalsIgnoreCase("dvmusic")) {
+			var3 = var1.indexOf("/");
+			if (var3 > 0) {
+				String musicType = var1.substring(0, var3);
+				var1 = var1.substring(var3 + 1);
+				if (musicType.equalsIgnoreCase("menu")) {
+					SoundManager.MusicType.MENU.soundPool.addSound(var1, var2);
+				} else if (musicType.equalsIgnoreCase("creative")) {
+					SoundManager.MusicType.CREATIVE.soundPool.addSound(var1, var2);
+				}
+			}
 		}
 
 	}
@@ -1369,19 +1370,19 @@
 		return this.glCapabilities;
 	}
 
-	public String func_6241_m() {
+	public String getDebugInfoRenders() {
 		return this.worldRenderer.getDebugInfoRenders();
 	}
 
-	public String func_6262_n() {
+	public String getDebugInfoEntities() {
 		return this.worldRenderer.getDebugInfoEntities();
 	}
 
-	public String func_21002_o() {
+	public String getDebugInfoChunkProvider() {
 		return this.theWorld.getChunkProviderName();
 	}
 
-	public String func_6245_o() {
+	public String getDebugInfoEffects() {
 		return "P: " + this.effectRenderer.getStatistics() + ". T: " + this.theWorld.getEntityDebugInfo();
 	}
 
@@ -1408,12 +1409,6 @@
 			var5 = false;
 		}
 
-		ChunkProvider var6 = this.theWorld.getChunkProvider();
-		if(var6 instanceof ChunkProviderLoadOrGenerate) {
-			ChunkProviderLoadOrGenerate var7 = (ChunkProviderLoadOrGenerate)var6;
-			var7.setCurrentChunkOver(var4.x >> 4, var4.z >> 4);
-		}
-
 		this.theWorld.setSpawnLocation();
 		this.theWorld.updateEntityList();
 		int var8 = 0;
@@ -1450,15 +1445,17 @@
 	}
 
 	public static void startMainThread(String var0, String var1, String var2) {
+		int w = PANORAMA_MODE ? 512 : 854;
+		int h = PANORAMA_MODE ? 512 : 480;
 		boolean var3 = false;
 		Frame var5 = new Frame("Minecraft");
 		Canvas var6 = new Canvas();
 		var5.setLayout(new BorderLayout());
 		var5.add(var6, "Center");
-		var6.setPreferredSize(new java.awt.Dimension(854, 480));
+		var6.setPreferredSize(new java.awt.Dimension(w, h));
 		var5.pack();
 		var5.setLocationRelativeTo((Component)null);
-		MinecraftImpl var7 = new MinecraftImpl(var5, var6, (MinecraftApplet)null, 854, 480, var3, var5);
+		MinecraftImpl var7 = new MinecraftImpl(var5, var6, (MinecraftApplet)null, w, h, var3, var5);
 		Thread var8 = new Thread(var7, "Minecraft main thread");
 		var8.setPriority(10);
 		var7.minecraftUri = "www.minecraft.net";
@@ -1503,7 +1500,11 @@
 	}
 
 	public static boolean isFancyGraphicsEnabled() {
-		return theMinecraft != null && theMinecraft.gameSettings.fancyGraphics;
+		return theMinecraft != null && theMinecraft.gameSettings.graphicsLevel > 0;
+	}
+
+	public static boolean isFabulousGraphicsEnabled() {
+		return theMinecraft != null && theMinecraft.gameSettings.graphicsLevel > 1;
 	}
 
 	public static boolean isAmbientOcclusionEnabled() {
@@ -1512,6 +1513,10 @@
 
 	public static boolean isDebugInfoEnabled() {
 		return theMinecraft != null && theMinecraft.gameSettings.showDebugInfo;
+	}
+
+	public static ScaledResolution getScaledResolution() {
+		return theMinecraft.scaledResolution;
 	}
 
 	public boolean lineIsCommand(String var1) {
--- /dev/null
+++ net/minecraft/game/world/biome/TundraBiome.java
@@ -1,0 +1,33 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.entity.animal.WolfEntity;
+import net.minecraft.game.world.SpawnListEntry;
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.feature.*;
+
+import java.util.Random;
+
+public class TundraBiome extends Biome {
+	public TundraBiome(int i) {
+		super(i);
+		this.spawnableCreatureList.add(new SpawnListEntry(WolfEntity.class, 1));
+		this.removeBeach();
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(12.0D, 24.0D)
+				.noiseUnderDamp(1.0D)
+				.heightOffset(2.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings();
+	}
+
+	public void decorate(PopulatorHost populator) {
+		int spikeCount = populator.rand.nextInt(25) == 0 ? populator.rand.nextInt(16) + 1 : 0;
+		populator.generateSurface(new SpikeFeature().block(Block.ice.blockID, 0).skew(1.0F), spikeCount, 8);
+	}
+}
--- net/minecraft/game/world/block/CakeBlock.java
+++ net/minecraft/game/world/block/CakeBlock.java
@@ -5,14 +5,27 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.IntProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.material.Material;
 
 public class CakeBlock extends Block {
+	private static final int TEX_TOP = TerrainLayout.texCoord("cake_top");
+	private static final int TEX_SIDE = TerrainLayout.texCoord("cake_side");
+	private static final int TEX_SLICE = TerrainLayout.texCoord("cake_slice");
+	private static final int TEX_BOTTOM = TerrainLayout.texCoord("cake_bottom");
+
+	public static final IntProperty BITES = new IntProperty("bites", 3);
+
 	protected CakeBlock(int var1, int var2) {
 		super(var1, var2, Material.cakeMaterial);
 		this.setTickOnLoad(true);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(BITES);
+	}
+
 	public void setBlockBoundsBasedOnState(BlockAccess var1, int var2, int var3, int var4) {
 		int var5 = var1.getBlockMetadata(var2, var3, var4);
 		float var6 = 1.0F / 16.0F;
@@ -44,11 +57,11 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return var1 == 1 ? this.textureIndex : (var1 == 0 ? this.textureIndex + 3 : (var2 > 0 && var1 == 4 ? this.textureIndex + 2 : this.textureIndex + 1));
+		return var1 == 1 ? TEX_TOP : var1 == 0 ? TEX_BOTTOM : var2 > 0 && var1 == 4 ? TEX_SLICE : TEX_SIDE;
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex : (var1 == 0 ? this.textureIndex + 3 : this.textureIndex + 1);
+		return var1 == 1 ? TEX_TOP : var1 == 0 ? TEX_BOTTOM : TEX_SIDE;
 	}
 
 	public boolean renderAsNormalBlock() {
--- com/mojang/nbt/ByteArrayTag.java
+++ com/mojang/nbt/ByteArrayTag.java
@@ -3,6 +3,7 @@
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.util.Arrays;
 
 public class ByteArrayTag extends NBTBaseTag {
 	public byte[] byteArray;
@@ -31,5 +32,9 @@
 
 	public String toString() {
 		return "[" + this.byteArray.length + " bytes]";
+	}
+
+	public NBTBaseTag copy() {
+		return new ByteArrayTag(Arrays.copyOf(this.byteArray, this.byteArray.length)).setKey(this.getKey());
 	}
 }
--- net/minecraft/game/world/block/CropsBlock.java
+++ net/minecraft/game/world/block/CropsBlock.java
@@ -5,11 +5,16 @@
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.IntProperty;
 
 public class CropsBlock extends FlowerBlock {
-	protected CropsBlock(int var1, int var2) {
-		super(var1, var2);
-		this.textureIndex = var2;
+	private final int[] texTypes;
+
+	public static final IntProperty AGE = new IntProperty("age");
+
+	protected CropsBlock(int var1, String var2) {
+		super(var1, TerrainLayout.texCoord(var2 + "_0"));
+		this.texTypes = TerrainLayout.varyingTexCoord(var2, 8);
 		this.setTickOnLoad(true);
 		float var3 = 0.5F;
 		this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, 0.25F, 0.5F + var3);
@@ -22,12 +27,12 @@
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		super.updateTick(var1, var2, var3, var4, var5);
 		if(var1.getBlockLightValue(var2, var3 + 1, var4) >= 9) {
-			int var6 = var1.getBlockMetadata(var2, var3, var4);
+			int var6 = var1.getBlockIntProperty(var2, var3, var4, AGE);
 			if(var6 < 7) {
 				float var7 = this.getGrowthRate(var1, var2, var3, var4);
 				if(var5.nextInt((int)(100.0F / var7)) == 0) {
 					++var6;
-					var1.setBlockMetadataWithNotify(var2, var3, var4, var6);
+					var1.setBlockPropertyWithNotify(var2, var3, var4, AGE, var6);
 				}
 			}
 		}
@@ -79,11 +84,10 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		if(var2 < 0) {
-			var2 = 7;
+		if(var2 < 0 || var2 > texTypes.length) {
+			var2 = 0;
 		}
-
-		return this.textureIndex + var2;
+		return this.texTypes[var2];
 	}
 
 	public int getRenderType() {
--- /dev/null
+++ net/minecraft/game/world/terrain/feature/SpikeFeature.java
@@ -1,0 +1,81 @@
+package net.minecraft.game.world.terrain.feature;
+
+import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.Block;
+import net.minecraft.util.IntArray2D;
+
+import java.util.Random;
+
+public class SpikeFeature extends Feature {
+	private int block = 1;
+	private int metadata = 0;
+	private float skew = 0.0F;
+	private int baseHeight = 4;
+	private int heightRange = 14;
+	private int baseRadius = 3;
+	private int radiusRange = 6;
+
+	public SpikeFeature block(int block, int metadata) {
+		this.block = block;
+		this.metadata = metadata;
+		return this;
+	}
+
+	public SpikeFeature skew(float skew) {
+		this.skew = skew;
+		return this;
+	}
+
+	public SpikeFeature height(int base, int range) {
+		this.baseHeight = base;
+		this.heightRange = range;
+		return this;
+	}
+
+	public SpikeFeature radius(int base, int range) {
+		this.baseRadius = base;
+		this.radiusRange = range;
+		return this;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int height = var2.nextInt(this.heightRange) + this.baseHeight;
+		int radius = var2.nextInt(this.radiusRange) + this.baseRadius;
+		float radiusSquare = radius * radius;
+		float skewX = (var2.nextFloat() - 0.5F) * this.skew;
+		float skewZ = (var2.nextFloat() - 0.5F) * this.skew;
+
+		IntArray2D groundArray = new IntArray2D(radius * 2 + 1, radius * 2 + 1);
+		for (int x = -radius; x <= radius; x++) {
+			for (int z = -radius; z <= radius; z++) {
+				groundArray.set(x + radius, z + radius, var1.getTopSolidOrLiquidBlock(x + var3, z + var5));
+			}
+		}
+
+		for (int x = -radius; x <= radius; x++) {
+			for (int z = -radius; z <= radius; z++) {
+				float distSquare = x * x + z * z;
+				float slope = 1 - distSquare / radiusSquare;
+
+				if (slope < 0) continue;
+				if (slope > 1) slope = 1;
+
+				slope *= slope;
+				int intSlope = (int) (slope * height);
+
+				int ground = groundArray.get(x + radius, z + radius);
+				if (intSlope > 0 && var1.getBlockId(x + var3, ground - 1, z + var5) == Block.grass.blockID) {
+					var1.setBlockAndMetadata(x + var3, ground - 1, z + var5, Block.dirt.blockID, 0);
+				}
+
+				for (int y = 0; y < intSlope; y++) {
+					int ox = (int)(x + skewX * y);
+					int oz = (int)(z + skewZ * y);
+					var1.setBlockAndMetadata(ox + var3, y + ground, oz + var5, this.block, this.metadata);
+				}
+			}
+		}
+
+		return true;
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/MountainBiome.java
@@ -1,0 +1,87 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.feature.Feature;
+import net.minecraft.game.world.terrain.feature.SkinnySpruceTreeFeature;
+import net.minecraft.game.world.terrain.feature.SpruceTreeFeature;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+
+import java.util.Random;
+
+public class MountainBiome extends Biome {
+	private final NoiseSettings edgeNoiseSettings = this.buildEdgeNoiseSettings().build();
+	private PerlinNoiseOctaves grassNoise;
+	private PerlinNoiseOctaves snowNoise;
+
+	protected MountainBiome(int id) {
+		super(id);
+		this.topBlock = (byte)Block.stone.blockID;
+		this.fillerBlock = this.topBlock;
+		this.removeBeach();
+	}
+
+	public Feature getRandomTreeFeature(Random var1) {
+		return var1.nextInt(3) == 0 ? new SkinnySpruceTreeFeature() : new SpruceTreeFeature();
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return 10;
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(0.0D)
+				.heightOffset(20.0D, 80.0D)
+				.selectorThreshold(1.0D)
+				.noiseUnderDamp(1.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings()
+				.heightOffset(50.0D, 130.0D);
+	}
+
+	protected NoiseSettings.Builder buildEdgeNoiseSettings() {
+		return this.buildNoiseSettings()
+				.heightOffset(5.0D, 25.0D);
+	}
+
+	public NoiseSettings getNoiseSettings(int x, int z, double boost, double ocean, double edge) {
+		return new NoiseSettings(this.edgeNoiseSettings, super.getNoiseSettings(x, z, boost, ocean, edge), edge);
+	}
+
+	protected void initializeNoise(Random random) {
+		this.grassNoise = new PerlinNoiseOctaves(random, 3);
+		this.snowNoise = new PerlinNoiseOctaves(random, 3);
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		int wx = chunk.xPosition * 16 + x;
+		int wz = chunk.zPosition * 16 + z;
+
+		double grassValue = Math.abs(this.grassNoise.generateNoiseNormalized2D(wx * 0.05D, wz * 0.05D));
+		double snowValue = this.getEnableSnow() ? this.snowNoise.generateNoiseNormalized2D(wx * 0.1D, wz * 0.1D) * 5.0D - 0.5D + random.nextDouble() * 0.5D : 0.0D;
+
+		if (grassValue < 0.8D - (surfaceHeight - seaLevel) / 80.0D + random.nextDouble() * 0.25D) {
+			this.topBlock = (byte)Block.grass.blockID;
+		} else {
+			this.topBlock = (byte)Block.stone.blockID;
+		}
+
+		if (grassValue < 0.65D - (surfaceHeight - seaLevel) / 80.0D + random.nextDouble() * 0.25D) {
+			this.fillerBlock = (byte)Block.dirt.blockID;
+		} else {
+			this.fillerBlock = (byte)Block.stone.blockID;
+		}
+
+		super.buildSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+
+		if (this.topBlock == Block.stone.blockID) {
+			for (int i = 0; i < snowValue; i++) {
+				chunk.setBlockRaw(x, surfaceHeight--, z, Block.snow.blockID);
+			}
+		}
+	}
+}
--- net/minecraft/client/render/texture/TexturedQuad.java
+++ net/minecraft/client/render/texture/TexturedQuad.java
@@ -17,13 +17,17 @@
 	}
 
 	public TexturedQuad(ModelVertex[] var1, int var2, int var3, int var4, int var5) {
+		this(var1, var2, var3, var4, var5, 64.0F, 32.0F);
+	}
+
+	public TexturedQuad(ModelVertex[] var1, int var2, int var3, int var4, int var5, float width, float height) {
 		this(var1);
 		float var6 = 0.0015625F;
 		float var7 = 0.003125F;
-		var1[0] = var1[0].setTexturePosition((float)var4 / 64.0F - var6, (float)var3 / 32.0F + var7);
-		var1[1] = var1[1].setTexturePosition((float)var2 / 64.0F + var6, (float)var3 / 32.0F + var7);
-		var1[2] = var1[2].setTexturePosition((float)var2 / 64.0F + var6, (float)var5 / 32.0F - var7);
-		var1[3] = var1[3].setTexturePosition((float)var4 / 64.0F - var6, (float)var5 / 32.0F - var7);
+		var1[0] = var1[0].setTexturePosition((float)var4 / width - var6, (float)var3 / height + var7);
+		var1[1] = var1[1].setTexturePosition((float)var2 / width + var6, (float)var3 / height + var7);
+		var1[2] = var1[2].setTexturePosition((float)var2 / width + var6, (float)var5 / height - var7);
+		var1[3] = var1[3].setTexturePosition((float)var4 / width - var6, (float)var5 / height - var7);
 	}
 
 	public void flipFace() {
--- /dev/null
+++ argo/jdom/JsonNodeType.java
@@ -1,0 +1,11 @@
+package argo.jdom;
+
+public enum JsonNodeType {
+	OBJECT,
+	ARRAY,
+	STRING,
+	NUMBER,
+	TRUE,
+	FALSE,
+	NULL;
+}
--- net/minecraft/game/world/chunk/ChunkProviderServer.java
+++ net/minecraft/game/world/chunk/ChunkProviderServer.java
@@ -2,23 +2,24 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.game.world.BlockPos;
 import net.minecraft.game.world.chunk.loader.ChunkLoader;
 import net.minecraft.server.world.WorldServer;
 import net.minecraft.util.ProgressUpdate;
 
 public class ChunkProviderServer implements ChunkProvider {
-	private Set field_725_a = new HashSet();
+	private LongSet field_725_a = new LongOpenHashSet();
 	private Chunk dummyChunk;
 	private ChunkProvider serverChunkGenerator;
 	private ChunkLoader field_729_d;
 	public boolean chunkLoadOverride = false;
-	private Map id2ChunkMap = new HashMap();
+	private Long2ObjectMap<Chunk> id2ChunkMap = new Long2ObjectOpenHashMap<>();
 	private List field_727_f = new ArrayList();
 	private WorldServer world;
 
@@ -30,7 +31,7 @@
 	}
 
 	public boolean chunkExists(int var1, int var2) {
-		return this.id2ChunkMap.containsKey(Integer.valueOf(ChunkCoordIntPair.chunkXZ2Int(var1, var2)));
+		return this.id2ChunkMap.containsKey(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
 	}
 
 	public void func_374_c(int var1, int var2) {
@@ -38,16 +39,16 @@
 		int var4 = var1 * 16 + 8 - var3.x;
 		int var5 = var2 * 16 + 8 - var3.z;
 		short var6 = 128;
+
 		if(var4 < -var6 || var4 > var6 || var5 < -var6 || var5 > var6) {
-			this.field_725_a.add(Integer.valueOf(ChunkCoordIntPair.chunkXZ2Int(var1, var2)));
+			this.field_725_a.add(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
 		}
-
 	}
 
 	public Chunk prepareChunk(int var1, int var2) {
-		int var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
-		this.field_725_a.remove(Integer.valueOf(var3));
-		Chunk var4 = (Chunk)this.id2ChunkMap.get(Integer.valueOf(var3));
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		this.field_725_a.remove(var3);
+		Chunk var4 = this.id2ChunkMap.get(var3);
 		if(var4 == null) {
 			var4 = this.func_4063_e(var1, var2);
 			if(var4 == null) {
@@ -58,11 +59,12 @@
 				}
 			}
 
-			this.id2ChunkMap.put(Integer.valueOf(var3), var4);
+			this.id2ChunkMap.put(var3, var4);
 			this.field_727_f.add(var4);
 			if(var4 != null) {
 				var4.doNothing2();
 				var4.onChunkLoad();
+				var4.initLightingForRealNotJustHeightmap();
 			}
 
 			if(!var4.isTerrainPopulated && this.chunkExists(var1 + 1, var2 + 1) && this.chunkExists(var1, var2 + 1) && this.chunkExists(var1 + 1, var2)) {
@@ -86,7 +88,7 @@
 	}
 
 	public Chunk provideChunk(int var1, int var2) {
-		Chunk var3 = (Chunk)this.id2ChunkMap.get(Integer.valueOf(ChunkCoordIntPair.chunkXZ2Int(var1, var2)));
+		Chunk var3 = this.id2ChunkMap.get(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
 		return var3 == null ? (!this.world.worldChunkLoadOverride && !this.chunkLoadOverride ? this.dummyChunk : this.prepareChunk(var1, var2)) : var3;
 	}
 
@@ -177,8 +179,8 @@
 		if(!this.world.levelSaving) {
 			for(int var1 = 0; var1 < 100; ++var1) {
 				if(!this.field_725_a.isEmpty()) {
-					Integer var2 = (Integer)this.field_725_a.iterator().next();
-					Chunk var3 = (Chunk)this.id2ChunkMap.get(var2);
+					long var2 = this.field_725_a.iterator().nextLong();
+					Chunk var3 = this.id2ChunkMap.get(var2);
 					var3.onChunkUnload();
 					this.func_373_b(var3);
 					this.func_375_a(var3);
--- /dev/null
+++ argo/jdom/JsonObjectNodeBuilder.java
@@ -1,0 +1,34 @@
+package argo.jdom;
+
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+
+public final class JsonObjectNodeBuilder implements JsonNodeBuilder {
+	private final List<JsonFieldBuilder> field_27238_a = new LinkedList<>();
+
+	public JsonObjectNodeBuilder withFieldBuilder(JsonFieldBuilder var1) {
+		this.field_27238_a.add(var1);
+		return this;
+	}
+
+	public JsonRootNode buildNode() {
+		return JsonNodeFactories.aJsonObject(new BuilderList(this));
+	}
+
+	static List<JsonFieldBuilder> func_27236_a(JsonObjectNodeBuilder var0) {
+		return var0.field_27238_a;
+	}
+
+    static class BuilderList extends HashMap<JsonStringNode, JsonNode> {
+        final JsonObjectNodeBuilder nodeBuilder;
+
+        BuilderList(JsonObjectNodeBuilder var1) {
+            this.nodeBuilder = var1;
+
+            for (JsonFieldBuilder object : func_27236_a(this.nodeBuilder)) {
+                this.put(object.func_27303_b(), object.buildValue());
+            }
+        }
+    }
+}
--- /dev/null
+++ net/minecraft/client/model/SlimPlayerModel.java
@@ -1,0 +1,23 @@
+package net.minecraft.client.model;
+
+public class SlimPlayerModel extends PlayerModel {
+	public SlimPlayerModel(float f) {
+		this(f, 0f);
+	}
+
+	public SlimPlayerModel(float f, float f1) {
+		super(f, f1);
+		this.leftArmOverlay = new ModelRenderer(48, 48).setTextureSize(64, 64);
+        this.leftArmOverlay.addBox(-1.0F, -2.0F, -2.0F, 3, 12, 4, f + 0.25F);
+        this.leftArmOverlay.setRotationPoint(5.0F, 2.5F, 0.0F);
+        this.rightArmOverlay = new ModelRenderer(40, 32).setTextureSize(64, 64);
+        this.rightArmOverlay.addBox(-2.0F, -2.0F, -2.0F, 3, 12, 4, f + 0.25F);
+        this.rightArmOverlay.setRotationPoint(-5.0F, 2.5F, 10.0F);
+        this.bipedLeftArm = new ModelRenderer(32, 48).setTextureSize(64, 64);
+        this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 3, 12, 4, f);
+        this.bipedLeftArm.setRotationPoint(5.0F, 2.5F, 0.0F);
+        this.bipedRightArm = new ModelRenderer(40, 16).setTextureSize(64, 64);
+		this.bipedRightArm.addBox(-2F, -2F, -2F, 3, 12, 4, f);
+		this.bipedRightArm.setRotationPoint(-5F, 2.5F + f1, 0.0F);
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerVoronoiZoom.java
@@ -1,0 +1,80 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.IntArray2D;
+
+public class LayerVoronoiZoom extends Layer {
+	public LayerVoronoiZoom(long seed, Layer parent) {
+		super(seed);
+		super.parent = parent;
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		x -= 2;
+		z -= 2;
+		byte var5 = 2;
+		int var6 = 1 << var5;
+		int var7 = x >> var5;
+		int var8 = z >> var5;
+		int var9 = (width >> var5) + 3;
+		int var10 = (length >> var5) + 3;
+		int[] var11 = this.parent.getCachedData(var7, var8, var9, var10).toXFirst().getArray();
+		int var12 = var9 << var5;
+		int var13 = var10 << var5;
+		int[] var14 = new int[var12 * var13];
+
+		int var16;
+		for(int var15 = 0; var15 < var10 - 1; ++var15) {
+			var16 = var11[(var15) * var9];
+			int var17 = var11[(var15 + 1) * var9];
+
+			for(int var18 = 0; var18 < var9 - 1; ++var18) {
+				double var19 = (double)var6 * 0.9D;
+				this.setChunkSeed((long) var18 + var7 << var5, (long) var15 + var8 << var5);
+				double var21 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19;
+				double var23 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19;
+				this.setChunkSeed((long) var18 + var7 + 1 << var5, (long) var15 + var8 << var5);
+				double var25 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19 + (double)var6;
+				double var27 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19;
+				this.setChunkSeed((long) var18 + var7 << var5, (long) var15 + var8 + 1 << var5);
+				double var29 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19;
+				double var31 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19 + (double)var6;
+				this.setChunkSeed((long) var18 + var7 + 1 << var5, (long) var15 + var8 + 1 << var5);
+				double var33 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19 + (double)var6;
+				double var35 = ((double)this.nextInt(1024) / 1024.0D - 0.5D) * var19 + (double)var6;
+				int var37 = var11[var18 + 1 + (var15) * var9];
+				int var38 = var11[var18 + 1 + (var15 + 1) * var9];
+
+				for(int var39 = 0; var39 < var6; ++var39) {
+					int var40 = ((var15 << var5) + var39) * var12 + (var18 << var5);
+
+					for(int var41 = 0; var41 < var6; ++var41) {
+						double var42 = ((double)var39 - var23) * ((double)var39 - var23) + ((double)var41 - var21) * ((double)var41 - var21);
+						double var44 = ((double)var39 - var27) * ((double)var39 - var27) + ((double)var41 - var25) * ((double)var41 - var25);
+						double var46 = ((double)var39 - var31) * ((double)var39 - var31) + ((double)var41 - var29) * ((double)var41 - var29);
+						double var48 = ((double)var39 - var35) * ((double)var39 - var35) + ((double)var41 - var33) * ((double)var41 - var33);
+						if(var42 < var44 && var42 < var46 && var42 < var48) {
+							var14[var40++] = var16;
+						} else if(var44 < var42 && var44 < var46 && var44 < var48) {
+							var14[var40++] = var37;
+						} else if(var46 < var42 && var46 < var44 && var46 < var48) {
+							var14[var40++] = var17;
+						} else {
+							var14[var40++] = var38;
+						}
+					}
+				}
+
+				var16 = var37;
+				var17 = var38;
+			}
+		}
+
+		int[] var50 = new int[width * length];
+
+		for(int i = 0; i < length; ++i) {
+			System.arraycopy(var14, (i + (z & var6 - 1)) * (var9 << var5) + (x & var6 - 1), var50, i * width, width);
+		}
+
+		return IntArray2D.xFirst(var50, width, length);
+	}
+}
--- net/minecraft/util/MCHashEntry.java
+++ net/minecraft/util/MCHashEntry.java
@@ -26,8 +26,8 @@
 			return false;
 		} else {
 			MCHashEntry var2 = (MCHashEntry)var1;
-			Integer var3 = Integer.valueOf(this.getHash());
-			Integer var4 = Integer.valueOf(var2.getHash());
+			Integer var3 = this.getHash();
+			Integer var4 = var2.getHash();
 			if(var3 == var4 || var3 != null && var3.equals(var4)) {
 				Object var5 = this.getValue();
 				Object var6 = var2.getValue();
--- net/minecraft/game/world/MobSpawner.java
+++ net/minecraft/game/world/MobSpawner.java
@@ -1,9 +1,11 @@
 package net.minecraft.game.world;
 
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
+
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.entity.SpawnableMobType;
 import net.minecraft.game.entity.animal.SheepEntity;
@@ -13,6 +15,7 @@
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.world.biome.Biome;
 import net.minecraft.game.world.block.BedBlock;
+import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.game.world.chunk.ChunkCoordIntPair;
 import net.minecraft.game.world.chunk.ChunkPosition;
 import net.minecraft.game.world.material.Material;
@@ -22,12 +25,15 @@
 import net.minecraft.util.MathHelper;
 
 public final class MobSpawner {
-	private static Set eligibleChunksForSpawning = new HashSet();
+	private static LongSet eligibleChunksForSpawning = new LongOpenHashSet();
 	protected static final Class[] nightmareMobs = new Class[]{SpiderEntity.class, ZombieEntity.class, SkeletonEntity.class};
 
 	protected static ChunkPosition getRandomSpawningPointInChunk(World var0, int var1, int var2) {
+		Chunk chunk = var0.getChunkFromBlockCoords(var1, var2);
+		int min = Math.min(chunk.getMinLevel() * 16, 0);
+		int max = Math.max(128, chunk.getMaxLevel() * 16 + 16);
 		int var3 = var1 + var0.rand.nextInt(16);
-		int var4 = var0.rand.nextInt(128);
+		int var4 = var0.rand.nextInt(max - min) + min;
 		int var5 = var2 + var0.rand.nextInt(16);
 		return new ChunkPosition(var3, var4, var5);
 	}
@@ -44,11 +50,13 @@
 				PlayerEntity var4 = (PlayerEntity)var0.playerEntities.get(var3);
 				int var5 = MathHelper.floor(var4.posX / 16.0D);
 				var6 = MathHelper.floor(var4.posZ / 16.0D);
-				byte var7 = 8;
+				int var7 = var0.simulationDistance;
 
 				for(int var8 = -var7; var8 <= var7; ++var8) {
 					for(int var9 = -var7; var9 <= var7; ++var9) {
-						eligibleChunksForSpawning.add(new ChunkCoordIntPair(var8 + var5, var9 + var6));
+						if (var0.chunkExists(var8 + var5, var9 + var6)) {
+							eligibleChunksForSpawning.add(ChunkCoordIntPair.chunkXZ2Int(var8 + var5, var9 + var6));
+						}
 					}
 				}
 			}
@@ -62,7 +70,7 @@
 			for(int var37 = 0; var37 < var6; ++var37) {
 				SpawnableMobType var38 = var36[var37];
 				if((!var38.getPeacefulCreature() || var2) && (var38.getPeacefulCreature() || var1) && var0.countEntities(var38.getCreatureClass()) <= var38.getMaxNumberOfCreature() * eligibleChunksForSpawning.size() / 256) {
-					Iterator var39 = eligibleChunksForSpawning.iterator();
+					LongIterator var39 = eligibleChunksForSpawning.iterator();
 
 					label130:
 					while(true) {
@@ -72,32 +80,39 @@
 						int var42;
 						do {
 							do {
-								ChunkCoordIntPair var10;
-								List var12;
+								long var10;
+								int chunkXPos;
+								int chunkZPos;
+
+								List<SpawnListEntry> var12;
 								do {
 									do {
 										if(!var39.hasNext()) {
 											continue label133;
 										}
 
-										var10 = (ChunkCoordIntPair)var39.next();
-										Biome var11 = var0.getBiomeSource().getBiomeGenAtChunkCoord(var10);
+										var10 = var39.nextLong();
+
+										chunkXPos = ChunkCoordIntPair.getChunkX(var10);
+										chunkZPos = ChunkCoordIntPair.getChunkZ(var10);
+
+										Biome var11 = var0.getBiomeAt(chunkXPos << 4, chunkZPos << 4);
 										var12 = var11.getSpawnableList(var38);
 									} while(var12 == null);
 								} while(var12.isEmpty());
 
 								int var13 = 0;
 
-								for(Iterator var14 = var12.iterator(); var14.hasNext(); var13 += var15.spawnRarityRate) {
-									var15 = (SpawnListEntry)var14.next();
+								for(Iterator<SpawnListEntry> var14 = var12.iterator(); var14.hasNext(); var13 += var15.spawnRarityRate) {
+									var15 = var14.next();
 								}
 
 								int var40 = var0.rand.nextInt(var13);
-								var15 = (SpawnListEntry)var12.get(0);
-								Iterator var16 = var12.iterator();
+								var15 = var12.get(0);
+								Iterator<SpawnListEntry> var16 = var12.iterator();
 
 								while(var16.hasNext()) {
-									SpawnListEntry var17 = (SpawnListEntry)var16.next();
+									SpawnListEntry var17 = var16.next();
 									var40 -= var17.spawnRarityRate;
 									if(var40 < 0) {
 										var15 = var17;
@@ -105,7 +120,7 @@
 									}
 								}
 
-								ChunkPosition var41 = getRandomSpawningPointInChunk(var0, var10.chunkXPos * 16, var10.chunkZPos * 16);
+								ChunkPosition var41 = getRandomSpawningPointInChunk(var0, chunkXPos * 16, chunkZPos * 16);
 								var42 = var41.x;
 								var18 = var41.y;
 								var19 = var41.z;
@@ -207,11 +222,6 @@
 				int var9 = MathHelper.floor(var5.posX) + var0.rand.nextInt(32) - var0.rand.nextInt(32);
 				int var10 = MathHelper.floor(var5.posZ) + var0.rand.nextInt(32) - var0.rand.nextInt(32);
 				int var11 = MathHelper.floor(var5.posY) + var0.rand.nextInt(16) - var0.rand.nextInt(16);
-				if(var11 < 1) {
-					var11 = 1;
-				} else if(var11 > 128) {
-					var11 = 128;
-				}
 
 				int var12 = var0.rand.nextInt(var6.length);
 
@@ -223,7 +233,7 @@
 					++var13;
 				}
 
-				if(var13 < var11 + 16 && var13 < 128) {
+				if(var13 < var11 + 16) {
 					float var14 = (float)var9 + 0.5F;
 					float var15 = (float)var13;
 					float var16 = (float)var10 + 0.5F;
--- net/minecraft/game/world/biome/TaigaBiome.java
+++ net/minecraft/game/world/biome/TaigaBiome.java
@@ -8,11 +8,16 @@
 import net.minecraft.game.world.terrain.feature.SpruceTreeFeature;
 
 public class TaigaBiome extends Biome {
-	public TaigaBiome() {
+	public TaigaBiome(int i) {
+		super(i);
 		this.spawnableCreatureList.add(new SpawnListEntry(WolfEntity.class, 2));
 	}
 
 	public Feature getRandomTreeFeature(Random var1) {
-		return (Feature)(var1.nextInt(3) == 0 ? new SkinnySpruceTreeFeature() : new SpruceTreeFeature());
+		return var1.nextInt(3) == 0 ? new SkinnySpruceTreeFeature() : new SpruceTreeFeature();
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return this.getEnableSnow() ? (treeBonus + treeNoise) * 3: treeBonus + treeNoise * 2 + 5;
 	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerSmooth.java
@@ -1,0 +1,24 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.IntArray2D;
+
+public class LayerSmooth extends Layer {
+	public LayerSmooth(long seed, Layer parent) {
+		super(seed);
+		this.parent = parent;
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		return forEachWithNeighbors(x, z, width, length, (input, ox, oz, neighbors) -> {
+			if (neighbors[0] == neighbors[1] && neighbors[2] == neighbors[3]) {
+				return nextInt(2) == 0 ? neighbors[0] : neighbors[2];
+			} else if (neighbors[2] == neighbors[3]) {
+				return neighbors[2];
+			} else if (neighbors[0] == neighbors[1]) {
+				return neighbors[0];
+			} else {
+				return input;
+			}
+		});
+	}
+}
--- /dev/null
+++ argo/jdom/JsonStringNode.java
@@ -1,0 +1,55 @@
+package argo.jdom;
+
+import java.util.List;
+import java.util.Map;
+
+public final class JsonStringNode extends JsonNode implements Comparable<JsonStringNode> {
+	private final String field_27224_a;
+
+	JsonStringNode(String var1) {
+		if(var1 == null) {
+			throw new NullPointerException("Attempt to construct a JsonString with a null value.");
+		} else {
+			this.field_27224_a = var1;
+		}
+	}
+
+	public JsonNodeType getType() {
+		return JsonNodeType.STRING;
+	}
+
+	public String getText() {
+		return this.field_27224_a;
+	}
+
+	public Map<JsonStringNode, JsonNode> getFields() {
+		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
+	}
+
+	public List<JsonNode> getElements() {
+		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
+	}
+
+	public boolean equals(Object var1) {
+		if(this == var1) {
+			return true;
+		} else if(var1 != null && this.getClass() == var1.getClass()) {
+			JsonStringNode var2 = (JsonStringNode)var1;
+			return this.field_27224_a.equals(var2.field_27224_a);
+		} else {
+			return false;
+		}
+	}
+
+	public int hashCode() {
+		return this.field_27224_a.hashCode();
+	}
+
+	public String toString() {
+		return "JsonStringNode value:[" + this.field_27224_a + "]";
+	}
+
+	public int compareTo(JsonStringNode var1) {
+		return this.field_27224_a.compareTo(var1.field_27224_a);
+	}
+}
--- net/minecraft/client/gui/component/GuiTextField.java
+++ net/minecraft/client/gui/component/GuiTextField.java
@@ -1,30 +1,25 @@
 package net.minecraft.client.gui.component;
 
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
-import net.minecraft.client.gui.Gui;
 import net.minecraft.client.gui.GuiScreen;
 import net.minecraft.util.ChatAllowedCharacters;
 
-public class GuiTextField extends Gui {
+public class GuiTextField extends GuiButton {
 	private final FontRenderer fontRenderer;
-	private final int xPos;
-	private final int yPos;
-	private final int width;
-	private final int height;
 	private String text;
 	private int maxStringLength;
 	private int cursorCounter;
 	public boolean isFocused = false;
-	public boolean isEnabled = true;
 	private GuiScreen parentGuiScreen;
 
 	public GuiTextField(GuiScreen var1, FontRenderer var2, int var3, int var4, int var5, int var6, String var7) {
 		this.parentGuiScreen = var1;
 		this.fontRenderer = var2;
-		this.xPos = var3;
-		this.yPos = var4;
-		this.width = var5;
-		this.height = var6;
+		this.xPosition = var3;
+		this.yPosition = var4;
+		this.buttonWidth = var5;
+		this.buttonHeight = var6;
 		this.setText(var7);
 	}
 
@@ -41,7 +36,7 @@
 	}
 
 	public void textboxKeyTyped(char var1, int var2) {
-		if(this.isEnabled && this.isFocused) {
+		if(this.enabled && this.isFocused) {
 			if(var1 == 9) {
 				this.parentGuiScreen.selectNextField();
 			}
@@ -73,9 +68,10 @@
 		}
 	}
 
-	public void mouseClicked(int var1, int var2, int var3) {
-		boolean var4 = this.isEnabled && var1 >= this.xPos && var1 < this.xPos + this.width && var2 >= this.yPos && var2 < this.yPos + this.height;
+	public boolean mousePressed(Minecraft var1, int var2, int var3) {
+		boolean var4 = super.mousePressed(var1, var2, var3);
 		this.setFocused(var4);
+		return var4;
 	}
 
 	public void setFocused(boolean var1) {
@@ -86,14 +82,19 @@
 		this.isFocused = var1;
 	}
 
-	public void drawTextBox() {
-		this.drawRect(this.xPos - 1, this.yPos - 1, this.xPos + this.width + 1, this.yPos + this.height + 1, -6250336);
-		this.drawRect(this.xPos, this.yPos, this.xPos + this.width, this.yPos + this.height, -16777216);
-		if(this.isEnabled) {
-			boolean var1 = this.isFocused && this.cursorCounter / 6 % 2 == 0;
-			this.drawString(this.fontRenderer, this.text + (var1 ? "_" : ""), this.xPos + 4, this.yPos + (this.height - 8) / 2, 14737632);
+	public void drawButton(Minecraft var1, int var2, int var3) {
+		int sx = this.getScaledX();
+		int sy = this.getScaledY();
+		int sw = this.getScaledWidth();
+		int sh = this.getScaledHeight();
+
+		this.drawRect(sx - 1, sy - 1, sx + sw + 1, sy + sh + 1, -6250336);
+		this.drawRect(sx, sy, sx + sw, sy + sh, -16777216);
+		if(this.enabled) {
+			boolean cursor = this.isFocused && this.cursorCounter / 6 % 2 == 0;
+			this.drawString(this.fontRenderer, this.text + (cursor ? "_" : ""), sx + 4, sy + (sh - 8) / 2, 14737632);
 		} else {
-			this.drawString(this.fontRenderer, this.text, this.xPos + 4, this.yPos + (this.height - 8) / 2, 7368816);
+			this.drawString(this.fontRenderer, this.text, sx + 4, sy + (sh - 8) / 2, 7368816);
 		}
 
 	}
--- argo/EnumJsonNodeTypeMappingHelper.java
+++ /dev/null
@@ -1,43 +1,0 @@
-package argo;
-
-class EnumJsonNodeTypeMappingHelper {
-	static final int[] field_27341_a = new int[EnumJsonNodeType.values().length];
-
-	static {
-		try {
-			field_27341_a[EnumJsonNodeType.ARRAY.ordinal()] = 1;
-		} catch (NoSuchFieldError var7) {
-		}
-
-		try {
-			field_27341_a[EnumJsonNodeType.OBJECT.ordinal()] = 2;
-		} catch (NoSuchFieldError var6) {
-		}
-
-		try {
-			field_27341_a[EnumJsonNodeType.STRING.ordinal()] = 3;
-		} catch (NoSuchFieldError var5) {
-		}
-
-		try {
-			field_27341_a[EnumJsonNodeType.NUMBER.ordinal()] = 4;
-		} catch (NoSuchFieldError var4) {
-		}
-
-		try {
-			field_27341_a[EnumJsonNodeType.FALSE.ordinal()] = 5;
-		} catch (NoSuchFieldError var3) {
-		}
-
-		try {
-			field_27341_a[EnumJsonNodeType.TRUE.ordinal()] = 6;
-		} catch (NoSuchFieldError var2) {
-		}
-
-		try {
-			field_27341_a[EnumJsonNodeType.NULL.ordinal()] = 7;
-		} catch (NoSuchFieldError var1) {
-		}
-
-	}
-}
--- /dev/null
+++ argo/jdom/JsonNodeSelectors.java
@@ -1,0 +1,207 @@
+package argo.jdom;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+public final class JsonNodeSelectors {
+	public static JsonNodeSelector func_27349_a(Object... var0) {
+		return chainOn(var0, new JsonNodeSelector(new StringSelector()));
+	}
+
+	public static JsonNodeSelector func_27346_b(Object... var0) {
+		return chainOn(var0, new JsonNodeSelector(new Array()));
+	}
+
+	public static JsonNodeSelector func_27353_c(Object... var0) {
+		return chainOn(var0, new JsonNodeSelector(new ObjectSelector()));
+	}
+
+	public static JsonNodeSelector func_27348_a(String var0) {
+		return func_27350_a(JsonNodeFactories.aJsonString(var0));
+	}
+
+	public static JsonNodeSelector func_27350_a(JsonStringNode var0) {
+		return new JsonNodeSelector(new Field(var0));
+	}
+
+	public static JsonNodeSelector func_27351_b(String var0) {
+		return func_27353_c().with(func_27348_a(var0));
+	}
+
+	public static JsonNodeSelector func_27347_a(int var0) {
+		return new JsonNodeSelector(new Element(var0));
+	}
+
+	public static JsonNodeSelector func_27354_b(int var0) {
+		return func_27346_b().with(func_27347_a(var0));
+	}
+
+	private static JsonNodeSelector chainOn(Object[] var0, JsonNodeSelector var1) {
+		JsonNodeSelector var2 = var1;
+
+		for(int var3 = var0.length - 1; var3 >= 0; --var3) {
+			if(var0[var3] instanceof Integer) {
+				var2 = chainedJsonNodeSelector(func_27354_b((Integer) var0[var3]), var2);
+			} else {
+				if(!(var0[var3] instanceof String)) {
+					throw new IllegalArgumentException("Element [" + var0[var3] + "] of path elements" + " [" + Arrays.toString(var0) + "] was of illegal type [" + var0[var3].getClass().getCanonicalName() + "]; only Integer and String are valid.");
+				}
+
+				var2 = chainedJsonNodeSelector(func_27351_b((String)var0[var3]), var2);
+			}
+		}
+
+		return var2;
+	}
+
+	private static JsonNodeSelector chainedJsonNodeSelector(JsonNodeSelector var0, JsonNodeSelector var1) {
+		return new JsonNodeSelector(new ChainedFunctor(var0, var1));
+	}
+
+	static final class Array extends LeafFunctor {
+		public boolean matchesNode(JsonNode var1) {
+			return JsonNodeType.ARRAY == var1.getType();
+		}
+
+		public String shortForm() {
+			return "A short form array";
+		}
+
+		public List<JsonNode> typeSafeApplyTo(JsonNode var1) {
+			return var1.getElements();
+		}
+
+		public String toString() {
+			return "an array";
+		}
+
+		public Object typeSafeApplyTo(Object var1) {
+			return this.typeSafeApplyTo((JsonNode)var1);
+		}
+
+		public boolean matchesNode(Object var1) {
+			return this.matchesNode((JsonNode)var1);
+		}
+	}
+
+	static final class Element extends LeafFunctor {
+		final int index;
+
+		Element(int var1) {
+			this.index = var1;
+		}
+
+		public boolean matchesNode(List<JsonNode> var1) {
+			return var1.size() > this.index;
+		}
+
+		public String shortForm() {
+			return Integer.toString(this.index);
+		}
+
+		public JsonNode typeSafeApplyTo(List<JsonNode> var1) {
+			return var1.get(this.index);
+		}
+
+		public String toString() {
+			return "an element at index [" + this.index + "]";
+		}
+
+		@SuppressWarnings("unchecked")
+		public Object typeSafeApplyTo(Object var1) {
+			return this.typeSafeApplyTo((List<JsonNode>)var1);
+		}
+
+		@SuppressWarnings("unchecked")
+		public boolean matchesNode(Object var1) {
+			return this.matchesNode((List<JsonNode>)var1);
+		}
+	}
+
+	static final class Field extends LeafFunctor {
+		final JsonStringNode field_27066_a;
+
+		Field(JsonStringNode var1) {
+			this.field_27066_a = var1;
+		}
+
+		public boolean matchesNode(Map<JsonStringNode, JsonNode> var1) {
+			return var1.containsKey(this.field_27066_a);
+		}
+
+		public String shortForm() {
+			return "\"" + this.field_27066_a.getText() + "\"";
+		}
+
+		public JsonNode typeSafeApplyTo(Map<JsonStringNode, JsonNode> var1) {
+			return var1.get(this.field_27066_a);
+		}
+
+		public String toString() {
+			return "a field called [\"" + this.field_27066_a.getText() + "\"]";
+		}
+
+		@SuppressWarnings("unchecked")
+		public Object typeSafeApplyTo(Object var1) {
+			return this.typeSafeApplyTo((Map<JsonStringNode, JsonNode>)var1);
+		}
+
+		@SuppressWarnings("unchecked")
+		public boolean matchesNode(Object var1) {
+			return this.matchesNode((Map<JsonStringNode, JsonNode>)var1);
+		}
+	}
+
+	static final class ObjectSelector extends LeafFunctor {
+		public boolean matchesNode(JsonNode var1) {
+			return JsonNodeType.OBJECT == var1.getType();
+		}
+
+		public String shortForm() {
+			return "A short form object";
+		}
+
+		public Map<JsonStringNode, JsonNode> typeSafeApplyTo(JsonNode var1) {
+			return var1.getFields();
+		}
+
+		public String toString() {
+			return "an object";
+		}
+
+		public Object typeSafeApplyTo(Object var1) {
+			return this.typeSafeApplyTo((JsonNode)var1);
+		}
+
+		public boolean matchesNode(Object var1) {
+			return this.matchesNode((JsonNode)var1);
+		}
+	}
+
+	static final class StringSelector extends LeafFunctor {
+		public boolean matchesNode(JsonNode var1) {
+			return JsonNodeType.STRING == var1.getType();
+		}
+
+		public String shortForm() {
+			return "A short form string";
+		}
+
+		public String typeSafeApplyTo(JsonNode var1) {
+			return var1.getText();
+		}
+
+		public String toString() {
+			return "a value that is a string";
+		}
+
+		public Object typeSafeApplyTo(Object var1) {
+			return this.typeSafeApplyTo((JsonNode)var1);
+		}
+
+		public boolean matchesNode(Object var1) {
+			return this.matchesNode((JsonNode)var1);
+		}
+	}
+}
--- net/minecraft/game/world/BlockAccess.java
+++ net/minecraft/game/world/BlockAccess.java
@@ -1,25 +1,47 @@
 package net.minecraft.game.world;
 
+import net.minecraft.game.world.biome.BiomeSource;
 import net.minecraft.game.world.biome.ClimaticBiomeSource;
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.block.properties.Property;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
 
 public interface BlockAccess {
 	int getBlockId(int var1, int var2, int var3);
 
+	default Block getBlock(int var1, int var2, int var3) {
+		return Block.blocksList[this.getBlockId(var1, var2, var3)];
+	}
+
+	default Material getBlockMaterial(int var1, int var2, int var3) {
+		int var4 = this.getBlockId(var1, var2, var3);
+		return var4 == 0 ? Material.air : Block.blocksList[var4].material;
+	}
+
+	default boolean isBlockOpaqueCube(int var1, int var2, int var3) {
+		Block var4 = Block.blocksList[this.getBlockId(var1, var2, var3)];
+		return var4 == null ? false : var4.isOpaqueCube();
+	}
+
+	default boolean isBlockNormalCube(int var1, int var2, int var3) {
+		Block var4 = Block.blocksList[this.getBlockId(var1, var2, var3)];
+		return var4 == null ? false : var4.material.isOpaque() && var4.renderAsNormalBlock();
+	}
+
+	int getBlockMetadata(int var1, int var2, int var3);
+
+	<T> T getBlockProperty(int x, int y, int z, Property<T> property);
+
+	int getBlockIntProperty(int x, int y, int z, Property<?> property);
+
+	boolean getBlockBooleanProperty(int x, int y, int z, Property<?> property);
+
 	TileEntity getBlockTileEntity(int var1, int var2, int var3);
 
 	float getBrightness(int var1, int var2, int var3, int var4);
 
 	float getLightBrightness(int var1, int var2, int var3);
 
-	int getBlockMetadata(int var1, int var2, int var3);
-
-	Material getBlockMaterial(int var1, int var2, int var3);
-
-	boolean isBlockOpaqueCube(int var1, int var2, int var3);
-
-	boolean isBlockNormalCube(int var1, int var2, int var3);
-
-	ClimaticBiomeSource getBiomeSource();
+	BiomeSource getBiomeSource();
 }
--- /dev/null
+++ argo/jdom/JsonNodeFactories.java
@@ -1,0 +1,38 @@
+package argo.jdom;
+
+import java.util.Arrays;
+import java.util.Map;
+
+public final class JsonNodeFactories {
+	public static JsonNode aJsonNull() {
+		return JsonConstants.NULL;
+	}
+
+	public static JsonNode aJsonTrue() {
+		return JsonConstants.TRUE;
+	}
+
+	public static JsonNode aJsonFalse() {
+		return JsonConstants.FALSE;
+	}
+
+	public static JsonStringNode aJsonString(String var0) {
+		return new JsonStringNode(var0);
+	}
+
+	public static JsonNode aJsonNumber(String var0) {
+		return new JsonNumberNode(var0);
+	}
+
+	public static JsonRootNode aJsonArray(Iterable<JsonNode> var0) {
+		return new JsonArray(var0);
+	}
+
+	public static JsonRootNode aJsonArray(JsonNode... var0) {
+		return aJsonArray(Arrays.asList(var0));
+	}
+
+	public static JsonRootNode aJsonObject(Map<JsonStringNode, JsonNode> var0) {
+		return new JsonObject(var0);
+	}
+}
--- net/minecraft/game/entity/animal/SquidEntity.java
+++ net/minecraft/game/entity/animal/SquidEntity.java
@@ -56,19 +56,6 @@
 		return 0.4F;
 	}
 
-	protected int getDropItemId() {
-		return 0;
-	}
-
-	protected void dropFewItems() {
-		int var1 = this.rand.nextInt(3) + 1;
-
-		for(int var2 = 0; var2 < var1; ++var2) {
-			this.entityDropItem(new ItemStack(Item.dye, 1, 0), 0.0F);
-		}
-
-	}
-
 	public boolean onInteract(PlayerEntity var1) {
 		return false;
 	}
--- net/minecraft/game/world/terrain/feature/SkinnySpruceTreeFeature.java
+++ net/minecraft/game/world/terrain/feature/SkinnySpruceTreeFeature.java
@@ -6,80 +6,68 @@
 
 public class SkinnySpruceTreeFeature extends Feature {
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
-		int var6 = var2.nextInt(5) + 7;
+		int var6 = var2.nextInt(7) + 7;
 		int var7 = var6 - var2.nextInt(2) - 3;
 		int var8 = var6 - var7;
-		int var9 = 1 + var2.nextInt(var8 + 1);
+		int var9 = 2 + var2.nextInt(var8 + 1);
 		boolean var10 = true;
-		if(var4 >= 1 && var4 + var6 + 1 <= 128) {
-			int var11;
-			int var13;
-			int var14;
-			int var15;
-			int var18;
-			for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
-				boolean var12 = true;
-				if(var11 - var4 < var7) {
-					var18 = 0;
-				} else {
-					var18 = var9;
-				}
-
-				for(var13 = var3 - var18; var13 <= var3 + var18 && var10; ++var13) {
-					for(var14 = var5 - var18; var14 <= var5 + var18 && var10; ++var14) {
-						if(var11 >= 0 && var11 < 128) {
-							var15 = var1.getBlockId(var13, var11, var14);
-							if(var15 != 0 && var15 != Block.leaves.blockID) {
-								var10 = false;
-							}
-						} else {
-							var10 = false;
-						}
-					}
-				}
-			}
-
-			if(!var10) {
-				return false;
+		int var11;
+		int var13;
+		int var14;
+		int var15;
+		int var18;
+		for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
+			boolean var12 = true;
+			if(var11 - var4 < var7) {
+				var18 = 0;
 			} else {
-				var11 = var1.getBlockId(var3, var4 - 1, var5);
-				if((var11 == Block.grass.blockID || var11 == Block.dirt.blockID) && var4 < 128 - var6 - 1) {
-					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
-					var18 = 0;
-
-					for(var13 = var4 + var6; var13 >= var4 + var7; --var13) {
-						for(var14 = var3 - var18; var14 <= var3 + var18; ++var14) {
-							var15 = var14 - var3;
-
-							for(int var16 = var5 - var18; var16 <= var5 + var18; ++var16) {
-								int var17 = var16 - var5;
-								if((Math.abs(var15) != var18 || Math.abs(var17) != var18 || var18 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var14, var13, var16)]) {
-									var1.setBlockAndMetadata(var14, var13, var16, Block.leaves.blockID, 1);
-								}
-							}
-						}
-
-						if(var18 >= 1 && var13 == var4 + var7 + 1) {
-							--var18;
-						} else if(var18 < var9) {
-							++var18;
-						}
-					}
-
-					for(var13 = 0; var13 < var6 - 1; ++var13) {
-						var14 = var1.getBlockId(var3, var4 + var13, var5);
-						if(var14 == 0 || var14 == Block.leaves.blockID) {
-							var1.setBlockAndMetadata(var3, var4 + var13, var5, Block.log.blockID, 1);
-						}
-					}
-
-					return true;
-				} else {
-					return false;
+				var18 = var9;
+			}
+
+			for(var13 = var3 - var18; var13 <= var3 + var18 && var10; ++var13) {
+				for(var14 = var5 - var18; var14 <= var5 + var18 && var10; ++var14) {
+					var15 = var1.getBlockId(var13, var11, var14);
+					if(var15 != 0 && var15 != Block.leaves.blockID) {
+						var10 = false;
+					}
 				}
 			}
-		} else {
+		}
+
+		if(!var10) {
 			return false;
+		} else {
+			if (!Block.sapling.canPlaceBlockAt(var1, var3, var4, var5)) return false;
+			if (var1.getBlockId(var3, var4 - 1, var5) == Block.grass.blockID) var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+			var18 = 0;
+
+			for(var13 = var4 + var6; var13 >= var4 + var7; --var13) {
+				for(var14 = var3 - var18; var14 <= var3 + var18; ++var14) {
+					var15 = var14 - var3;
+
+					for(int var16 = var5 - var18; var16 <= var5 + var18; ++var16) {
+						int var17 = var16 - var5;
+						if((Math.abs(var15) != var18 || Math.abs(var17) != var18 || var18 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var14, var13, var16)]) {
+							var1.setBlockAndMetadata(var14, var13, var16, Block.leaves.blockID, 1);
+						}
+					}
+				}
+
+				if(var18 >= 1 && var13 == var4 + var7 + 1) {
+					--var18;
+				} else if(var18 < var9) {
+					++var18;
+				}
+			}
+
+			for(var13 = 0; var13 < var6 - 1; ++var13) {
+				var14 = var1.getBlockId(var3, var4 + var13, var5);
+				if(var14 == 0 || var14 == Block.leaves.blockID) {
+					var1.setBlockAndMetadata(var3, var4 + var13, var5, Block.log.blockID, 1);
+				}
+			}
+
+			return true;
 		}
 	}
 }
--- /dev/null
+++ net/minecraft/game/world/block/properties/Property.java
@@ -1,0 +1,26 @@
+package net.minecraft.game.world.block.properties;
+
+public interface Property<T> {
+	T getValue(int metadataSlice);
+
+	int getIntValue(T value);
+
+	String toString(T value);
+
+	String getName();
+
+	int getSize();
+
+	default boolean supportDynamicSize() {
+		return true;
+	}
+
+	default String toString(int value) {
+		return this.toString(this.getValue(value));
+	}
+
+	static void checkBounds(int size, int requiredSize) {
+		if (size <= 0) size += PropertyList.MAX_BITS;
+		if (size < requiredSize) throw new IllegalArgumentException("Size is too small");
+	}
+}
--- net/minecraft/game/world/block/LeavesBlock.java
+++ net/minecraft/game/world/block/LeavesBlock.java
@@ -1,41 +1,95 @@
 package net.minecraft.game.world.block;
 
+import java.util.Arrays;
+import java.util.Objects;
 import java.util.Random;
 import net.minecraft.client.render.color.ColorizerFoliage;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.item.Item;
 import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.item.LeavesItem;
 import net.minecraft.game.stats.StatList;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.BiomeColorType;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
+import net.minecraft.game.world.block.properties.StringProperty;
 import net.minecraft.game.world.material.Material;
+import net.minecraft.game.world.terrain.noise.PerlinNoise;
+import net.minecraft.util.MathHelper;
 
 public class LeavesBlock extends BaseLeavesBlock {
-	private int baseIndexInPNG;
-	int[] adjacentTreeBlocks;
+	private static final int TEX_FLOWERS = TerrainLayout.texCoord("leaf_flowers");
+	private static final int[] TEX_TYPES = TerrainLayout.varyingTexCoord("leaves", SharedProperties.WOOD_NAMES);
+	private static final int[] TEX_TYPES_FAST = TerrainLayout.varyingTexCoord("leaves_fast", SharedProperties.WOOD_NAMES);
+	private static final int[] TEX_TYPES_BLOOMING = Arrays.stream(TEX_TYPES).map(t -> TerrainLayout.combine(t, TEX_FLOWERS)).toArray();
+	private static final int[] TEX_TYPES_BLOOMING_FAST = Arrays.stream(TEX_TYPES_FAST).map(t -> TerrainLayout.combine(t, TEX_FLOWERS)).toArray();
+
+	public static final StringProperty TYPE = SharedProperties.woodProperty("type", 6);
+	public static final BooleanProperty BLOOMING = new BooleanProperty("blooming");
+	public static final BooleanProperty DECAYING = new BooleanProperty("decaying");
+
+	private static final PerlinNoise MAPLE_NOISE = new PerlinNoise(new Random("oh so pwetty :3".hashCode()));
+	private static final PerlinNoise BLOOMING_MAPLE_NOISE = new PerlinNoise(new Random(":O cute flowers! ^w^".hashCode()));
+
+	private int[] adjacentTreeBlocks;
 
 	protected LeavesBlock(int var1, int var2) {
-		super(var1, var2, Material.leaves, false);
-		this.baseIndexInPNG = var2;
+		super(var1, var2, Material.leaves);
 		this.setTickOnLoad(true);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(TYPE, BLOOMING, DECAYING);
+	}
+
+	protected Item getItem() {
+		return new LeavesItem(this.blockID - 256);
+	}
+
 	public int getInventoryColor(int var1) {
-		return (var1 & 1) == 1 ? ColorizerFoliage.getFoliageColorPine() : ((var1 & 2) == 2 ? ColorizerFoliage.getFoliageColorBirch() : ColorizerFoliage.func_31073_c());
+		boolean blooming = this.properties.getBoolean(var1, BLOOMING);
+		var1 = this.properties.getInt(var1, TYPE);
+		return var1 == 1 ? ColorizerFoliage.getFoliageColorPine()
+				: var1 == 2 ? blooming
+						? ColorizerFoliage.getFoliageColorBloomingMaple()
+						: ColorizerFoliage.getFoliageColorMaple()
+				: var1 == 3 ? ColorizerFoliage.getFoliageColorMahogany()
+				: var1 == 4 ? ColorizerFoliage.getFoliageColorWillow()
+				: ColorizerFoliage.func_31073_c();
 	}
 
 	public int getColorMultiplier(BlockAccess var1, int var2, int var3, int var4) {
-		int var5 = var1.getBlockMetadata(var2, var3, var4);
-		if((var5 & 1) == 1) {
+		int metadata = var1.getBlockMetadata(var2, var3, var4);
+		int woodType = properties.getInt(metadata, TYPE);
+		boolean blooming = properties.getBoolean(metadata, BLOOMING);
+		if(woodType == 1) {
 			return ColorizerFoliage.getFoliageColorPine();
-		} else if((var5 & 2) == 2) {
-			return ColorizerFoliage.getFoliageColorBirch();
+		} else if(woodType == 2) {
+			if (blooming) {
+				if (this.graphicsLevel > 1) {
+					double colorFactor = MathHelper.clamp(MAPLE_NOISE.generateNoise3D(var2 * 0.01D, var3 * 0.01D, var4 * 0.01D) + 0.5D, 0.0D, 1.0D);
+					int r = (int)MathHelper.lerp(255, 225, colorFactor);
+					int g = (int)MathHelper.lerp(120, 160, colorFactor);
+					int b = (int)MathHelper.lerp(215, 255, colorFactor);
+					return r << 16 | g << 8 | b;
+				}
+				return ColorizerFoliage.getFoliageColorBloomingMaple();
+			} else {
+				if (this.graphicsLevel > 1) {
+					double colorFactor = MathHelper.clamp(MAPLE_NOISE.generateNoise3D(var2 * 0.01D, var3 * 0.01D, var4 * 0.01D) + 0.5D, 0.0D, 1.0D);
+					int r = 255;
+					int g = (int)MathHelper.lerp(50, 150, colorFactor);
+					int b = (int)MathHelper.lerp(80, 60, colorFactor);
+					return r << 16 | g << 8 | b;
+				}
+				return ColorizerFoliage.getFoliageColorMaple();
+			}
 		} else {
-			var1.getBiomeSource().getBlockGeneratorData(var2, var4, 1, 1);
-			double var6 = var1.getBiomeSource().temperature[0];
-			double var8 = var1.getBiomeSource().humidity[0];
-			return ColorizerFoliage.getFoliageColor(var6, var8);
+			return var1.getBiomeSource().getColorAt(var2, var4, BiomeColorType.FOLIAGE);
 		}
 	}
 
@@ -48,8 +102,7 @@
 					for(int var9 = -var5; var9 <= var5; ++var9) {
 						int var10 = var1.getBlockId(var2 + var7, var3 + var8, var4 + var9);
 						if(var10 == Block.leaves.blockID) {
-							int var11 = var1.getBlockMetadata(var2 + var7, var3 + var8, var4 + var9);
-							var1.setBlockMetadata(var2 + var7, var3 + var8, var4 + var9, var11 | 8);
+							var1.setBlockProperty(var2, var3, var4, DECAYING, true);
 						}
 					}
 				}
@@ -60,8 +113,7 @@
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(!var1.remoteWorld) {
-			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			if((var6 & 8) != 0) {
+			if(var1.getBlockBooleanProperty(var2, var3, var4, DECAYING)) {
 				byte var7 = 4;
 				int var8 = var7 + 1;
 				byte var9 = 32;
@@ -143,7 +195,7 @@
 
 				var12 = this.adjacentTreeBlocks[var11 * var10 + var11 * var9 + var11];
 				if(var12 >= 0) {
-					var1.setBlockMetadata(var2, var3, var4, var6 & -9);
+					var1.setBlockProperty(var2, var3, var4, DECAYING, false);
 				} else {
 					this.removeLeaves(var1, var2, var3, var4);
 				}
@@ -153,7 +205,7 @@
 	}
 
 	private void removeLeaves(World var1, int var2, int var3, int var4) {
-		this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+		this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockIntProperty(var2, var3, var4, TYPE));
 		var1.setBlockWithNotify(var2, var3, var4, 0);
 	}
 
@@ -176,20 +228,36 @@
 	}
 
 	protected int damageDropped(int var1) {
-		return var1 & 3;
+		return var1 & 127;
 	}
 
 	public boolean isOpaqueCube() {
-		return !this.fancyGraphics;
+		return this.graphicsLevel <= 0;
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return (var2 & 3) == 1 ? this.textureIndex + 80 : this.textureIndex;
-	}
-
-	public void setGraphicsLevel(boolean var1) {
-		this.fancyGraphics = var1;
-		this.textureIndex = this.baseIndexInPNG + (var1 ? 0 : 1);
+		boolean blooming = this.properties.getBoolean(var2, BLOOMING);
+		var2 = this.properties.getInt(var2, TYPE);
+		if (var2 >= TEX_TYPES.length) var2 = 0;
+		return this.graphicsLevel > 0
+				? blooming ? TEX_TYPES_BLOOMING[var2] : TEX_TYPES[var2]
+				: blooming ? TEX_TYPES_BLOOMING_FAST[var2] : TEX_TYPES_FAST[var2];
+	}
+
+	public int getBlockTexture(BlockAccess var1, int var2, int var3, int var4, int var5) {
+		int metadata = var1.getBlockMetadata(var2, var3, var4);
+		if (this.properties.getBoolean(metadata, BLOOMING)) {
+			if (this.graphicsLevel < 2 && this.properties.getInt(metadata, TYPE) == 2) {
+				metadata = this.properties.set(metadata, BLOOMING, false);
+			} else {
+				metadata = this.properties.set(metadata, BLOOMING, BLOOMING_MAPLE_NOISE.generateNoise3D(var2, var3, var4) > 0.15D);
+			}
+		}
+		return this.getBlockTextureFromSideAndMetadata(var5, metadata);
+	}
+
+	public void setGraphicsLevel(int var1) {
+		this.graphicsLevel = var1;
 	}
 
 	public void onEntityWalking(World var1, int var2, int var3, int var4, Entity var5) {
--- net/minecraft/game/entity/EntityProperties.java
+++ net/minecraft/game/entity/EntityProperties.java
@@ -3,18 +3,16 @@
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
+import java.util.stream.Collectors;
+
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.BlockPos;
 import net.minecraft.network.packet.Packet;
 
 public class EntityProperties {
 	private static final HashMap dataTypes = new HashMap();
-	private final Map properties = new HashMap();
+	private final Map<Integer, EntityProperty> properties = new HashMap();
 	private boolean objectChanged;
 
 	public void addProperty(int var1, Object var2) {
@@ -23,28 +21,28 @@
 			throw new IllegalArgumentException("Unknown data type: " + var2.getClass());
 		} else if(var1 > 31) {
 			throw new IllegalArgumentException("Data value id is too big with " + var1 + "! (Max is " + 31 + ")");
-		} else if(this.properties.containsKey(Integer.valueOf(var1))) {
+		} else if(this.properties.containsKey(var1)) {
 			throw new IllegalArgumentException("Duplicate id value for " + var1 + "!");
 		} else {
-			EntityProperty var4 = new EntityProperty(var3.intValue(), var1, var2);
-			this.properties.put(Integer.valueOf(var1), var4);
+			EntityProperty var4 = new EntityProperty(var3, var1, var2);
+			this.properties.put(var1, var4);
 		}
 	}
 
 	public byte getByte(int var1) {
-		return ((Byte)((EntityProperty)this.properties.get(Integer.valueOf(var1))).getObject()).byteValue();
+		return (Byte) this.properties.get(var1).getObject();
 	}
 
 	public int getInt(int var1) {
-		return ((Integer)((EntityProperty)this.properties.get(Integer.valueOf(var1))).getObject()).intValue();
+		return (Integer) this.properties.get(var1).getObject();
 	}
 
 	public String getString(int var1) {
-		return (String)((EntityProperty)this.properties.get(Integer.valueOf(var1))).getObject();
+		return (String) this.properties.get(var1).getObject();
 	}
 
 	public void updateProperty(int var1, Object var2) {
-		EntityProperty var3 = (EntityProperty)this.properties.get(Integer.valueOf(var1));
+		EntityProperty var3 = this.properties.get(var1);
 		if(!var2.equals(var3.getObject())) {
 			var3.setObject(var2);
 			var3.setWatching(true);
@@ -108,16 +106,16 @@
 		var0.writeByte(var2);
 		switch(var1.getObjectType()) {
 		case 0:
-			var0.writeByte(((Byte)var1.getObject()).byteValue());
+			var0.writeByte((Byte) var1.getObject());
 			break;
 		case 1:
-			var0.writeShort(((Short)var1.getObject()).shortValue());
+			var0.writeShort((Short) var1.getObject());
 			break;
 		case 2:
-			var0.writeInt(((Integer)var1.getObject()).intValue());
+			var0.writeInt((Integer) var1.getObject());
 			break;
 		case 3:
-			var0.writeFloat(((Float)var1.getObject()).floatValue());
+			var0.writeFloat((Float) var1.getObject());
 			break;
 		case 4:
 			Packet.writeString((String)var1.getObject(), var0);
@@ -150,16 +148,16 @@
 			EntityProperty var5 = null;
 			switch(var3) {
 			case 0:
-				var5 = new EntityProperty(var3, var4, Byte.valueOf(var0.readByte()));
+				var5 = new EntityProperty(var3, var4, var0.readByte());
 				break;
 			case 1:
-				var5 = new EntityProperty(var3, var4, Short.valueOf(var0.readShort()));
+				var5 = new EntityProperty(var3, var4, var0.readShort());
 				break;
 			case 2:
-				var5 = new EntityProperty(var3, var4, Integer.valueOf(var0.readInt()));
+				var5 = new EntityProperty(var3, var4, var0.readInt());
 				break;
 			case 3:
-				var5 = new EntityProperty(var3, var4, Float.valueOf(var0.readFloat()));
+				var5 = new EntityProperty(var3, var4, var0.readFloat());
 				break;
 			case 4:
 				var5 = new EntityProperty(var3, var4, Packet.readString(var0, 64));
@@ -188,7 +186,7 @@
 
 		while(var2.hasNext()) {
 			EntityProperty var3 = (EntityProperty)var2.next();
-			EntityProperty var4 = (EntityProperty)this.properties.get(Integer.valueOf(var3.getDataValueId()));
+			EntityProperty var4 = this.properties.get(var3.getDataValueId());
 			if(var4 != null) {
 				var4.setObject(var3.getObject());
 			}
@@ -196,13 +194,30 @@
 
 	}
 
+	public String[] getDebugInfo() {
+		String[] lines = new String[this.properties.size()];
+		Set<Map.Entry<Integer, EntityProperty>> sortedProperties = this.properties.entrySet().stream()
+				.sorted(Comparator.comparingInt(Map.Entry::getKey))
+				.collect(Collectors.toCollection(LinkedHashSet::new));
+		int i = 0;
+		for (Map.Entry<Integer, EntityProperty> property : sortedProperties) {
+			Object obj = property.getValue().getObject();
+			lines[i++] = String.format("0x%02X§7=§f%s", property.getKey(),
+					obj instanceof Byte ? String.format("%02X", obj)
+					: obj instanceof Short ? String.format("%04X", obj)
+					: obj instanceof Integer ? String.format("%08X", obj)
+					: obj.toString());
+		}
+		return lines;
+	}
+
 	static {
-		dataTypes.put(Byte.class, Integer.valueOf(0));
-		dataTypes.put(Short.class, Integer.valueOf(1));
-		dataTypes.put(Integer.class, Integer.valueOf(2));
-		dataTypes.put(Float.class, Integer.valueOf(3));
-		dataTypes.put(String.class, Integer.valueOf(4));
-		dataTypes.put(ItemStack.class, Integer.valueOf(5));
-		dataTypes.put(BlockPos.class, Integer.valueOf(6));
+		dataTypes.put(Byte.class, 0);
+		dataTypes.put(Short.class, 1);
+		dataTypes.put(Integer.class, 2);
+		dataTypes.put(Float.class, 3);
+		dataTypes.put(String.class, 4);
+		dataTypes.put(ItemStack.class, 5);
+		dataTypes.put(BlockPos.class, 6);
 	}
 }
--- net/minecraft/game/world/chunk/loader/ChunkLoaderImpl.java
+++ net/minecraft/game/world/chunk/loader/ChunkLoaderImpl.java
@@ -8,12 +8,16 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Iterator;
+import java.util.Set;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.EntityRegistry;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.WorldInfo;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.chunk.ChunkSection;
 import net.minecraft.util.NibbleArray;
 
 public class ChunkLoaderImpl implements ChunkLoader {
@@ -51,6 +55,11 @@
 		return !var6.exists() && !this.createIfNecessary ? null : var6;
 	}
 
+	public boolean chunkExists(int var1, int var2) {
+		File file = this.chunkFileForXZ(var1, var2);
+		return file != null && file.exists();
+	}
+
 	public Chunk loadChunk(World var1, int var2, int var3) throws IOException {
 		File var4 = this.chunkFileForXZ(var2, var3);
 		if(var4 != null && var4.exists()) {
@@ -62,7 +71,7 @@
 					return null;
 				}
 
-				if(!var6.getCompoundTag("Level").hasKey("Blocks")) {
+				if(!var6.getCompoundTag("Level").hasKey("Sections")) {
 					System.out.println("Chunk file at " + var2 + "," + var3 + " is missing block data, skipping");
 					return null;
 				}
@@ -120,22 +129,24 @@
 		var2.setInteger("xPos", var0.xPosition);
 		var2.setInteger("zPos", var0.zPosition);
 		var2.setLong("LastUpdate", var1.getWorldTime());
-		var2.setByteArray("Blocks", var0.blocks);
-		var2.setByteArray("Data", var0.data.data);
-		var2.setByteArray("SkyLight", var0.skylightMap.data);
-		var2.setByteArray("BlockLight", var0.blocklightMap.data);
-		var2.setByteArray("HeightMap", var0.heightMap);
+		var2.setIntArray("HeightMap", var0.heightMap);
 		var2.setBoolean("TerrainPopulated", var0.isTerrainPopulated);
 		var0.hasEntities = false;
+
+		ListTag sectionList = new ListTag();
+		for (Int2ObjectMap.Entry<ChunkSection> kv : var0.sections.int2ObjectEntrySet()) {
+			ChunkSection section = kv.getValue();
+			if (!section.isEmpty()) {
+				sectionList.setTag(section.toNBT(kv.getIntKey()));
+			}
+		}
+		var2.setTag("Sections", sectionList);
+		var2.setByteArray("Biomes", var0.getBiomeArray());
+
 		ListTag var3 = new ListTag();
-
-		Iterator var5;
 		CompoundTag var7;
-		for(int var4 = 0; var4 < var0.entities.length; ++var4) {
-			var5 = var0.entities[var4].iterator();
-
-			while(var5.hasNext()) {
-				Entity var6 = (Entity)var5.next();
+		for(Set<Entity> entitySet : var0.entities.values()) {
+			for(Entity var6 : entitySet) {
 				var0.hasEntities = true;
 				var7 = new CompoundTag();
 				if(var6.addEntityID(var7)) {
@@ -146,14 +157,12 @@
 
 		var2.setTag("Entities", var3);
 		ListTag var8 = new ListTag();
-		var5 = var0.chunkTileEntityMap.values().iterator();
 
-		while(var5.hasNext()) {
-			TileEntity var9 = (TileEntity)var5.next();
-			var7 = new CompoundTag();
-			var9.writeToNBT(var7);
-			var8.setTag(var7);
-		}
+        for (TileEntity var9 : var0.chunkTileEntityMap.values()) {
+            var7 = new CompoundTag();
+            var9.writeToNBT(var7);
+            var8.setTag(var7);
+        }
 
 		var2.setTag("TileEntities", var8);
 	}
@@ -162,25 +171,25 @@
 		int var2 = var1.getInteger("xPos");
 		int var3 = var1.getInteger("zPos");
 		Chunk var4 = new Chunk(var0, var2, var3);
-		var4.blocks = var1.getByteArray("Blocks");
-		var4.data = new NibbleArray(var1.getByteArray("Data"));
-		var4.skylightMap = new NibbleArray(var1.getByteArray("SkyLight"));
-		var4.blocklightMap = new NibbleArray(var1.getByteArray("BlockLight"));
-		var4.heightMap = var1.getByteArray("HeightMap");
+
+		ListTag sectionList = var1.getTagList("Sections");
+		for (int i = 0; i < sectionList.tagCount(); i++) {
+			CompoundTag compound = (CompoundTag)sectionList.tagAt(i);
+			int level = compound.getInteger("Level");
+			var4.addSection(level, ChunkSection.fromNBT(compound));
+		}
+
+		if (var1.hasKey("Biomes")) {
+			var4.setBiomeArray(var1.getByteArray("Biomes"));
+		}
+
+		var4.heightMap = var1.getIntArray("HeightMap");
 		var4.isTerrainPopulated = var1.getBoolean("TerrainPopulated");
-		if(!var4.data.isValid()) {
-			var4.data = new NibbleArray(var4.blocks.length);
-		}
 
-		if(var4.heightMap == null || !var4.skylightMap.isValid()) {
-			var4.heightMap = new byte[256];
+		if(var4.heightMap == null) {
+			var4.heightMap = new int[256];
 			var4.skylightMap = new NibbleArray(var4.blocks.length);
 			var4.generateSkylightMap();
-		}
-
-		if(!var4.blocklightMap.isValid()) {
-			var4.blocklightMap = new NibbleArray(var4.blocks.length);
-			var4.doNothing1();
 		}
 
 		ListTag var5 = var1.getTagList("Entities");
--- net/minecraft/game/world/block/LadderBlock.java
+++ net/minecraft/game/world/block/LadderBlock.java
@@ -3,13 +3,22 @@
 import java.util.Random;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
 import net.minecraft.game.world.material.Material;
 
 public class LadderBlock extends Block {
+	public static final EnumProperty<Direction> DIRECTION = SharedProperties.DIRECTION;
+
 	protected LadderBlock(int var1, int var2) {
 		super(var1, var2, Material.circuits);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION);
+	}
+	
 	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
 		int var5 = var1.getBlockMetadata(var2, var3, var4);
 		float var6 = 2.0F / 16.0F;
--- argo/J_JsonStringNode.java
+++ /dev/null
@@ -1,59 +1,0 @@
-package argo;
-
-import java.util.List;
-import java.util.Map;
-
-public final class J_JsonStringNode extends J_JsonNode implements Comparable {
-	private final String field_27224_a;
-
-	J_JsonStringNode(String var1) {
-		if(var1 == null) {
-			throw new NullPointerException("Attempt to construct a JsonString with a null value.");
-		} else {
-			this.field_27224_a = var1;
-		}
-	}
-
-	public EnumJsonNodeType func_27218_a() {
-		return EnumJsonNodeType.STRING;
-	}
-
-	public String getText() {
-		return this.field_27224_a;
-	}
-
-	public Map getFields() {
-		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
-	}
-
-	public List getElements() {
-		throw new IllegalStateException("Attempt to get elements on a JsonNode without elements.");
-	}
-
-	public boolean equals(Object var1) {
-		if(this == var1) {
-			return true;
-		} else if(var1 != null && this.getClass() == var1.getClass()) {
-			J_JsonStringNode var2 = (J_JsonStringNode)var1;
-			return this.field_27224_a.equals(var2.field_27224_a);
-		} else {
-			return false;
-		}
-	}
-
-	public int hashCode() {
-		return this.field_27224_a.hashCode();
-	}
-
-	public String toString() {
-		return "JsonStringNode value:[" + this.field_27224_a + "]";
-	}
-
-	public int func_27223_a(J_JsonStringNode var1) {
-		return this.field_27224_a.compareTo(var1.field_27224_a);
-	}
-
-	public int compareTo(Object var1) {
-		return this.func_27223_a((J_JsonStringNode)var1);
-	}
-}
--- net/minecraft/game/item/ItemStack.java
+++ net/minecraft/game/item/ItemStack.java
@@ -8,6 +8,14 @@
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.block.Block;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.function.Predicate;
+
+import static net.minecraft.util.StringTranslate.i18n;
+
 public final class ItemStack {
 	public int count;
 	public int pickupTimer;
@@ -197,6 +205,15 @@
 
 	public String getItemName() {
 		return Item.itemsList[this.id].getNameFromStack(this);
+	}
+
+	public List<String> getItemTooltip() {
+		List<String> lines = new ArrayList<>();
+		Item.itemsList[this.id].buildTooltipFromStack(this, lines);
+		String desc = i18n(this.getItemName() + ".desc", "");
+		lines.addAll(Arrays.asList(desc.split("\n")));
+		lines.removeIf(((Predicate<String>)Objects::isNull).or(String::isEmpty));
+		return lines;
 	}
 
 	public static ItemStack copyItemStack(ItemStack var0) {
--- argo/J_JsonFieldBuilder.java
+++ /dev/null
@@ -1,28 +1,0 @@
-package argo;
-
-final class J_JsonFieldBuilder {
-	private J_JsonNodeBuilder field_27306_a;
-	private J_JsonNodeBuilder field_27305_b;
-
-	static J_JsonFieldBuilder func_27301_a() {
-		return new J_JsonFieldBuilder();
-	}
-
-	J_JsonFieldBuilder func_27304_a(J_JsonNodeBuilder var1) {
-		this.field_27306_a = var1;
-		return this;
-	}
-
-	J_JsonFieldBuilder func_27300_b(J_JsonNodeBuilder var1) {
-		this.field_27305_b = var1;
-		return this;
-	}
-
-	J_JsonStringNode func_27303_b() {
-		return (J_JsonStringNode)this.field_27306_a.func_27234_b();
-	}
-
-	J_JsonNode func_27302_c() {
-		return this.field_27305_b.func_27234_b();
-	}
-}
--- net/minecraft/game/stats/StatList.java
+++ net/minecraft/game/stats/StatList.java
@@ -74,14 +74,14 @@
 
 			while(var1.hasNext()) {
 				IRecipe var2 = (IRecipe)var1.next();
-				var0.add(Integer.valueOf(var2.getRecipeOutput().id));
+				var0.add(var2.getRecipeOutput().id);
 			}
 
 			var1 = FurnaceRecipes.smelting().getSmeltingList().values().iterator();
 
 			while(var1.hasNext()) {
 				ItemStack var4 = (ItemStack)var1.next();
-				var0.add(Integer.valueOf(var4.id));
+				var0.add(var4.id);
 			}
 
 			craftItemStatArray = new StatBase[32000];
@@ -90,7 +90,7 @@
 			while(var1.hasNext()) {
 				Integer var5 = (Integer)var1.next();
 				if(Item.itemsList[var5.intValue()] != null) {
-					String var3 = StatCollector.translateToLocalFormatted("stat.craftItem", new Object[]{Item.itemsList[var5.intValue()].getStatName()});
+					String var3 = StatCollector.translateToLocalFormatted("stat.craftItem", Item.itemsList[var5.intValue()].getStatName());
 					craftItemStatArray[var5.intValue()] = (new StatCrafting(16842752 + var5.intValue(), var3, var5.intValue())).registerStat();
 				}
 			}
@@ -104,7 +104,7 @@
 
 		for(int var3 = 0; var3 < 256; ++var3) {
 			if(Block.blocksList[var3] != null && Block.blocksList[var3].areStatsEnabled()) {
-				String var4 = StatCollector.translateToLocalFormatted(var0, new Object[]{Block.blocksList[var3].getLocalizedStatName()});
+				String var4 = StatCollector.translateToLocalFormatted(var0, Block.blocksList[var3].getLocalizedStatName());
 				var2[var3] = (new StatCrafting(var1 + var3, var4, var3)).registerStat();
 				blockStats.add((StatCrafting)var2[var3]);
 			}
@@ -121,7 +121,7 @@
 
 		for(int var5 = var3; var5 < var4; ++var5) {
 			if(Item.itemsList[var5] != null) {
-				String var6 = StatCollector.translateToLocalFormatted(var1, new Object[]{Item.itemsList[var5].getStatName()});
+				String var6 = StatCollector.translateToLocalFormatted(var1, Item.itemsList[var5].getStatName());
 				var0[var5] = (new StatCrafting(var2 + var5, var6, var5)).registerStat();
 				if(var5 >= Block.blocksList.length) {
 					itemStats.add((StatCrafting)var0[var5]);
@@ -140,7 +140,7 @@
 
 		for(int var5 = var3; var5 < var4; ++var5) {
 			if(Item.itemsList[var5] != null && Item.itemsList[var5].isDamagable()) {
-				String var6 = StatCollector.translateToLocalFormatted(var1, new Object[]{Item.itemsList[var5].getStatName()});
+				String var6 = StatCollector.translateToLocalFormatted(var1, Item.itemsList[var5].getStatName());
 				var0[var5] = (new StatCrafting(var2 + var5, var6, var5)).registerStat();
 			}
 		}
@@ -175,7 +175,7 @@
 	}
 
 	public static StatBase getStatFromId(int var0) {
-		return (StatBase)idToStat.get(Integer.valueOf(var0));
+		return (StatBase)idToStat.get(var0);
 	}
 
 	static {
--- net/minecraft/game/world/terrain/feature/BigTreeFeature.java
+++ net/minecraft/game/world/terrain/feature/BigTreeFeature.java
@@ -18,8 +18,31 @@
 	double leafDensity = 1.0D;
 	int trunkSize = 1;
 	int heightLimitLimit = 12;
-	int leafDistanceLimit = 4;
+	int leafDistanceLimit = 5;
 	int[][] leafNodes;
+	final int woodMetadata;
+	final int leavesMetadata;
+
+	public BigTreeFeature() {
+		this(0, 0);
+	}
+
+	public BigTreeFeature(int metadata) {
+		this(metadata, metadata);
+	}
+
+	public BigTreeFeature(int woodMetadata, int leavesMetadata) {
+		this.woodMetadata = woodMetadata;
+		this.leavesMetadata = leavesMetadata;
+	}
+
+	public int getWoodMetadata() {
+		return this.woodMetadata;
+	}
+
+	public int getLeavesMetadata() {
+		return this.leavesMetadata;
+	}
 
 	void generateLeafNodeList() {
 		this.height = (int)((double)this.heightLimit * this.heightAttenuation);
@@ -118,7 +141,7 @@
 						if(var14 != 0 && var14 != 18) {
 							++var13;
 						} else {
-							this.worldObj.setBlock(var11[0], var11[1], var11[2], var6);
+							this.worldObj.setBlockAndMetadata(var11[0], var11[1], var11[2], var6, this.leavesMetadata);
 							++var13;
 						}
 					}
@@ -193,7 +216,7 @@
 				var14[var6] = MathHelper.floor((double)(var1[var6] + var15) + 0.5D);
 				var14[var7] = MathHelper.floor((double)var1[var7] + (double)var15 * var10 + 0.5D);
 				var14[var8] = MathHelper.floor((double)var1[var8] + (double)var15 * var12 + 0.5D);
-				this.worldObj.setBlock(var14[0], var14[1], var14[2], var3);
+				this.worldObj.setBlockAndMetadata(var14[0], var14[1], var14[2], var3, this.woodMetadata);
 			}
 
 		}
@@ -230,8 +253,8 @@
 			++var5[2];
 			++var6[2];
 			this.placeBlockLine(var5, var6, 17);
-			var5[0] += -1;
-			var6[0] += -1;
+			var5[0] -= 1;
+			var6[0] -= 1;
 			this.placeBlockLine(var5, var6, 17);
 		}
 
@@ -333,9 +356,7 @@
 		this.basePos[0] = var3;
 		this.basePos[1] = var4;
 		this.basePos[2] = var5;
-		if(this.heightLimit == 0) {
-			this.heightLimit = 5 + this.rand.nextInt(this.heightLimitLimit);
-		}
+		this.heightLimit = 5 + this.rand.nextInt(this.heightLimitLimit);
 
 		if(!this.validTreeLocation()) {
 			return false;
--- net/minecraft/game/world/block/WorkbenchBlock.java
+++ net/minecraft/game/world/block/WorkbenchBlock.java
@@ -5,21 +5,23 @@
 import net.minecraft.game.world.material.Material;
 
 public class WorkbenchBlock extends Block {
+	private static final int TEX_SIDE = TerrainLayout.texCoord("crafting_table_side");
+	private static final int TEX_SIDE_ALT = TerrainLayout.texCoord("crafting_table_side_alt");
+	private static final int TEX_TOP = TerrainLayout.texCoord("crafting_table_top");
+
 	protected WorkbenchBlock(int var1) {
 		super(var1, Material.wood);
-		this.textureIndex = 59;
+		this.textureIndex = TEX_SIDE;
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex - 16 : (var1 == 0 ? Block.planks.getBlockTextureFromSide(0) : (var1 != 2 && var1 != 4 ? this.textureIndex : this.textureIndex + 1));
+		return var1 == 1 ? TEX_TOP : var1 == 0 ? Block.planks.getBlockTextureFromSide(0) : var1 != 2 && var1 != 4 ? TEX_SIDE : TEX_SIDE_ALT;
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, PlayerEntity var5) {
-		if(var1.remoteWorld) {
-			return true;
-		} else {
+		if (!var1.remoteWorld) {
 			var5.displayWorkbenchGUI(var2, var3, var4);
-			return true;
 		}
+		return true;
 	}
 }
--- argo/J_JsonNodeBuilder.java
+++ /dev/null
@@ -1,5 +1,0 @@
-package argo;
-
-public interface J_JsonNodeBuilder {
-	J_JsonNode func_27234_b();
-}
--- net/minecraft/client/gui/container/ContainerScreen.java
+++ net/minecraft/client/gui/container/ContainerScreen.java
@@ -7,11 +7,12 @@
 import net.minecraft.game.item.Container;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.item.slot.Slot;
-import net.minecraft.util.StringTranslate;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
 
+import java.util.List;
+
 public abstract class ContainerScreen extends GuiScreen {
 	private static RenderItem itemRenderer = new RenderItem();
 	protected int xSize = 176;
@@ -28,7 +29,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		int var4 = (this.width - this.xSize) / 2;
 		int var5 = (this.height - this.ySize) / 2;
 		this.drawGuiContainerBackgroundLayer(var3);
@@ -69,23 +70,31 @@
 		GL11.glDisable(GL12.GL_RESCALE_NORMAL);
 		RenderHelper.disableStandardItemLighting();
 		GL11.glDisable(GL11.GL_LIGHTING);
-		GL11.glDisable(GL11.GL_DEPTH_TEST);
 		this.drawGuiContainerForegroundLayer();
 		if(var12.getItemStack() == null && var6 != null && var6.hasStack()) {
-			String var13 = ("" + StringTranslate.getInstance().translateNamedKey(var6.getStack().getItemName())).trim();
-			if(var13.length() > 0) {
+			ItemStack stack = var6.getStack();
+			List<String> tooltip = stack.getItemTooltip();
+			if(!tooltip.isEmpty()) {
+				if (this.mc.gameSettings.showDebugInfo) {
+					tooltip.add("§8" + stack);
+				}
+
 				var9 = var1 - var4 + 12;
 				var10 = var2 - var5 - 12;
-				int var11 = this.fontRenderer.getStringWidth(var13);
-				this.drawGradientRect(var9 - 3, var10 - 3, var9 + var11 + 3, var10 + 8 + 3, -1073741824, -1073741824);
-				this.fontRenderer.drawStringWithShadow(var13, var9, var10, -1);
+				int var11 = tooltip.stream().mapToInt(this.fontRenderer::getStringWidth).max().getAsInt();
+				GL11.glTranslatef(0.0F, 0.0F, 300.0F);
+				this.drawGradientRect(var9 - 3, var10 - 3, var9 + var11 + 3, var10 + tooltip.size() * 10 + 1, -1073741824, -1073741824);
+				for (int i = 0; i < tooltip.size(); i++) {
+					String line = tooltip.get(i);
+					if (i != 0) line = "§7" + line;
+					this.fontRenderer.drawStringWithShadow(line, var9, var10 + i * 10, -1);
+				}
+				GL11.glTranslatef(0.0F, 0.0F, -300.0F);
 			}
 		}
 
 		GL11.glPopMatrix();
 		super.drawScreen(var1, var2, var3);
-		GL11.glEnable(GL11.GL_LIGHTING);
-		GL11.glEnable(GL11.GL_DEPTH_TEST);
 	}
 
 	protected void drawGuiContainerForegroundLayer() {
@@ -151,12 +160,6 @@
 				boolean var9 = var8 != -999 && (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT));
 				this.mc.playerController.func_27174_a(this.inventorySlots.windowId, var8, var3, var9, this.mc.thePlayer);
 			}
-		}
-
-	}
-
-	protected void mouseMovedOrUp(int var1, int var2, int var3) {
-		if(var3 == 0) {
 		}
 
 	}
--- argo/J_JsonRootNode.java
+++ /dev/null
@@ -1,4 +1,0 @@
-package argo;
-
-public abstract class J_JsonRootNode extends J_JsonNode {
-}
--- net/minecraft/game/world/terrain/feature/TreeFeature.java
+++ net/minecraft/game/world/terrain/feature/TreeFeature.java
@@ -5,76 +5,80 @@
 import net.minecraft.game.world.block.Block;
 
 public class TreeFeature extends Feature {
+	private final int woodMetadata;
+	private final int leavesMetadata;
+
+	public TreeFeature() {
+		this(0, 0);
+	}
+
+	public TreeFeature(int metadata) {
+		this(metadata, metadata);
+	}
+
+	public TreeFeature(int woodMetadata, int leavesMetadata) {
+		this.woodMetadata = woodMetadata;
+		this.leavesMetadata = leavesMetadata;
+	}
+
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
 		int var6 = var2.nextInt(3) + 4;
 		boolean var7 = true;
-		if(var4 >= 1 && var4 + var6 + 1 <= 128) {
-			int var8;
-			int var10;
-			int var11;
-			int var12;
-			for(var8 = var4; var8 <= var4 + 1 + var6; ++var8) {
-				byte var9 = 1;
-				if(var8 == var4) {
-					var9 = 0;
-				}
-
-				if(var8 >= var4 + 1 + var6 - 2) {
-					var9 = 2;
-				}
-
-				for(var10 = var3 - var9; var10 <= var3 + var9 && var7; ++var10) {
-					for(var11 = var5 - var9; var11 <= var5 + var9 && var7; ++var11) {
-						if(var8 >= 0 && var8 < 128) {
-							var12 = var1.getBlockId(var10, var8, var11);
-							if(var12 != 0 && var12 != Block.leaves.blockID) {
-								var7 = false;
-							}
-						} else {
-							var7 = false;
-						}
-					}
-				}
-			}
-
-			if(!var7) {
-				return false;
-			} else {
-				var8 = var1.getBlockId(var3, var4 - 1, var5);
-				if((var8 == Block.grass.blockID || var8 == Block.dirt.blockID) && var4 < 128 - var6 - 1) {
-					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
-
-					int var16;
-					for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
-						var10 = var16 - (var4 + var6);
-						var11 = 1 - var10 / 2;
-
-						for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
-							int var13 = var12 - var3;
-
-							for(int var14 = var5 - var11; var14 <= var5 + var11; ++var14) {
-								int var15 = var14 - var5;
-								if((Math.abs(var13) != var11 || Math.abs(var15) != var11 || var2.nextInt(2) != 0 && var10 != 0) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var16, var14)]) {
-									var1.setBlock(var12, var16, var14, Block.leaves.blockID);
-								}
-							}
-						}
-					}
-
-					for(var16 = 0; var16 < var6; ++var16) {
-						var10 = var1.getBlockId(var3, var4 + var16, var5);
-						if(var10 == 0 || var10 == Block.leaves.blockID) {
-							var1.setBlock(var3, var4 + var16, var5, Block.log.blockID);
-						}
-					}
-
-					return true;
-				} else {
-					return false;
-				}
-			}
-		} else {
+		int var8;
+		int var10;
+		int var11;
+		int var12;
+		for(var8 = var4; var8 <= var4 + 1 + var6; ++var8) {
+			byte var9 = 1;
+			if(var8 == var4) {
+				var9 = 0;
+			}
+
+			if(var8 >= var4 + 1 + var6 - 2) {
+				var9 = 2;
+			}
+
+			for(var10 = var3 - var9; var10 <= var3 + var9 && var7; ++var10) {
+				for(var11 = var5 - var9; var11 <= var5 + var9 && var7; ++var11) {
+					var12 = var1.getBlockId(var10, var8, var11);
+					if(var12 != 0 && var12 != Block.leaves.blockID) {
+						var7 = false;
+					}
+				}
+			}
+		}
+
+		if(!var7) {
 			return false;
+		} else {
+			if (!Block.sapling.canPlaceBlockAt(var1, var3, var4, var5)) return false;
+			if (var1.getBlockId(var3, var4 - 1, var5) == Block.grass.blockID) var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
+
+			int var16;
+			for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
+				var10 = var16 - (var4 + var6);
+				var11 = 1 - var10 / 2;
+
+				for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
+					int var13 = var12 - var3;
+
+					for(int var14 = var5 - var11; var14 <= var5 + var11; ++var14) {
+						int var15 = var14 - var5;
+						if((Math.abs(var13) != var11 || Math.abs(var15) != var11 || var2.nextInt(2) != 0 && var10 != 0) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var16, var14)]) {
+							var1.setBlockAndMetadata(var12, var16, var14, Block.leaves.blockID, this.leavesMetadata);
+						}
+					}
+				}
+			}
+
+			for(var16 = 0; var16 < var6; ++var16) {
+				var10 = var1.getBlockId(var3, var4 + var16, var5);
+				if(var10 == 0 || var10 == Block.leaves.blockID) {
+					var1.setBlockAndMetadata(var3, var4 + var16, var5, Block.log.blockID, this.woodMetadata);
+				}
+			}
+
+			return true;
 		}
 	}
 }
--- /dev/null
+++ argo/format/JsonEscapedString.java
@@ -1,0 +1,13 @@
+package argo.format;
+
+final class JsonEscapedString {
+	private final String escapedString;
+
+	JsonEscapedString(String var1) {
+		this.escapedString = var1.replace("\\", "\\\\").replace("\"", "\\\"").replace("\b", "\\b").replace("\f", "\\f").replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
+	}
+
+	public String toString() {
+		return this.escapedString;
+	}
+}
--- net/minecraft/game/world/terrain/NetherChunkProvider.java
+++ net/minecraft/game/world/terrain/NetherChunkProvider.java
@@ -57,36 +57,40 @@
 		int var8 = var4 + 1;
 		this.noiseArray = this.initializeNoiseField(this.noiseArray, var1 * var4, 0, var2 * var4, var6, var7, var8);
 
-		for(int var9 = 0; var9 < var4; ++var9) {
-			for(int var10 = 0; var10 < var4; ++var10) {
-				for(int var11 = 0; var11 < 16; ++var11) {
+		for(int xS = 0; xS < var4; ++xS) {
+			for(int zS = 0; zS < var4; ++zS) {
+				for(int yS = 0; yS < 16; ++yS) {
 					double var12 = 0.125D;
-					double var14 = this.noiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 + 0];
-					double var16 = this.noiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 + 0];
-					double var18 = this.noiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 + 0];
-					double var20 = this.noiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 + 0];
-					double var22 = (this.noiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 + 1] - var14) * var12;
-					double var24 = (this.noiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 + 1] - var16) * var12;
-					double var26 = (this.noiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 + 1] - var18) * var12;
-					double var28 = (this.noiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 + 1] - var20) * var12;
+					double var14 = this.noiseArray[((xS + 0) * var8 + zS + 0) * var7 + yS + 0];
+					double var16 = this.noiseArray[((xS + 0) * var8 + zS + 1) * var7 + yS + 0];
+					double var18 = this.noiseArray[((xS + 1) * var8 + zS + 0) * var7 + yS + 0];
+					double var20 = this.noiseArray[((xS + 1) * var8 + zS + 1) * var7 + yS + 0];
+					double var22 = (this.noiseArray[((xS + 0) * var8 + zS + 0) * var7 + yS + 1] - var14) * var12;
+					double var24 = (this.noiseArray[((xS + 0) * var8 + zS + 1) * var7 + yS + 1] - var16) * var12;
+					double var26 = (this.noiseArray[((xS + 1) * var8 + zS + 0) * var7 + yS + 1] - var18) * var12;
+					double var28 = (this.noiseArray[((xS + 1) * var8 + zS + 1) * var7 + yS + 1] - var20) * var12;
 
-					for(int var30 = 0; var30 < 8; ++var30) {
+					for(int yI = 0; yI < 8; ++yI) {
 						double var31 = 0.25D;
 						double var33 = var14;
 						double var35 = var16;
 						double var37 = (var18 - var14) * var31;
 						double var39 = (var20 - var16) * var31;
 
-						for(int var41 = 0; var41 < 4; ++var41) {
-							int var42 = var41 + var9 * 4 << 11 | 0 + var10 * 4 << 7 | var11 * 8 + var30;
-							short var43 = 128;
+						for(int xI = 0; xI < 4; ++xI) {
 							double var44 = 0.25D;
 							double var46 = var33;
 							double var48 = (var35 - var33) * var44;
 
-							for(int var50 = 0; var50 < 4; ++var50) {
+							for(int zI = 0; zI < 4; ++zI) {
+								int x = xS << 2 | xI;
+								int y = yS << 3 | yI;
+								int z = zS << 2 | zI;
+
+								int index = y << 8 | z << 4 | x;
+
 								int var51 = 0;
-								if(var11 * 8 + var30 < var5) {
+								if(y < var5) {
 									var51 = Block.stillLava.blockID;
 								}
 
@@ -94,8 +98,7 @@
 									var51 = Block.netherrack.blockID;
 								}
 
-								var3[var42] = (byte)var51;
-								var42 += var43;
+								var3[index] = (byte)var51;
 								var46 += var48;
 							}
 
@@ -117,27 +120,27 @@
 	public void generateSurface(int var1, int var2, byte[] var3) {
 		byte var4 = 64;
 		double var5 = 1.0D / 32.0D;
-		this.sandNoiseArray = this.beachNoise.generateNoiseArray3D(this.sandNoiseArray, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var5, var5, 1.0D);
+		this.sandNoiseArray = this.beachNoise.generateNoiseArray3D(this.sandNoiseArray, (double)(var1 * 16), 0.0D, (double)(var2 * 16), 16, 1, 16, var5, 1.0D, var5);
 		this.gravelNoiseArray = this.beachNoise.generateNoiseArray3D(this.gravelNoiseArray, (double)(var1 * 16), 109.0134D, (double)(var2 * 16), 16, 1, 16, var5, 1.0D, var5);
-		this.erosionNoiseArray = this.erosionNoise.generateNoiseArray3D(this.erosionNoiseArray, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var5 * 2.0D, var5 * 2.0D, var5 * 2.0D);
+		this.erosionNoiseArray = this.erosionNoise.generateNoiseArray3D(this.erosionNoiseArray, (double)(var1 * 16), 0.0D, (double)(var2 * 16), 16, 1, 16, var5 * 2.0D, var5 * 2.0D, var5 * 2.0D);
 
-		for(int var7 = 0; var7 < 16; ++var7) {
-			for(int var8 = 0; var8 < 16; ++var8) {
-				boolean var9 = this.sandNoiseArray[var7 + var8 * 16] + this.rand.nextDouble() * 0.2D > 0.0D;
-				boolean var10 = this.gravelNoiseArray[var7 + var8 * 16] + this.rand.nextDouble() * 0.2D > 0.0D;
-				int var11 = (int)(this.erosionNoiseArray[var7 + var8 * 16] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);
+		for(int z = 0; z < 16; ++z) {
+			for(int x = 0; x < 16; ++x) {
+				boolean var9 = this.sandNoiseArray[x << 4 | z] + this.rand.nextDouble() * 0.2D > 0.0D;
+				boolean var10 = this.gravelNoiseArray[x << 4 | z] + this.rand.nextDouble() * 0.2D > 0.0D;
+				int var11 = (int)(this.erosionNoiseArray[x << 4 | z] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);
 				int var12 = -1;
 				byte var13 = (byte)Block.netherrack.blockID;
 				byte var14 = (byte)Block.netherrack.blockID;
 
-				for(int var15 = 127; var15 >= 0; --var15) {
-					int var16 = (var8 * 16 + var7) * 128 + var15;
-					if(var15 >= 127 - this.rand.nextInt(5)) {
-						var3[var16] = (byte)Block.bedrock.blockID;
-					} else if(var15 <= 0 + this.rand.nextInt(5)) {
-						var3[var16] = (byte)Block.bedrock.blockID;
+				for(int y = 127; y >= 0; --y) {
+					int index = y << 8 | z << 4 | x;
+					if(y >= 127 - this.rand.nextInt(5)) {
+						var3[index] = (byte)Block.bedrock.blockID;
+					} else if(y <= this.rand.nextInt(5)) {
+						var3[index] = (byte)Block.bedrock.blockID;
 					} else {
-						byte var17 = var3[var16];
+						byte var17 = var3[index];
 						if(var17 == 0) {
 							var12 = -1;
 						} else if(var17 == Block.netherrack.blockID) {
@@ -145,7 +148,7 @@
 								if(var11 <= 0) {
 									var13 = 0;
 									var14 = (byte)Block.netherrack.blockID;
-								} else if(var15 >= var4 - 4 && var15 <= var4 + 1) {
+								} else if(y >= var4 - 4 && y <= var4 + 1) {
 									var13 = (byte)Block.netherrack.blockID;
 									var14 = (byte)Block.netherrack.blockID;
 									if(var10) {
@@ -165,19 +168,19 @@
 									}
 								}
 
-								if(var15 < var4 && var13 == 0) {
+								if(y < var4 && var13 == 0) {
 									var13 = (byte)Block.stillLava.blockID;
 								}
 
 								var12 = var11;
-								if(var15 >= var4 - 1) {
-									var3[var16] = var13;
+								if(y >= var4 - 1) {
+									var3[index] = var13;
 								} else {
-									var3[var16] = var14;
+									var3[index] = var14;
 								}
 							} else if(var12 > 0) {
 								--var12;
-								var3[var16] = var14;
+								var3[index] = var14;
 							}
 						}
 					}
--- /dev/null
+++ net/minecraft/game/world/biome/BiomeSource.java
@@ -1,0 +1,58 @@
+package net.minecraft.game.world.biome;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.game.world.chunk.ChunkCoordIntPair;
+
+public abstract class BiomeSource {
+	private static final int MAX_CACHE_SIZE = 500;
+
+	private final Long2ObjectMap<CachedBiomeRegion> biomeCache = new Long2ObjectOpenHashMap<>();
+	private Biome[] blockGeneratorData;
+
+	private CachedBiomeRegion getCachedBiomeRegion(int x, int z) {
+		long key = ChunkCoordIntPair.chunkXZ2Int(x, z);
+		CachedBiomeRegion region = biomeCache.computeIfAbsent(key, k -> new CachedBiomeRegion(this, x, z));
+		if (biomeCache.size() > MAX_CACHE_SIZE) {
+			biomeCache.clear();
+		}
+		return region;
+	}
+
+	public Biome getBiomeGenAtChunkCoord(ChunkCoordIntPair coord) {
+		return this.getBiomeGenAt(coord.chunkXPos << 4, coord.chunkZPos << 4);
+	}
+
+	public Biome getBiomeGenAt(int x, int z) {
+		return this.getCachedBiomeRegion(x >> 4, z >> 4).getBiome(x & 15, z & 15);
+	}
+
+	public int getEdgeAt(int x, int z) {
+		return this.getCachedBiomeRegion(x >> 4, z >> 4).getEdge(x & 15, z & 15);
+	}
+
+	public int getOceanAt(int x, int z) {
+		return this.getCachedBiomeRegion(x >> 4, z >> 4).getOcean(x & 15, z & 15);
+	}
+
+	public int getColorAt(int x, int z, BiomeColorType type) {
+		return this.getCachedBiomeRegion(x >> 4, z >> 4).getColor(x & 15, z & 15, type);
+	}
+
+	public Biome[] getBlockGeneratorData(int var1, int var2, int var3, int var4) {
+		this.blockGeneratorData = this.loadBlockGeneratorData(this.blockGeneratorData, var1, var2, var3, var4);
+		return this.blockGeneratorData;
+	}
+
+	public abstract int[] loadColorData(int[] colors, int x, int z, int width, int length, BiomeColorType type);
+
+	public int[] loadEdgeData(int[] edge, int x, int z, int width, int length) {
+		return edge;
+	}
+
+	public int[] loadOceanData(int[] ocean, int x, int z, int width, int length) {
+		return ocean;
+	}
+
+	public abstract Biome[] loadBlockGeneratorData(Biome[] biomes, int x, int z, int width, int length);
+}
--- net/minecraft/server/cli/ConsoleLogFormatter.java
+++ net/minecraft/server/cli/ConsoleLogFormatter.java
@@ -12,7 +12,7 @@
 
 	public String format(LogRecord var1) {
 		StringBuilder var2 = new StringBuilder();
-		var2.append(this.dateFormat.format(Long.valueOf(var1.getMillis())));
+		var2.append(this.dateFormat.format(var1.getMillis()));
 		Level var3 = var1.getLevel();
 		if(var3 == Level.FINEST) {
 			var2.append(" [FINEST] ");
--- /dev/null
+++ net/mine_diver/smoothbeta/util/UtilsFromHell.java
@@ -1,0 +1,426 @@
+package net.mine_diver.smoothbeta.util;
+
+import net.minecraft.client.render.GLAllocation;
+
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channels;
+import java.nio.channels.FileChannel;
+import java.nio.channels.ReadableByteChannel;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class UtilsFromHell {
+	public static String getPosixFullPath(String path) {
+        return getFullPath(path).replace(File.separator, "/");
+    }
+
+	private static String getFullPath(final String fileName) {
+        if (fileName == null) {
+            return null;
+        }
+        final int prefix = getPrefixLength(fileName);
+        if (prefix < 0) {
+            return null;
+        }
+        if (prefix >= fileName.length()) {
+            return getPrefix(fileName);  // add end slash if necessary
+        }
+        final int index = indexOfLastSeparator(fileName);
+        if (index < 0) {
+            return fileName.substring(0, prefix);
+        }
+        int end = index + 1;
+        return fileName.substring(0, end);
+    }
+
+	public static String getPrefix(final String fileName) {
+        if (fileName == null) {
+            return null;
+        }
+        final int len = getPrefixLength(fileName);
+        if (len < 0) {
+            return null;
+        }
+        if (len > fileName.length()) {
+            requireNonNullChars(fileName);
+            return fileName + '/';
+        }
+        return requireNonNullChars(fileName.substring(0, len));
+    }
+	
+	public static int indexOfLastSeparator(final String fileName) {
+        if (fileName == null) {
+            return -1;
+        }
+        final int lastUnixPos = fileName.lastIndexOf('/');
+        final int lastWindowsPos = fileName.lastIndexOf('\\');
+        return Math.max(lastUnixPos, lastWindowsPos);
+    }
+
+	private static String requireNonNullChars(final String path) {
+        if (path.indexOf(0) >= 0) {
+            throw new IllegalArgumentException(
+                "Null character present in file/path name. There are no known legitimate use cases for such data, but several injection attacks may use it");
+        }
+        return path;
+    }
+
+	public static int getPrefixLength(final String fileName) {
+        if (fileName == null) {
+            return -1;
+        }
+        final int len = fileName.length();
+        if (len == 0) {
+            return 0;
+        }
+        char ch0 = fileName.charAt(0);
+        if (ch0 == ':') {
+            return -1;
+        }
+        if (len == 1) {
+            if (ch0 == '~') {
+                return 2;  // return a length greater than the input
+            }
+            return isSeparator(ch0) ? 1 : 0;
+        }
+        if (ch0 == '~') {
+            int posUnix = fileName.indexOf('/', 1);
+            int posWin = fileName.indexOf('\\', 1);
+            if (posUnix == -1 && posWin == -1) {
+                return len + 1;  // return a length greater than the input
+            }
+            posUnix = posUnix == -1 ? posWin : posUnix;
+            posWin = posWin == -1 ? posUnix : posWin;
+            return Math.min(posUnix, posWin) + 1;
+        }
+        final char ch1 = fileName.charAt(1);
+        if (ch1 == ':') {
+            ch0 = Character.toUpperCase(ch0);
+            if (ch0 >= 'A' && ch0 <= 'Z') {
+                if (len == 2 && !IS_OS_WINDOWS) {
+                    return 0;
+                }
+                if (len == 2 || !isSeparator(fileName.charAt(2))) {
+                    return 2;
+                }
+                return 3;
+            }
+            if (ch0 == '/') {
+                return 1;
+            }
+            return -1;
+
+        }
+        if (!isSeparator(ch0) || !isSeparator(ch1)) {
+            return isSeparator(ch0) ? 1 : 0;
+        }
+        int posUnix = fileName.indexOf('/', 2);
+        int posWin = fileName.indexOf('\\', 2);
+        if (posUnix == -1 && posWin == -1 || posUnix == 2 || posWin == 2) {
+            return -1;
+        }
+        posUnix = posUnix == -1 ? posWin : posUnix;
+        posWin = posWin == -1 ? posUnix : posWin;
+        final int pos = Math.min(posUnix, posWin) + 1;
+        final String hostnamePart = fileName.substring(2, pos - 1);
+        return isValidHostName(hostnamePart) ? pos : -1;
+    }
+
+	private static final boolean IS_OS_WINDOWS = getOsMatchesName("Windows");
+
+	public static boolean getOsMatchesName(final String osNamePrefix) {
+        return isOsNameMatch(getSystemProperty("os.name"), osNamePrefix);
+    }
+
+	private static String getSystemProperty(final String property) {
+        try {
+            return System.getProperty(property);
+        } catch (final SecurityException ex) {
+            // we are not allowed to look at this property
+            System.err.println("Caught a SecurityException reading the system property '" + property
+                    + "'; the SystemUtils property value will default to null.");
+            return null;
+        }
+    }
+
+	private static boolean isOsNameMatch(final String osName, final String osNamePrefix) {
+        if (osName == null) {
+            return false;
+        }
+        return osName.toUpperCase(Locale.ROOT).startsWith(osNamePrefix.toUpperCase(Locale.ROOT));
+    }
+
+	private static boolean isSeparator(final char ch) {
+        return ch == '/' || ch == '\\';
+    }
+
+	private static boolean isValidHostName(final String name) {
+        return isIPv6Address(name) || isRFC3986HostName(name);
+    }
+
+	private static boolean isIPv6Address(final String inet6Address) {
+        final boolean containsCompressedZeroes = inet6Address.contains("::");
+        if (containsCompressedZeroes && inet6Address.indexOf("::") != inet6Address.lastIndexOf("::")) {
+            return false;
+        }
+        if (inet6Address.startsWith(":") && !inet6Address.startsWith("::")
+                || inet6Address.endsWith(":") && !inet6Address.endsWith("::")) {
+            return false;
+        }
+        String[] octets = inet6Address.split(":");
+        if (containsCompressedZeroes) {
+            final List<String> octetList = new ArrayList<>(Arrays.asList(octets));
+            if (inet6Address.endsWith("::")) {
+                // String.split() drops ending empty segments
+                octetList.add("");
+            } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) {
+                octetList.remove(0);
+            }
+            octets = octetList.toArray(new String[0]);
+        }
+        if (octets.length > 8) {
+            return false;
+        }
+        int validOctets = 0;
+        int emptyOctets = 0; // consecutive empty chunks
+        for (int index = 0; index < octets.length; index++) {
+            final String octet = octets[index];
+            if (octet.isEmpty()) {
+                emptyOctets++;
+                if (emptyOctets > 1) {
+                    return false;
+                }
+            } else {
+                emptyOctets = 0;
+                // Is last chunk an IPv4 address?
+                if (index == octets.length - 1 && octet.contains(".")) {
+                    if (!isIPv4Address(octet)) {
+                        return false;
+                    }
+                    validOctets += 2;
+                    continue;
+                }
+                if (octet.length() > 4) {
+                    return false;
+                }
+                final int octetInt;
+                try {
+                    octetInt = Integer.parseInt(octet, 16);
+                } catch (final NumberFormatException e) {
+                    return false;
+                }
+                if (octetInt < 0 || octetInt > 0xffff) {
+                    return false;
+                }
+            }
+            validOctets++;
+        }
+        return validOctets <= 8 && (validOctets >= 8 || containsCompressedZeroes);
+    }
+
+	private static final Pattern IPV4_PATTERN = Pattern.compile("^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$");
+
+	private static boolean isIPv4Address(final String name) {
+        final Matcher m = IPV4_PATTERN.matcher(name);
+        if (!m.matches() || m.groupCount() != 4) {
+            return false;
+        }
+
+        // verify that address subgroups are legal
+        for (int i = 1; i <= 4; i++) {
+            final String ipSegment = m.group(i);
+            final int iIpSegment = Integer.parseInt(ipSegment);
+            if (iIpSegment > 255) {
+                return false;
+            }
+
+            if (ipSegment.length() > 1 && ipSegment.startsWith("0")) {
+                return false;
+            }
+
+        }
+
+        return true;
+    }
+
+	private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile("^[a-zA-Z0-9][a-zA-Z0-9-]*$");
+
+    private static boolean isRFC3986HostName(final String name) {
+        final String[] parts = name.split("\\.", -1);
+        for (int i = 0; i < parts.length; i++) {
+            if (parts[i].isEmpty()) {
+                // trailing dot is legal, otherwise we've hit a .. sequence
+                return i == parts.length - 1;
+            }
+            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static ByteBuffer readResource(InputStream inputStream) throws IOException {
+        ByteBuffer byteBuffer;
+        if (inputStream instanceof FileInputStream) {
+			FileInputStream fileInputStream = (FileInputStream)inputStream;
+            FileChannel fileChannel = fileInputStream.getChannel();
+            byteBuffer = GLAllocation.createDirectByteBuffer((int)fileChannel.size() + 1);
+            while (true) {
+                if (fileChannel.read(byteBuffer) == -1) break;
+            }
+        } else {
+            byteBuffer = GLAllocation.createDirectByteBuffer(8192);
+            ReadableByteChannel readableByteChannel = Channels.newChannel(inputStream);
+            while (readableByteChannel.read(byteBuffer) != -1) {
+                if (byteBuffer.remaining() != 0) continue;
+                byteBuffer = GLAllocation.createDirectByteBuffer(byteBuffer.capacity() * 2);
+            }
+        }
+        return byteBuffer;
+    }
+
+    public static String readResourceAsString(InputStream inputStream) {
+        ByteBuffer byteBuffer;
+        try {
+            byteBuffer = readResource(inputStream);
+            int i = byteBuffer.position();
+            byteBuffer.rewind();
+            byte[] ascii = new byte[byteBuffer.capacity()];
+            byteBuffer.get(ascii);
+            byteBuffer.rewind();
+            //noinspection deprecation
+            return new String(ascii, 0, 0, i);
+        }
+        catch (IOException ignored) {
+            return null;
+        }
+    }
+
+    public static String normalizeToPosix(String path) {
+        return normalize(path).replace(File.separator, "/");
+    }
+
+    private static String normalize(String fileName) {
+        char separator = File.separatorChar;
+        if (fileName == null) {
+            return null;
+        }
+
+        requireNonNullChars(fileName);
+
+        int size = fileName.length();
+        if (size == 0) {
+            return fileName;
+        }
+        final int prefix = getPrefixLength(fileName);
+        if (prefix < 0) {
+            return null;
+        }
+
+        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy
+        fileName.getChars(0, fileName.length(), array, 0);
+
+        // fix separators throughout
+        final char otherSeparator = flipSeparator(separator);
+        for (int i = 0; i < array.length; i++) {
+            if (array[i] == otherSeparator) {
+                array[i] = separator;
+            }
+        }
+
+        // add extra separator on the end to simplify code below
+        boolean lastIsDirectory = true;
+        if (array[size - 1] != separator) {
+            array[size++] = separator;
+            lastIsDirectory = false;
+        }
+
+        // adjoining slashes
+        // If we get here, prefix can only be 0 or greater, size 1 or greater
+        // If prefix is 0, set loop start to 1 to prevent index errors
+        for (int i = prefix != 0 ? prefix : 1; i < size; i++) {
+            if (array[i] == separator && array[i - 1] == separator) {
+                System.arraycopy(array, i, array, i - 1, size - i);
+                size--;
+                i--;
+            }
+        }
+
+        // dot slash
+        for (int i = prefix + 1; i < size; i++) {
+            if (array[i] == separator && array[i - 1] == '.' &&
+                    (i == prefix + 1 || array[i - 2] == separator)) {
+                if (i == size - 1) {
+                    lastIsDirectory = true;
+                }
+                System.arraycopy(array, i + 1, array, i - 1, size - i);
+                size -=2;
+                i--;
+            }
+        }
+
+        // double dot slash
+        outer:
+        for (int i = prefix + 2; i < size; i++) {
+            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&
+                    (i == prefix + 2 || array[i - 3] == separator)) {
+                if (i == prefix + 2) {
+                    return null;
+                }
+                if (i == size - 1) {
+                    lastIsDirectory = true;
+                }
+                int j;
+                for (j = i - 4 ; j >= prefix; j--) {
+                    if (array[j] == separator) {
+                        // remove b/../ from a/b/../c
+                        System.arraycopy(array, i + 1, array, j + 1, size - i);
+                        size -= i - j;
+                        i = j + 1;
+                        continue outer;
+                    }
+                }
+                // remove a/../ from a/../c
+                System.arraycopy(array, i + 1, array, prefix, size - i);
+                size -= i + 1 - prefix;
+                i = prefix + 1;
+            }
+        }
+
+        if (size <= 0) {  // should never be less than 0
+            return "";
+        }
+        if (size <= prefix) {  // should never be less than prefix
+            return new String(array, 0, size);
+        }
+        if (lastIsDirectory) {
+            return new String(array, 0, size);  // keep trailing separator
+        }
+        return new String(array, 0, size - 1);  // lose trailing separator
+    }
+
+    private static char flipSeparator(final char ch) {
+        if (ch == '/') {
+            return '\\';
+        }
+        if (ch == '\\') {
+            return '/';
+        }
+        throw new IllegalArgumentException(String.valueOf(ch));
+    }
+
+    public static String toString(Reader reader) throws IOException {
+        BufferedReader bReader = new BufferedReader(reader);
+        String line;
+        StringBuilder output = new StringBuilder();
+        while ((line = bReader.readLine()) != null) {
+            output.append(line).append("\n");
+        }
+        return output.toString();
+    }
+}
--- net/minecraft/game/world/block/SaplingBlock.java
+++ net/minecraft/game/world/block/SaplingBlock.java
@@ -1,27 +1,43 @@
 package net.minecraft.game.world.block;
 
 import java.util.Random;
+
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.SubtypedItem;
 import net.minecraft.game.world.World;
-import net.minecraft.game.world.terrain.feature.BigTreeFeature;
-import net.minecraft.game.world.terrain.feature.BirchTreeFeature;
-import net.minecraft.game.world.terrain.feature.Feature;
-import net.minecraft.game.world.terrain.feature.SpruceTreeFeature;
-import net.minecraft.game.world.terrain.feature.TreeFeature;
+import net.minecraft.game.world.block.properties.IntProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
+import net.minecraft.game.world.block.properties.StringProperty;
+import net.minecraft.game.world.terrain.feature.*;
 
 public class SaplingBlock extends FlowerBlock {
+	private static final int[] TEX_TYPES = TerrainLayout.varyingTexCoord("sapling", SharedProperties.WOOD_NAMES);
+
+	public static final StringProperty TYPE = SharedProperties.woodProperty("type", 7);
+	public static final IntProperty AGE = new IntProperty("age", 1);
+
 	protected SaplingBlock(int var1, int var2) {
 		super(var1, var2);
 		float var3 = 0.4F;
 		this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 2.0F, 0.5F + var3);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(TYPE, AGE);
+	}
+
+	protected Item getItem() {
+		return new SubtypedItem(this.blockID - 256);
+	}
+
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(!var1.remoteWorld) {
 			super.updateTick(var1, var2, var3, var4, var5);
 			if(var1.getBlockLightValue(var2, var3 + 1, var4) >= 9 && var5.nextInt(30) == 0) {
 				int var6 = var1.getBlockMetadata(var2, var3, var4);
-				if((var6 & 8) == 0) {
-					var1.setBlockMetadataWithNotify(var2, var3, var4, var6 | 8);
+				if(!var1.getBlockBooleanProperty(var2, var3, var4, AGE)) {
+					var1.setBlockPropertyWithNotify(var2, var3, var4, AGE, true);
 				} else {
 					this.growTree(var1, var2, var3, var4, var5);
 				}
@@ -31,32 +47,38 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		var2 &= 3;
-		return var2 == 1 ? 63 : (var2 == 2 ? 79 : super.getBlockTextureFromSideAndMetadata(var1, var2));
+		var2 = this.properties.getInt(var2, TYPE);
+		if (var2 >= TEX_TYPES.length) var2 = 0;
+		return TEX_TYPES[var2];
 	}
 
 	public void growTree(World var1, int var2, int var3, int var4, Random var5) {
-		int var6 = var1.getBlockMetadata(var2, var3, var4) & 3;
+		int var6 = var1.getBlockIntProperty(var2, var3, var4, TYPE);
 		var1.setBlock(var2, var3, var4, 0);
-		Object var7 = null;
+		Feature var7;
 		if(var6 == 1) {
 			var7 = new SpruceTreeFeature();
 		} else if(var6 == 2) {
-			var7 = new BirchTreeFeature();
+			var7 = new BigTreeFeature(2, 2);
+		} else if(var6 == 3) {
+			var7 = new MahoganyTreeFeature();
+		} else if(var6 == 4) {
+			var7 = new WillowTreeFeature();
 		} else {
 			var7 = new TreeFeature();
 			if(var5.nextInt(10) == 0) {
 				var7 = new BigTreeFeature();
 			}
 		}
+		var7 = var1.getBiomeAt(var2, var4).modifyGrownTree(var7, var5);
 
-		if(!((Feature)var7).generate(var1, var5, var2, var3, var4)) {
+		if(!var7.generate(var1, var5, var2, var3, var4)) {
 			var1.setBlockAndMetadata(var2, var3, var4, this.blockID, var6);
 		}
 
 	}
 
 	protected int damageDropped(int var1) {
-		return var1 & 3;
+		return this.properties.getInt(var1, TYPE);
 	}
 }
--- argo/J_JsonListener.java
+++ /dev/null
@@ -1,29 +1,0 @@
-package argo;
-
-public interface J_JsonListener {
-	void func_27195_b();
-
-	void func_27204_c();
-
-	void func_27200_d();
-
-	void func_27197_e();
-
-	void func_27194_f();
-
-	void func_27203_g();
-
-	void func_27205_a(String var1);
-
-	void func_27199_h();
-
-	void func_27198_c(String var1);
-
-	void func_27201_b(String var1);
-
-	void func_27196_i();
-
-	void func_27193_j();
-
-	void func_27202_k();
-}
--- net/minecraft/game/world/block/JukeboxBlock.java
+++ net/minecraft/game/world/block/JukeboxBlock.java
@@ -4,17 +4,28 @@
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.block.tileentity.JukeboxTileEntity;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
 
 public class JukeboxBlock extends ContainerBlock {
+	private static final int TEX_SIDE = TerrainLayout.texCoord("note_block");
+	private static final int TEX_TOP = TerrainLayout.texCoord("jukebox");
+
+	public static final BooleanProperty CONTAINS_DISC = new BooleanProperty("contains_disc");
+
 	protected JukeboxBlock(int var1, int var2) {
 		super(var1, var2, Material.wood);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(CONTAINS_DISC);
+	}
+
 	public int getBlockTextureFromSide(int var1) {
-		return this.textureIndex + (var1 == 1 ? 1 : 0);
+		return var1 == 1 ? TEX_TOP : TEX_SIDE;
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, PlayerEntity var5) {
--- net/minecraft/client/controller/SurvivalPlayerController.java
+++ net/minecraft/client/controller/SurvivalPlayerController.java
@@ -1,6 +1,7 @@
 package net.minecraft.client.controller;
 
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.sound.SoundManager;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.World;
@@ -75,7 +76,7 @@
 				Block var6 = Block.blocksList[var5];
 				this.curBlockDamage += var6.blockStrength(this.mc.thePlayer);
 				if(this.field_1069_h % 4.0F == 0.0F && var6 != null) {
-					this.mc.sndManager.playSound(var6.stepSound.baseStepSoundDir(), (float)var1 + 0.5F, (float)var2 + 0.5F, (float)var3 + 0.5F, (var6.stepSound.getVolume() + 1.0F) / 8.0F, var6.stepSound.getPitch() * 0.5F);
+					this.mc.sndManager.playSound(var6.stepSound.baseSteppySoundDir(), (float)var1 + 0.5F, (float)var2 + 0.5F, (float)var3 + 0.5F, (var6.stepSound.getVolume() + 1.0F) / 8.0F, var6.stepSound.getPitch() * 0.5F);
 				}
 
 				++this.field_1069_h;
@@ -84,7 +85,7 @@
 					this.curBlockDamage = 0.0F;
 					this.prevBlockDamage = 0.0F;
 					this.field_1069_h = 0.0F;
-					this.blockHitWait = 5;
+//					this.blockHitWait = 5;
 				}
 			} else {
 				this.curBlockDamage = 0.0F;
@@ -120,6 +121,6 @@
 
 	public void updateController() {
 		this.prevBlockDamage = this.curBlockDamage;
-		this.mc.sndManager.playRandomMusicIfReady();
+		this.mc.sndManager.playRandomMusicIfReady(SoundManager.MusicType.  GAME);
 	}
 }
--- /dev/null
+++ argo/saj/ThingWithPosition.java
@@ -1,0 +1,7 @@
+package argo.saj;
+
+interface ThingWithPosition {
+	int getColumn();
+
+	int getRow();
+}
--- net/minecraft/game/world/block/SpongeBlock.java
+++ net/minecraft/game/world/block/SpongeBlock.java
@@ -6,7 +6,7 @@
 public class SpongeBlock extends Block {
 	protected SpongeBlock(int var1) {
 		super(var1, Material.sponge);
-		this.textureIndex = 48;
+		this.textureIndex = TerrainLayout.texCoord("sponge");
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
--- net/minecraft/game/stats/StatStringFormatKeyInv.java
+++ net/minecraft/game/stats/StatStringFormatKeyInv.java
@@ -11,6 +11,6 @@
 	}
 
 	public String formatString(String var1) {
-		return String.format(var1, new Object[]{Keyboard.getKeyName(this.mc.gameSettings.keyBindInventory.keyCode)});
+		return String.format(var1, Keyboard.getKeyName(this.mc.gameSettings.keyBindInventory.keyCode));
 	}
 }
--- net/minecraft/server/player/ServerPlayerEntity.java
+++ net/minecraft/server/player/ServerPlayerEntity.java
@@ -1,9 +1,10 @@
 package net.minecraft.server.player;
 
-import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Set;
+
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.entity.misc.ItemEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
@@ -26,6 +27,7 @@
 import net.minecraft.game.world.block.tileentity.FurnaceContainer;
 import net.minecraft.game.world.block.tileentity.FurnaceTileEntity;
 import net.minecraft.game.world.block.tileentity.TileEntity;
+import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.game.world.chunk.ChunkCoordIntPair;
 import net.minecraft.network.NetServerHandler;
 import net.minecraft.network.packet.Packet;
@@ -54,8 +56,8 @@
 	public ItemInWorldManager itemInWorldManager;
 	public double field_9155_d;
 	public double field_9154_e;
-	public List loadedChunks = new LinkedList();
-	public Set field_420_ah = new HashSet();
+	public List<Long> loadedChunks = new LinkedList<>(); //BOXING??? WHERE IS MY VALUE TYPES
+	public LongSet field_420_ah = new LongOpenHashSet();
 	private int lastHealth = -99999999;
 	private int ticksOfInvuln = 60;
 	private ItemStack[] playerInventory = new ItemStack[]{null, null, null, null, null};
@@ -171,22 +173,25 @@
 		}
 
 		if(var1 && !this.loadedChunks.isEmpty()) {
-			ChunkCoordIntPair var7 = (ChunkCoordIntPair)this.loadedChunks.get(0);
-			if(var7 != null) {
-				boolean var8 = false;
-				if(this.playerNetServerHandler.getNumChunkDataPackets() < 4) {
-					var8 = true;
-				}
-
-				if(var8) {
-					WorldServer var9 = this.mcServer.getWorldManager(this.dimension);
-					this.loadedChunks.remove(var7);
-					this.playerNetServerHandler.sendPacket(new Packet51MapChunk(var7.chunkXPos * 16, 0, var7.chunkZPos * 16, 16, 128, 16, var9));
-					List var5 = var9.getTileEntityList(var7.chunkXPos * 16, 0, var7.chunkZPos * 16, var7.chunkXPos * 16 + 16, 128, var7.chunkZPos * 16 + 16);
-
-					for(int var6 = 0; var6 < var5.size(); ++var6) {
-						this.getTileEntityInfo((TileEntity)var5.get(var6));
-					}
+			long var7 = this.loadedChunks.get(0);
+			boolean var8 = false;
+			if(this.playerNetServerHandler.getNumChunkDataPackets() < 4) {
+				var8 = true;
+			}
+
+			if(var8) {
+				WorldServer var9 = this.mcServer.getWorldManager(this.dimension);
+				this.loadedChunks.remove(var7);
+
+				int chunkXPos = ChunkCoordIntPair.getChunkX(var7);
+				int chunkZPos = ChunkCoordIntPair.getChunkZ(var7);
+
+				this.playerNetServerHandler.sendPacket(new Packet51MapChunk(chunkXPos, chunkZPos, true, var9));
+				Chunk chunk = var9.getChunkFromChunkCoords(chunkXPos, chunkZPos);
+				List var5 = var9.getTileEntityList(chunkXPos * 16, chunk.getMinLevel() << 4, chunkZPos * 16, chunkXPos * 16 + 16, (chunk.getMaxLevel() << 4) + 16, chunkZPos * 16 + 16);
+
+				for(int var6 = 0; var6 < var5.size(); ++var6) {
+					this.getTileEntityInfo((TileEntity)var5.get(var6));
 				}
 			}
 		}
--- /dev/null
+++ net/minecraft/game/world/biome/RockyValleyBiome.java
@@ -1,0 +1,70 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.feature.*;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+
+import java.util.Random;
+
+public class RockyValleyBiome extends Biome {
+	private PerlinNoiseOctaves stoneNoise;
+	private PerlinNoiseOctaves gravelNoise;
+
+	protected RockyValleyBiome(int id) {
+		super(id);
+		this.removeBeach();
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(10.0D)
+				.heightOffset(-2.5D, 40.0D)
+				.selectorThreshold(1.0D)
+				.noiseUnderDamp(1.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings()
+				.heightOffset(-2.5D, 50.0D)
+				.selectorThreshold(0.1D)
+				.selectorOffset(-0.5D);
+	}
+
+	protected void initializeNoise(Random random) {
+		this.gravelNoise = new PerlinNoiseOctaves(random, 3);
+		this.stoneNoise = new PerlinNoiseOctaves(random, 3);
+	}
+
+	public Feature getRandomTreeFeature(Random var1) {
+		return var1.nextInt(2) == 0
+				? var1.nextInt(3) == 0 ? new SkinnySpruceTreeFeature() : new SpruceTreeFeature()
+				: var1.nextInt(10) == 0 ? new BigTreeFeature() : new TreeFeature();
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return treeBonus + treeNoise + 2;
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		int wx = chunk.xPosition * 16 + x;
+		int wz = chunk.zPosition * 16 + z;
+
+		double stoneValue = Math.abs(this.stoneNoise.generateNoiseNormalized2D(wx * 0.02D, wz * 0.02D));
+		double gravelValue = Math.abs(this.gravelNoise.generateNoiseNormalized2D(wx * 0.02D, wz * 0.02D));
+
+		if (stoneValue < 0.1D + random.nextDouble() * 0.1D) {
+			this.topBlock = (byte)Block.stone.blockID;
+			this.fillerBlock = (byte)Block.stone.blockID;
+		} else if (gravelValue < 0.1D + random.nextDouble() * 0.1D) {
+			this.topBlock = (byte)Block.gravel.blockID;
+			this.fillerBlock = (byte)Block.gravel.blockID;
+		} else {
+			this.topBlock = (byte)Block.grass.blockID;
+			this.fillerBlock = (byte)Block.dirt.blockID;
+		}
+
+		super.buildSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+	}
+}
--- argo/J_JsonNodeBuilders.java
+++ /dev/null
@@ -1,31 +1,0 @@
-package argo;
-
-public final class J_JsonNodeBuilders {
-	public static J_JsonNodeBuilder func_27248_a() {
-		return new J_JsonNullNodeBuilder();
-	}
-
-	public static J_JsonNodeBuilder func_27251_b() {
-		return new J_JsonTrueNodeBuilder();
-	}
-
-	public static J_JsonNodeBuilder func_27252_c() {
-		return new J_JsonFalseNodeBuilder();
-	}
-
-	public static J_JsonNodeBuilder func_27250_a(String var0) {
-		return new J_JsonNumberNodeBuilder(var0);
-	}
-
-	public static J_JsonStringNodeBuilder func_27254_b(String var0) {
-		return new J_JsonStringNodeBuilder(var0);
-	}
-
-	public static J_JsonObjectNodeBuilder func_27253_d() {
-		return new J_JsonObjectNodeBuilder();
-	}
-
-	public static J_JsonArrayNodeBuilder func_27249_e() {
-		return new J_JsonArrayNodeBuilder();
-	}
-}
--- net/minecraft/game/world/terrain/OverworldChunkProvider.java
+++ net/minecraft/game/world/terrain/OverworldChunkProvider.java
@@ -3,210 +3,254 @@
 import java.util.Random;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.biome.Biome;
+import net.minecraft.game.world.biome.layers.LayerFillEdge;
+import net.minecraft.game.world.biome.layers.LayerLand;
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.block.SandBlock;
 import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.game.world.chunk.ChunkProvider;
 import net.minecraft.game.world.material.Material;
-import net.minecraft.game.world.terrain.feature.CactusFeature;
-import net.minecraft.game.world.terrain.feature.ClayFeature;
-import net.minecraft.game.world.terrain.feature.DeadBushFeature;
-import net.minecraft.game.world.terrain.feature.DungeonFeature;
-import net.minecraft.game.world.terrain.feature.Feature;
-import net.minecraft.game.world.terrain.feature.FlowersFeature;
-import net.minecraft.game.world.terrain.feature.LakeFeature;
-import net.minecraft.game.world.terrain.feature.LiquidsFeature;
-import net.minecraft.game.world.terrain.feature.OreFeature;
-import net.minecraft.game.world.terrain.feature.PumpkinFeature;
-import net.minecraft.game.world.terrain.feature.ReedFeature;
-import net.minecraft.game.world.terrain.feature.TallGrassFeature;
+import net.minecraft.game.world.terrain.feature.*;
 import net.minecraft.game.world.terrain.generate.TerrainGenCaves;
 import net.minecraft.game.world.terrain.generate.TerrainGenerator;
 import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
-import net.minecraft.util.ProgressUpdate;
+import net.minecraft.util.*;
 
 public class OverworldChunkProvider implements ChunkProvider {
+	private static final int BIOME_SAMPLE_RANGE = 8;
+	private static final int BIOME_SAMPLE_NOISE_RANGE = BIOME_SAMPLE_RANGE / 4;
+	private static final int BIOME_SAMPLE_AREA = BIOME_SAMPLE_RANGE * 2 + 17;
+
 	private Random rand;
-	private PerlinNoiseOctaves minBaseNoise;
-	private PerlinNoiseOctaves maxBaseNoise;
-	private PerlinNoiseOctaves selectionNoise;
-	private PerlinNoiseOctaves beachNoise;
-	private PerlinNoiseOctaves erosionNoise;
-	public PerlinNoiseOctaves landNoise;
-	public PerlinNoiseOctaves depthNoise;
+	private PerlinNoiseOctaves minTargetNoise;
+	private PerlinNoiseOctaves maxTargetNoise;
+	private PerlinNoiseOctaves selectorNoise;
+	private PerlinNoiseOctaves boostNoise;
 	public PerlinNoiseOctaves treeNoise;
 	private World worldObj;
-	private double[] noiseArray;
-	private double[] sandNoiseArray = new double[256];
-	private double[] gravelNoiseArray = new double[256];
-	private double[] erosionNoiseArray = new double[256];
-	private TerrainGenerator caves = new TerrainGenCaves();
+	private TerrainGenerator caves;
 	private Biome[] biomesForGeneration;
-	double[] selectionNoiseArray;
-	double[] minBaseNoiseArray;
-	double[] maxBaseNoiseArray;
-	double[] landNoiseArray;
-	double[] depthNoiseArray;
-	int[][] unusedIntArray = new int[32][32];
-	private double[] generatedTemperatures;
+	private int[] oceanValuesForGeneration;
+	private int[] edgeValuesForGeneration;
+	private Array2D<NoiseSettings> noiseSettingSamples;
+	private Array2D<NoiseSettings> noiseSettingsForGen;
+	private NoiseSettings[] noiseSettingsForAvg = new NoiseSettings[100];
+	double[] minSamplesArray;
+	double[] maxSamplesArray;
+	double[] selectionSamplesArray;
+	double[] lerpedMinSamplesArray;
+	double[] lerpedMaxSamplesArray;
+	double[] lerpedSelectionSamplesArray;
+
+	private final int minLevel;
+	private final int minY;
+	private final int totalHeight;
+	private final int genHeight;
+	private final int seaLevel;
 
 	public OverworldChunkProvider(World var1, long var2) {
 		this.worldObj = var1;
 		this.rand = new Random(var2);
-		this.minBaseNoise = new PerlinNoiseOctaves(this.rand, 16);
-		this.maxBaseNoise = new PerlinNoiseOctaves(this.rand, 16);
-		this.selectionNoise = new PerlinNoiseOctaves(this.rand, 8);
-		this.beachNoise = new PerlinNoiseOctaves(this.rand, 4);
-		this.erosionNoise = new PerlinNoiseOctaves(this.rand, 4);
-		this.landNoise = new PerlinNoiseOctaves(this.rand, 10);
-		this.depthNoise = new PerlinNoiseOctaves(this.rand, 16);
+		this.minTargetNoise = new PerlinNoiseOctaves(this.rand, 8);
+		this.maxTargetNoise = new PerlinNoiseOctaves(this.rand, 8);
+		this.selectorNoise = new PerlinNoiseOctaves(this.rand, 4);
+		this.boostNoise = new PerlinNoiseOctaves(this.rand, 4);
 		this.treeNoise = new PerlinNoiseOctaves(this.rand, 8);
-	}
-
-	public void generateTerrain(int var1, int var2, byte[] var3, Biome[] var4, double[] var5) {
-		byte var6 = 4;
-		byte var7 = 64;
-		int var8 = var6 + 1;
-		byte var9 = 17;
-		int var10 = var6 + 1;
-		this.noiseArray = this.initializeNoiseField(this.noiseArray, var1 * var6, 0, var2 * var6, var8, var9, var10);
-
-		for(int var11 = 0; var11 < var6; ++var11) {
-			for(int var12 = 0; var12 < var6; ++var12) {
-				for(int var13 = 0; var13 < 16; ++var13) {
-					double var14 = 0.125D;
-					double var16 = this.noiseArray[((var11 + 0) * var10 + var12 + 0) * var9 + var13 + 0];
-					double var18 = this.noiseArray[((var11 + 0) * var10 + var12 + 1) * var9 + var13 + 0];
-					double var20 = this.noiseArray[((var11 + 1) * var10 + var12 + 0) * var9 + var13 + 0];
-					double var22 = this.noiseArray[((var11 + 1) * var10 + var12 + 1) * var9 + var13 + 0];
-					double var24 = (this.noiseArray[((var11 + 0) * var10 + var12 + 0) * var9 + var13 + 1] - var16) * var14;
-					double var26 = (this.noiseArray[((var11 + 0) * var10 + var12 + 1) * var9 + var13 + 1] - var18) * var14;
-					double var28 = (this.noiseArray[((var11 + 1) * var10 + var12 + 0) * var9 + var13 + 1] - var20) * var14;
-					double var30 = (this.noiseArray[((var11 + 1) * var10 + var12 + 1) * var9 + var13 + 1] - var22) * var14;
-
-					for(int var32 = 0; var32 < 8; ++var32) {
-						double var33 = 0.25D;
-						double var35 = var16;
-						double var37 = var18;
-						double var39 = (var20 - var16) * var33;
-						double var41 = (var22 - var18) * var33;
-
-						for(int var43 = 0; var43 < 4; ++var43) {
-							int var44 = var43 + var11 * 4 << 11 | 0 + var12 * 4 << 7 | var13 * 8 + var32;
-							short var45 = 128;
-							double var46 = 0.25D;
-							double var48 = var35;
-							double var50 = (var37 - var35) * var46;
-
-							for(int var52 = 0; var52 < 4; ++var52) {
-								double var53 = var5[(var11 * 4 + var43) * 16 + var12 * 4 + var52];
-								int var55 = 0;
-								if(var13 * 8 + var32 < var7) {
-									if(var53 < 0.5D && var13 * 8 + var32 >= var7 - 1) {
-										var55 = Block.ice.blockID;
-									} else {
-										var55 = Block.stillWater.blockID;
-									}
-								}
-
-								if(var48 > 0.0D) {
-									var55 = Block.stone.blockID;
-								}
-
-								var3[var44] = (byte)var55;
-								var44 += var45;
-								var48 += var50;
-							}
-
-							var35 += var39;
-							var37 += var41;
-						}
-
-						var16 += var24;
-						var18 += var26;
-						var20 += var28;
-						var22 += var30;
-					}
-				}
-			}
-		}
-
-	}
-
-	public void generateSurface(int var1, int var2, byte[] var3, Biome[] var4) {
-		byte var5 = 64;
-		double var6 = 1.0D / 32.0D;
-		this.sandNoiseArray = this.beachNoise.generateNoiseArray3D(this.sandNoiseArray, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var6, var6, 1.0D);
-		this.gravelNoiseArray = this.beachNoise.generateNoiseArray3D(this.gravelNoiseArray, (double)(var1 * 16), 109.0134D, (double)(var2 * 16), 16, 1, 16, var6, 1.0D, var6);
-		this.erosionNoiseArray = this.erosionNoise.generateNoiseArray3D(this.erosionNoiseArray, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var6 * 2.0D, var6 * 2.0D, var6 * 2.0D);
-
-		for(int var8 = 0; var8 < 16; ++var8) {
-			for(int var9 = 0; var9 < 16; ++var9) {
-				Biome var10 = var4[var8 + var9 * 16];
-				boolean var11 = this.sandNoiseArray[var8 + var9 * 16] + this.rand.nextDouble() * 0.2D > 0.0D;
-				boolean var12 = this.gravelNoiseArray[var8 + var9 * 16] + this.rand.nextDouble() * 0.2D > 3.0D;
-				int var13 = (int)(this.erosionNoiseArray[var8 + var9 * 16] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);
-				int var14 = -1;
-				byte var15 = var10.topBlock;
-				byte var16 = var10.fillerBlock;
-
-				for(int var17 = 127; var17 >= 0; --var17) {
-					int var18 = (var9 * 16 + var8) * 128 + var17;
-					if(var17 <= 0 + this.rand.nextInt(5)) {
-						var3[var18] = (byte)Block.bedrock.blockID;
+		Biome.initializeAllNoise(this.rand);
+
+		this.minLevel = 0;
+		this.totalHeight = 192;
+		this.genHeight = 192;
+		this.minY = this.minLevel << 4;
+		this.seaLevel = 64;
+		this.caves = new TerrainGenCaves(-64, this.totalHeight);
+	}
+
+	public void generateTerrain(int var1, int var2, Chunk var3) {
+		final int BSR = BIOME_SAMPLE_RANGE;
+		final int BSA = BIOME_SAMPLE_AREA;
+
+		this.biomesForGeneration = this.worldObj.getBiomeSource().loadBlockGeneratorData(this.biomesForGeneration, var1 * 16 - BSR, var2 * 16 - BSR, BSA, BSA);
+		this.oceanValuesForGeneration = this.worldObj.getBiomeSource().loadOceanData(this.oceanValuesForGeneration, var1 * 16 - BSR, var2 * 16 - BSR, BSA, BSA);
+		this.edgeValuesForGeneration = this.worldObj.getBiomeSource().loadEdgeData(this.edgeValuesForGeneration, var1 * 16 - BSR, var2 * 16 - BSR, BSA, BSA);
+		this.generateExperimentalTerrain(var3);
+		this.biomesForGeneration = this.worldObj.getBiomeSource().loadBlockGeneratorData(this.biomesForGeneration, var1 * 16, var2 * 16, 16, 16);
+	}
+
+	public void generateExperimentalTerrain(Chunk chunk) {
+		final int BSR = BIOME_SAMPLE_RANGE;
+		final int BSNR = BIOME_SAMPLE_NOISE_RANGE;
+		final int BSA = BIOME_SAMPLE_AREA;
+		final int RES_H = 4;
+		final int RES_V = 4;
+		final int NOISE_H = 16 / RES_H + 1;
+		final int NOISE_V = this.genHeight / RES_V + 1;
+
+		int bx = chunk.xPosition << 4;
+		int bz = chunk.zPosition << 4;
+		int nx = bx / RES_H;
+		int nz = bz / RES_H;
+
+		double noiseScaleHorizontal = 3.0D;
+		double noiseScaleVertical = 2.0D;
+		double selectorScaleHorizontal = 0.4D;
+		double selectorScaleVertical = 0.1D;
+		double boostScale = 0.05D;
+		double cliffThreshold = 0.25D;
+		boolean cliffBlocks = false;
+		int heightRoundoff = 16;
+
+		Array2D<NoiseSettings> biomeNoiseSettings = new Array2D<>(NoiseSettings[]::new, BSA, BSA);
+		for (int x = 0; x < BSA; x++) {
+			for (int z = 0; z < BSA; z++) {
+				int wx = x + bx - BSR;
+				int wz = z + bz - BSR;
+
+				double boost = this.boostNoise.generateNoiseNormalized2D(wx * boostScale, wz * boostScale) / 2.0D + 0.5D;
+				double ocean = this.oceanValuesForGeneration[x * BSA + z] / (double)LayerLand.OCEAN_QUALITY;
+				double edge = this.edgeValuesForGeneration[x * BSA + z] / (double)LayerFillEdge.EDGE_QUALITY;
+				biomeNoiseSettings.set(x, z, this.biomesForGeneration[x * BSA + z].getNoiseSettings(wx, wz, boost, ocean, edge));
+			}
+		}
+
+		Array2D<Biome> biomes = new Array2D<>(this.biomesForGeneration, BSA, BSA);
+
+		if (this.noiseSettingSamples == null) this.noiseSettingSamples = new Array2D<>(NoiseSettings[]::new, NOISE_H, NOISE_H);
+		for (int x = 0; x < NOISE_H; x++) {
+			for (int z = 0; z < NOISE_H; z++) {
+				int i = 0;
+				for (int nsx = -BSNR; nsx <= BSNR; nsx++) {
+					for (int nsz = -BSNR; nsz <= BSNR; nsz++) {
+						int bnsx = x * RES_H + BSR + nsx * RES_H;
+						int bnsz = z * RES_H + BSR + nsz * RES_H;
+
+						int mj = 1;
+						if (nsx == 0 && nsz == 0) mj = 8;
+						else if (Math.abs(nsx + nsz) == 1) mj = 5;
+						else if (Math.abs(nsx + nsz) == 2) mj = 3;
+						else if (Math.abs(nsx + nsz) == 3) mj = 2;
+
+						for (int j = 0; j < mj; j++) {
+							this.noiseSettingsForAvg[i++] = biomeNoiseSettings.get(bnsx, bnsz);
+						}
+					}
+				}
+				this.noiseSettingSamples.set(x, z, new NoiseSettings(this.noiseSettingsForAvg));
+			}
+		}
+
+		if (this.noiseSettingsForGen == null) this.noiseSettingsForGen = new Array2D<>(NoiseSettings[]::new, 16, 16);
+		for (int x = 0; x < this.noiseSettingSamples.width - 1; x++) {
+			for (int z = 0; z < this.noiseSettingSamples.height - 1; z++) {
+				NoiseSettings n00 = this.noiseSettingSamples.get(x, z);
+				NoiseSettings n01 = this.noiseSettingSamples.get(x + 1, z);
+				NoiseSettings n10 = this.noiseSettingSamples.get(x, z + 1);
+				NoiseSettings n11 = this.noiseSettingSamples.get(x + 1, z + 1);
+				for (int lx = 0; lx < RES_H; lx++) {
+					for (int lz = 0; lz < RES_H; lz++) {
+						this.noiseSettingsForGen.set(x * RES_H + lx, z * RES_H + lz, new NoiseSettings(n00, n01, n10, n11, lx / (double)RES_H, lz / (double)RES_H));
+					}
+				}
+			}
+		}
+
+		this.minSamplesArray = this.minTargetNoise.generateNoiseArray3DNormalized(this.minSamplesArray, nx, 0.0D, nz, NOISE_H, NOISE_V, NOISE_H, noiseScaleHorizontal, noiseScaleVertical, noiseScaleHorizontal, 0.5D, 0.5D);
+		this.maxSamplesArray = this.maxTargetNoise.generateNoiseArray3DNormalized(this.maxSamplesArray, nx, 0.0D, nz, NOISE_H, NOISE_V, NOISE_H, noiseScaleHorizontal, noiseScaleVertical, noiseScaleHorizontal, 0.5D, 0.5D);
+		this.selectionSamplesArray = this.selectorNoise.generateNoiseArray3DNormalized(this.selectionSamplesArray, nx, 0.0D, nz, NOISE_H, NOISE_V, NOISE_H, selectorScaleHorizontal, selectorScaleVertical, selectorScaleHorizontal, 0.5D, 0.5D);
+
+		DoubleArray3D minSamples = new DoubleArray3D(this.minSamplesArray, NOISE_H, NOISE_V, NOISE_H);
+		DoubleArray3D maxSamples = new DoubleArray3D(this.maxSamplesArray, NOISE_H, NOISE_V, NOISE_H);
+		DoubleArray3D selectionSamples = new DoubleArray3D(this.selectionSamplesArray, NOISE_H, NOISE_V, NOISE_H);
+
+		if (this.lerpedMinSamplesArray == null || this.lerpedMinSamplesArray.length < this.genHeight * 256) {
+			this.lerpedMinSamplesArray = new double[this.genHeight * 256];
+			this.lerpedMaxSamplesArray = new double[this.genHeight * 256];
+			this.lerpedSelectionSamplesArray = new double[this.genHeight * 256];
+		}
+
+		DoubleArray3D lerpedMinSamples = new DoubleArray3D(this.lerpedMinSamplesArray, 16, this.genHeight, 16);
+		DoubleArray3D lerpedMaxSamples = new DoubleArray3D(this.lerpedMaxSamplesArray, 16, this.genHeight, 16);
+		DoubleArray3D lerpedSelectionSamples = new DoubleArray3D(this.lerpedSelectionSamplesArray, 16, this.genHeight, 16);
+
+		MathHelper.lerp3DPoints(minSamples, lerpedMinSamples, RES_H, RES_V);
+		MathHelper.lerp3DPoints(maxSamples, lerpedMaxSamples, RES_H, RES_V);
+		MathHelper.lerp3DPoints(selectionSamples, lerpedSelectionSamples, RES_H, RES_V);
+
+		int yOff = this.totalHeight - this.genHeight;
+
+		for (int z = 0; z < 16; z++) {
+			for (int x = 0; x < 16; x++) {
+				NoiseSettings s = this.noiseSettingsForGen.get(x, z);
+				Biome biome = biomes.get(x + BSR, z + BSR);
+				double selection = lerpedSelectionSamples.get(x, 0, z) + s.selectorThreshold() / 2.0D;
+				double selectionTarget = s.selectorThreshold() > 0.0D
+							? Math.min(Math.max(selection / s.selectorThreshold() + s.selectorOffset(), 0.0D), 1.0D)
+							: selection + s.selectorOffset() < 0.0D ? 0.0D : 1.0D;
+
+				for (int y = this.totalHeight - 1; y >= 0; y--) {
+					if (y >= yOff) {
+						double min = lerpedMinSamples.get(x, y - yOff, z);
+						double max = lerpedMaxSamples.get(x, y - yOff, z);
+						double selection3D = lerpedSelectionSamples.get(x, y - yOff, z) + s.selectorThreshold() / 2.0D;
+
+						double selectionTarget3D = s.selectorThreshold() > 0.0D
+								? Math.min(Math.max(selection3D / s.selectorThreshold() + s.selectorOffset(), 0.0D), 1.0D)
+								: selection3D + s.selectorOffset() < 0.0D ? 0.0D : 1.0D;
+						double target = MathHelper.lerp(min, max, selectionTarget3D);
+						double noiseStretch = MathHelper.lerp(s.noiseStretchMin(), s.noiseStretchMax(), selectionTarget);
+						double heightOffset = MathHelper.lerp(s.heightOffsetMin(), s.heightOffsetMax(), selectionTarget);
+						double noiseUnderDamp = MathHelper.lerp(s.noiseUnderDampMin(), s.noiseUnderDampMax(), selectionTarget);
+
+						double threshold = (y + this.minY - this.seaLevel - heightOffset) / noiseStretch;
+						if (threshold < 0.0D) {
+							threshold *= noiseUnderDamp;
+						}
+						target -= threshold;
+
+						if (target > 0.0D && y + this.minY > this.totalHeight - heightRoundoff) {
+							target -= 1.0F - (this.totalHeight - y) / (double)heightRoundoff;
+						}
+
+						if (target > 0.0D) {
+							if (cliffBlocks
+									&& Math.abs(selection3D) < s.selectorThreshold()
+									&& Math.abs(min - max) > cliffThreshold) {
+								chunk.setBlockRaw(x, y + this.minY, z, Block.cobblestone.blockID);
+							} else {
+								chunk.setBlockRaw(x, y + this.minY, z, Block.stone.blockID);
+							}
+						} else if (y + this.minY < this.seaLevel) {
+							if (biome.getEnableSnow() && y + this.minY >= this.seaLevel - 1) {
+								chunk.setBlockRaw(x, y + this.minY, z, Block.ice.blockID);
+							} else {
+								chunk.setBlockRaw(x, y + this.minY, z, Block.stillWater.blockID);
+							}
+						}
 					} else {
-						byte var19 = var3[var18];
-						if(var19 == 0) {
-							var14 = -1;
-						} else if(var19 == Block.stone.blockID) {
-							if(var14 == -1) {
-								if(var13 <= 0) {
-									var15 = 0;
-									var16 = (byte)Block.stone.blockID;
-								} else if(var17 >= var5 - 4 && var17 <= var5 + 1) {
-									var15 = var10.topBlock;
-									var16 = var10.fillerBlock;
-									if(var12) {
-										var15 = 0;
-									}
-
-									if(var12) {
-										var16 = (byte)Block.gravel.blockID;
-									}
-
-									if(var11) {
-										var15 = (byte)Block.sand.blockID;
-									}
-
-									if(var11) {
-										var16 = (byte)Block.sand.blockID;
-									}
-								}
-
-								if(var17 < var5 && var15 == 0) {
-									var15 = (byte)Block.stillWater.blockID;
-								}
-
-								var14 = var13;
-								if(var17 >= var5 - 1) {
-									var3[var18] = var15;
-								} else {
-									var3[var18] = var16;
-								}
-							} else if(var14 > 0) {
-								--var14;
-								var3[var18] = var16;
-								if(var14 == 0 && var16 == Block.sand.blockID) {
-									var14 = this.rand.nextInt(4);
-									var16 = (byte)Block.sandstone.blockID;
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-
+						chunk.setBlockRaw(x, y + this.minY, z, Block.stone.blockID);
+					}
+				}
+			}
+		}
+	}
+
+	public void generateSurface(Chunk var3) {
+		for (int x = 0; x < 16; x++) {
+			for (int z = 0; z < 16; z++) {
+				int maxY = var3.getMaxY() + 1;
+				boolean hitSurface = false;
+				while (!hitSurface && maxY > var3.getMinY()) {
+					maxY--;
+					Block block = Block.blocksList[var3.getBlockID(x, maxY, z)];
+					if (block != null) {
+						hitSurface = block.isOpaqueCube();
+					}
+				}
+
+				var3.getBiome(x, z, this.worldObj.getBiomeSource())
+						.buildSurfaceColumn(var3, x, z, maxY, this.seaLevel, this.rand);
+			}
+		}
 	}
 
 	public Chunk prepareChunk(int var1, int var2) {
@@ -215,115 +259,22 @@
 
 	public Chunk provideChunk(int var1, int var2) {
 		this.rand.setSeed((long)var1 * 341873128712L + (long)var2 * 132897987541L);
-		byte[] var3 = new byte[-Short.MIN_VALUE];
-		Chunk var4 = new Chunk(this.worldObj, var3, var1, var2);
-		this.biomesForGeneration = this.worldObj.getBiomeSource().loadBlockGeneratorData(this.biomesForGeneration, var1 * 16, var2 * 16, 16, 16);
-		double[] var5 = this.worldObj.getBiomeSource().temperature;
-		this.generateTerrain(var1, var2, var3, this.biomesForGeneration, var5);
-		this.generateSurface(var1, var2, var3, this.biomesForGeneration);
-		this.caves.generate(this, this.worldObj, var1, var2, var3);
-		var4.generateSkylightMap();
-		return var4;
-	}
-
-	private double[] initializeNoiseField(double[] var1, int var2, int var3, int var4, int var5, int var6, int var7) {
-		if(var1 == null) {
-			var1 = new double[var5 * var6 * var7];
-		}
-
-		double var8 = 684.412D;
-		double var10 = 684.412D;
-		double[] var12 = this.worldObj.getBiomeSource().temperature;
-		double[] var13 = this.worldObj.getBiomeSource().humidity;
-		this.landNoiseArray = this.landNoise.generateNoiseArray2D(this.landNoiseArray, var2, var4, var5, var7, 1.121D, 1.121D, 0.5D);
-		this.depthNoiseArray = this.depthNoise.generateNoiseArray2D(this.depthNoiseArray, var2, var4, var5, var7, 200.0D, 200.0D, 0.5D);
-		this.selectionNoiseArray = this.selectionNoise.generateNoiseArray3D(this.selectionNoiseArray, (double)var2, (double)var3, (double)var4, var5, var6, var7, var8 / 80.0D, var10 / 160.0D, var8 / 80.0D);
-		this.minBaseNoiseArray = this.minBaseNoise.generateNoiseArray3D(this.minBaseNoiseArray, (double)var2, (double)var3, (double)var4, var5, var6, var7, var8, var10, var8);
-		this.maxBaseNoiseArray = this.maxBaseNoise.generateNoiseArray3D(this.maxBaseNoiseArray, (double)var2, (double)var3, (double)var4, var5, var6, var7, var8, var10, var8);
-		int var14 = 0;
-		int var15 = 0;
-		int var16 = 16 / var5;
-
-		for(int var17 = 0; var17 < var5; ++var17) {
-			int var18 = var17 * var16 + var16 / 2;
-
-			for(int var19 = 0; var19 < var7; ++var19) {
-				int var20 = var19 * var16 + var16 / 2;
-				double var21 = var12[var18 * 16 + var20];
-				double var23 = var13[var18 * 16 + var20] * var21;
-				double var25 = 1.0D - var23;
-				var25 *= var25;
-				var25 *= var25;
-				var25 = 1.0D - var25;
-				double var27 = (this.landNoiseArray[var15] + 256.0D) / 512.0D;
-				var27 *= var25;
-				if(var27 > 1.0D) {
-					var27 = 1.0D;
-				}
-
-				double var29 = this.depthNoiseArray[var15] / 8000.0D;
-				if(var29 < 0.0D) {
-					var29 = -var29 * 0.3D;
-				}
-
-				var29 = var29 * 3.0D - 2.0D;
-				if(var29 < 0.0D) {
-					var29 /= 2.0D;
-					if(var29 < -1.0D) {
-						var29 = -1.0D;
-					}
-
-					var29 /= 1.4D;
-					var29 /= 2.0D;
-					var27 = 0.0D;
-				} else {
-					if(var29 > 1.0D) {
-						var29 = 1.0D;
-					}
-
-					var29 /= 8.0D;
-				}
-
-				if(var27 < 0.0D) {
-					var27 = 0.0D;
-				}
-
-				var27 += 0.5D;
-				var29 = var29 * (double)var6 / 16.0D;
-				double var31 = (double)var6 / 2.0D + var29 * 4.0D;
-				++var15;
-
-				for(int var33 = 0; var33 < var6; ++var33) {
-					double var34 = 0.0D;
-					double var36 = ((double)var33 - var31) * 12.0D / var27;
-					if(var36 < 0.0D) {
-						var36 *= 4.0D;
-					}
-
-					double var38 = this.minBaseNoiseArray[var14] / 512.0D;
-					double var40 = this.maxBaseNoiseArray[var14] / 512.0D;
-					double var42 = (this.selectionNoiseArray[var14] / 10.0D + 1.0D) / 2.0D;
-					if(var42 < 0.0D) {
-						var34 = var38;
-					} else if(var42 > 1.0D) {
-						var34 = var40;
-					} else {
-						var34 = var38 + (var40 - var38) * var42;
-					}
-
-					var34 -= var36;
-					if(var33 > var6 - 4) {
-						double var44 = (double)((float)(var33 - (var6 - 4)) / 3.0F);
-						var34 = var34 * (1.0D - var44) + -10.0D * var44;
-					}
-
-					var1[var14] = var34;
-					++var14;
-				}
-			}
-		}
-
-		return var1;
+		Chunk chunk = new Chunk(this.worldObj, var1, var2);
+		chunk.blockSkylightRefresh = true;
+		this.generateTerrain(var1, var2, chunk);
+
+		byte[] biomes = chunk.getBiomeArray();
+
+		for (int i = 0; i < biomes.length; i++) {
+			biomes[i] = (byte)biomesForGeneration[i].id;
+		}
+
+		this.generateSurface(chunk);
+		this.caves.generate(this, this.worldObj, var1, var2, chunk);
+
+		chunk.blockSkylightRefresh = false;
+		chunk.generateSkylightMap();
+		return chunk;
 	}
 
 	public boolean chunkExists(int var1, int var2) {
@@ -334,38 +285,35 @@
 		SandBlock.fallInstantly = true;
 		int var4 = var2 * 16;
 		int var5 = var3 * 16;
-		Biome var6 = this.worldObj.getBiomeSource().getBiomeGenAt(var4 + 16, var5 + 16);
+		Biome biome = this.worldObj.getBiomeAt(var4 + 16, var5 + 16);
 		this.rand.setSeed(this.worldObj.getRandomSeed());
 		long var7 = this.rand.nextLong() / 2L * 2L + 1L;
 		long var9 = this.rand.nextLong() / 2L * 2L + 1L;
 		this.rand.setSeed((long)var2 * var7 + (long)var3 * var9 ^ this.worldObj.getRandomSeed());
+		PopulatorHost host = new PopulatorHost(this, var4, var5, worldObj, rand, null);
+		int minY = this.minLevel << 4;
+		int maxY = this.totalHeight + minY;
+		biome.decorate(host);
+
 		double var11 = 0.25D;
 		int var13;
 		int var14;
 		int var15;
-		if(this.rand.nextInt(4) == 0) {
-			var13 = var4 + this.rand.nextInt(16) + 8;
-			var14 = this.rand.nextInt(128);
-			var15 = var5 + this.rand.nextInt(16) + 8;
-			(new LakeFeature(Block.stillWater.blockID)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		if(this.rand.nextInt(8) == 0) {
-			var13 = var4 + this.rand.nextInt(16) + 8;
-			var14 = this.rand.nextInt(this.rand.nextInt(120) + 8);
-			var15 = var5 + this.rand.nextInt(16) + 8;
-			if(var14 < 64 || this.rand.nextInt(10) == 0) {
-				(new LakeFeature(Block.stillLava.blockID)).generate(this.worldObj, this.rand, var13, var14, var15);
-			}
-		}
+//		if(this.rand.nextInt(4 * this.totalHeight / 128) == 0) {
+//			host.generate(new LakeFeature(Block.stillWater.blockID), 1, minY, maxY);
+//		}
+//
+//		if(this.rand.nextInt(8 * this.totalHeight / 128) == 0) {
+//			var13 = var4 + this.rand.nextInt(16) + 8;
+//			var14 = this.rand.nextInt(this.rand.nextInt(120) + 8);
+//			var15 = var5 + this.rand.nextInt(16) + 8;
+//			if(var14 < 64 || this.rand.nextInt(10) == 0) {
+//				(new LakeFeature(Block.stillLava.blockID)).generate(this.worldObj, this.rand, var13, var14, var15);
+//			}
+//		}
 
 		int var16;
-		for(var13 = 0; var13 < 8; ++var13) {
-			var14 = var4 + this.rand.nextInt(16) + 8;
-			var15 = this.rand.nextInt(128);
-			var16 = var5 + this.rand.nextInt(16) + 8;
-			(new DungeonFeature()).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
+		host.generate(new DungeonFeature(), 8 * this.totalHeight / 128, minY, maxY, 8);
 
 		for(var13 = 0; var13 < 10; ++var13) {
 			var14 = var4 + this.rand.nextInt(16);
@@ -374,60 +322,24 @@
 			(new ClayFeature(32)).generate(this.worldObj, this.rand, var14, var15, var16);
 		}
 
-		for(var13 = 0; var13 < 20; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(128);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.dirt.blockID, 32)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var13 = 0; var13 < 10; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(128);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.gravel.blockID, 32)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var13 = 0; var13 < 20; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(128);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.coalOre.blockID, 16)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var13 = 0; var13 < 20; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(64);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.ironOre.blockID, 8)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var13 = 0; var13 < 2; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(32);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.goldOre.blockID, 8)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var13 = 0; var13 < 8; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(16);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.redstoneOre.blockID, 7)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var13 = 0; var13 < 1; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(16);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.diamondOre.blockID, 7)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var13 = 0; var13 < 1; ++var13) {
-			var14 = var4 + this.rand.nextInt(16);
-			var15 = this.rand.nextInt(16) + this.rand.nextInt(16);
-			var16 = var5 + this.rand.nextInt(16);
-			(new OreFeature(Block.lapisOre.blockID, 6)).generate(this.worldObj, this.rand, var14, var15, var16);
+		if (this.minY >= 0) {
+			host.generateMinable(Block.dirt, 32, 10, 0, 64);
+			host.generateMinable(Block.gravel, 32, 5, 0, 64);
+			host.generateMinableInStone(Block.coalOre, 16, 20, 0, 128);
+			host.generateMinableInStone(Block.ironOre, 8, 20, 0, 64);
+			host.generateMinableInStone(Block.goldOre, 2, 8, 0, 32);
+			host.generateMinableInStone(Block.redstoneOre, 7, 8, 0, 16);
+			host.generateMinableInStone(Block.diamondOre, 7, 1, 0, 16);
+			host.generateLapis(Block.lapisOre, 6, 1, 0, 16);
+		} else {
+			host.generateMinable(Block.dirt, 32, 20, -64, 64);
+			host.generateMinable(Block.gravel, 32, 10, -64, 64);
+			host.generateMinableInStone(Block.coalOre, 16, 40, -64, 192);
+			host.generateMinableInStone(Block.ironOre, 8, 40, -64, 64);
+			host.generateMinableInStone(Block.goldOre, 2, 16, -64, 0);
+			host.generateMinableInStone(Block.redstoneOre, 7, 16, -64, -32);
+			host.generateMinableInStone(Block.diamondOre, 7, 2, -64, -32);
+			host.generateLapis(Block.lapisOre, 6, 2, -64, 32);
 		}
 
 		var11 = 0.5D;
@@ -437,110 +349,29 @@
 			++var14;
 		}
 
-		if(var6 == Biome.forest) {
-			var14 += var13 + 5;
-		}
-
-		if(var6 == Biome.rainforest) {
-			var14 += var13 + 5;
-		}
-
-		if(var6 == Biome.seasonalForest) {
-			var14 += var13 + 2;
-		}
-
-		if(var6 == Biome.taiga) {
-			var14 += var13 + 5;
-		}
-
-		if(var6 == Biome.desert) {
-			var14 -= 20;
-		}
-
-		if(var6 == Biome.tundra) {
-			var14 -= 20;
-		}
-
-		if(var6 == Biome.plains) {
-			var14 -= 20;
-		}
+		var14 = biome.getTreeCount(var13, var14);
 
 		int var17;
 		for(var15 = 0; var15 < var14; ++var15) {
 			var16 = var4 + this.rand.nextInt(16) + 8;
 			var17 = var5 + this.rand.nextInt(16) + 8;
-			Feature var18 = var6.getRandomTreeFeature(this.rand);
+			Feature var18 = biome.getRandomTreeFeature(this.rand);
 			var18.setScale(1.0D, 1.0D, 1.0D);
 			var18.generate(this.worldObj, this.rand, var16, this.worldObj.getHeightValue(var16, var17), var17);
 		}
 
-		byte var27 = 0;
-		if(var6 == Biome.forest) {
-			var27 = 2;
-		}
-
-		if(var6 == Biome.seasonalForest) {
-			var27 = 4;
-		}
-
-		if(var6 == Biome.taiga) {
-			var27 = 2;
-		}
-
-		if(var6 == Biome.plains) {
-			var27 = 3;
-		}
-
 		int var19;
-		int var25;
-		for(var16 = 0; var16 < var27; ++var16) {
-			var17 = var4 + this.rand.nextInt(16) + 8;
-			var25 = this.rand.nextInt(128);
-			var19 = var5 + this.rand.nextInt(16) + 8;
-			(new FlowersFeature(Block.flower.blockID)).generate(this.worldObj, this.rand, var17, var25, var19);
-		}
-
-		byte var28 = 0;
-		if(var6 == Biome.forest) {
-			var28 = 2;
-		}
-
-		if(var6 == Biome.rainforest) {
-			var28 = 10;
-		}
-
-		if(var6 == Biome.seasonalForest) {
-			var28 = 2;
-		}
-
-		if(var6 == Biome.taiga) {
-			var28 = 1;
-		}
-
-		if(var6 == Biome.plains) {
-			var28 = 10;
-		}
-
 		int var20;
 		int var21;
-		for(var17 = 0; var17 < var28; ++var17) {
-			byte var26 = 1;
-			if(var6 == Biome.rainforest && this.rand.nextInt(3) != 0) {
-				var26 = 2;
-			}
-
-			var19 = var4 + this.rand.nextInt(16) + 8;
-			var20 = this.rand.nextInt(128);
-			var21 = var5 + this.rand.nextInt(16) + 8;
-			(new TallGrassFeature(Block.tallGrass.blockID, var26)).generate(this.worldObj, this.rand, var19, var20, var21);
-		}
-
-		var28 = 0;
-		if(var6 == Biome.desert) {
-			var28 = 2;
-		}
-
-		for(var17 = 0; var17 < var28; ++var17) {
+		int var25;
+		for(var16 = 0; var16 < 1; ++var16) {
+			var17 = var4 + this.rand.nextInt(16) + 8;
+			var25 = this.rand.nextInt(128);
+			var19 = var5 + this.rand.nextInt(16) + 8;
+			(new FlowersFeature(Block.flower.blockID)).generate(this.worldObj, this.rand, var17, var25, var19);
+		}
+
+		for(var17 = 0; var17 < biome.getDeadBushCount(); ++var17) {
 			var25 = var4 + this.rand.nextInt(16) + 8;
 			var19 = this.rand.nextInt(128);
 			var20 = var5 + this.rand.nextInt(16) + 8;
@@ -582,41 +413,33 @@
 			(new PumpkinFeature()).generate(this.worldObj, this.rand, var17, var25, var19);
 		}
 
-		var17 = 0;
-		if(var6 == Biome.desert) {
-			var17 += 10;
-		}
-
-		for(var25 = 0; var25 < var17; ++var25) {
+		for(var25 = 0; var25 < biome.getCactusCount(); ++var25) {
 			var19 = var4 + this.rand.nextInt(16) + 8;
 			var20 = this.rand.nextInt(128);
 			var21 = var5 + this.rand.nextInt(16) + 8;
 			(new CactusFeature()).generate(this.worldObj, this.rand, var19, var20, var21);
 		}
 
-		for(var25 = 0; var25 < 50; ++var25) {
-			var19 = var4 + this.rand.nextInt(16) + 8;
-			var20 = this.rand.nextInt(this.rand.nextInt(120) + 8);
-			var21 = var5 + this.rand.nextInt(16) + 8;
-			(new LiquidsFeature(Block.flowingWater.blockID)).generate(this.worldObj, this.rand, var19, var20, var21);
-		}
-
-		for(var25 = 0; var25 < 20; ++var25) {
-			var19 = var4 + this.rand.nextInt(16) + 8;
-			var20 = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(112) + 8) + 8);
-			var21 = var5 + this.rand.nextInt(16) + 8;
-			(new LiquidsFeature(Block.flowingLava.blockID)).generate(this.worldObj, this.rand, var19, var20, var21);
-		}
-
-		this.generatedTemperatures = this.worldObj.getBiomeSource().getTemperatures(this.generatedTemperatures, var4 + 8, var5 + 8, 16, 16);
+//		for(var25 = 0; var25 < 50; ++var25) {
+//			var19 = var4 + this.rand.nextInt(16) + 8;
+//			var20 = this.rand.nextInt(this.rand.nextInt(120) + 8);
+//			var21 = var5 + this.rand.nextInt(16) + 8;
+//			(new LiquidsFeature(Block.flowingWater.blockID)).generate(this.worldObj, this.rand, var19, var20, var21);
+//		}
+//
+//		for(var25 = 0; var25 < 20; ++var25) {
+//			var19 = var4 + this.rand.nextInt(16) + 8;
+//			var20 = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(112) + 8) + 8);
+//			var21 = var5 + this.rand.nextInt(16) + 8;
+//			(new LiquidsFeature(Block.flowingLava.blockID)).generate(this.worldObj, this.rand, var19, var20, var21);
+//		}
 
 		for(var25 = var4 + 8; var25 < var4 + 8 + 16; ++var25) {
 			for(var19 = var5 + 8; var19 < var5 + 8 + 16; ++var19) {
 				var20 = var25 - (var4 + 8);
 				var21 = var19 - (var5 + 8);
 				int var22 = this.worldObj.getTopSolidOrLiquidBlock(var25, var19);
-				double var23 = this.generatedTemperatures[var20 * 16 + var21] - (double)(var22 - 64) / 64.0D * 0.3D;
-				if(var23 < 0.5D && var22 > 0 && var22 < 128 && this.worldObj.isAirBlock(var25, var22, var19) && this.worldObj.getBlockMaterial(var25, var22 - 1, var19).getIsSolid() && this.worldObj.getBlockMaterial(var25, var22 - 1, var19) != Material.ice) {
+				if(this.worldObj.getBiomeAt(var25, var19).getEnableSnow() && this.worldObj.isAirBlock(var25, var22, var19) && this.worldObj.getBlockMaterial(var25, var22 - 1, var19).getIsSolid() && this.worldObj.getBlockMaterial(var25, var22 - 1, var19) != Material.ice) {
 					this.worldObj.setBlockWithNotify(var25, var22, var19, Block.snowLayer.blockID);
 				}
 			}
--- net/minecraft/server/command/ConsoleCommandHandler.java
+++ net/minecraft/server/command/ConsoleCommandHandler.java
@@ -66,11 +66,11 @@
 						var13 = var2.substring(var2.indexOf(" ")).trim();
 						var5.opPlayer(var13);
 						this.sendNoticeToOps(var4, "Opping " + var13);
-						var5.sendChatMessageToPlayer(var13, "\u00a7eYou are now op!");
+						var5.sendChatMessageToPlayer(var13, "§eYou are now op!");
 					} else if(var2.toLowerCase().startsWith("deop ")) {
 						var13 = var2.substring(var2.indexOf(" ")).trim();
 						var5.deopPlayer(var13);
-						var5.sendChatMessageToPlayer(var13, "\u00a7eYou are no longer op!");
+						var5.sendChatMessageToPlayer(var13, "§eYou are no longer op!");
 						this.sendNoticeToOps(var4, "De-opping " + var13);
 					} else if(var2.toLowerCase().startsWith("ban-ip ")) {
 						var13 = var2.substring(var2.indexOf(" ")).trim();
@@ -207,14 +207,14 @@
 									} else if(var2.toLowerCase().startsWith("say ")) {
 										var2 = var2.substring(var2.indexOf(" ")).trim();
 										minecraftLogger.info("[" + var4 + "] " + var2);
-										var5.sendPacketToAllPlayers(new Packet3Chat("\u00a7d[Server] " + var2));
+										var5.sendPacketToAllPlayers(new Packet3Chat("§d[Server] " + var2));
 									} else if(var2.toLowerCase().startsWith("tell ")) {
 										var18 = var2.split(" ");
 										if(var18.length >= 3) {
 											var2 = var2.substring(var2.indexOf(" ")).trim();
 											var2 = var2.substring(var2.indexOf(" ")).trim();
 											minecraftLogger.info("[" + var4 + "->" + var18[1] + "] " + var2);
-											var2 = "\u00a77" + var4 + " whispers " + var2;
+											var2 = "§7" + var4 + " whispers " + var2;
 											minecraftLogger.info(var2);
 											if(!var5.sendPacketToPlayer(var18[1], new Packet3Chat(var2))) {
 												var3.log("There\'s no player by that name online.");
@@ -302,7 +302,7 @@
 
 	private void sendNoticeToOps(String var1, String var2) {
 		String var3 = var1 + ": " + var2;
-		this.minecraftServer.configManager.sendChatMessageToAllOps("\u00a77(" + var3 + ")");
+		this.minecraftServer.configManager.sendChatMessageToAllOps("§7(" + var3 + ")");
 		minecraftLogger.info(var3);
 	}
 
--- net/minecraft/game/world/block/PistonExtensionBlock.java
+++ net/minecraft/game/world/block/PistonExtensionBlock.java
@@ -5,9 +5,15 @@
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.EnumProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
 import net.minecraft.game.world.material.Material;
 
 public class PistonExtensionBlock extends Block {
+	public static final EnumProperty<Direction> DIRECTION = SharedProperties.DIRECTION;
+	public static final BooleanProperty STICKY = new BooleanProperty("sticky");
 	private int overrideTexture = -1;
 
 	public PistonExtensionBlock(int var1, int var2) {
@@ -16,6 +22,10 @@
 		this.setHardness(0.5F);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, STICKY);
+	}
+
 	public void setOverrideTexture(int var1) {
 		this.overrideTexture = var1;
 	}
@@ -26,14 +36,15 @@
 
 	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
 		super.onBlockRemoval(var1, var2, var3, var4);
-		int var5 = var1.getBlockMetadata(var2, var3, var4);
-		int var6 = Direction.oppositeFace[wrapEight(var5)];
-		var2 += Direction.faceToX[var6];
-		var3 += Direction.faceToY[var6];
-		var4 += Direction.faceToZ[var6];
+		Direction dir = var1.getBlockProperty(var2, var3, var4, DIRECTION); // FIXME: why is this always null?
+		if (dir == null) dir = Direction.TOP;
+		else dir = dir.getOpposite();
+		var2 += dir.X;
+		var3 += dir.Y;
+		var4 += dir.Z;
 		int var7 = var1.getBlockId(var2, var3, var4);
 		if(var7 == Block.piston.blockID || var7 == Block.stickyPiston.blockID) {
-			var5 = var1.getBlockMetadata(var2, var3, var4);
+			int var5 = var1.getBlockMetadata(var2, var3, var4);
 			if(PistonBaseBlock.isExtended(var5)) {
 				Block.blocksList[var7].dropBlockAsItem(var1, var2, var3, var4, var5);
 				var1.setBlockWithNotify(var2, var3, var4, 0);
@@ -43,8 +54,9 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		int var3 = wrapEight(var2);
-		return var1 == var3 ? (this.overrideTexture >= 0 ? this.overrideTexture : ((var2 & 8) != 0 ? this.textureIndex - 1 : this.textureIndex)) : (var1 == Direction.oppositeFace[var3] ? 107 : 108);
+		Direction var3 = this.properties.get(var2, DIRECTION);
+		boolean var3a = this.properties.get(var2, STICKY);
+		return var1 == var3.ordinal() ? (this.overrideTexture >= 0 ? this.overrideTexture : (var3a ? Block.stickyPiston.textureIndex : Block.piston.textureIndex)) : (var1 == var3.getOpposite().ordinal() ? Block.piston.textureIndex : PistonBaseBlock.TEX_SIDE);
 	}
 
 	public int getRenderType() {
@@ -139,12 +151,12 @@
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = wrapEight(var1.getBlockMetadata(var2, var3, var4));
-		int var7 = var1.getBlockId(var2 - Direction.faceToX[var6], var3 - Direction.faceToY[var6], var4 - Direction.faceToZ[var6]);
+		Direction var6 = var1.getBlockProperty(var2, var3, var4, DIRECTION);
+		int var7 = var1.getBlockId(var2 - var6.X, var3 - var6.Y, var4 - var6.Z);
 		if(var7 != Block.piston.blockID && var7 != Block.stickyPiston.blockID) {
 			var1.setBlockWithNotify(var2, var3, var4, 0);
 		} else {
-			Block.blocksList[var7].onNeighborBlockChange(var1, var2 - Direction.faceToX[var6], var3 - Direction.faceToY[var6], var4 - Direction.faceToZ[var6], var5);
+			Block.blocksList[var7].onNeighborBlockChange(var1, var2 - var6.X, var3 - var6.Y, var4 - var6.Z, var5);
 		}
 
 	}
--- net/minecraft/client/gui/component/GuiSlot.java
+++ net/minecraft/client/gui/component/GuiSlot.java
@@ -60,7 +60,7 @@
 		return this.getSize() * this.posZ + this.field_27261_r;
 	}
 
-	protected abstract void drawBackground();
+	protected abstract void drawBackground(float var3);
 
 	protected abstract void drawSlot(int var1, int var2, int var3, int var4, Tessellator var5);
 
@@ -118,7 +118,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawBackground();
+		this.drawBackground(var3);
 		int var4 = this.getSize();
 		int var5 = this.width / 2 + 124;
 		int var6 = var5 + 6;
@@ -186,16 +186,6 @@
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glDisable(GL11.GL_FOG);
 		Tessellator var16 = Tessellator.instance;
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/gui/background.png"));
-		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-		float var17 = 32.0F;
-		var16.startDrawingQuads();
-		var16.setColorOpaque_I(2105376);
-		var16.addVertexWithUV((double)this.left, (double)this.bottom, 0.0D, (double)((float)this.left / var17), (double)((float)(this.bottom + (int)this.amountScrolled) / var17));
-		var16.addVertexWithUV((double)this.right, (double)this.bottom, 0.0D, (double)((float)this.right / var17), (double)((float)(this.bottom + (int)this.amountScrolled) / var17));
-		var16.addVertexWithUV((double)this.right, (double)this.top, 0.0D, (double)((float)this.right / var17), (double)((float)(this.top + (int)this.amountScrolled) / var17));
-		var16.addVertexWithUV((double)this.left, (double)this.top, 0.0D, (double)((float)this.left / var17), (double)((float)(this.top + (int)this.amountScrolled) / var17));
-		var16.draw();
 		var9 = this.width / 2 - 92 - 16;
 		var10 = this.top + 4 - (int)this.amountScrolled;
 		if(this.field_27262_q) {
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerApplyBiomesToLand.java
@@ -1,0 +1,41 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.util.IntArray2D;
+
+public class LayerApplyBiomesToLand extends Layer {
+	private final Layer biomes;
+	private final Layer land;
+
+	public LayerApplyBiomesToLand(Layer biomes, Layer land) {
+		super(0L, biomes);
+		this.biomes = biomes;
+		this.land = land;
+	}
+
+	public void setWorldSeed(long seed) {
+		this.biomes.setWorldSeed(seed);
+		this.land.setWorldSeed(seed);
+		super.setWorldSeed(seed);
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		IntArray2D biomeData = this.biomes.getCachedData(x, z, width, length);
+		IntArray2D landData = this.land.getCachedData(x, z, width, length);
+		IntArray2D output = new IntArray2D(width, length);
+
+		for (int xx = 0; xx < width; xx++) {
+			for (int zz = 0; zz < length; zz++) {
+				int land = landData.get(xx, zz);
+				int biome = biomeData.get(xx, zz);
+				output.set(xx, zz,
+						land < 0 ? 0
+						: land < 0.05D * LayerLand.OCEAN_QUALITY && Biome.biomeIndex[biome].hasBeach() ? Biome.beach.id
+						: biome
+				);
+			}
+		}
+
+		return output;
+	}
+}
--- argo/J_LeafFunctor.java
+++ /dev/null
@@ -1,13 +1,0 @@
-package argo;
-
-abstract class J_LeafFunctor implements J_Functor {
-	public final Object func_27059_b(Object var1) {
-		if(!this.func_27058_a(var1)) {
-			throw J_JsonNodeDoesNotMatchChainedJsonNodeSelectorException.func_27322_a(this);
-		} else {
-			return this.func_27063_c(var1);
-		}
-	}
-
-	protected abstract Object func_27063_c(Object var1);
-}
--- net/minecraft/game/world/block/BookshelfBlock.java
+++ net/minecraft/game/world/block/BookshelfBlock.java
@@ -9,7 +9,7 @@
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 <= 1 ? 4 : this.textureIndex;
+		return var1 <= 1 ? Block.planks.textureIndex : this.textureIndex;
 	}
 
 	public int quantityDropped(Random var1) {
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/Program.java
@@ -1,0 +1,98 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import net.mine_diver.smoothbeta.util.UtilsFromHell;
+import org.lwjgl.opengl.GL20;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Map;
+
+public class Program {
+	private static final int MAX_LOG_LENGTH = 0x8000;
+	private final Type shaderType;
+	private final String name;
+	private int shaderRef;
+
+	protected Program(Type shaderType, int shaderRef, String name) {
+		this.shaderType = shaderType;
+		this.shaderRef = shaderRef;
+		this.name = name;
+	}
+
+	public void attachTo(GlShader program) {
+		GL20.glAttachShader(program.getProgramRef(), this.getShaderRef());
+	}
+
+	public void release() {
+		if (this.shaderRef != -1) {
+			GL20.glDeleteShader(this.shaderRef);
+			this.shaderRef = -1;
+			this.shaderType.getProgramCache().remove(this.name);
+		}
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public static Program createFromResource(Type type, String name, InputStream stream, String domain, GLImportProcessor loader) throws IOException {
+		int i = loadProgram(type, name, stream, domain, loader);
+		Program program = new Program(type, i, name);
+		type.getProgramCache().put(name, program);
+		return program;
+	}
+
+	protected static int loadProgram(Type type, String name, InputStream stream, String domain, GLImportProcessor loader) throws IOException {
+		String string = UtilsFromHell.readResourceAsString(stream);
+		if (string == null) throw new IOException("Could not load program " + type.getName());
+		else {
+			int i = GL20.glCreateShader(type.getGlType());
+			GlStateManager.glShaderSource(i, loader.readSource(string));
+			GL20.glCompileShader(i);
+			if (GL20.glGetShaderi(i, GL20.GL_COMPILE_STATUS) == 0) {
+				String string2 = GL20.glGetShaderInfoLog(i, MAX_LOG_LENGTH).trim();
+				throw new IOException("Couldn't compile " + type.getName() + " program (" + domain + ", " + name + ") : " + string2);
+			} else return i;
+		}
+	}
+
+	protected int getShaderRef() {
+		return this.shaderRef;
+	}
+
+	public enum Type {
+		VERTEX("vertex", ".vsh", GL20.GL_VERTEX_SHADER),
+		FRAGMENT("fragment", ".fsh", GL20.GL_FRAGMENT_SHADER);
+
+		private final String name;
+		private final String fileExtension;
+		private final int glType;
+		private final Map<String, Program> programCache = new HashMap<>();
+
+		Type(String name, String extension, int glType) {
+			this.name = name;
+			this.fileExtension = extension;
+			this.glType = glType;
+		}
+
+		public String getName() {
+			return this.name;
+		}
+
+		public String getFileExtension() {
+			return this.fileExtension;
+		}
+
+		int getGlType() {
+			return this.glType;
+		}
+
+		/**
+		 * Gets a map of loaded shaders.
+		 */
+		public Map<String, Program> getProgramCache() {
+			return this.programCache;
+		}
+	}
+}
--- net/minecraft/game/world/block/RedstoneWireBlock.java
+++ net/minecraft/game/world/block/RedstoneWireBlock.java
@@ -12,16 +12,19 @@
 import net.minecraft.game.world.material.Material;
 
 public class RedstoneWireBlock extends Block {
+	public static final int TEX_CROSS = TerrainLayout.texCoord("redstone_cross");
+	public static final int TEX_LINE = TerrainLayout.texCoord("redstone_line");
+
 	private boolean wiresProvidePower = true;
 	private Set powerUpdates = new HashSet();
 
-	public RedstoneWireBlock(int var1, int var2) {
-		super(var1, var2, Material.circuits);
+	public RedstoneWireBlock(int var1) {
+		super(var1, TEX_CROSS, Material.circuits);
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F / 16.0F, 1.0F);
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return this.textureIndex;
+		return var1 == 1 ? TEX_LINE : TEX_CROSS;
 	}
 
 	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
--- net/minecraft/game/entity/LivingEntity.java
+++ net/minecraft/game/entity/LivingEntity.java
@@ -2,6 +2,8 @@
 
 import com.mojang.nbt.CompoundTag;
 import java.util.List;
+
+import net.minecraft.game.entity.loot.EntityLootEntry;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.physics.AxisAlignedBB;
@@ -65,6 +67,8 @@
 	protected boolean isJumping = false;
 	protected float defaultPitch = 0.0F;
 	protected float moveSpeed = 0.7F;
+	protected float groundSpeedMultiplier = 1.0F;
+	protected float airSpeedMultiplier = 1.0F;
 	private Entity currentTarget;
 	protected int numTicksToChaseTarget = 0;
 
@@ -81,6 +85,10 @@
 	protected void entityInit() {
 	}
 
+	public boolean moveInRemoteWorld() {
+		return false;
+	}
+
 	public boolean canEntityBeSeen(Entity var1) {
 		return this.worldObj.rayTraceBlocks(Vec3D.createVector(this.posX, this.posY + (double)this.getEyeHeight(), this.posZ), Vec3D.createVector(var1.posX, var1.posY + (double)var1.getEyeHeight(), var1.posZ)) == null;
 	}
@@ -433,19 +441,17 @@
 	}
 
 	protected void dropFewItems() {
-		int var1 = this.getDropItemId();
-		if(var1 > 0) {
-			int var2 = this.rand.nextInt(3);
+		List<EntityLootEntry> loot = EntityRegistry.getLoot(this);
+		if (loot == null) return;
 
-			for(int var3 = 0; var3 < var2; ++var3) {
-				this.dropItem(var1, 1);
+		for (EntityLootEntry lootEntry : loot) {
+			ItemStack item = lootEntry.getItem(this, this.rand);
+			if (item != null) {
+				for (int i = 0; i < item.count; i++) {
+					this.entityDropItem(new ItemStack(item.id, 1, item.getItemDamage()), 0.0F);
+				}
 			}
 		}
-
-	}
-
-	protected int getDropItemId() {
-		return 0;
 	}
 
 	protected void onFall(float var1) {
@@ -456,7 +462,7 @@
 			int var3 = this.worldObj.getBlockId(MathHelper.floor(this.posX), MathHelper.floor(this.posY - (double)0.2F - (double)this.yOffset), MathHelper.floor(this.posZ));
 			if(var3 > 0) {
 				StepSound var4 = Block.blocksList[var3].stepSound;
-				this.worldObj.playSoundAtEntity(this, var4.baseStepSoundDir(), var4.getVolume() * 0.5F, var4.getPitch() * (12.0F / 16.0F));
+				this.worldObj.playSoundAtEntity(this, var4.baseSteppySoundDir(), var4.getVolume() * 0.5F, var4.getPitch() * (12.0F / 16.0F));
 			}
 		}
 
@@ -497,7 +503,7 @@
 			}
 
 			float var9 = 0.16277136F / (var8 * var8 * var8);
-			this.moveFlying(var1, var2, this.onGround ? 0.1F * var9 : 0.02F);
+			this.moveFlying(var1, var2, (this.onGround ? 0.1F * var9 * this.groundSpeedMultiplier : 0.02F * this.airSpeedMultiplier));
 			var8 = 0.91F;
 			if(this.onGround) {
 				var8 = 546.0F * 0.1F * 0.1F * 0.1F;
@@ -540,7 +546,9 @@
 				this.motionY = 0.2D;
 			}
 
-			this.motionY -= 0.08D;
+			if (!this.flying) {
+				this.motionY -= 0.08D;
+			}
 			this.motionY *= (double)0.98F;
 			this.motionX *= (double)var8;
 			this.motionZ *= (double)var8;
--- /dev/null
+++ net/minecraft/game/item/InventoryReadonly.java
@@ -1,0 +1,155 @@
+package net.minecraft.game.item;
+
+import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.world.block.Block;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.*;
+
+public class InventoryReadonly implements Inventory {
+	private final ItemStack[] items;
+	private final boolean pickable;
+	public final Map<Integer, String> labels;
+	public boolean pickOne;
+
+	public InventoryReadonly(ItemStack[] items, boolean pickable, Map<Integer, String> labels) {
+		this.items = items;
+		this.pickable = pickable;
+		this.labels = labels;
+	}
+
+	public String getLabel(int row) {
+		return labels != null ? labels.get(row) : null;
+	}
+
+	public static InventoryReadonly generateCreativeInventory(boolean debug) {
+		List<ItemStack> items = new ArrayList<>();
+		for (int i = 0; i < Item.itemsList.length - 1; i++) {
+			Item item = Item.itemsList[i];
+			if (i < 10000 && Item.itemsList[i] instanceof BlockItem) {
+				Block block = Block.blocksList[i];
+				if (block == null) {
+					continue;
+				}
+//				for (int m : block.availableMetadata()) {
+					ItemStack stack = new ItemStack(i, 1, /*-1, */0/*m*/);
+					if (stack.getItem() != null/* && (debug || !stack.getTooltip().gradient.equals(ItemTooltip.INVALID_GRAD))*/) {
+						items.add(stack);
+					}
+//				}
+			} else {
+				if (item == null) {
+					continue;
+				}
+//				for (int m : item.availableMetadata()) {
+					ItemStack stack = new ItemStack(i, 1, /*-1,*/ 0/*m*/);
+					if (stack.getItem() != null/* && (debug || !stack.getTooltip().gradient.equals(ItemTooltip.INVALID_GRAD))*/) {
+						items.add(stack);
+					}
+//				}
+			}
+		}
+		ItemStack[] itemArray = new ItemStack[items.size()];
+		items.toArray(itemArray);
+		return new InventoryReadonly(itemArray, true, null);
+//		return null;
+	}
+
+	public static InventoryReadonly getCreativeInventory() {
+		try {
+			List<String> ids = new ArrayList<>();
+			BufferedReader reader = new BufferedReader(
+					new InputStreamReader(
+							Objects.requireNonNull(InventoryReadonly.class.getResourceAsStream("/gui/creative_items.txt"))));
+
+			String line;
+			while ((line = reader.readLine()) != null) {
+				if (!line.matches("\\s*#.*") && !line.isEmpty()) {
+					if (line.startsWith(": ")) {
+						ids.add(line);
+					} else {
+						ids.addAll(Arrays.asList(line.trim().split("#")[0].split("\\s+")));
+					}
+				}
+			}
+
+			CreativeInventoryBuilder inv = new CreativeInventoryBuilder();
+			for (String id : ids) {
+				if (id.startsWith(": ")) {
+					inv.addLabel(id.substring(2));
+					continue;
+				}
+
+				if (id.equals("/br")) {
+					inv.lineBreak();
+					continue;
+				}
+
+				if (id.equals("/n")) {
+					inv.newLine();
+					continue;
+				}
+
+				String[] idSplit = id.split("-");
+				boolean isItem = idSplit[0].startsWith("i");
+				if (isItem) {
+					idSplit[0] = idSplit[0].substring(1);
+				}
+
+				int itemID = Integer.parseInt(idSplit[0]);
+				int itemMetadata = idSplit.length >= 2 ? Integer.parseInt(idSplit[1]) : 0;
+				if (isItem) {
+					itemID += 256;
+				}
+
+				inv.addItem(itemID, itemMetadata);
+			}
+
+			return inv.toInventory();
+		} catch (Exception e) {
+			System.out.println("Could not get creative inventory!");
+			e.printStackTrace();
+			System.out.println("Generating creative inventory instead...");
+			return generateCreativeInventory(false);
+		}
+	}
+
+	public int getSize() {
+		return items.length;
+	}
+
+	public ItemStack getStackInSlot(int var1) {
+		return var1 < items.length
+			? items[var1] == null
+				? null
+				: items[var1].copy()
+			: null;
+	}
+
+	public ItemStack decrStackSize(int var1, int var2) {
+		return this.pickable
+				? new ItemStack(items[var1].id,
+						this.pickOne ? 1 : items[var1].getMaxStackSize(),
+						items[var1].getItemDamage())
+				: null;
+	}
+
+	public void setInventorySlotContents(int var1, ItemStack var2) {
+	}
+
+	public String getName() {
+		return "Readonly Inventory";
+	}
+
+	public int getStackLimit() {
+		return 64;
+	}
+
+	public void onChanged() {
+	}
+
+	public boolean canInteractWith(PlayerEntity var1) {
+		return true;
+	}
+}
--- net/minecraft/client/render/ChunkRenderer.java
+++ net/minecraft/client/render/ChunkRenderer.java
@@ -3,6 +3,13 @@
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+
+import net.mine_diver.smoothbeta.client.render.SmoothChunkRenderer;
+import net.mine_diver.smoothbeta.client.render.SmoothTessellator;
+import net.mine_diver.smoothbeta.client.render.SmoothWorldRenderer;
+import net.mine_diver.smoothbeta.client.render.VboPool;
+import net.mine_diver.smoothbeta.client.render.gl.VertexBuffer;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.render.camera.ICamera;
 import net.minecraft.client.render.entity.RenderItem;
 import net.minecraft.client.render.tileentity.TileEntityRenderer;
@@ -16,7 +23,7 @@
 import net.minecraft.util.MathHelper;
 import org.lwjgl.opengl.GL11;
 
-public class ChunkRenderer {
+public class ChunkRenderer implements SmoothChunkRenderer {
 	public World worldObj;
 	private int glRenderList = -1;
 	private static Tessellator tessellator = Tessellator.instance;
@@ -49,6 +56,18 @@
 	private boolean isInitialized = false;
 	public List tileEntityRenderers = new ArrayList();
 	private List tileEntities;
+	private VertexBuffer[] smoothbeta_buffers;
+	private int smoothbeta_currentBufferIndex = -1;
+
+	@Override
+	public VertexBuffer smoothbeta_getBuffer(int pass) {
+		return smoothbeta_buffers[pass];
+	}
+
+	@Override
+	public VertexBuffer smoothbeta_getCurrentBuffer() {
+		return smoothbeta_buffers[smoothbeta_currentBufferIndex];
+	}
 
 	public ChunkRenderer(World var1, List var2, int var3, int var4, int var5, int var6, int var7) {
 		this.worldObj = var1;
@@ -59,6 +78,10 @@
 		this.posX = -999;
 		this.setPosition(var3, var4, var5);
 		this.needsUpdate = false;
+		smoothbeta_buffers = new VertexBuffer[skipRenderPass.length];
+		VboPool pool = ((SmoothWorldRenderer) Minecraft.getInstance().worldRenderer).smoothbeta_getTerrainVboPool();
+        for (int i = 0; i < smoothbeta_buffers.length; i++)
+            smoothbeta_buffers[i] = new VertexBuffer(pool);
 	}
 
 	public void setPosition(int var1, int var2, int var3) {
@@ -86,7 +109,6 @@
 	}
 
 	private void setupGLTranslation() {
-		GL11.glTranslatef((float)this.posXClip, (float)this.posYClip, (float)this.posZClip);
 	}
 
 	public void updateRenderer() {
@@ -104,8 +126,7 @@
 			}
 
 			Chunk.isLit = false;
-			HashSet var21 = new HashSet();
-			var21.addAll(this.tileEntityRenderers);
+			HashSet var21 = new HashSet(this.tileEntityRenderers);
 			this.tileEntityRenderers.clear();
 			byte var8 = 1;
 			ChunkCache var9 = new ChunkCache(this.worldObj, var1 - var8, var2 - var8, var3 - var8, var4 + var8, var5 + var8, var6 + var8);
@@ -123,15 +144,13 @@
 							if(var18 > 0) {
 								if(!var14) {
 									var14 = true;
-									GL11.glNewList(this.glRenderList + var11, GL11.GL_COMPILE);
-									GL11.glPushMatrix();
 									this.setupGLTranslation();
 									float var19 = 1.000001F;
-									GL11.glTranslatef((float)(-this.sizeDepth) / 2.0F, (float)(-this.sizeHeight) / 2.0F, (float)(-this.sizeDepth) / 2.0F);
-									GL11.glScalef(var19, var19, var19);
-									GL11.glTranslatef((float)this.sizeDepth / 2.0F, (float)this.sizeHeight / 2.0F, (float)this.sizeDepth / 2.0F);
+									smoothbeta_currentBufferIndex = var11;
+							        ((SmoothTessellator) tessellator).smoothbeta_startRenderingTerrain(this);
 									tessellator.startDrawingQuads();
 									tessellator.setTranslationD((double)(-this.posX), (double)(-this.posY), (double)(-this.posZ));
+									tessellator.setTranslationF(this.posXClip, this.posYClip, this.posZClip);
 								}
 
 								if(var11 == 0 && Block.isBlockContainer[var18]) {
@@ -155,8 +174,8 @@
 
 				if(var14) {
 					tessellator.draw();
-					GL11.glPopMatrix();
-					GL11.glEndList();
+					smoothbeta_currentBufferIndex = -1;
+			        ((SmoothTessellator) tessellator).smoothbeta_stopRenderingTerrain();
 					tessellator.setTranslationD(0.0D, 0.0D, 0.0D);
 				} else {
 					var13 = false;
@@ -171,11 +190,10 @@
 				}
 			}
 
-			HashSet var22 = new HashSet();
-			var22.addAll(this.tileEntityRenderers);
+			HashSet var22 = new HashSet(this.tileEntityRenderers);
 			var22.removeAll(var21);
 			this.tileEntities.addAll(var22);
-			var21.removeAll(this.tileEntityRenderers);
+			this.tileEntityRenderers.forEach(var21::remove);
 			this.tileEntities.removeAll(var21);
 			this.isChunkLit = Chunk.isLit;
 			this.isInitialized = true;
--- /dev/null
+++ argo/jdom/JsonArrayNodeBuilder.java
@@ -1,0 +1,23 @@
+package argo.jdom;
+
+import java.util.LinkedList;
+import java.util.List;
+
+public final class JsonArrayNodeBuilder implements JsonNodeBuilder {
+	private final List<JsonNodeBuilder> elementBuilders = new LinkedList<>();
+
+	public JsonArrayNodeBuilder withElement(JsonNodeBuilder var1) {
+		this.elementBuilders.add(var1);
+		return this;
+	}
+
+	public JsonRootNode buildNode() {
+		LinkedList<JsonNode> var1 = new LinkedList<>();
+
+        for (JsonNodeBuilder object : this.elementBuilders) {
+            var1.add(object.buildNode());
+        }
+
+		return JsonNodeFactories.aJsonArray(var1);
+	}
+}
--- net/minecraft/game/world/block/PumpkinBlock.java
+++ net/minecraft/game/world/block/PumpkinBlock.java
@@ -6,6 +6,11 @@
 import net.minecraft.util.MathHelper;
 
 public class PumpkinBlock extends Block {
+	private static final int TEX_TOP = TerrainLayout.texCoord("pumpkin_top");
+	private static final int TEX_SIDE = TerrainLayout.texCoord("pumpkin_side");
+	private static final int TEX_FRONT = TerrainLayout.texCoord("pumpkin_front");
+	private static final int TEX_FRONT_LIT = TerrainLayout.texCoord("jack_o_lantern");
+
 	private boolean lit;
 
 	protected PumpkinBlock(int var1, int var2, boolean var3) {
@@ -16,22 +21,16 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		if(var1 == 1) {
-			return this.textureIndex;
-		} else if(var1 == 0) {
-			return this.textureIndex;
+		if (var1 < 2) {
+			return TEX_TOP;
 		} else {
-			int var3 = this.textureIndex + 1 + 16;
-			if(this.lit) {
-				++var3;
-			}
-
-			return var2 == 2 && var1 == 2 ? var3 : (var2 == 3 && var1 == 5 ? var3 : (var2 == 0 && var1 == 3 ? var3 : (var2 == 1 && var1 == 4 ? var3 : this.textureIndex + 16)));
+			int var3 = this.lit ? TEX_FRONT_LIT : TEX_FRONT;
+			return var2 == 2 && var1 == 2 || var2 == 3 && var1 == 5 || var2 == 0 && var1 == 3 || var2 == 1 && var1 == 4 ? var3 : TEX_SIDE;
 		}
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex : (var1 == 0 ? this.textureIndex : (var1 == 3 ? this.textureIndex + 1 + 16 : this.textureIndex + 16));
+		return var1 < 2 ? TEX_TOP : var1 == 3 ? (this.lit ? TEX_FRONT_LIT : TEX_FRONT) : TEX_SIDE;
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
--- net/minecraft/network/NetClientHandler.java
+++ net/minecraft/network/NetClientHandler.java
@@ -7,6 +7,7 @@
 import java.net.Socket;
 import java.net.URL;
 import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
 import java.util.List;
 import java.util.Random;
 import net.minecraft.client.Minecraft;
@@ -50,6 +51,7 @@
 import net.minecraft.game.world.block.tileentity.SignTileEntity;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.chunk.ChunkSection;
 import net.minecraft.game.world.map.MapStorage;
 import net.minecraft.game.world.save.SaveHandler;
 import net.minecraft.network.packet.Packet;
@@ -125,7 +127,7 @@
 	public void handleLogin(Packet1Login var1) {
 		this.mc.playerController = new ClientPlayerController(this.mc, this);
 		this.mc.statFileWriter.readStat(StatList.joinMultiplayerStat, 1);
-		this.worldClient = new WorldClient(this, var1.mapSeed, var1.dimension);
+		this.worldClient = new WorldClient(this, var1.dimension);
 		this.worldClient.remoteWorld = true;
 		this.mc.changeWorld1(this.worldClient);
 		this.mc.thePlayer.dimension = var1.dimension;
@@ -201,6 +203,10 @@
 			var8 = new FallingBlockEntity(this.worldClient, var2, var4, var6, Block.gravel.blockID);
 		}
 
+		if(var1.type == 72) {
+			var8 = new FallingBlockEntity(this.worldClient, var2, var4, var6, Block.redSand.blockID);
+		}
+
 		if(var8 != null) {
 			((Entity)var8).serverPosX = var1.xPosition;
 			((Entity)var8).serverPosY = var1.yPosition;
@@ -365,12 +371,12 @@
 		int var4 = var1.zPosition * 16;
 
 		for(int var5 = 0; var5 < var1.size; ++var5) {
-			short var6 = var1.coordinateArray[var5];
+			int var6 = var1.coordinateArray[var5];
 			int var7 = var1.typeArray[var5] & 255;
 			byte var8 = var1.metadataArray[var5];
-			int var9 = var6 >> 12 & 15;
-			int var10 = var6 >> 8 & 15;
-			int var11 = var6 & 255;
+			int var9 = var6 >>> 4 & 15;
+			int var10 = var6 & 15;
+			int var11 = (var6 >>> 8) - (1 << 23);
 			var2.setBlockAndMetadata(var9, var11, var10, var7, var8);
 			this.worldClient.func_711_c(var9 + var3, var11, var10 + var4, var9 + var3, var11, var10 + var4);
 			this.worldClient.markBlocksDirty(var9 + var3, var11, var10 + var4, var9 + var3, var11, var10 + var4);
@@ -379,8 +385,26 @@
 	}
 
 	public void handleMapChunk(Packet51MapChunk var1) {
-		this.worldClient.func_711_c(var1.xPosition, var1.yPosition, var1.zPosition, var1.xPosition + var1.xSize - 1, var1.yPosition + var1.ySize - 1, var1.zPosition + var1.zSize - 1);
-		this.worldClient.setChunkData(var1.xPosition, var1.yPosition, var1.zPosition, var1.xSize, var1.ySize, var1.zSize, var1.chunk);
+		Chunk chunk = this.worldClient.getChunkFromChunkCoords(var1.xPosition, var1.zPosition);
+		int worldX = var1.xPosition * 16;
+		int worldZ = var1.zPosition * 16;
+
+		int offset = 0;
+		while (offset < var1.data.length) {
+			if (var1.data.length - offset < ChunkSection.PACKED_DATA_SIZE)
+				break; //Can't possibly be a chunk section.
+
+			int level = ByteBuffer.wrap(var1.data, offset, 4).getInt();
+			ChunkSection section = ChunkSection.fromBytes(var1.data, offset + 4);
+			chunk.addSection(level, section);
+			this.worldClient.markBlocksDirty(worldX, level << 4, worldZ, 16, 16, 16);
+			offset += ChunkSection.PACKED_DATA_SIZE;
+		}
+
+		if (var1.includeInitialize)
+			System.arraycopy(var1.data, offset, chunk.getBiomeArray(), 0, 256);
+
+		this.worldClient.func_711_c(var1.xPosition, chunk.getMinLevel() << 4, var1.zPosition, var1.xPosition + 15, (chunk.getMaxLevel() << 4) + 15, var1.zPosition + 15);
 	}
 
 	public void handleBlockChange(Packet53BlockChange var1) {
@@ -388,10 +412,10 @@
 	}
 
 	public void handleKickDisconnect(Packet255KickDisconnect var1) {
-		this.netManager.networkShutdown("disconnect.kicked", new Object[0]);
+		this.netManager.networkShutdown("disconnect.kicked");
 		this.disconnected = true;
 		this.mc.changeWorld1((World)null);
-		this.mc.displayGuiScreen(new ConnectionFailedScreen("disconnect.disconnected", "disconnect.genericReason", new Object[]{var1.reason}));
+		this.mc.displayGuiScreen(new ConnectionFailedScreen("disconnect.disconnected", "disconnect.genericReason", var1.reason));
 	}
 
 	public void handleErrorMessage(String var1, Object[] var2) {
@@ -467,7 +491,7 @@
 
 	public void handleHandshake(Packet2Handshake var1) {
 		if(var1.username.equals("-")) {
-			this.addToSendQueue(new Packet1Login(this.mc.session.username, 14));
+			this.addToSendQueue(new Packet1Login(this.mc.session.username, PROTOCOL_VERSION));
 		} else {
 			try {
 				URL var2 = new URL("http://www.minecraft.net/game/joinserver.jsp?user=" + this.mc.session.username + "&sessionId=" + this.mc.session.sessionId + "&serverId=" + var1.username);
@@ -475,13 +499,13 @@
 				String var4 = var3.readLine();
 				var3.close();
 				if(var4.equalsIgnoreCase("ok")) {
-					this.addToSendQueue(new Packet1Login(this.mc.session.username, 14));
+					this.addToSendQueue(new Packet1Login(this.mc.session.username, PROTOCOL_VERSION));
 				} else {
-					this.netManager.networkShutdown("disconnect.loginFailedInfo", new Object[]{var4});
+					this.netManager.networkShutdown("disconnect.loginFailedInfo", var4);
 				}
 			} catch (Exception var5) {
 				var5.printStackTrace();
-				this.netManager.networkShutdown("disconnect.genericReason", new Object[]{"Internal client error: " + var5.toString()});
+				this.netManager.networkShutdown("disconnect.genericReason", "Internal client error: " + var5.toString());
 			}
 		}
 
@@ -490,7 +514,7 @@
 	public void disconnect() {
 		this.disconnected = true;
 		this.netManager.wakeThreads();
-		this.netManager.networkShutdown("disconnect.closed", new Object[0]);
+		this.netManager.networkShutdown("disconnect.closed");
 	}
 
 	public void handleMobSpawn(Packet24MobSpawn var1) {
@@ -554,7 +578,7 @@
 	public void handleRespawnPacket(Packet9Respawn var1) {
 		if(var1.dimension != this.mc.thePlayer.dimension) {
 			this.field_1210_g = false;
-			this.worldClient = new WorldClient(this, this.worldClient.getWorldInfo().getRandomSeed(), var1.dimension);
+			this.worldClient = new WorldClient(this, var1.dimension);
 			this.worldClient.remoteWorld = true;
 			this.mc.changeWorld1(this.worldClient);
 			this.mc.thePlayer.dimension = var1.dimension;
@@ -641,9 +665,7 @@
 			if(var2 instanceof SignTileEntity) {
 				SignTileEntity var3 = (SignTileEntity)var2;
 
-				for(int var4 = 0; var4 < 4; ++var4) {
-					var3.signText[var4] = var1.signLines[var4];
-				}
+				System.arraycopy(var1.signLines, 0, var3.signText, 0, 4);
 
 				var3.onChanged();
 			}
--- net/minecraft/client/render/RenderList.java
+++ net/minecraft/client/render/RenderList.java
@@ -4,15 +4,15 @@
 import org.lwjgl.opengl.GL11;
 
 public class RenderList {
-	private int field_1242_a;
-	private int field_1241_b;
-	private int field_1240_c;
-	private float field_1239_d;
-	private float field_1238_e;
-	private float field_1237_f;
-	private IntBuffer field_1236_g = GLAllocation.createDirectIntBuffer(65536);
-	private boolean field_1235_h = false;
-	private boolean field_1234_i = false;
+	protected int field_1242_a;
+	protected int field_1241_b;
+	protected int field_1240_c;
+	protected double field_1239_d;
+	protected double field_1238_e;
+	protected double field_1237_f;
+	protected IntBuffer field_1236_g = GLAllocation.createDirectIntBuffer(65536);
+	protected boolean field_1235_h = false;
+	protected boolean field_1234_i = false;
 
 	public void func_861_a(int var1, int var2, int var3, double var4, double var6, double var8) {
 		this.field_1235_h = true;
@@ -20,9 +20,9 @@
 		this.field_1242_a = var1;
 		this.field_1241_b = var2;
 		this.field_1240_c = var3;
-		this.field_1239_d = (float)var4;
-		this.field_1238_e = (float)var6;
-		this.field_1237_f = (float)var8;
+		this.field_1239_d = var4;
+		this.field_1238_e = var6;
+		this.field_1237_f = var8;
 	}
 
 	public boolean func_862_a(int var1, int var2, int var3) {
@@ -46,7 +46,7 @@
 
 			if(this.field_1236_g.remaining() > 0) {
 				GL11.glPushMatrix();
-				GL11.glTranslatef((float)this.field_1242_a - this.field_1239_d, (float)this.field_1241_b - this.field_1238_e, (float)this.field_1240_c - this.field_1237_f);
+				GL11.glTranslatef((float) (this.field_1242_a - this.field_1239_d), (float) (this.field_1241_b - this.field_1238_e), (float) (this.field_1240_c - this.field_1237_f));
 				GL11.glCallLists(this.field_1236_g);
 				GL11.glPopMatrix();
 			}
--- net/minecraft/game/entity/monster/SpiderEntity.java
+++ net/minecraft/game/entity/monster/SpiderEntity.java
@@ -2,7 +2,6 @@
 
 import com.mojang.nbt.CompoundTag;
 import net.minecraft.game.entity.Entity;
-import net.minecraft.game.item.Item;
 import net.minecraft.game.world.World;
 import net.minecraft.util.MathHelper;
 
@@ -73,11 +72,7 @@
 		super.readEntityFromNBT(var1);
 	}
 
-	protected int getDropItemId() {
-		return Item.string.itemID;
-	}
-
-	public boolean isOnLadder() {
+    public boolean isOnLadder() {
 		return this.isCollidedHorizontally;
 	}
 }
--- net/minecraft/client/render/EntityRenderer.java
+++ net/minecraft/client/render/EntityRenderer.java
@@ -1,8 +1,6 @@
 package net.minecraft.client.render;
 
-import java.nio.FloatBuffer;
-import java.util.List;
-import java.util.Random;
+import net.mine_diver.smoothbeta.client.render.Shaders;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.MouseFilter;
 import net.minecraft.client.controller.CreativePlayerController;
@@ -21,8 +19,6 @@
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.biome.Biome;
 import net.minecraft.game.world.block.Block;
-import net.minecraft.game.world.chunk.ChunkProvider;
-import net.minecraft.game.world.chunk.ChunkProviderLoadOrGenerate;
 import net.minecraft.game.world.material.Material;
 import net.minecraft.util.MathHelper;
 import org.lwjgl.input.Mouse;
@@ -32,6 +28,10 @@
 import org.lwjgl.opengl.NVFogDistance;
 import org.lwjgl.util.glu.GLU;
 
+import java.nio.FloatBuffer;
+import java.util.List;
+import java.util.Random;
+
 public class EntityRenderer {
 	public static boolean field_28135_a = false;
 	public static int anaglyphField;
@@ -72,6 +72,10 @@
 	float fogColorBlue;
 	private float fogColor2;
 	private float fogColor1;
+	private float prevFovBoost = 1.0F;
+	private float nextFovBoost = 1.0F;
+	private float fovModifierHand;
+	private float fovModifierHandPrev;
 
 	public EntityRenderer(Minecraft var1) {
 		this.mc = var1;
@@ -79,6 +83,8 @@
 	}
 
 	public void updateRenderer() {
+		this.updateFOV();
+		this.updateFOVModifierHand();
 		this.fogColor2 = this.fogColor1;
 		this.field_22227_s = this.field_22228_r;
 		this.field_22225_u = this.field_22226_t;
@@ -90,7 +96,7 @@
 		}
 
 		float var1 = this.mc.theWorld.getLightBrightness(MathHelper.floor(this.mc.renderViewEntity.posX), MathHelper.floor(this.mc.renderViewEntity.posY), MathHelper.floor(this.mc.renderViewEntity.posZ));
-		float var2 = (float)(3 - this.mc.gameSettings.renderDistance) / 3.0F;
+		float var2 = Math.min((float)(Math.log10(this.mc.gameSettings.renderDistance / 0.75F) / Math.log10(2)) / 4.0F, 1.0F);
 		float var3 = var1 * (1.0F - var2) + var2;
 		this.fogColor1 += (var3 - this.fogColor1) * 0.1F;
 		++this.rendererUpdateCount;
@@ -98,6 +104,11 @@
 		this.addRainParticles();
 	}
 
+	private void updateFOVModifierHand() {
+		fovModifierHandPrev = fovModifierHand;
+		fovModifierHand += (nextFovBoost - fovModifierHand) * 0.5F;
+	}
+
 	public void getMouseOver(float var1) {
 		if(this.mc.renderViewEntity != null) {
 			if(this.mc.theWorld != null) {
@@ -147,7 +158,7 @@
 					}
 				}
 
-				if(this.pointedEntity != null && !(this.mc.playerController instanceof CreativePlayerController)) {
+				if(this.pointedEntity != null) {
 					this.mc.objectMouseOver = new MovingObjectPosition(this.pointedEntity);
 				}
 
@@ -155,9 +166,19 @@
 		}
 	}
 
-	private float getFOVModifier(float var1) {
+	private void updateFOV() {
+		float fovBoost = this.mc.thePlayer.getFovBoost();
+		this.prevFovBoost = this.nextFovBoost;
+		this.nextFovBoost += (fovBoost - this.nextFovBoost) * 0.5F;
+	}
+
+	private float getFOVModifier(float var1, boolean useFOV) {
+		if (Minecraft.PANORAMA_MODE) return 90.0F;
+
 		LivingEntity var2 = this.mc.renderViewEntity;
-		float var3 = 70.0F;
+		float var3 = 30.0F;
+		var3 *= this.prevFovBoost + (this.nextFovBoost - this.prevFovBoost) * var1;
+
 		if(var2.isInsideOfMaterial(Material.water)) {
 			var3 = 60.0F;
 		}
@@ -167,6 +188,11 @@
 			var3 /= (1.0F - 500.0F / (var4 + 500.0F)) * 2.0F + 1.0F;
 		}
 
+		if (useFOV) {
+			var3 += this.mc.gameSettings.fov * 90.0F;
+			var3 *= fovModifierHandPrev + (fovModifierHand - fovModifierHandPrev) * var1;
+		} else var3 = 70.0F;
+
 		return var3 + this.field_22221_y + (this.field_22222_x - this.field_22221_y) * var1;
 	}
 
@@ -280,7 +306,7 @@
 	}
 
 	private void setupCameraTransform(float var1, int var2) {
-		this.farPlaneDistance = (float)(256 >> this.mc.gameSettings.renderDistance);
+		this.farPlaneDistance = this.mc.gameSettings.renderDistance * 16;
 		GL11.glMatrixMode(GL11.GL_PROJECTION);
 		GL11.glLoadIdentity();
 		float var3 = 0.07F;
@@ -291,9 +317,9 @@
 		if(this.cameraZoom != 1.0D) {
 			GL11.glTranslatef((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
 			GL11.glScaled(this.cameraZoom, this.cameraZoom, 1.0D);
-			GLU.gluPerspective(this.getFOVModifier(var1), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+			GLU.gluPerspective(this.getFOVModifier(var1, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
 		} else {
-			GLU.gluPerspective(this.getFOVModifier(var1), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+			GLU.gluPerspective(this.getFOVModifier(var1, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
 		}
 
 		GL11.glMatrixMode(GL11.GL_MODELVIEW);
@@ -320,6 +346,19 @@
 	}
 
 	private void func_4135_b(float var1, int var2) {
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glLoadIdentity();
+
+		if(cameraZoom != 1.0D) {
+			GL11.glTranslatef((float)cameraYaw, (float)(-cameraPitch), 0.0F);
+			GL11.glScaled(cameraZoom, cameraZoom, 1.0D);
+			GLU.gluPerspective(getFOVModifier(var1, false), (float)mc.displayWidth / (float)mc.displayHeight, 0.05F, farPlaneDistance * 2.0F);
+		} else {
+			GLU.gluPerspective(getFOVModifier(var1, false), (float)mc.displayWidth / (float)mc.displayHeight, 0.05F, farPlaneDistance * 2.0F);
+		}
+
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+
 		GL11.glLoadIdentity();
 		if(this.mc.gameSettings.anaglyph) {
 			GL11.glTranslatef((float)(var2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
@@ -451,6 +490,8 @@
 	}
 
 	public void renderWorld(float var1, long var2) {
+		Shaders.getTerrainShader().getUniform("FogShape").set(this.mc.gameSettings.fogShape);
+
 		GL11.glEnable(GL11.GL_CULL_FACE);
 		GL11.glEnable(GL11.GL_DEPTH_TEST);
 		if(this.mc.renderViewEntity == null) {
@@ -464,14 +505,7 @@
 		double var7 = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * (double)var1;
 		double var9 = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * (double)var1;
 		double var11 = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * (double)var1;
-		ChunkProvider var13 = this.mc.theWorld.getChunkProvider();
 		int var16;
-		if(var13 instanceof ChunkProviderLoadOrGenerate) {
-			ChunkProviderLoadOrGenerate var14 = (ChunkProviderLoadOrGenerate)var13;
-			int var15 = MathHelper.floor((float)((int)var7)) >> 4;
-			var16 = MathHelper.floor((float)((int)var11)) >> 4;
-			var14.setCurrentChunkOver(var15, var16);
-		}
 
 		for(int var18 = 0; var18 < 2; ++var18) {
 			if(this.mc.gameSettings.anaglyph) {
@@ -489,7 +523,7 @@
 			GL11.glEnable(GL11.GL_CULL_FACE);
 			this.setupCameraTransform(var1, var18);
 			ClippingHelperImpl.getInstance();
-			if(this.mc.gameSettings.renderDistance < 2) {
+			if(this.mc.gameSettings.renderDistance > 4) {
 				this.setupFog(-1, var1);
 				var5.renderSky(var1);
 			}
@@ -538,7 +572,7 @@
 			GL11.glEnable(GL11.GL_BLEND);
 			GL11.glDisable(GL11.GL_CULL_FACE);
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/terrain.png"));
-			if(this.mc.gameSettings.fancyGraphics) {
+			if(this.mc.gameSettings.graphicsLevel > 0) {
 				if(this.mc.gameSettings.ambientOcclusion) {
 					GL11.glShadeModel(GL11.GL_SMOOTH);
 				}
@@ -600,7 +634,7 @@
 
 	private void addRainParticles() {
 		float var1 = this.mc.theWorld.getRainingStrength(1.0F);
-		if(!this.mc.gameSettings.fancyGraphics) {
+		if(this.mc.gameSettings.graphicsLevel <= 0) {
 			var1 /= 2.0F;
 		}
 
@@ -622,7 +656,7 @@
 				int var17 = var6 + this.random.nextInt(var7) - this.random.nextInt(var7);
 				int var18 = var3.getTopSolidOrLiquidBlock(var16, var17);
 				int var19 = var3.getBlockId(var16, var18 - 1, var17);
-				if(var18 <= var5 + var7 && var18 >= var5 - var7 && var3.getBiomeSource().getBiomeGenAt(var16, var17).canSpawnLightningBolt()) {
+				if(var18 <= var5 + var7 && var18 >= var5 - var7 && var3.getBiomeAt(var16, var17).canSpawnLightningBolt()) {
 					float var20 = this.random.nextFloat();
 					float var21 = this.random.nextFloat();
 					if(var19 > 0) {
@@ -674,7 +708,7 @@
 			double var13 = var3.lastTickPosZ + (var3.posZ - var3.lastTickPosZ) * (double)var1;
 			int var15 = MathHelper.floor(var11);
 			byte var16 = 5;
-			if(this.mc.gameSettings.fancyGraphics) {
+			if(this.mc.gameSettings.graphicsLevel > 0) {
 				var16 = 10;
 			}
 
@@ -742,7 +776,7 @@
 			}
 
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/environment/rain.png"));
-			if(this.mc.gameSettings.fancyGraphics) {
+			if(this.mc.gameSettings.graphicsLevel > 0) {
 				var16 = 10;
 			}
 
@@ -809,7 +843,7 @@
 	private void updateFogColor(float var1) {
 		World var2 = this.mc.theWorld;
 		LivingEntity var3 = this.mc.renderViewEntity;
-		float var4 = 1.0F / (float)(4 - this.mc.gameSettings.renderDistance);
+		float var4 = 1.0F / (float)(Math.log10(this.mc.gameSettings.renderDistance / 0.75F) / Math.log10(2));
 		var4 = 1.0F - (float)Math.pow((double)var4, 0.25D);
 		Vec3D var5 = var2.getSkyColor(this.mc.renderViewEntity, var1);
 		float var6 = (float)var5.xCoord;
@@ -916,10 +950,15 @@
 				var8 = (var4 * 30.0F + var5 * 70.0F) / 100.0F;
 				var9 = (var4 * 30.0F + var6 * 70.0F) / 100.0F;
 			}
+		} else if (var1 >= 0 && this.mc.gameSettings.fogShape == 0) {
+			GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
+			GL11.glFogf(GL11.GL_FOG_START, Float.MAX_VALUE / 2.0F);
+			GL11.glFogf(GL11.GL_FOG_END, Float.MAX_VALUE);
 		} else {
 			GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
-			GL11.glFogf(GL11.GL_FOG_START, this.farPlaneDistance * 0.25F);
-			GL11.glFogf(GL11.GL_FOG_END, this.farPlaneDistance);
+			float fogStart = this.farPlaneDistance * this.mc.gameSettings.fogDistance;
+			GL11.glFogf(GL11.GL_FOG_START, Math.min(fogStart * (1.0F - this.mc.gameSettings.fogDensity), fogStart - 0.001F));
+			GL11.glFogf(GL11.GL_FOG_END, fogStart);
 			if(var1 < 0) {
 				GL11.glFogf(GL11.GL_FOG_START, 0.0F);
 				GL11.glFogf(GL11.GL_FOG_END, this.farPlaneDistance * 0.8F);
--- /dev/null
+++ argo/saj/InvalidSyntaxException.java
@@ -1,0 +1,18 @@
+package argo.saj;
+
+public final class InvalidSyntaxException extends Exception {
+	private final int column;
+	private final int row;
+
+	InvalidSyntaxException(String var1, ThingWithPosition var2) {
+		super("At line " + var2.getRow() + ", column " + var2.getColumn() + ":  " + var1);
+		this.column = var2.getColumn();
+		this.row = var2.getRow();
+	}
+
+	InvalidSyntaxException(String var1, Throwable var2, ThingWithPosition var3) {
+		super("At line " + var3.getRow() + ", column " + var3.getColumn() + ":  " + var1, var2);
+		this.column = var3.getColumn();
+		this.row = var3.getRow();
+	}
+}
--- net/minecraft/game/world/block/DoorBlock.java
+++ net/minecraft/game/world/block/DoorBlock.java
@@ -8,30 +8,42 @@
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.MovingObjectPosition;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.StringProperty;
 import net.minecraft.game.world.material.Material;
 
 public class DoorBlock extends Block {
-	protected DoorBlock(int var1, Material var2) {
+	public static final StringProperty DIRECTION = new StringProperty("direction", 2, "east", "south", "west", "north");
+	public static final BooleanProperty OPEN = new BooleanProperty("open");
+	public static final BooleanProperty HALF = new BooleanProperty("half", "top", "bottom");
+
+	private final int texBottom;
+	private final int texTop;
+
+	protected DoorBlock(int var1, Material var2, String var2a) {
 		super(var1, var2);
-		this.textureIndex = 97;
-		if(var2 == Material.iron) {
-			++this.textureIndex;
-		}
+		this.texBottom = TerrainLayout.texCoord(var2a + "_bottom");
+		this.texTop = TerrainLayout.texCoord(var2a + "_top");
 
 		float var3 = 0.5F;
 		float var4 = 1.0F;
 		this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var4, 0.5F + var3);
 	}
 
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, OPEN, HALF);
+	}
+
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
 		if(var1 != 0 && var1 != 1) {
 			int var3 = this.getState(var2);
 			if((var3 == 0 || var3 == 2) ^ var1 <= 3) {
-				return this.textureIndex;
+				return this.texBottom;
 			} else {
 				int var4 = var3 / 2 + (var1 & 1 ^ var3);
 				var4 += (var2 & 4) / 4;
-				int var5 = this.textureIndex - (var2 & 8) * 2;
+				int var5 = (var2 & 8) != 0 ? this.texTop : this.texBottom;
 				if((var4 & 1) != 0) {
 					var5 = -var5;
 				}
@@ -39,7 +51,7 @@
 				return var5;
 			}
 		} else {
-			return this.textureIndex;
+			return this.texBottom;
 		}
 	}
 
@@ -52,7 +64,7 @@
 	}
 
 	public int getRenderType() {
-		return 7;
+		return 0;
 	}
 
 	public AxisAlignedBB getSelectedBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
@@ -190,7 +202,7 @@
 	}
 
 	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
-		return var3 >= 127 ? false : var1.isBlockNormalCube(var2, var3 - 1, var4) && super.canPlaceBlockAt(var1, var2, var3, var4) && super.canPlaceBlockAt(var1, var2, var3 + 1, var4);
+		return var1.isBlockNormalCube(var2, var3 - 1, var4) && super.canPlaceBlockAt(var1, var2, var3, var4) && super.canPlaceBlockAt(var1, var2, var3 + 1, var4);
 	}
 
 	public static boolean isOpen(int var0) {
--- net/minecraft/game/world/biome/SkyBiome.java
+++ net/minecraft/game/world/biome/SkyBiome.java
@@ -4,7 +4,8 @@
 import net.minecraft.game.world.SpawnListEntry;
 
 public class SkyBiome extends Biome {
-	public SkyBiome() {
+	public SkyBiome(int i) {
+		super(i);
 		this.spawnableMonsterList.clear();
 		this.spawnableCreatureList.clear();
 		this.spawnableWaterCreatureList.clear();
--- net/minecraft/game/item/SubtypedItem.java
+++ net/minecraft/game/item/SubtypedItem.java
@@ -10,10 +10,14 @@
 	}
 
 	public int getTextureFromDamage(int var1) {
-		return Block.log.getBlockTextureFromSideAndMetadata(2, var1);
+		return Block.blocksList[this.blockID].getBlockTextureFromSideAndMetadata(2, var1);
 	}
 
 	public int getPlacedBlockMetadata(int var1) {
 		return var1;
+	}
+
+	public String getNameFromStack(ItemStack var1) {
+		return super.getName() + "." + var1.getItemDamage();
 	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerSmoothZoomRGB.java
@@ -1,0 +1,41 @@
+package net.minecraft.game.world.biome.layers;
+
+public class LayerSmoothZoomRGB extends LayerZoomBase {
+	public LayerSmoothZoomRGB(long seed, Layer parent) {
+		super(seed, parent);
+	}
+
+	protected int interpolate(int a, int b) {
+		int aR = (a >> 16) & 0xFF;
+		int aG = (a >> 8) & 0xFF;
+		int aB = a & 0xFF;
+		int bR = (b >> 16) & 0xFF;
+		int bG = (b >> 8) & 0xFF;
+		int bB = b & 0xFF;
+
+		int R = (aR + bR) / 2;
+		int G = (aG + bG) / 2;
+		int B = (aB + bB) / 2;
+		return R << 16 | G << 8 | B;
+	}
+
+	protected int interpolate(int a, int b, int c, int d) {
+		int aR = (a >> 16) & 0xFF;
+		int aG = (a >> 8) & 0xFF;
+		int aB = a & 0xFF;
+		int bR = (b >> 16) & 0xFF;
+		int bG = (b >> 8) & 0xFF;
+		int bB = b & 0xFF;
+		int cR = (c >> 16) & 0xFF;
+		int cG = (c >> 8) & 0xFF;
+		int cB = c & 0xFF;
+		int dR = (d >> 16) & 0xFF;
+		int dG = (d >> 8) & 0xFF;
+		int dB = d & 0xFF;
+
+		int R = (aR + bR + cR + dR) / 4;
+		int G = (aG + bG + cG + dG) / 4;
+		int B = (aB + bB + cB + dB) / 4;
+		return R << 16 | G << 8 | B;
+	}
+}
--- net/minecraft/client/controller/PlayerController.java
+++ net/minecraft/client/controller/PlayerController.java
@@ -80,7 +80,7 @@
 
 	public boolean sendPlaceBlock(PlayerEntity var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7) {
 		int var8 = var2.getBlockId(var4, var5, var6);
-		return var8 > 0 && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1) ? true : (var3 == null ? false : var3.useItem(var1, var2, var4, var5, var6, var7));
+		return var8 > 0 && !var1.isSneaking() && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1) ? true : (var3 == null ? false : var3.useItem(var1, var2, var4, var5, var6, var7));
 	}
 
 	public PlayerEntity createPlayer(World var1) {
--- net/minecraft/client/gui/DownloadTerrainScreen.java
+++ net/minecraft/client/gui/DownloadTerrainScreen.java
@@ -36,7 +36,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawBackground(0);
+		this.drawBackground(0, var3);
 		StringTranslate var4 = StringTranslate.getInstance();
 		this.drawCenteredString(this.fontRenderer, var4.translateKey("multiplayer.downloadingTerrain"), this.width / 2, this.height / 2 - 50, 16777215);
 		super.drawScreen(var1, var2, var3);
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/GLImportProcessor.java
@@ -1,0 +1,149 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import net.mine_diver.smoothbeta.util.StringHelper;
+import net.mine_diver.smoothbeta.util.UtilsFromHell;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Handles the flattening of "moj_" import strings in the loaded GLSL shader file.
+ * Instances of an import are replaced by the contents of the referenced file
+ * prefixed by a comment describing the line position and original file location
+ * of the import.
+ */
+public abstract class GLImportProcessor {
+	private static final String MULTI_LINE_COMMENT_PATTERN = "/\\*(?:[^*]|\\*+[^*/])*\\*+/";
+	private static final String SINGLE_LINE_COMMENT_PATTERN = "//\\V*";
+	private static final Pattern MOJ_IMPORT_PATTERN = Pattern.compile("(#(?:" + MULTI_LINE_COMMENT_PATTERN + "|\\h)*moj_import(?:" + MULTI_LINE_COMMENT_PATTERN + "|\\h)*(?:\"(.*)\"|<(.*)>))");
+	private static final Pattern IMPORT_VERSION_PATTERN = Pattern.compile("(#(?:" + MULTI_LINE_COMMENT_PATTERN + "|\\h)*version(?:" + MULTI_LINE_COMMENT_PATTERN + "|\\h)*(\\d+))\\b");
+	private static final Pattern TRAILING_WHITESPACE_PATTERN = Pattern.compile("(?:^|\\v)(?:\\s|" + MULTI_LINE_COMMENT_PATTERN + "|(" + SINGLE_LINE_COMMENT_PATTERN + "))*\\z");
+
+	/**
+	 * Reads the source code supplied into a list of lines suitable for uploading to
+	 * the GL Shader cache.
+	 * 
+	 * <p>Imports are processed as per the description of this class.
+	 */
+	public List<String> readSource(String source) {
+		Context context = new Context();
+		List<String> list = this.parseImports(source, context, "");
+		list.set(0, this.readImport(list.get(0), context.column));
+		return list;
+	}
+
+	private List<String> parseImports(String source, Context context, String path) {
+		int i = context.line;
+		int j = 0;
+		String string = "";
+		List<String> list = new ArrayList<>();
+		Matcher matcher = MOJ_IMPORT_PATTERN.matcher(source);
+
+		String string2;
+		while(matcher.find()) {
+			if (method_36424(source, matcher, j)) {
+				string2 = matcher.group(2);
+				boolean bl = string2 != null;
+				if (!bl) {
+					string2 = matcher.group(3);
+				}
+
+				if (string2 != null) {
+					String string3 = source.substring(j, matcher.start(1));
+					String string4 = path + string2;
+					String string5 = this.loadImport(bl, string4);
+					int k;
+					if (!StringHelper.isEmpty(string5)) {
+						if (!StringHelper.endsWithLineBreak(string5)) {
+							string5 = string5 + System.lineSeparator();
+						}
+
+						++context.line;
+						k = context.line;
+						List<String> list2 = this.parseImports(string5, context, bl ? UtilsFromHell.getPosixFullPath(string4) : "");
+						list2.set(0, String.format(Locale.ROOT, "#line %d %d\n%s", 0, k, this.extractVersion(list2.get(0), context)));
+						if (!StringHelper.isBlank(string3)) {
+							list.add(string3);
+						}
+
+						list.addAll(list2);
+					} else {
+						String string6 = bl ? String.format("/*#moj_import \"%s\"*/", string2) : String.format("/*#moj_import <%s>*/", string2);
+						list.add(string + string3 + string6);
+					}
+
+					k = StringHelper.countLines(source.substring(0, matcher.end(1)));
+					string = String.format(Locale.ROOT, "#line %d %d", k, i);
+					j = matcher.end(1);
+				}
+			}
+		}
+
+		string2 = source.substring(j);
+		if (!StringHelper.isBlank(string2)) {
+			list.add(string + string2);
+		}
+
+		return list;
+	}
+
+	/**
+	 * Converts a line known to contain an import into a fully-qualified
+	 * version of itself for insertion as a comment.
+	 */
+	private String extractVersion(String line, Context context) {
+		Matcher matcher = IMPORT_VERSION_PATTERN.matcher(line);
+		if (matcher.find() && method_36423(line, matcher)) {
+			context.column = Math.max(context.column, Integer.parseInt(matcher.group(2)));
+			String var10000 = line.substring(0, matcher.start(1));
+			return var10000 + "/*" + line.substring(matcher.start(1), matcher.end(1)) + "*/" + line.substring(matcher.end(1));
+		} else {
+			return line;
+		}
+	}
+
+	private String readImport(String line, int start) {
+		Matcher matcher = IMPORT_VERSION_PATTERN.matcher(line);
+		if (matcher.find() && method_36423(line, matcher)) {
+			String var10000 = line.substring(0, matcher.start(2));
+			return var10000 + Math.max(start, Integer.parseInt(matcher.group(2))) + line.substring(matcher.end(2));
+		} else {
+			return line;
+		}
+	}
+
+	private static boolean method_36423(String string, Matcher matcher) {
+		return method_36424(string, matcher, 0);
+	}
+
+	private static boolean method_36424(String string, Matcher matcher, int i) {
+		int j = matcher.start() - i;
+		if (j == 0) {
+			return true;
+		} else {
+			Matcher matcher2 = TRAILING_WHITESPACE_PATTERN.matcher(string.substring(i, matcher.start()));
+			if (!matcher2.find()) {
+				return false;
+			} else {
+				int k = matcher2.end(1);
+				return k != matcher.start();
+			}
+		}
+	}
+
+	/**
+	 * Called to load an import reference's source code.
+	 */
+	public abstract String loadImport(boolean inline, String name);
+
+	/**
+	 * A context for the parser to keep track of its current line and caret position in the file.
+	 */
+	static final class Context {
+		int column;
+		int line;
+	}
+}
--- net/minecraft/game/world/biome/NetherBiome.java
+++ net/minecraft/game/world/biome/NetherBiome.java
@@ -5,7 +5,8 @@
 import net.minecraft.game.world.SpawnListEntry;
 
 public class NetherBiome extends Biome {
-	public NetherBiome() {
+	public NetherBiome(int i) {
+		super(i);
 		this.spawnableMonsterList.clear();
 		this.spawnableCreatureList.clear();
 		this.spawnableWaterCreatureList.clear();
--- net/minecraft/game/item/SwordItem.java
+++ net/minecraft/game/item/SwordItem.java
@@ -4,18 +4,26 @@
 import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.world.block.Block;
 
+import java.util.List;
+
+import static net.minecraft.util.StringTranslate.i18nf;
+
 public class SwordItem extends Item {
-	private int weaponDamage;
+	private final int weaponDamage;
 
 	public SwordItem(int var1, ToolMaterial var2) {
+		this(var1, var2.getMaxUses(), 4 + var2.getDamageVsEntity() * 2);
+	}
+
+	public SwordItem(int var1, int maxUses, int damage) {
 		super(var1);
 		this.maxStackSize = 1;
-		this.setMaxDamage(var2.getMaxUses());
-		this.weaponDamage = 4 + var2.getDamageVsEntity() * 2;
+		this.setMaxDamage(maxUses);
+		this.weaponDamage = damage;
 	}
 
 	public float getStrengthAgainstBlock(ItemStack var1, Block var2) {
-		return var2.blockID == Block.web.blockID ? 15.0F : 1.5F;
+		return var2.effectiveTool == ToolType.SWORD ? 15.0F : 1.5F;
 	}
 
 	public boolean hitEntity(ItemStack var1, LivingEntity var2, LivingEntity var3) {
@@ -38,5 +46,10 @@
 
 	public boolean canHarvestBlock(Block var1) {
 		return var1.blockID == Block.web.blockID;
+	}
+
+	public void buildTooltipFromStack(ItemStack var1, List<String> tooltip) {
+		super.buildTooltipFromStack(var1, tooltip);
+		tooltip.add(i18nf("tooltip.damage", this.weaponDamage));
 	}
 }
--- /dev/null
+++ net/minecraft/game/entity/loot/EntityLootItem.java
@@ -1,0 +1,58 @@
+package net.minecraft.game.entity.loot;
+
+import net.minecraft.game.entity.LivingEntity;
+import net.minecraft.game.item.ItemStack;
+
+import java.util.Random;
+import java.util.function.ToIntFunction;
+
+public class EntityLootItem implements EntityLootEntry {
+	public final int item;
+	public final int damage;
+	public final ToIntFunction<LivingEntity> damageGetter;
+	public final int min;
+	public final int max;
+	public final float chance;
+
+	public EntityLootItem(int item, int damage, int range) {
+		this(item, damage, 0, range - 1, 1.0F);
+	}
+
+	public EntityLootItem(int item, int damage, int min, int max) {
+		this(item, damage, min, max, 1.0F);
+	}
+
+	public EntityLootItem(int item, int damage, int min, int max, float chance) {
+		this.item = item;
+		this.damage = damage;
+		this.damageGetter = null;
+		this.min = min;
+		this.max = max;
+		this.chance = chance;
+	}
+
+	public EntityLootItem(int item, ToIntFunction<LivingEntity> damageGetter, int min, int max, float chance) {
+		this.item = item;
+		this.damage = 0;
+		this.damageGetter = damageGetter;
+		this.min = min;
+		this.max = max;
+		this.chance = chance;
+	}
+
+	public ItemStack getItem(LivingEntity entity, Random random) {
+		if (random.nextFloat() > this.chance) return null;
+
+		int count = this.min;
+		if (this.max - this.min + 1 > 0) {
+			count += random.nextInt(this.max - this.min + 1);
+		}
+
+		int damage = this.damage;
+		if (this.damageGetter != null) {
+			damage = this.damageGetter.applyAsInt(entity);
+		}
+
+		return new ItemStack(this.item, count, damage);
+	}
+}
--- net/minecraft/game/world/block/NoteBlock.java
+++ net/minecraft/game/world/block/NoteBlock.java
@@ -8,7 +8,7 @@
 
 public class NoteBlock extends ContainerBlock {
 	public NoteBlock(int var1) {
-		super(var1, 74, Material.wood);
+		super(var1, TerrainLayout.texCoord("note_block"), Material.wood);
 	}
 
 	public int getBlockTextureFromSide(int var1) {
--- com/mojang/nbt/IntTag.java
+++ com/mojang/nbt/IntTag.java
@@ -29,4 +29,8 @@
 	public String toString() {
 		return "" + this.intValue;
 	}
+
+	public NBTBaseTag copy() {
+		return new IntTag(intValue).setKey(this.getKey());
+	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerEdge.java
@@ -1,0 +1,24 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.util.IntArray2D;
+
+public class LayerEdge extends Layer {
+	public LayerEdge(Layer parent) {
+		super(0L, parent);
+	}
+
+	protected IntArray2D getData(int x, int z, int width, int length) {
+		return this.forEachWithNeighbors(x, z, width, length, (i, ox, oz, neighbors) -> {
+			if (i > 0) return i;
+
+			int maxNeighbor = 0;
+			for (int neighbor : neighbors) {
+				if (neighbor > maxNeighbor) {
+					maxNeighbor = neighbor;
+				}
+			}
+
+			return maxNeighbor > 0 ? maxNeighbor + 1 : 0;
+		});
+	}
+}
--- net/minecraft/game/item/recipe/RecipesFood.java
+++ net/minecraft/game/item/recipe/RecipesFood.java
@@ -6,8 +6,8 @@
 
 public class RecipesFood {
 	public void addRecipes(CraftingManager var1) {
-		var1.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.brownMushroom, Character.valueOf('Y'), Block.redMushroom, Character.valueOf('#'), Item.bowlEmpty});
-		var1.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.redMushroom, Character.valueOf('Y'), Block.brownMushroom, Character.valueOf('#'), Item.bowlEmpty});
-		var1.addRecipe(new ItemStack(Item.cookie, 8), new Object[]{"#X#", Character.valueOf('X'), new ItemStack(Item.dye, 1, 3), Character.valueOf('#'), Item.wheat});
+		var1.addRecipe(new ItemStack(Item.bowlSoup), "Y", "X", "#", 'X', Block.brownMushroom, 'Y', Block.redMushroom, '#', Item.bowlEmpty);
+		var1.addRecipe(new ItemStack(Item.bowlSoup), "Y", "X", "#", 'X', Block.redMushroom, 'Y', Block.brownMushroom, '#', Item.bowlEmpty);
+		var1.addRecipe(new ItemStack(Item.cookie, 8), "#X#", 'X', new ItemStack(Item.dye, 1, 12), '#', Item.wheat);
 	}
 }
--- /dev/null
+++ argo/saj/JsonListener.java
@@ -1,0 +1,29 @@
+package argo.saj;
+
+public interface JsonListener {
+	void startDocument();
+
+	void endDocument();
+
+	void startArray();
+
+	void endArray();
+
+	void startObject();
+
+	void endObject();
+
+	void startField(String var1);
+
+	void endField();
+
+	void stringValue(String var1);
+
+	void numberValue(String var1);
+
+	void trueValue();
+
+	void falseValue();
+
+	void nullValue();
+}
--- /dev/null
+++ argo/format/CompactJsonFormatter.java
@@ -1,0 +1,82 @@
+package argo.format;
+
+import argo.jdom.JsonNode;
+import argo.jdom.JsonRootNode;
+import argo.jdom.JsonStringNode;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.TreeSet;
+
+public final class CompactJsonFormatter implements JsonFormatter {
+	public String format(JsonRootNode var1) {
+		StringWriter var2 = new StringWriter();
+
+		try {
+			this.format(var1, var2);
+		} catch (IOException var4) {
+			throw new RuntimeException("Coding failure in Argo:  StringWriter gave an IOException", var4);
+		}
+
+		return var2.toString();
+	}
+
+	public void format(JsonRootNode var1, Writer var2) throws IOException {
+		this.formatJsonNode(var1, var2);
+	}
+
+	private void formatJsonNode(JsonNode var1, Writer var2) throws IOException {
+		boolean var3 = true;
+		switch (var1.getType()) {
+			case ARRAY:
+				var2.append('[');
+
+                for (JsonNode var6 : var1.getElements()) {
+                    if (!var3) {
+                        var2.append(',');
+                    }
+
+                    var3 = false;
+                    this.formatJsonNode(var6, var2);
+                }
+
+				var2.append(']');
+				break;
+			case OBJECT:
+				var2.append('{');
+
+                for (JsonStringNode var5 : new TreeSet<>(var1.getFields().keySet())) {
+                    if (!var3) {
+                        var2.append(',');
+                    }
+
+                    var3 = false;
+                    this.formatJsonNode(var5, var2);
+                    var2.append(':');
+                    this.formatJsonNode(var1.getFields().get(var5), var2);
+                }
+
+				var2.append('}');
+				break;
+			case STRING:
+				var2.append('\"').append((new JsonEscapedString(var1.getText())).toString()).append('\"');
+				break;
+			case NUMBER:
+				var2.append(var1.getText());
+				break;
+			case FALSE:
+				var2.append("false");
+				break;
+			case TRUE:
+				var2.append("true");
+				break;
+			case NULL:
+				var2.append("null");
+				break;
+			default:
+				throw new RuntimeException("Coding failure in Argo:  Attempt to format a JsonNode of unknown type [" + var1.getType() + "];");
+		}
+
+	}
+}
--- /dev/null
+++ net/minecraft/game/world/block/ModelBlock.java
@@ -1,0 +1,25 @@
+package net.minecraft.game.world.block;
+
+public class ModelBlock {
+	public final int sideTexture;
+	public final int topTexture;
+	public final int bottomTexture;
+
+	public ModelBlock(int texture) {
+		this(texture, texture, texture);
+	}
+
+	public ModelBlock(int sideTexture, int verTexture) {
+		this(sideTexture, verTexture, verTexture);
+	}
+
+	public ModelBlock(int sideTexture, int topTexture, int bottomTexture) {
+		this.sideTexture = sideTexture;
+		this.topTexture = topTexture;
+		this.bottomTexture = bottomTexture;
+	}
+
+	public int getTextureFromSide(int side) {
+		return side == 0 ? this.bottomTexture : side == 1 ? this.topTexture : this.sideTexture;
+	}
+}
--- net/minecraft/game/world/biome/ClimaticBiomeSource.java
+++ net/minecraft/game/world/biome/ClimaticBiomeSource.java
@@ -2,38 +2,68 @@
 
 import java.util.Random;
 import net.minecraft.game.world.World;
-import net.minecraft.game.world.chunk.ChunkCoordIntPair;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
 import net.minecraft.game.world.terrain.noise.SimplexNoiseOctaves;
 
-public class ClimaticBiomeSource {
+public class ClimaticBiomeSource extends BiomeSource {
 	private SimplexNoiseOctaves temperatureNoise;
 	private SimplexNoiseOctaves humidityNoise;
 	private SimplexNoiseOctaves offsetNoise;
+	private PerlinNoiseOctaves oceanNoise;
 	public double[] temperature;
 	public double[] humidity;
 	public double[] offset;
+	public double[] ocean;
 	public Biome[] blockGeneratorData;
+	private final boolean experimental;
+	private double temperatureScale = 0.025D;
+	private double temperatureRange = 0.15D;
+	private double temperatureOffset = 0.7D;
+	private double humidityScale = 0.05D;
+	private double humidityRange = 0.15D;
+	private double humidityOffset = 0.5D;
+	private double offsetScale = 0.25D;
+	private double offsetRange = 1.1D;
+	private double offsetOffset = 0.5D;
+	private double offsetTemperatureAmount = 0.01D;
+	private double offsetHumidityAmount = 0.002D;
+	private double oceanScale = 20.0D;
 
 	protected ClimaticBiomeSource() {
+		this.experimental = false;
 	}
 
 	public ClimaticBiomeSource(World var1) {
-		this.temperatureNoise = new SimplexNoiseOctaves(new Random(var1.getRandomSeed() * 9871L), 4);
-		this.humidityNoise = new SimplexNoiseOctaves(new Random(var1.getRandomSeed() * 39811L), 4);
-		this.offsetNoise = new SimplexNoiseOctaves(new Random(var1.getRandomSeed() * 543321L), 2);
-	}
-
-	public Biome getBiomeGenAtChunkCoord(ChunkCoordIntPair var1) {
-		return this.getBiomeGenAt(var1.chunkXPos << 4, var1.chunkZPos << 4);
-	}
-
-	public Biome getBiomeGenAt(int var1, int var2) {
-		return this.getBlockGeneratorData(var1, var2, 1, 1)[0];
+		this(var1.getRandomSeed(), false);
+	}
+
+	public ClimaticBiomeSource(long var1, boolean var2) {
+		this.experimental = var2;
+		this.temperatureNoise = new SimplexNoiseOctaves(new Random(var1 * 9871L), 4);
+		this.humidityNoise = new SimplexNoiseOctaves(new Random(var1 * 39811L), 4);
+		this.offsetNoise = new SimplexNoiseOctaves(new Random(var1 * 543321L), 2);
+		this.oceanNoise = var2 ? new PerlinNoiseOctaves(new Random(var1 * 257469L), 16) : null;
+
+		if (var2) {
+			this.temperatureScale = 0.01D;
+			this.humidityScale = 0.02D;
+		}
+	}
+
+	public double remapTemperature(double value) {
+		if (this.experimental) {
+			return 1.0D - Math.pow(Math.max(1.0D - Math.abs(value), 0.0D), 1.2D);
+		}
+		return 1.0D - (1.0D - value) * (1.0D - value);
+	}
+
+	public double remapHumidity(double value) {
+		return value;
 	}
 
 	public double getTemperature(int var1, int var2) {
-		this.temperature = this.temperatureNoise.generateNoiseArray2D(this.temperature, (double)var1, (double)var2, 1, 1, (double)0.025F, (double)0.025F, 0.5D);
-		return this.temperature[0];
+		this.temperature = this.temperatureNoise.generateNoiseArray2D(this.temperature, (double)var1, (double)var2, 1, 1, this.temperatureScale, this.temperatureScale, 0.5D);
+		return this.remapTemperature(this.temperature[0] * this.temperatureRange + this.temperatureOffset);
 	}
 
 	public Biome[] getBlockGeneratorData(int var1, int var2, int var3, int var4) {
@@ -46,17 +76,17 @@
 			var1 = new double[var4 * var5];
 		}
 
-		var1 = this.temperatureNoise.generateNoiseArray2D(var1, (double)var2, (double)var3, var4, var5, (double)0.025F, (double)0.025F, 0.25D);
-		this.offset = this.offsetNoise.generateNoiseArray2D(this.offset, (double)var2, (double)var3, var4, var5, 0.25D, 0.25D, 0.5882352941176471D);
+		var1 = this.temperatureNoise.generateNoiseArray2D(var1, (double)var2, (double)var3, var4, var5, this.temperatureScale, this.temperatureScale, 0.25D);
+		this.offset = this.offsetNoise.generateNoiseArray2D(this.offset, (double)var2, (double)var3, var4, var5, this.offsetScale, this.offsetScale, 0.5882352941176471D);
 		int var6 = 0;
 
 		for(int var7 = 0; var7 < var4; ++var7) {
 			for(int var8 = 0; var8 < var5; ++var8) {
-				double var9 = this.offset[var6] * 1.1D + 0.5D;
-				double var11 = 0.01D;
+				double var9 = this.offset[var6] * this.offsetRange + this.offsetOffset;
+				double var11 = this.offsetTemperatureAmount;
 				double var13 = 1.0D - var11;
-				double var15 = (var1[var6] * 0.15D + 0.7D) * var13 + var9 * var11;
-				var15 = 1.0D - (1.0D - var15) * (1.0D - var15);
+				double var15 = (var1[var6] * this.temperatureRange + this.temperatureOffset) * var13 + var9 * var11;
+				var15 = this.remapTemperature(var15);
 				if(var15 < 0.0D) {
 					var15 = 0.0D;
 				}
@@ -74,25 +104,53 @@
 	}
 
 	public Biome[] loadBlockGeneratorData(Biome[] var1, int var2, int var3, int var4, int var5) {
+		return this.loadBlockGeneratorData(var1, var2, var3, var4, var5, 1.0D);
+	}
+
+	public Biome[] loadBlockGeneratorData(Biome[] var1, int var2, int var3, int var4, int var5, double var5a) {
 		if(var1 == null || var1.length < var4 * var5) {
 			var1 = new Biome[var4 * var5];
 		}
 
-		this.temperature = this.temperatureNoise.generateNoiseArray2D(this.temperature, (double)var2, (double)var3, var4, var4, (double)0.025F, (double)0.025F, 0.25D);
-		this.humidity = this.humidityNoise.generateNoiseArray2D(this.humidity, (double)var2, (double)var3, var4, var4, (double)0.05F, (double)0.05F, 1.0D / 3.0D);
-		this.offset = this.offsetNoise.generateNoiseArray2D(this.offset, (double)var2, (double)var3, var4, var4, 0.25D, 0.25D, 0.5882352941176471D);
+		this.temperature = this.temperatureNoise.generateNoiseArray2D(this.temperature, var2, var3, var4, var4, this.temperatureScale * var5a, this.temperatureScale * var5a, 0.25D);
+		this.humidity = this.humidityNoise.generateNoiseArray2D(this.humidity, var2, var3, var4, var4, this.humidityScale * var5a, this.humidityScale * var5a, 1.0D / 3.0D);
+		this.offset = this.offsetNoise.generateNoiseArray2D(this.offset, var2, var3, var4, var4, this.offsetScale * var5a, this.offsetScale * var5a, 0.5882352941176471D);
+		this.ocean = this.experimental ? this.oceanNoise.generateNoiseArray2D(this.ocean, var2, var3, var4, var4, this.oceanScale * var5a, this.oceanScale * var5a, 0.5D) : null;
 		int var6 = 0;
 
+		double var11 = this.offsetTemperatureAmount;
+		double var13 = 1.0D - var11;
+		double var11a = this.offsetHumidityAmount;
+		double var13a = 1.0D - var11;
 		for(int var7 = 0; var7 < var4; ++var7) {
 			for(int var8 = 0; var8 < var5; ++var8) {
-				double var9 = this.offset[var6] * 1.1D + 0.5D;
-				double var11 = 0.01D;
-				double var13 = 1.0D - var11;
-				double var15 = (this.temperature[var6] * 0.15D + 0.7D) * var13 + var9 * var11;
-				var11 = 0.002D;
-				var13 = 1.0D - var11;
-				double var17 = (this.humidity[var6] * 0.15D + 0.5D) * var13 + var9 * var11;
-				var15 = 1.0D - (1.0D - var15) * (1.0D - var15);
+				double var9 = this.offset[var6] * this.offsetRange + this.offsetOffset;
+				double var15 = (this.temperature[var6] * this.temperatureRange + this.temperatureOffset) * var13 + var9 * var11;
+				double var17 = (this.humidity[var6] * this.humidityRange + this.humidityOffset) * var13a + var9 * var11a;
+				var15 = this.remapTemperature(var15);
+				var17 = this.remapHumidity(var17);
+
+				double oceanValue = 0.0D;
+				if (experimental) {
+					oceanValue = this.ocean[var6] / 10000.0D;
+					double absOcean = 1.0D - Math.abs(oceanValue);
+					oceanValue = (1.0D - (absOcean * absOcean)) * Math.signum(oceanValue);
+					if (oceanValue > 0.0D) {
+						oceanValue /= 5.0D;
+					} else {
+						oceanValue += 0.5D;
+						if (oceanValue < 0.0D) {
+							oceanValue *= 1.8D;
+						}
+						oceanValue -= 0.5D;
+						oceanValue = Math.max(oceanValue, -1.0D);
+					}
+					this.ocean[var6] = oceanValue;
+					if (oceanValue < 0.08D) {
+						var17 += (0.08D - Math.max(oceanValue, 0.0D)) * 4.0D;
+					}
+				}
+
 				if(var15 < 0.0D) {
 					var15 = 0.0D;
 				}
@@ -111,10 +169,24 @@
 
 				this.temperature[var6] = var15;
 				this.humidity[var6] = var17;
-				var1[var6++] = Biome.getBiomeFromLookup(var15, var17);
+
+				Biome biome = Biome.getBiomeFromLookup(var15, var17, oceanValue);
+				var1[var6++] = biome;
 			}
 		}
 
 		return var1;
+	}
+
+	public int[] loadColorData(int[] colors, int x, int z, int width, int length, BiomeColorType type) {
+		for (int i = 0; i < width * length; i++) {
+			colors[i] =
+					type == BiomeColorType.GRASS ? this.blockGeneratorData[i].getGrassColor()
+					: type == BiomeColorType.FOLIAGE ? this.blockGeneratorData[i].getFoliageColor()
+					: type == BiomeColorType.SKY ? this.blockGeneratorData[i].getSkyColor()
+					: 0;
+		}
+
+		return colors;
 	}
 }
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/GlBlendState.java
@@ -1,0 +1,119 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL14;
+
+import java.util.Locale;
+
+public class GlBlendState {
+	private static GlBlendState activeBlendState;
+	private final int srcRgb;
+	private final int srcAlpha;
+	private final int dstRgb;
+	private final int dstAlpha;
+	private final int func;
+	private final boolean separateBlend;
+	private final boolean blendDisabled;
+
+	private GlBlendState(boolean separateBlend, boolean blendDisabled, int srcRgb, int dstRgb, int srcAlpha, int dstAlpha, int func) {
+		this.separateBlend = separateBlend;
+		this.srcRgb = srcRgb;
+		this.dstRgb = dstRgb;
+		this.srcAlpha = srcAlpha;
+		this.dstAlpha = dstAlpha;
+		this.blendDisabled = blendDisabled;
+		this.func = func;
+	}
+
+	public GlBlendState() {
+		this(false, true, 1, 0, 1, 0, GL14.GL_FUNC_ADD);
+	}
+
+	public GlBlendState(int srcRgb, int dstRgb, int func) {
+		this(false, false, srcRgb, dstRgb, srcRgb, dstRgb, func);
+	}
+
+	public GlBlendState(int srcRgb, int dstRgb, int srcAlpha, int dstAlpha, int func) {
+		this(true, false, srcRgb, dstRgb, srcAlpha, dstAlpha, func);
+	}
+
+	public void enable() {
+		if (!this.equals(activeBlendState)) {
+			if (activeBlendState == null || this.blendDisabled != activeBlendState.isBlendDisabled()) {
+				activeBlendState = this;
+				if (this.blendDisabled) {
+					GlStateManager._disableBlend();
+					return;
+				}
+
+				GlStateManager._enableBlend();
+			}
+
+			GL14.glBlendEquation(this.func);
+			if (this.separateBlend)
+				GlStateManager._blendFuncSeparate(this.srcRgb, this.dstRgb, this.srcAlpha, this.dstAlpha);
+			else GlStateManager._blendFunc(this.srcRgb, this.dstRgb);
+
+		}
+	}
+
+	public boolean equals(Object o) {
+		if (this == o) return true;
+		if (!(o instanceof GlBlendState)) return false;
+		GlBlendState glBlendState = (GlBlendState)o;
+		if (this.func != glBlendState.func) return false;
+		else if (this.dstAlpha != glBlendState.dstAlpha) return false;
+		else if (this.dstRgb != glBlendState.dstRgb) return false;
+		else if (this.blendDisabled != glBlendState.blendDisabled) return false;
+		else if (this.separateBlend != glBlendState.separateBlend) return false;
+		else if (this.srcAlpha != glBlendState.srcAlpha) return false;
+		else return this.srcRgb == glBlendState.srcRgb;
+	}
+
+	public int hashCode() {
+		int i = this.srcRgb;
+		i = 31 * i + this.srcAlpha;
+		i = 31 * i + this.dstRgb;
+		i = 31 * i + this.dstAlpha;
+		i = 31 * i + this.func;
+		i = 31 * i + (this.separateBlend ? 1 : 0);
+		i = 31 * i + (this.blendDisabled ? 1 : 0);
+		return i;
+	}
+
+	public boolean isBlendDisabled() {
+		return this.blendDisabled;
+	}
+
+	public static int getFuncFromString(String name) {
+		String string = name.trim().toLowerCase(Locale.ROOT);
+		switch (string) {
+			case "add": return GL14.GL_FUNC_ADD;
+			case "subtract": return GL14.GL_FUNC_SUBTRACT;
+			case "reversesubtract":
+			case "reverse_subtract": return GL14.GL_FUNC_REVERSE_SUBTRACT;
+			case "min": return GL14.GL_MIN;
+			default: return "max".equals(string) ? GL14.GL_MAX : GL14.GL_FUNC_ADD;
+		}
+	}
+
+	public static int getComponentFromString(String expression) {
+		String string = expression.trim().toLowerCase(Locale.ROOT);
+		string = string.replaceAll("_", "");
+		string = string.replaceAll("one", "1");
+		string = string.replaceAll("zero", "0");
+		string = string.replaceAll("minus", "-");
+		switch (string) {
+			case "0": return 0;
+			case "1": return 1;
+			case "srccolor": return GL11.GL_SRC_COLOR;
+			case "1-srccolor": return GL11.GL_ONE_MINUS_SRC_COLOR;
+			case "dstcolor": return GL11.GL_DST_COLOR;
+			case "1-dstcolor": return GL11.GL_ONE_MINUS_DST_COLOR;
+			case "srcalpha": return GL11.GL_SRC_ALPHA;
+			case "1-srcalpha": return GL11.GL_ONE_MINUS_SRC_ALPHA;
+			case "dstalpha": return GL11.GL_DST_ALPHA;
+			default: return "1-dstalpha".equals(string) ? GL11.GL_ONE_MINUS_DST_ALPHA : -1;
+		}
+	}
+}
--- argo/J_JsonNodeSelector.java
+++ /dev/null
@@ -1,29 +1,0 @@
-package argo;
-
-public final class J_JsonNodeSelector {
-	final J_Functor field_27359_a;
-
-	J_JsonNodeSelector(J_Functor var1) {
-		this.field_27359_a = var1;
-	}
-
-	public boolean func_27356_a(Object var1) {
-		return this.field_27359_a.func_27058_a(var1);
-	}
-
-	public Object func_27357_b(Object var1) {
-		return this.field_27359_a.func_27059_b(var1);
-	}
-
-	public J_JsonNodeSelector func_27355_a(J_JsonNodeSelector var1) {
-		return new J_JsonNodeSelector(new J_ChainedFunctor(this, var1));
-	}
-
-	String func_27358_a() {
-		return this.field_27359_a.func_27060_a();
-	}
-
-	public String toString() {
-		return this.field_27359_a.toString();
-	}
-}
--- net/minecraft/game/world/block/GrassBlock.java
+++ net/minecraft/game/world/block/GrassBlock.java
@@ -1,34 +1,50 @@
 package net.minecraft.game.world.block;
 
 import java.util.Random;
-import net.minecraft.client.render.color.ColorizerGrass;
+
 import net.minecraft.game.world.BlockAccess;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.BiomeColorType;
 import net.minecraft.game.world.material.Material;
 
 public class GrassBlock extends Block {
+	public static final int TEX_SIDE_TINTED = TerrainLayout.texCoord("grass_side_tinted");
+	public static final int TEX_SIDE = TerrainLayout.texCoord("grass_side");
+	private static final int TEX_TOP = TerrainLayout.texCoord("grass_top");
+	private static final int TEX_TOP_TINTED = TerrainLayout.texCoord("grass_top_tinted");
+	private static final int TEX_SIDE_SNOWY = TerrainLayout.texCoord("grass_side_snowy");
+	private static final int TEX_BOTTOM = TerrainLayout.texCoord("dirt");
+	private static final int TEX_TALL = TerrainLayout.texCoord("tall_grass");
+
 	protected GrassBlock(int var1) {
 		super(var1, Material.grass);
-		this.textureIndex = 3;
+		this.textureIndex = TEX_SIDE;
 		this.setTickOnLoad(true);
 	}
 
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return var2 == -1 ? TEX_TALL : var1 == 0 ? TEX_BOTTOM : var1 == 1 ? TEX_TOP : TEX_SIDE;
+	}
+
 	public int getBlockTexture(BlockAccess var1, int var2, int var3, int var4, int var5) {
 		if(var5 == 1) {
-			return 0;
+			return TEX_TOP_TINTED;
 		} else if(var5 == 0) {
-			return 2;
+			return TEX_BOTTOM;
+		} else if(var5 == -1) {
+			return TEX_TALL;
 		} else {
 			Material var6 = var1.getBlockMaterial(var2, var3 + 1, var4);
-			return var6 != Material.snow && var6 != Material.builtSnow ? 3 : 68;
+			return var6 != Material.snow && var6 != Material.builtSnow ? TEX_SIDE : TEX_SIDE_SNOWY;
 		}
 	}
 
 	public int getColorMultiplier(BlockAccess var1, int var2, int var3, int var4) {
-		var1.getBiomeSource().getBlockGeneratorData(var2, var4, 1, 1);
-		double var5 = var1.getBiomeSource().temperature[0];
-		double var7 = var1.getBiomeSource().humidity[0];
-		return ColorizerGrass.getGrassColor(var5, var7);
+		return var1.getBiomeSource().getColorAt(var2, var4, BiomeColorType.GRASS);
+	}
+
+	public int getRenderType() {
+		return 7;
 	}
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
--- net/minecraft/game/world/chunk/loader/McRegionChunkLoader.java
+++ net/minecraft/game/world/chunk/loader/McRegionChunkLoader.java
@@ -25,7 +25,7 @@
 			if(!var5.hasKey("Level")) {
 				System.out.println("Chunk file at " + var2 + "," + var3 + " is missing level data, skipping");
 				return null;
-			} else if(!var5.getCompoundTag("Level").hasKey("Blocks")) {
+			} else if(!var5.getCompoundTag("Level").hasKey("Sections")) {
 				System.out.println("Chunk file at " + var2 + "," + var3 + " is missing block data, skipping");
 				return null;
 			} else {
@@ -43,6 +43,10 @@
 		} else {
 			return null;
 		}
+	}
+
+	public boolean chunkExists(int var1, int var2) {
+		return RegionFileCache.chunkExists(this.worldDir, var1, var2);
 	}
 
 	public void saveChunk(World var1, Chunk var2) throws IOException {
--- argo/J_JsonArray.java
+++ /dev/null
@@ -1,52 +1,0 @@
-package argo;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-final class J_JsonArray extends J_JsonRootNode {
-	private final List field_27221_a;
-
-	J_JsonArray(Iterable var1) {
-		this.field_27221_a = func_27220_a(var1);
-	}
-
-	public EnumJsonNodeType func_27218_a() {
-		return EnumJsonNodeType.ARRAY;
-	}
-
-	public List getElements() {
-		return new ArrayList(this.field_27221_a);
-	}
-
-	public String getText() {
-		throw new IllegalStateException("Attempt to get text on a JsonNode without text.");
-	}
-
-	public Map getFields() {
-		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
-	}
-
-	public boolean equals(Object var1) {
-		if(this == var1) {
-			return true;
-		} else if(var1 != null && this.getClass() == var1.getClass()) {
-			J_JsonArray var2 = (J_JsonArray)var1;
-			return this.field_27221_a.equals(var2.field_27221_a);
-		} else {
-			return false;
-		}
-	}
-
-	public int hashCode() {
-		return this.field_27221_a.hashCode();
-	}
-
-	public String toString() {
-		return "JsonArray elements:[" + this.field_27221_a + "]";
-	}
-
-	private static List func_27220_a(Iterable var0) {
-		return new J_JsonNodeList(var0);
-	}
-}
--- argo/J_JsonNodeList.java
+++ /dev/null
@@ -1,19 +1,0 @@
-package argo;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-
-final class J_JsonNodeList extends ArrayList {
-	final Iterable field_27405_a;
-
-	J_JsonNodeList(Iterable var1) {
-		this.field_27405_a = var1;
-		Iterator var2 = this.field_27405_a.iterator();
-
-		while(var2.hasNext()) {
-			J_JsonNode var3 = (J_JsonNode)var2.next();
-			this.add(var3);
-		}
-
-	}
-}
--- net/minecraft/client/gui/TexturePackSlotGui.java
+++ net/minecraft/client/gui/TexturePackSlotGui.java
@@ -34,8 +34,8 @@
 		return this.getSize() * 36;
 	}
 
-	protected void drawBackground() {
-		this.parentTexturePackGui.drawDefaultBackground();
+	protected void drawBackground(float var3) {
+		this.parentTexturePackGui.drawDefaultBackground(var3);
 	}
 
 	protected void drawSlot(int var1, int var2, int var3, int var4, Tessellator var5) {
--- argo/J_JsonFieldNodeSelector.java
+++ /dev/null
@@ -1,35 +1,0 @@
-package argo;
-
-import java.util.Map;
-
-final class J_JsonFieldNodeSelector extends J_LeafFunctor {
-	final J_JsonStringNode field_27066_a;
-
-	J_JsonFieldNodeSelector(J_JsonStringNode var1) {
-		this.field_27066_a = var1;
-	}
-
-	public boolean func_27065_a(Map var1) {
-		return var1.containsKey(this.field_27066_a);
-	}
-
-	public String func_27060_a() {
-		return "\"" + this.field_27066_a.getText() + "\"";
-	}
-
-	public J_JsonNode func_27064_b(Map var1) {
-		return (J_JsonNode)var1.get(this.field_27066_a);
-	}
-
-	public String toString() {
-		return "a field called [\"" + this.field_27066_a.getText() + "\"]";
-	}
-
-	public Object func_27063_c(Object var1) {
-		return this.func_27064_b((Map)var1);
-	}
-
-	public boolean func_27058_a(Object var1) {
-		return this.func_27065_a((Map)var1);
-	}
-}
--- net/minecraft/game/world/terrain/generate/TerrainGenCaves.java
+++ net/minecraft/game/world/terrain/generate/TerrainGenCaves.java
@@ -2,20 +2,31 @@
 
 import java.util.Random;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.biome.Biome;
 import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.util.MathHelper;
 
 public class TerrainGenCaves extends TerrainGenerator {
-	protected void generateLargeCaveNode(int var1, int var2, byte[] var3, double var4, double var6, double var8) {
+	private long caveSeed;
+	private final int minHeight;
+	private final int terrainHeight;
+
+	public TerrainGenCaves(int minHeight, int terrainHeight) {
+		this.minHeight = minHeight;
+		this.terrainHeight = terrainHeight;
+	}
+
+	protected void generateLargeCaveNode(int var1, int var2, Chunk var3, double var4, double var6, double var8) {
 		this.generateCaveNode(var1, var2, var3, var4, var6, var8, 1.0F + this.rand.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5D);
 	}
 
-	protected void generateCaveNode(int var1, int var2, byte[] var3, double var4, double var6, double var8, float var10, float var11, float var12, int var13, int var14, double var15) {
+	protected void generateCaveNode(int var1, int var2, Chunk var3, double var4, double var6, double var8, float var10, float var11, float var12, int var13, int var14, double var15) {
 		double var17 = (double)(var1 * 16 + 8);
 		double var19 = (double)(var2 * 16 + 8);
 		float var21 = 0.0F;
 		float var22 = 0.0F;
-		Random var23 = new Random(this.rand.nextLong());
+		Random var23 = new Random(caveSeed);
 		if(var14 <= 0) {
 			int var24 = this.range * 16 - 16;
 			var14 = var24 - var23.nextInt(var24 / 4);
@@ -79,12 +90,12 @@
 						var34 = 16;
 					}
 
-					if(var54 < 1) {
-						var54 = 1;
+					if(var54 < this.minHeight + 1) {
+						var54 = this.minHeight + 1;
 					}
 
-					if(var36 > 120) {
-						var36 = 120;
+					if(var36 > this.terrainHeight - 8) {
+						var36 = this.terrainHeight - 8;
 					}
 
 					if(var55 < 0) {
@@ -102,9 +113,9 @@
 					for(var40 = var53; !var56 && var40 < var34; ++var40) {
 						for(int var41 = var55; !var56 && var41 < var38; ++var41) {
 							for(int var42 = var36 + 1; !var56 && var42 >= var54 - 1; --var42) {
-								var43 = (var40 * 16 + var41) * 128 + var42;
-								if(var42 >= 0 && var42 < 128) {
-									if(var3[var43] == Block.flowingWater.blockID || var3[var43] == Block.stillWater.blockID) {
+								if(var42 >= 0 && var42 < this.terrainHeight) {
+									int b = var3.getBlockID(var40, var42, var41);
+									if(b == Block.flowingWater.blockID || b == Block.stillWater.blockID) {
 										var56 = true;
 									}
 
@@ -122,30 +133,29 @@
 
 							for(var43 = var55; var43 < var38; ++var43) {
 								double var44 = ((double)(var43 + var2 * 16) + 0.5D - var8) / var27;
-								int var46 = (var40 * 16 + var43) * 128 + var36;
 								boolean var47 = false;
 								if(var57 * var57 + var44 * var44 < 1.0D) {
 									for(int var48 = var36 - 1; var48 >= var54; --var48) {
 										double var49 = ((double)var48 + 0.5D - var6) / var29;
 										if(var49 > -0.7D && var57 * var57 + var49 * var49 + var44 * var44 < 1.0D) {
-											byte var51 = var3[var46];
-											if(var51 == Block.grass.blockID) {
+											Biome biome = var3.getBiome(var40, var43, this.worldObj.getBiomeSource());
+
+											int var51 = var3.getBlockID(var40, var48 + 1, var43);
+											if(var51 == biome.topBlock) {
 												var47 = true;
 											}
 
-											if(var51 == Block.stone.blockID || var51 == Block.dirt.blockID || var51 == Block.grass.blockID) {
-												if(var48 < 10) {
-													var3[var46] = (byte)Block.flowingLava.blockID;
+											if(var51 == Block.stone.blockID || var51 == biome.fillerBlock || var51 == biome.topBlock) {
+												if(var48 < 10 + this.minHeight) {
+													var3.setBlockRaw(var40, var48 + 1, var43, Block.stillLava.blockID);
 												} else {
-													var3[var46] = 0;
-													if(var47 && var3[var46 - 1] == Block.dirt.blockID) {
-														var3[var46 - 1] = (byte)Block.grass.blockID;
+													var3.setBlockRaw(var40, var48 + 1, var43, 0);
+													if(var47 && var3.getBlockID(var40, var48, var43) == biome.fillerBlock) {
+														var3.setBlockRaw(var40, var48, var43, biome.topBlock);
 													}
 												}
 											}
 										}
-
-										--var46;
 									}
 								}
 							}
@@ -161,18 +171,20 @@
 
 	}
 
-	protected void generateRecursive(World var1, int var2, int var3, int var4, int var5, byte[] var6) {
+	protected void generateRecursive(World var1, int var2, int var3, int var4, int var5, Chunk var6) {
 		int var7 = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(40) + 1) + 1);
 		if(this.rand.nextInt(15) != 0) {
 			var7 = 0;
 		}
+		var7 = var7 * this.terrainHeight / 128;
 
 		for(int var8 = 0; var8 < var7; ++var8) {
 			double var9 = (double)(var2 * 16 + this.rand.nextInt(16));
-			double var11 = (double)this.rand.nextInt(this.rand.nextInt(120) + 8);
+			double var11 = (double)this.rand.nextInt(this.rand.nextInt(this.terrainHeight - 8) + 8) + this.minHeight;
 			double var13 = (double)(var3 * 16 + this.rand.nextInt(16));
 			int var15 = 1;
 			if(this.rand.nextInt(4) == 0) {
+				caveSeed = this.rand.nextLong();
 				this.generateLargeCaveNode(var4, var5, var6, var9, var11, var13);
 				var15 += this.rand.nextInt(4);
 			}
@@ -181,6 +193,7 @@
 				float var17 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
 				float var18 = (this.rand.nextFloat() - 0.5F) * 2.0F / 8.0F;
 				float var19 = this.rand.nextFloat() * 2.0F + this.rand.nextFloat();
+				caveSeed = this.rand.nextLong();
 				this.generateCaveNode(var4, var5, var6, var9, var11, var13, var19, var17, var18, 0, 0, 1.0D);
 			}
 		}
--- /dev/null
+++ net/minecraft/game/world/biome/SwampBiome.java
@@ -1,0 +1,68 @@
+package net.minecraft.game.world.biome;
+
+import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
+import net.minecraft.game.world.terrain.NoiseSettings;
+import net.minecraft.game.world.terrain.feature.Feature;
+import net.minecraft.game.world.terrain.feature.WillowTreeFeature;
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+
+import java.util.Random;
+
+public class SwampBiome extends Biome {
+	private PerlinNoiseOctaves puddleNoise;
+	private PerlinNoiseOctaves mudNoise;
+
+	protected SwampBiome(int id) {
+		super(id);
+		this.removeBeach();
+	}
+
+	protected NoiseSettings.Builder buildNoiseSettings() {
+		return super.buildNoiseSettings()
+				.noiseStretch(10.0D, 30.0D)
+				.heightOffset(-1.0D, 5.0D)
+				.noiseUnderDamp(1.0D);
+	}
+
+	protected NoiseSettings.Builder buildBoostedNoiseSettings() {
+		return this.buildNoiseSettings();
+	}
+
+	protected void initializeNoise(Random random) {
+		this.puddleNoise = new PerlinNoiseOctaves(random, 2);
+		this.mudNoise = new PerlinNoiseOctaves(random, 3);
+	}
+
+	public Feature getRandomTreeFeature(Random var1) {
+		return new WillowTreeFeature();
+	}
+
+	public int getTreeCount(int treeNoise, int treeBonus) {
+		return treeBonus + treeNoise + 5;
+	}
+
+	public void buildSurfaceColumn(Chunk chunk, int x, int z, int surfaceHeight, int seaLevel, Random random) {
+		super.buildSurfaceColumn(chunk, x, z, surfaceHeight, seaLevel, random);
+
+		int wx = chunk.xPosition * 16 + x;
+		int wz = chunk.zPosition * 16 + z;
+
+		double mudValue = this.mudNoise.generateNoiseNormalized2D(wx * 0.25D, wz * 0.25D);
+		if (mudValue > 0.2D - random.nextDouble() * 0.2D) {
+			if (surfaceHeight >= seaLevel) {
+				chunk.setBlockRaw(x, surfaceHeight, z, 0);
+				chunk.setBlockRaw(x, surfaceHeight - 1, z, Block.mud.blockID);
+			} else {
+				chunk.setBlockRaw(x, surfaceHeight, z, Block.mud.blockID);
+			}
+		}
+
+		if (surfaceHeight == seaLevel - 1) {
+	        double water = puddleNoise.generateNoise2D((double)wx * 0.25D, (double)wz * 0.25D);
+			if (water > 0.25D) {
+				chunk.setBlockRaw(x, surfaceHeight, z, Block.stillWater.blockID);
+			}
+		}
+	}
+}
--- net/minecraft/client/gui/RenameWorldScreen.java
+++ net/minecraft/client/gui/RenameWorldScreen.java
@@ -25,12 +25,12 @@
 		StringTranslate var1 = StringTranslate.getInstance();
 		Keyboard.enableRepeatEvents(true);
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 96 + 12, var1.translateKey("selectWorld.renameButton")));
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 120 + 12, var1.translateKey("gui.cancel")));
+		this.controlList.add(new GuiButton(0, -100, 108, var1.translateKey("selectWorld.renameButton")).alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(1, -100, 132, var1.translateKey("gui.cancel")).alignedAt(0.5F, 0.25F));
 		SaveFormat var2 = this.mc.getSaveLoader();
 		WorldInfo var3 = var2.getWorldInfo(this.field_22113_i);
 		String var4 = var3.getWorldName();
-		this.field_22114_h = new GuiTextField(this, this.fontRenderer, this.width / 2 - 100, 60, 200, 20, var4);
+		this.controlList.add(this.field_22114_h = (GuiTextField) new GuiTextField(this, this.fontRenderer, -100, 60, 200, 20, var4).alignedAt(0.5F, 0.0F));
 		this.field_22114_h.isFocused = true;
 		this.field_22114_h.setMaxStringLength(32);
 	}
@@ -63,15 +63,13 @@
 
 	protected void mouseClicked(int var1, int var2, int var3) {
 		super.mouseClicked(var1, var2, var3);
-		this.field_22114_h.mouseClicked(var1, var2, var3);
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
 		StringTranslate var4 = StringTranslate.getInstance();
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, var4.translateKey("selectWorld.renameTitle"), this.width / 2, this.height / 4 - 60 + 20, 16777215);
 		this.drawString(this.fontRenderer, var4.translateKey("selectWorld.enterName"), this.width / 2 - 100, 47, 10526880);
-		this.field_22114_h.drawTextBox();
 		super.drawScreen(var1, var2, var3);
 	}
 }
--- net/minecraft/game/world/block/TNTBlock.java
+++ net/minecraft/game/world/block/TNTBlock.java
@@ -9,12 +9,16 @@
 import net.minecraft.game.world.material.Material;
 
 public class TNTBlock extends Block {
+	private static final int TEX_TOP = TerrainLayout.texCoord("tnt_top");
+	private static final int TEX_SIDE = TerrainLayout.texCoord("tnt_side");
+	private static final int TEX_BOTTOM = TerrainLayout.texCoord("tnt_bottom");
+
 	public TNTBlock(int var1, int var2) {
 		super(var1, var2, Material.tnt);
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 0 ? this.textureIndex + 2 : (var1 == 1 ? this.textureIndex + 1 : this.textureIndex);
+		return var1 == 0 ? TEX_BOTTOM : var1 == 1 ? TEX_TOP : TEX_SIDE;
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
--- /dev/null
+++ net/mine_diver/smoothbeta/client/render/gl/GlStateManager.java
@@ -1,0 +1,132 @@
+package net.mine_diver.smoothbeta.client.render.gl;
+
+import net.mine_diver.smoothbeta.util.UtilsFromHell;
+import net.minecraft.client.render.GLAllocation;
+import org.lwjgl.opengl.*;
+
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.List;
+import java.util.stream.IntStream;
+
+public class GlStateManager {
+    private static final boolean ON_LINUX = UtilsFromHell.getOsMatchesName("Linux");
+    private static final BlendFuncState BLEND = new BlendFuncState();
+    private static int activeTexture;
+    private static final Texture2DState[] TEXTURES = IntStream.range(0, 12).mapToObj(i -> new Texture2DState()).toArray(Texture2DState[]::new);
+
+    public static void _glDeleteBuffers(int buffer) {
+        if (ON_LINUX) {
+            GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, buffer);
+            GL15.glBufferData(GL15.GL_ARRAY_BUFFER, 0L, GL15.GL_DYNAMIC_DRAW);
+            GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
+        }
+        GL15.glDeleteBuffers(buffer);
+    }
+
+    public static void glShaderSource(int shader, List<String> strings) {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (String string : strings) {
+            stringBuilder.append(string);
+        }
+        byte[] bs = stringBuilder.toString().getBytes(StandardCharsets.UTF_8);
+        ByteBuffer byteBuffer = GLAllocation.createDirectByteBuffer(bs.length + 1);
+        byteBuffer.put(bs);
+        byteBuffer.put((byte)0);
+        byteBuffer.flip();
+        GL20.glShaderSource(shader, byteBuffer);
+    }
+
+    public static void _disableBlend() {
+        GlStateManager.BLEND.capState.disable();
+    }
+
+    public static void _enableBlend() {
+        GlStateManager.BLEND.capState.enable();
+    }
+
+    public static void _blendFunc(int srcFactor, int dstFactor) {
+        if (srcFactor != GlStateManager.BLEND.srcFactorRGB || dstFactor != GlStateManager.BLEND.dstFactorRGB) {
+            GlStateManager.BLEND.srcFactorRGB = srcFactor;
+            GlStateManager.BLEND.dstFactorRGB = dstFactor;
+            GL11.glBlendFunc(srcFactor, dstFactor);
+        }
+    }
+
+    public static void _blendFuncSeparate(int srcFactorRGB, int dstFactorRGB, int srcFactorAlpha, int dstFactorAlpha) {
+        if (srcFactorRGB != GlStateManager.BLEND.srcFactorRGB || dstFactorRGB != GlStateManager.BLEND.dstFactorRGB || srcFactorAlpha != GlStateManager.BLEND.srcFactorAlpha || dstFactorAlpha != GlStateManager.BLEND.dstFactorAlpha) {
+            GlStateManager.BLEND.srcFactorRGB = srcFactorRGB;
+            GlStateManager.BLEND.dstFactorRGB = dstFactorRGB;
+            GlStateManager.BLEND.srcFactorAlpha = srcFactorAlpha;
+            GlStateManager.BLEND.dstFactorAlpha = dstFactorAlpha;
+            GL14.glBlendFuncSeparate(srcFactorRGB, dstFactorRGB, srcFactorAlpha, dstFactorAlpha);
+        }
+    }
+
+    public static void _bindTexture(int texture) {
+        if (texture != GlStateManager.TEXTURES[GlStateManager.activeTexture].boundTexture) {
+            GlStateManager.TEXTURES[GlStateManager.activeTexture].boundTexture = texture;
+            GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture);
+        }
+    }
+
+    public static int _getActiveTexture() {
+        return activeTexture + GL13.GL_TEXTURE0;
+    }
+
+    public static void _activeTexture(int texture) {
+        if (activeTexture != texture - GL13.GL_TEXTURE0) {
+            activeTexture = texture - GL13.GL_TEXTURE0;
+            GL13.glActiveTexture(texture);
+        }
+    }
+
+    public static void _enableTexture() {
+        GlStateManager.TEXTURES[GlStateManager.activeTexture].capState = true;
+    }
+
+    static class CapabilityTracker {
+        private final int cap;
+        private boolean state;
+
+        public CapabilityTracker(int cap) {
+            this.cap = cap;
+        }
+
+        public void disable() {
+            this.setState(false);
+        }
+
+        public void enable() {
+            this.setState(true);
+        }
+
+        public void setState(boolean state) {
+            if (state != this.state) {
+                this.state = state;
+                if (state) {
+                    GL11.glEnable(this.cap);
+                } else {
+                    GL11.glDisable(this.cap);
+                }
+            }
+        }
+    }
+
+    static class BlendFuncState {
+        public final CapabilityTracker capState = new CapabilityTracker(GL11.GL_BLEND);
+        public int srcFactorRGB = 1;
+        public int dstFactorRGB = 0;
+        public int srcFactorAlpha = 1;
+        public int dstFactorAlpha = 0;
+
+        BlendFuncState() {}
+    }
+
+    static class Texture2DState {
+        public boolean capState;
+        public int boundTexture;
+
+        Texture2DState() {}
+    }
+}
--- net/minecraft/game/item/BlockItem.java
+++ net/minecraft/game/item/BlockItem.java
@@ -5,7 +5,7 @@
 import net.minecraft.game.world.block.Block;
 
 public class BlockItem extends Item {
-	private int blockID;
+	protected final int blockID;
 
 	public BlockItem(int var1) {
 		super(var1);
@@ -15,7 +15,7 @@
 
 	public boolean onItemUse(ItemStack var1, PlayerEntity var2, World var3, int var4, int var5, int var6, int var7) {
 		if(var3.getBlockId(var4, var5, var6) == Block.snowLayer.blockID) {
-			var7 = 0;
+			var7 = 1;
 		} else {
 			if(var7 == 0) {
 				--var5;
@@ -44,14 +44,12 @@
 
 		if(var1.count == 0) {
 			return false;
-		} else if(var5 == 127 && Block.blocksList[this.blockID].material.isSolid()) {
-			return false;
 		} else if(var3.canBlockBePlacedAt(this.blockID, var4, var5, var6, false, var7)) {
 			Block var8 = Block.blocksList[this.blockID];
 			if(var3.setBlockAndMetadataWithNotify(var4, var5, var6, this.blockID, this.getPlacedBlockMetadata(var1.getItemDamage()))) {
 				Block.blocksList[this.blockID].onBlockPlaced(var3, var4, var5, var6, var7);
 				Block.blocksList[this.blockID].onBlockPlacedBy(var3, var4, var5, var6, var2);
-				var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var8.stepSound.baseStepSoundDir(), (var8.stepSound.getVolume() + 1.0F) / 2.0F, var8.stepSound.getPitch() * 0.8F);
+				var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var8.stepSound.baseSteppySoundDir(), (var8.stepSound.getVolume() + 1.0F) / 2.0F, var8.stepSound.getPitch() * 0.8F);
 				--var1.count;
 			}
 
@@ -67,5 +65,9 @@
 
 	public String getName() {
 		return Block.blocksList[this.blockID].getName();
+	}
+
+	public int getColorFromDamage(int var1) {
+		return Block.blocksList[this.blockID].getInventoryColor(var1);
 	}
 }
--- net/minecraft/client/gui/GameOverScreen.java
+++ net/minecraft/client/gui/GameOverScreen.java
@@ -7,8 +7,8 @@
 public class GameOverScreen extends GuiScreen {
 	public void initGui() {
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 72, "Respawn"));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 96, "Title menu"));
+		this.controlList.add(new GuiButton(1, -100, 72, "Respawn").alignedAt(0.5F, 0.25F));
+		this.controlList.add(new GuiButton(2, -100, 96, "Title menu").alignedAt(0.5F, 0.25F));
 		if(this.mc.session == null) {
 			((GuiButton)this.controlList.get(1)).enabled = false;
 		}
--- net/minecraft/client/render/GLAllocation.java
+++ net/minecraft/client/render/GLAllocation.java
@@ -4,18 +4,19 @@
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
-import java.util.ArrayList;
-import java.util.List;
+
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import it.unimi.dsi.fastutil.ints.IntList;
 import org.lwjgl.opengl.GL11;
 
 public class GLAllocation {
-	private static List displayLists = new ArrayList();
-	private static List textureNames = new ArrayList();
+	private static final IntList displayLists = new IntArrayList();
+	private static final IntList textureNames = new IntArrayList();
 
 	public static synchronized int generateDisplayLists(int var0) {
 		int var1 = GL11.glGenLists(var0);
-		displayLists.add(Integer.valueOf(var1));
-		displayLists.add(Integer.valueOf(var0));
+		displayLists.add(var1);
+		displayLists.add(var0);
 		return var1;
 	}
 
@@ -23,21 +24,21 @@
 		GL11.glGenTextures(var0);
 
 		for(int var1 = var0.position(); var1 < var0.limit(); ++var1) {
-			textureNames.add(Integer.valueOf(var0.get(var1)));
+			textureNames.add(var0.get(var1));
 		}
 
 	}
 
 	public static synchronized void func_28194_b(int var0) {
-		int var1 = displayLists.indexOf(Integer.valueOf(var0));
-		GL11.glDeleteLists(((Integer)displayLists.get(var1)).intValue(), ((Integer)displayLists.get(var1 + 1)).intValue());
-		displayLists.remove(var1);
-		displayLists.remove(var1);
+		int var1 = displayLists.indexOf(var0);
+		GL11.glDeleteLists(displayLists.getInt(var1), displayLists.getInt(var1 + 1));
+		displayLists.removeInt(var1);
+		displayLists.removeInt(var1);
 	}
 
 	public static synchronized void deleteTexturesAndDisplayLists() {
 		for(int var0 = 0; var0 < displayLists.size(); var0 += 2) {
-			GL11.glDeleteLists(((Integer)displayLists.get(var0)).intValue(), ((Integer)displayLists.get(var0 + 1)).intValue());
+			GL11.glDeleteLists(displayLists.getInt(var0), displayLists.getInt(var0 + 1));
 		}
 
 		IntBuffer var2 = createDirectIntBuffer(textureNames.size());
@@ -45,7 +46,7 @@
 		GL11.glDeleteTextures(var2);
 
 		for(int var1 = 0; var1 < textureNames.size(); ++var1) {
-			var2.put(((Integer)textureNames.get(var1)).intValue());
+			var2.put(textureNames.getInt(var1));
 		}
 
 		var2.flip();
@@ -55,8 +56,7 @@
 	}
 
 	public static synchronized ByteBuffer createDirectByteBuffer(int var0) {
-		ByteBuffer var1 = ByteBuffer.allocateDirect(var0).order(ByteOrder.nativeOrder());
-		return var1;
+		return ByteBuffer.allocateDirect(var0).order(ByteOrder.nativeOrder());
 	}
 
 	public static IntBuffer createDirectIntBuffer(int var0) {
--- argo/J_JsonEscapedString.java
+++ /dev/null
@@ -1,13 +1,0 @@
-package argo;
-
-final class J_JsonEscapedString {
-	private final String field_27031_a;
-
-	J_JsonEscapedString(String var1) {
-		this.field_27031_a = var1.replace("\\", "\\\\").replace("\"", "\\\"").replace("\b", "\\b").replace("\f", "\\f").replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
-	}
-
-	public String toString() {
-		return this.field_27031_a;
-	}
-}
--- net/minecraft/game/entity/monster/SkeletonEntity.java
+++ net/minecraft/game/entity/monster/SkeletonEntity.java
@@ -68,26 +68,6 @@
 		super.readEntityFromNBT(var1);
 	}
 
-	protected int getDropItemId() {
-		return Item.arrow.itemID;
-	}
-
-	protected void dropFewItems() {
-		int var1 = this.rand.nextInt(3);
-
-		int var2;
-		for(var2 = 0; var2 < var1; ++var2) {
-			this.dropItem(Item.arrow.itemID, 1);
-		}
-
-		var1 = this.rand.nextInt(3);
-
-		for(var2 = 0; var2 < var1; ++var2) {
-			this.dropItem(Item.bone.itemID, 1);
-		}
-
-	}
-
 	public ItemStack getHeldItem() {
 		return defaultHeldItem;
 	}
--- com/mojang/nbt/DoubleTag.java
+++ com/mojang/nbt/DoubleTag.java
@@ -29,4 +29,8 @@
 	public String toString() {
 		return "" + this.doubleValue;
 	}
+
+	public NBTBaseTag copy() {
+		return new DoubleTag(this.doubleValue).setKey(this.getKey());
+	}
 }
--- net/minecraft/game/world/terrain/noise/PerlinNoiseOctaves.java
+++ net/minecraft/game/world/terrain/noise/PerlinNoiseOctaves.java
@@ -1,19 +1,24 @@
 package net.minecraft.game.world.terrain.noise;
 
+import java.util.Arrays;
 import java.util.Random;
 
 public class PerlinNoiseOctaves extends NoiseGenerator {
-	private PerlinNoise[] noise;
-	private int octaves;
+	private final PerlinNoise[] noise;
+	private final int octaves;
+	private final double totFreq;
 
 	public PerlinNoiseOctaves(Random var1, int var2) {
 		this.octaves = var2;
 		this.noise = new PerlinNoise[var2];
 
+		double tf = 0.5D;
 		for(int var3 = 0; var3 < var2; ++var3) {
 			this.noise[var3] = new PerlinNoise(var1);
+			tf *= 2.0D;
 		}
 
+		this.totFreq = tf;
 	}
 
 	public double generateNoise2D(double var1, double var3) {
@@ -29,25 +34,74 @@
 	}
 
 	public double[] generateNoiseArray3D(double[] var1, double var2, double var4, double var6, int var8, int var9, int var10, double var11, double var13, double var15) {
-		if(var1 == null) {
+		return this.generateNoiseArray3D(var1, var2, var4, var6, var8, var9, var10, var11, var13, var15, 0.5D, 0.5D);
+	}
+
+	public double[] generateNoiseArray3D(double[] var1, double var2, double var4, double var6, int var8, int var9, int var10, double var11, double var13, double var15, double var20m, double var22m) {
+		if(var1 == null || var1.length < var8 * var9 * var10) {
 			var1 = new double[var8 * var9 * var10];
 		} else {
-			for(int var17 = 0; var17 < var1.length; ++var17) {
-				var1[var17] = 0.0D;
-			}
+			Arrays.fill(var1, 0.0D);
 		}
 
 		double var20 = 1.0D;
+		double var22 = 1.0D;
 
 		for(int var19 = 0; var19 < this.octaves; ++var19) {
-			this.noise[var19].generateNoiseArray3D(var1, var2, var4, var6, var8, var9, var10, var11 * var20, var13 * var20, var15 * var20, var20);
-			var20 /= 2.0D;
+			this.noise[var19].generateNoiseArray3D(var1, var2, var4, var6, var8, var9, var10, var11 * var22, var13 * var22, var15 * var22, var20);
+			var20 *= var20m;
+			var22 *= var22m;
 		}
 
 		return var1;
 	}
 
 	public double[] generateNoiseArray2D(double[] var1, int var2, int var3, int var4, int var5, double var6, double var8, double var10) {
-		return this.generateNoiseArray3D(var1, (double)var2, 10.0D, (double)var3, var4, 1, var5, var6, 1.0D, var8);
+		return this.generateNoiseArray3D(var1, (double)var2, 10.0D, (double)var3, var4, 1, var5, var6, 1.0D, var8, var10, 0.5D);
+	}
+
+	public double[] generateNoiseArray2D(double[] var1, int var2, int var3, int var4, int var5, double var6, double var8, double var10, double var12) {
+		return this.generateNoiseArray3D(var1, (double)var2, 10.0D, (double)var3, var4, 1, var5, var6, 1.0D, var8, var10, var12);
+	}
+
+	public double[] generateNoiseArray3DNormalized(double[] var1, double var2, double var4, double var6, int var8, int var9, int var10, double var11, double var13, double var15, double var20m, double var22m) {
+		if(var1 == null || var1.length < var8 * var9 * var10) {
+			var1 = new double[var8 * var9 * var10];
+		} else {
+			Arrays.fill(var1, 0.0D);
+		}
+
+		double totFreq = Math.pow(var20m, this.octaves);
+
+		double var20 = 1.0D;
+		double var22 = 1.0D;
+
+		for(int var19 = 0; var19 < this.octaves; ++var19) {
+			this.noise[var19].generateNoiseArray3D(var1, var2, var4, var6, var8, var9, var10, var11 * var22, var13 * var22, var15 * var22, var20 / totFreq);
+			var20 *= var20m;
+			var22 *= var22m;
+		}
+
+		return var1;
+	}
+
+	public double generateNoise3D(double var1, double var3, double var5) {
+		double var7 = 0.0D;
+		double var9 = 1.0D;
+
+		for(int var11 = 0; var11 < this.octaves; ++var11) {
+			var7 += this.noise[var11].generateNoise3D(var1 / var9, var3 / var9, var5 / var9) * var9;
+			var9 *= 2.0D;
+		}
+
+		return var7;
+	}
+
+	public double generateNoiseNormalized2D(double var1, double var3) {
+		return this.generateNoise2D(var1, var3) / this.totFreq;
+	}
+
+	public double generateNoiseNormalized3D(double var1, double var3, double var5) {
+		return this.generateNoise3D(var1, var3, var5) / this.totFreq;
 	}
 }
--- net/minecraft/game/world/block/FarmlandBlock.java
+++ net/minecraft/game/world/block/FarmlandBlock.java
@@ -4,15 +4,27 @@
 import net.minecraft.game.entity.Entity;
 import net.minecraft.game.physics.AxisAlignedBB;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.IntProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
 import net.minecraft.game.world.material.Material;
 
 public class FarmlandBlock extends Block {
+	private static final int TEX_WET = TerrainLayout.texCoord("wet_farmland");
+	private static final int TEX_DRY = TerrainLayout.texCoord("farmland");
+
+	public static final IntProperty IRRIGATION = new IntProperty("irrigation", 3);
+
 	protected FarmlandBlock(int var1) {
 		super(var1, Material.ground);
 		this.textureIndex = 87;
 		this.setTickOnLoad(true);
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 15.0F / 16.0F, 1.0F);
 		this.setLightOpacity(255);
+		this.setSpecialLighting();
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(IRRIGATION);
 	}
 
 	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
@@ -28,20 +40,20 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return var1 == 1 && var2 > 0 ? this.textureIndex - 1 : (var1 == 1 ? this.textureIndex : 2);
+		return var1 == 1 && var2 > 0 ? TEX_WET : var1 == 1 ? TEX_DRY : Block.dirt.textureIndex;
 	}
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(var5.nextInt(5) == 0) {
 			if(!this.isWaterNearby(var1, var2, var3, var4) && !var1.canBlockBeRainedOn(var2, var3 + 1, var4)) {
-				int var6 = var1.getBlockMetadata(var2, var3, var4);
-				if(var6 > 0) {
-					var1.setBlockMetadataWithNotify(var2, var3, var4, var6 - 1);
+				int irrigation = var1.getBlockIntProperty(var2, var3, var4, IRRIGATION);
+				if(irrigation > 0) {
+					var1.setBlockPropertyWithNotify(var2, var3, var4, IRRIGATION, irrigation - 1);
 				} else if(!this.isCropsNearby(var1, var2, var3, var4)) {
 					var1.setBlockWithNotify(var2, var3, var4, Block.dirt.blockID);
 				}
 			} else {
-				var1.setBlockMetadataWithNotify(var2, var3, var4, 7);
+				var1.setBlockPropertyWithNotify(var2, var3, var4, IRRIGATION, 7);
 			}
 		}
 
--- net/minecraft/client/gui/IngameHud.java
+++ net/minecraft/client/gui/IngameHud.java
@@ -8,16 +8,25 @@
 import net.minecraft.client.render.RenderHelper;
 import net.minecraft.client.render.Tessellator;
 import net.minecraft.client.render.entity.RenderItem;
+import net.minecraft.game.entity.EntityProperties;
+import net.minecraft.game.entity.EntityRegistry;
 import net.minecraft.game.entity.player.InventoryPlayer;
 import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.world.MovingObjectPosition;
+import net.minecraft.game.world.MovingObjectType;
+import net.minecraft.game.world.biome.BiomeSource;
 import net.minecraft.game.world.block.Block;
+import net.minecraft.game.world.chunk.Chunk;
 import net.minecraft.game.world.material.Material;
 import net.minecraft.util.MathHelper;
 import net.minecraft.util.StringTranslate;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
 
+import static net.minecraft.util.StringTranslate.i18n;
+
 public class IngameHud extends Gui {
+	private static final float debugLineHeight = 12.0F;
 	private static RenderItem itemRenderer = new RenderItem();
 	private List chatMessageList = new ArrayList();
 	private Random rand = new Random();
@@ -29,12 +38,15 @@
 	private boolean field_22065_l = false;
 	public float damageGuiPartialTime;
 	float prevVignetteBrightness = 1.0F;
+	private float debugLinesLeft = 0.0F;
+	private float debugLinesRight = 0.0F;
 
 	public IngameHud(Minecraft var1) {
 		this.mc = var1;
 	}
 
 	public void renderGameOverlay(float var1, boolean var2, int var3, int var4) {
+		this.debugLinesLeft = this.debugLinesRight = 0.0F;
 		ScaledResolution var5 = new ScaledResolution(this.mc.gameSettings, this.mc.displayWidth, this.mc.displayHeight);
 		int var6 = var5.getScaledWidth();
 		int var7 = var5.getScaledHeight();
@@ -73,6 +85,7 @@
 
 		int var13 = this.mc.thePlayer.health;
 		int var14 = this.mc.thePlayer.prevHealth;
+		float energy = this.mc.thePlayer.energy;
 		this.rand.setSeed((long)(this.updateCounter * 312871));
 		int var15;
 		int var16;
@@ -84,17 +97,17 @@
 			for(var16 = 0; var16 < 10; ++var16) {
 				var17 = var7 - 32;
 				if(var15 > 0) {
-					var18 = var6 / 2 + 91 - var16 * 8 - 9;
+					var18 = var6 / 2 - 91 + var16 * 8;
 					if(var16 * 2 + 1 < var15) {
-						this.drawTexturedRect(var18, var17, 34, 9, 9, 9);
+						this.drawTexturedRect(var18, var17 - 10, 34, 9, 9, 9);
 					}
 
 					if(var16 * 2 + 1 == var15) {
-						this.drawTexturedRect(var18, var17, 25, 9, 9, 9);
+						this.drawTexturedRect(var18, var17 - 10, 25, 9, 9, 9);
 					}
 
 					if(var16 * 2 + 1 > var15) {
-						this.drawTexturedRect(var18, var17, 16, 9, 9, 9);
+						this.drawTexturedRect(var18, var17 - 10, 16, 9, 9, 9);
 					}
 				}
 
@@ -126,6 +139,13 @@
 				if(var16 * 2 + 1 == var13) {
 					this.drawTexturedRect(var19, var17, 61, 0, 9, 9);
 				}
+
+				var19 = var6 / 2 + 91 - var16 * 8 - 9;
+				int var17e = var17;
+				if (this.mc.thePlayer.tired && this.rand.nextInt(3) == 0) var17e += this.rand.nextInt(3) - 1;
+				this.drawTexturedRect(var19, var17e, 34, 18, 9, 9);
+				int ci3 = MathHelper.floor(MathHelper.clamp((var16 * 2 + 2 - energy) * 9, 0, 9));
+				this.drawTexturedRect(var19 + ci3, var17e, 52 + ci3, 18, 9, 9);
 			}
 
 			if(this.mc.thePlayer.isInsideOfMaterial(Material.water)) {
@@ -173,29 +193,69 @@
 		}
 
 		String var23;
+		if (Minecraft.DEV_MODE) {
+			this.drawDebugTextLeft(var8, Minecraft.VERSION, var6);
+		}
+
 		if(this.mc.gameSettings.showDebugInfo) {
 			GL11.glPushMatrix();
-			if(Minecraft.hasPaidCheckTime > 0L) {
-				GL11.glTranslatef(0.0F, 32.0F, 0.0F);
-			}
 
-			var8.drawStringWithShadow("Minecraft Beta 1.7.3 (" + this.mc.debug + ")", 2, 2, 16777215);
-			var8.drawStringWithShadow(this.mc.func_6241_m(), 2, 12, 16777215);
-			var8.drawStringWithShadow(this.mc.func_6262_n(), 2, 22, 16777215);
-			var8.drawStringWithShadow(this.mc.func_6245_o(), 2, 32, 16777215);
-			var8.drawStringWithShadow(this.mc.func_21002_o(), 2, 42, 16777215);
+			if (!Minecraft.DEV_MODE) {
+				this.drawDebugTextLeft(var8, Minecraft.VERSION, var6);
+			}
+			this.drawDebugTextLeft(var8, this.mc.debug, var6);
+			this.drawDebugTextLeft(var8, this.mc.getDebugInfoRenders(), var6);
+			this.drawDebugTextLeft(var8, null, var6);
+			this.drawDebugTextLeft(var8, this.mc.getDebugInfoEntities(), var6);
+			this.drawDebugTextLeft(var8, this.mc.getDebugInfoEffects(), var6);
+			this.drawDebugTextLeft(var8, this.mc.getDebugInfoChunkProvider(), var6);
 			long var24 = Runtime.getRuntime().maxMemory();
 			long var29 = Runtime.getRuntime().totalMemory();
 			long var30 = Runtime.getRuntime().freeMemory();
 			long var21 = var29 - var30;
 			var23 = "Used memory: " + var21 * 100L / var24 + "% (" + var21 / 1024L / 1024L + "MB) of " + var24 / 1024L / 1024L + "MB";
-			this.drawString(var8, var23, var6 - var8.getStringWidth(var23) - 2, 2, 14737632);
+			this.drawDebugTextRight(var8, var23, var6, 14737632);
 			var23 = "Allocated memory: " + var29 * 100L / var24 + "% (" + var29 / 1024L / 1024L + "MB)";
-			this.drawString(var8, var23, var6 - var8.getStringWidth(var23) - 2, 12, 14737632);
-			this.drawString(var8, "x: " + this.mc.thePlayer.posX, 2, 64, 14737632);
-			this.drawString(var8, "y: " + this.mc.thePlayer.posY, 2, 72, 14737632);
-			this.drawString(var8, "z: " + this.mc.thePlayer.posZ, 2, 80, 14737632);
-			this.drawString(var8, "f: " + (MathHelper.floor((double)(this.mc.thePlayer.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3), 2, 88, 14737632);
+			this.drawDebugTextRight(var8, var23, var6, 14737632);
+			double px = this.mc.thePlayer.prevPosX + (this.mc.thePlayer.posX - this.mc.thePlayer.prevPosX) * var1;
+			double py = this.mc.thePlayer.prevPosY + (this.mc.thePlayer.posY - this.mc.thePlayer.prevPosY) * var1 - (this.mc.thePlayer.posY - this.mc.thePlayer.boundingBox.minY);
+			double pz = this.mc.thePlayer.prevPosZ + (this.mc.thePlayer.posZ - this.mc.thePlayer.prevPosZ) * var1;
+			String pxFmt = String.format("%.2f", px);
+			String pyFmt = String.format("%.2f", py);
+			String pzFmt = String.format("%.2f", pz);
+			int pf = (MathHelper.floor((double)(this.mc.thePlayer.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3);
+			this.drawDebugTextLeft(var8, "Pos: " + pxFmt + ", " + pyFmt + ", " + pzFmt + "; Facing " + pf, var6);
+			this.drawDebugTextLeft(var8, null, var6);
+			this.drawDebugTextLeft(var8, "Biome: " + this.mc.theWorld.getBiomeAt(MathHelper.floor(px), MathHelper.floor(pz)).name, var6);
+			Chunk chunk = this.mc.theWorld.getChunkFromBlockCoords(MathHelper.floor(px), MathHelper.floor(pz));
+			this.drawDebugTextLeft(var8, chunk.getSectionInfo() + ", Current: " + (MathHelper.floor(py) >> 4), var6);
+
+			MovingObjectPosition hover = this.mc.objectMouseOver;
+			if (hover != null) {
+				if (hover.typeOfHit == MovingObjectType.BLOCK) {
+					int blockID = this.mc.theWorld.getBlockId(hover.blockX, hover.blockY, hover.blockZ);
+					Block block = Block.blocksList[blockID];
+
+					if (block != null) {
+						int metadata = this.mc.theWorld.getBlockMetadata(hover.blockX, hover.blockY, hover.blockZ);
+						this.drawDebugTextRight(var8, null, var6);
+						this.drawDebugTextRight(var8, "§bBlock: §f" + i18n(block.getName() + ".name")
+								+ " §7(§b" + blockID + "§7:§e" + String.format("%02X", metadata) + "§7)", var6);
+						for (String line : block.properties.getDebugInfo(metadata)) {
+							this.drawDebugTextRight(var8, line, var6);
+						}
+					}
+				} else if (hover.typeOfHit == MovingObjectType.ENTITY) {
+					this.drawDebugTextRight(var8, null, var6);
+					this.drawDebugTextRight(var8, "§bEntity: §f" + EntityRegistry.getEntityString(hover.entityHit)
+							+ " §7#" + hover.entityHit.entityId, var6);
+					EntityProperties properties = hover.entityHit.getEntityProperties();
+					for (String line : properties.getDebugInfo()) {
+						this.drawDebugTextRight(var8, line, var6);
+					}
+				}
+			}
+
 			GL11.glPopMatrix();
 		}
 
@@ -270,6 +330,40 @@
 		GL11.glDisable(GL11.GL_BLEND);
 	}
 
+	private void drawDebugTextLeft(FontRenderer fontRenderer, String text, int ignoredScrWidth) {
+		this.drawDebugTextLeft(fontRenderer, text, ignoredScrWidth, 16777215);
+	}
+
+	private void drawDebugTextLeft(FontRenderer fontRenderer, String text, int ignoredScrWidth, int color) {
+		if (text == null) {
+			this.debugLinesLeft += 0.5F;
+			return;
+		}
+
+		int width = fontRenderer.getStringWidth(text);
+		this.drawRect(0, (int)(this.debugLinesLeft * debugLineHeight),
+				width + 4, (int)((this.debugLinesLeft + 1) * debugLineHeight), 0x80000000);
+		fontRenderer.drawString(text, 2, (int)(this.debugLinesLeft * debugLineHeight + 2), color);
+		this.debugLinesLeft++;
+	}
+
+	private void drawDebugTextRight(FontRenderer fontRenderer, String text, int scrWidth) {
+		this.drawDebugTextRight(fontRenderer, text, scrWidth, 16777215);
+	}
+
+	private void drawDebugTextRight(FontRenderer fontRenderer, String text, int scrWidth, int color) {
+		if (text == null) {
+			this.debugLinesRight += 0.5F;
+			return;
+		}
+
+		int width = fontRenderer.getStringWidth(text);
+		this.drawRect(scrWidth - width - 4, (int)(this.debugLinesRight * debugLineHeight),
+				scrWidth, (int)((this.debugLinesRight + 1) * debugLineHeight), 0x80000000);
+		fontRenderer.drawString(text, scrWidth - width - 2, (int)(this.debugLinesRight * debugLineHeight + 2), color);
+		this.debugLinesRight++;
+	}
+
 	private void renderPumpkinBlur(int var1, int var2) {
 		GL11.glDisable(GL11.GL_DEPTH_TEST);
 		GL11.glDepthMask(false);
@@ -332,10 +426,10 @@
 		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, var1);
 		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.textureRegistry.getTexture("/terrain.png"));
-		float var4 = (float)(Block.portal.textureIndex % 16) / 16.0F;
-		float var5 = (float)(Block.portal.textureIndex / 16) / 16.0F;
-		float var6 = (float)(Block.portal.textureIndex % 16 + 1) / 16.0F;
-		float var7 = (float)(Block.portal.textureIndex / 16 + 1) / 16.0F;
+		float var4 = (float)(Block.portal.textureIndex % 32) / 32.0F;
+		float var5 = (float)(Block.portal.textureIndex / 32) / 32.0F;
+		float var6 = (float)(Block.portal.textureIndex % 32 + 1) / 32.0F;
+		float var7 = (float)(Block.portal.textureIndex / 32 + 1) / 32.0F;
 		Tessellator var8 = Tessellator.instance;
 		var8.startDrawingQuads();
 		var8.addVertexWithUV(0.0D, (double)var3, -90.0D, (double)var4, (double)var7);
--- /dev/null
+++ argo/format/JsonFormatter.java
@@ -1,0 +1,7 @@
+package argo.format;
+
+import argo.jdom.JsonRootNode;
+
+public interface JsonFormatter {
+	String format(JsonRootNode var1);
+}
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerRandomBiomes.java
@@ -1,0 +1,35 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.game.world.biome.Biome;
+import net.minecraft.util.IntArray2D;
+
+public class LayerRandomBiomes extends Layer {
+	private static final Biome[] biomes = {
+			Biome.plains,
+			Biome.forest,
+			Biome.desert,
+			Biome.taiga,
+			Biome.mountains,
+			Biome.mapleForest,
+			Biome.snowyTaiga,
+			Biome.savanna,
+			Biome.swamp,
+			Biome.rainforest,
+			Biome.tundra,
+			Biome.badlands,
+			Biome.bloomingMapleForest,
+			Biome.frostyMountains,
+			Biome.bloomingForest,
+			Biome.freshwaterForest,
+			Biome.rockyValley,
+			Biome.bloomingTundra,
+	};
+
+	public LayerRandomBiomes(long seed) {
+		super(seed);
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		return this.forEach(x, z, width, length, i -> biomes[this.nextInt(biomes.length)].id);
+	}
+}
--- net/minecraft/game/world/block/ChestBlock.java
+++ net/minecraft/game/world/block/ChestBlock.java
@@ -1,139 +1,97 @@
 package net.minecraft.game.world.block;
 
 import java.util.Random;
+
+import net.minecraft.game.entity.LivingEntity;
 import net.minecraft.game.entity.misc.ItemEntity;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.item.Inventory;
 import net.minecraft.game.item.ItemStack;
+import net.minecraft.game.physics.Vec3D;
 import net.minecraft.game.world.BlockAccess;
+import net.minecraft.game.world.MovingObjectPosition;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.BooleanProperty;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.StringProperty;
 import net.minecraft.game.world.block.tileentity.ChestTileEntity;
 import net.minecraft.game.world.block.tileentity.InventoryLargeChest;
 import net.minecraft.game.world.block.tileentity.TileEntity;
 import net.minecraft.game.world.material.Material;
+import net.minecraft.util.MathHelper;
 
 public class ChestBlock extends ContainerBlock {
+	private static final int TEX_TOP = TerrainLayout.texCoord("chest_top");
+	private static final int TEX_SIDE = TerrainLayout.texCoord("chest_side");
+	private static final int TEX_SIDE_LEFT = TerrainLayout.texCoord("chest_side_left");
+	private static final int TEX_SIDE_RIGHT = TerrainLayout.texCoord("chest_side_right");
+	private static final int TEX_FRONT = TerrainLayout.texCoord("chest_front");
+	private static final int TEX_FRONT_LEFT = TerrainLayout.texCoord("chest_front_left");
+	private static final int TEX_FRONT_RIGHT = TerrainLayout.texCoord("chest_front_right");
+
 	private Random random = new Random();
+	public static final String[] directions = new String[]{"north", "east", "south", "west"};
+	public static final StringProperty DIRECTION = new StringProperty("direction", 2, directions);
+	public static final BooleanProperty SIDE = new BooleanProperty("side", "right", "left");
+	public static final BooleanProperty SINGLE = new BooleanProperty("single");
 
 	protected ChestBlock(int var1) {
 		super(var1, Material.wood);
-		this.textureIndex = 26;
+		this.textureIndex = TEX_SIDE;
 	}
 
 	public int getBlockTexture(BlockAccess var1, int var2, int var3, int var4, int var5) {
-		if(var5 == 1) {
-			return this.textureIndex - 1;
-		} else if(var5 == 0) {
+		int metadata = var1.getBlockMetadata(var2, var3, var4);
+		if(var5 < 2) {
 			return this.textureIndex - 1;
 		} else {
-			int var6 = var1.getBlockId(var2, var3, var4 - 1);
-			int var7 = var1.getBlockId(var2, var3, var4 + 1);
-			int var8 = var1.getBlockId(var2 - 1, var3, var4);
-			int var9 = var1.getBlockId(var2 + 1, var3, var4);
-			int var10;
-			int var11;
-			int var12;
-			byte var13;
-			if(var6 != this.blockID && var7 != this.blockID) {
-				if(var8 != this.blockID && var9 != this.blockID) {
-					byte var14 = 3;
-					if(Block.opaqueCubeLookup[var6] && !Block.opaqueCubeLookup[var7]) {
-						var14 = 3;
-					}
-
-					if(Block.opaqueCubeLookup[var7] && !Block.opaqueCubeLookup[var6]) {
-						var14 = 2;
-					}
-
-					if(Block.opaqueCubeLookup[var8] && !Block.opaqueCubeLookup[var9]) {
-						var14 = 5;
-					}
-
-					if(Block.opaqueCubeLookup[var9] && !Block.opaqueCubeLookup[var8]) {
-						var14 = 4;
-					}
-
-					return var5 == var14 ? this.textureIndex + 1 : this.textureIndex;
-				} else if(var5 != 4 && var5 != 5) {
-					var10 = 0;
-					if(var8 == this.blockID) {
-						var10 = -1;
-					}
-
-					var11 = var1.getBlockId(var8 == this.blockID ? var2 - 1 : var2 + 1, var3, var4 - 1);
-					var12 = var1.getBlockId(var8 == this.blockID ? var2 - 1 : var2 + 1, var3, var4 + 1);
-					if(var5 == 3) {
-						var10 = -1 - var10;
-					}
-
-					var13 = 3;
-					if((Block.opaqueCubeLookup[var6] || Block.opaqueCubeLookup[var11]) && !Block.opaqueCubeLookup[var7] && !Block.opaqueCubeLookup[var12]) {
-						var13 = 3;
-					}
-
-					if((Block.opaqueCubeLookup[var7] || Block.opaqueCubeLookup[var12]) && !Block.opaqueCubeLookup[var6] && !Block.opaqueCubeLookup[var11]) {
-						var13 = 2;
-					}
-
-					return (var5 == var13 ? this.textureIndex + 16 : this.textureIndex + 32) + var10;
-				} else {
-					return this.textureIndex;
-				}
-			} else if(var5 != 2 && var5 != 3) {
-				var10 = 0;
-				if(var6 == this.blockID) {
-					var10 = -1;
-				}
-
-				var11 = var1.getBlockId(var2 - 1, var3, var6 == this.blockID ? var4 - 1 : var4 + 1);
-				var12 = var1.getBlockId(var2 + 1, var3, var6 == this.blockID ? var4 - 1 : var4 + 1);
-				if(var5 == 4) {
-					var10 = -1 - var10;
-				}
-
-				var13 = 5;
-				if((Block.opaqueCubeLookup[var8] || Block.opaqueCubeLookup[var11]) && !Block.opaqueCubeLookup[var9] && !Block.opaqueCubeLookup[var12]) {
-					var13 = 5;
-				}
-
-				if((Block.opaqueCubeLookup[var9] || Block.opaqueCubeLookup[var12]) && !Block.opaqueCubeLookup[var8] && !Block.opaqueCubeLookup[var11]) {
-					var13 = 4;
-				}
-
-				return (var5 == var13 ? this.textureIndex + 16 : this.textureIndex + 32) + var10;
-			} else {
-				return this.textureIndex;
-			}
+			int direction = var1.getBlockIntProperty(var2, var3, var4, DIRECTION);
+			byte byte0 = 0;
+			if(direction == 0) {
+				byte0 = 2;
+			}
+			if(direction == 1) {
+				byte0 = 5;
+			}
+			if(direction == 2) {
+				byte0 = 3;
+			}
+			if(direction == 3) {
+				byte0 = 4;
+			}
+
+			if ((metadata >> 3 & 1) == 1) {
+				if (var5 == byte0) return TEX_FRONT;
+				else return TEX_SIDE;
+			}
+
+			int i2 = 0;
+			if((metadata >> 2 & 1) == 0) {
+				i2 = -1;
+			}
+
+			if(direction == 0 || direction == 2) {
+				if (var5 == 3) i2 = -1 - i2;
+				if (var5 == 4 || var5 == 5) return TEX_SIDE;
+			}
+
+			if(direction == 1 || direction == 3) {
+				if (var5 == 4) i2 = -1 - i2;
+				if (var5 == 2 || var5 == 3) return TEX_SIDE;
+			}
+
+			return var5 == byte0
+					? i2 == 0 ? TEX_FRONT_RIGHT : TEX_FRONT_LEFT
+					: i2 == 0 ? TEX_SIDE_RIGHT : TEX_SIDE_LEFT;
 		}
+	}
+
+	protected PropertyList getProperties() {
+		return new PropertyList(DIRECTION, SIDE, SINGLE);
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.textureIndex - 1 : (var1 == 0 ? this.textureIndex - 1 : (var1 == 3 ? this.textureIndex + 1 : this.textureIndex));
-	}
-
-	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
-		int var5 = 0;
-		if(var1.getBlockId(var2 - 1, var3, var4) == this.blockID) {
-			++var5;
-		}
-
-		if(var1.getBlockId(var2 + 1, var3, var4) == this.blockID) {
-			++var5;
-		}
-
-		if(var1.getBlockId(var2, var3, var4 - 1) == this.blockID) {
-			++var5;
-		}
-
-		if(var1.getBlockId(var2, var3, var4 + 1) == this.blockID) {
-			++var5;
-		}
-
-		return var5 > 1 ? false : (this.isThereANeighborChest(var1, var2 - 1, var3, var4) ? false : (this.isThereANeighborChest(var1, var2 + 1, var3, var4) ? false : (this.isThereANeighborChest(var1, var2, var3, var4 - 1) ? false : !this.isThereANeighborChest(var1, var2, var3, var4 + 1))));
-	}
-
-	private boolean isThereANeighborChest(World var1, int var2, int var3, int var4) {
-		return var1.getBlockId(var2, var3, var4) != this.blockID ? false : (var1.getBlockId(var2 - 1, var3, var4) == this.blockID ? true : (var1.getBlockId(var2 + 1, var3, var4) == this.blockID ? true : (var1.getBlockId(var2, var3, var4 - 1) == this.blockID ? true : var1.getBlockId(var2, var3, var4 + 1) == this.blockID)));
+		return var1 < 2 ? TEX_TOP : var1 == 3 ? TEX_FRONT : TEX_SIDE;
 	}
 
 	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
@@ -167,41 +125,225 @@
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, PlayerEntity var5) {
-		Object var6 = (ChestTileEntity)var1.getBlockTileEntity(var2, var3, var4);
-		if(var1.isBlockNormalCube(var2, var3 + 1, var4)) {
-			return true;
-		} else if(var1.getBlockId(var2 - 1, var3, var4) == this.blockID && var1.isBlockNormalCube(var2 - 1, var3 + 1, var4)) {
-			return true;
-		} else if(var1.getBlockId(var2 + 1, var3, var4) == this.blockID && var1.isBlockNormalCube(var2 + 1, var3 + 1, var4)) {
-			return true;
-		} else if(var1.getBlockId(var2, var3, var4 - 1) == this.blockID && var1.isBlockNormalCube(var2, var3 + 1, var4 - 1)) {
-			return true;
-		} else if(var1.getBlockId(var2, var3, var4 + 1) == this.blockID && var1.isBlockNormalCube(var2, var3 + 1, var4 + 1)) {
-			return true;
-		} else {
-			if(var1.getBlockId(var2 - 1, var3, var4) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (ChestTileEntity)var1.getBlockTileEntity(var2 - 1, var3, var4), (Inventory)var6);
-			}
-
-			if(var1.getBlockId(var2 + 1, var3, var4) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (Inventory)var6, (ChestTileEntity)var1.getBlockTileEntity(var2 + 1, var3, var4));
-			}
-
-			if(var1.getBlockId(var2, var3, var4 - 1) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (ChestTileEntity)var1.getBlockTileEntity(var2, var3, var4 - 1), (Inventory)var6);
-			}
-
-			if(var1.getBlockId(var2, var3, var4 + 1) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (Inventory)var6, (ChestTileEntity)var1.getBlockTileEntity(var2, var3, var4 + 1));
-			}
-
-			if(var1.remoteWorld) {
-				return true;
-			} else {
-				var5.displayGUIChest((Inventory)var6);
-				return true;
-			}
-		}
+		if(var1.remoteWorld) {
+			return true;
+		} else {
+			this.validateChest(var1, var2, var3, var4);
+			var5.displayGUIChest(getInventory(var1, var2, var3, var4));
+			return true;
+		}
+	}
+
+	public Inventory getInventory(World world, int x, int y, int z) {
+		Inventory inventory = (Inventory) world.getBlockTileEntity(x, y, z);
+
+		int metadata = world.getBlockMetadata(x, y, z);
+		int type = metadata >> 2;
+
+		if (type < 2) {
+			Inventory inventory1 = null;
+
+			int direction = metadata & 3;
+
+			int x2 = x;
+			int z2 = z;
+
+			if (direction == 0 || direction == 2) {
+				if (type > 0) x2++;
+				if (type == 0) x2--;
+			}
+			if (direction == 1 || direction == 3) {
+				if (type > 0) z2++;
+				if (type == 0) z2--;
+			}
+
+			if (Block.blocksList[world.getBlockId(x2, y, z2)] instanceof ChestBlock) {
+				int metadata2 = world.getBlockMetadata(x2, y, z2);
+				if ((metadata2 & 3) == direction) {
+					int type2 = metadata2 >> 2;
+					if (type > 0 && type2 == 0) {
+						inventory1 = (Inventory) world.getBlockTileEntity(x2, y, z2);
+					}
+
+					if (type == 0 && type2 > 0) {
+						inventory1 = inventory;
+						inventory = (Inventory) world.getBlockTileEntity(x2, y, z2);
+					}
+				}
+			}
+
+			if (inventory1 != null) {
+				inventory = new InventoryLargeChest("Large chest", inventory, inventory1);
+			}
+		}
+
+		return inventory;
+	}
+
+	public void onBlockPlacedBy(World world, int x, int y, int z, LivingEntity entity) {
+		int l1 = MathHelper.floor((double)((entity.rotationYaw * 4F) / 360F) + 0.5D) & 3;
+		float var4 = 1.0F;
+		float var5 = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * var4;
+		float var6 = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * var4;
+		double var7 = entity.prevPosX + (entity.posX - entity.prevPosX) * (double)var4;
+		double var9 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)var4 + 1.62D - (double)entity.yOffset;
+		double var11 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double)var4;
+		Vec3D var13 = Vec3D.createVector(var7, var9, var11);
+		float var14 = MathHelper.cos(-var6 * ((float)Math.PI / 180.0F) - (float)Math.PI);
+		float var15 = MathHelper.sin(-var6 * ((float)Math.PI / 180.0F) - (float)Math.PI);
+		float var16 = -MathHelper.cos(-var5 * ((float)Math.PI / 180.0F));
+		float var17 = MathHelper.sin(-var5 * ((float)Math.PI / 180.0F));
+		float var18 = var15 * var16;
+		float var20 = var14 * var16;
+		double var21 = 5.0D;
+		Vec3D var23 = var13.addVector((double)var18 * var21, (double)var17 * var21, (double)var20 * var21);
+		MovingObjectPosition var24 = world.rayTraceBlocks_do(var13, var23, false);
+
+		int side = var24.sideHit;
+		int type = l1 | 8;
+
+		if (entity.isSneaking() && side != 0 && side != 1) {
+			int x2 = x;
+			int z2 = z;
+
+			if (side == 2) x2++;
+			if (side == 3) x2--;
+			if (side == 4) z2--;
+			if (side == 5) z2++;
+
+			int metadata = world.getBlockMetadata(x2, y, z2);
+
+			if ((metadata >> 3 & 1) == 1) {
+				int direction = metadata & 3;
+				if (direction == 0 || direction == 2) {
+					if (side == 2) {
+						world.setBlockMetadata(x2, y, z2, direction);
+						type = direction | 4;
+					}
+
+					if (side == 3) {
+						world.setBlockMetadata(x2, y, z2, direction | 4);
+						type = direction;
+					}
+				}
+
+				if (direction == 1 || direction == 3) {
+					if (side == 5) {
+						world.setBlockMetadata(x2, y, z2, direction);
+						type = direction | 4;
+					}
+
+					if (side == 4) {
+						world.setBlockMetadata(x2, y, z2, direction | 4);
+						type = direction;
+					}
+				}
+			}
+		} else if (!entity.isSneaking()) {
+			if (l1 == 0) {
+				if (hasSingleChestInDirection(world, x - 1, y, z, l1) && !hasSingleChestInDirection(world, x + 1, y, z, l1)) {
+					type = l1;
+					world.setBlockMetadata(x - 1, y, z, l1 | 4);
+				}
+
+				if (hasSingleChestInDirection(world, x + 1, y, z, l1) && !hasSingleChestInDirection(world, x - 1, y, z, l1)) {
+					type = l1 | 4;
+					world.setBlockMetadata(x + 1, y, z, l1);
+				}
+			}
+
+			if (l1 == 1) {
+				if (hasSingleChestInDirection(world, x, y, z - 1, l1) && !hasSingleChestInDirection(world, x, y, z + 1, l1)) {
+					type = l1;
+					world.setBlockMetadata(x, y, z - 1, l1 | 4);
+				}
+
+				if (hasSingleChestInDirection(world, x, y, z + 1, l1) && !hasSingleChestInDirection(world, x, y, z - 1, l1)) {
+					type = l1 | 4;
+					world.setBlockMetadata(x, y, z + 1, l1);
+				}
+			}
+
+			if (l1 == 2) {
+				if (hasSingleChestInDirection(world, x + 1, y, z, l1) && !hasSingleChestInDirection(world, x - 1, y, z, l1)) {
+					type = l1 | 4;
+					world.setBlockMetadata(x + 1, y, z, l1);
+				}
+
+				if (hasSingleChestInDirection(world, x - 1, y, z, l1) && !hasSingleChestInDirection(world, x + 1, y, z, l1)) {
+					type = l1;
+					world.setBlockMetadata(x - 1, y, z, l1 | 4);
+				}
+			}
+
+			if (l1 == 3) {
+				if (hasSingleChestInDirection(world, x, y, z + 1, l1) && !hasSingleChestInDirection(world, x, y, z - 1, l1)) {
+					type = l1 | 4;
+					world.setBlockMetadata(x, y, z + 1, l1);
+				}
+
+				if (hasSingleChestInDirection(world, x, y, z - 1, l1) && !hasSingleChestInDirection(world, x, y, z + 1, l1)) {
+					type = l1;
+					world.setBlockMetadata(x, y, z - 1, l1 | 4);
+				}
+			}
+		}
+
+		world.setBlockMetadata(x, y, z, type);
+	}
+
+	public boolean hasSingleChestInDirection(World world, int x, int y, int z, int direction) {
+		if (world.getBlockId(x, y, z) == blockID) {
+			int metadata = world.getBlockMetadata(x, y, z);
+			int direction_ = metadata & 3;
+			return direction_ == direction && (metadata >> 3 & 1) == 1;
+		} else {
+			return false;
+		}
+	}
+
+	public void validateChest(World world, int x, int y, int z) {
+		int metadata = world.getBlockMetadata(x, y, z);
+		if ((metadata >> 3 & 1) == 0) {
+			int direction = metadata & 3;
+			int type = metadata >> 2 & 1;
+
+			int x2 = x;
+			int z2 = z;
+
+			if (direction == 0 || direction == 2) {
+				if (type > 0) x2++;
+				if (type == 0) x2--;
+			}
+			if (direction == 1 || direction == 3) {
+				if (type > 0) z2++;
+				if (type == 0) z2--;
+			}
+
+			boolean valid = false;
+
+			if (Block.blocksList[world.getBlockId(x2, y, z2)] instanceof ChestBlock) {
+				int metadata2 = world.getBlockMetadata(x2, y, z2);
+				int direction2 = metadata2 & 3;
+
+				if (direction2 == direction) {
+					int type2 = metadata2 >> 2 & 1;
+					if ((type == 0 && type2 > 0) || (type > 0 && type2 == 0)) {
+						valid = true;
+					}
+				}
+			}
+
+			if (!valid) {
+				world.setBlockMetadataWithNotify(x, y, z, direction | 8);
+				world.markBlocksDirty(x, y, z, x, y, z);
+			}
+		}
+	}
+
+	public void onNeighborBlockChange(World world, int x, int y, int z, int blockId) {
+		super.onNeighborBlockChange(world, x, y, z, blockId);
+		this.validateChest(world, x, y, z);
 	}
 
 	protected TileEntity getTileEntity() {
--- /dev/null
+++ argo/jdom/JsonArray.java
@@ -1,0 +1,64 @@
+package argo.jdom;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+final class JsonArray extends JsonRootNode {
+	private final List<JsonNode> elements;
+
+	JsonArray(Iterable<JsonNode> var1) {
+		this.elements = asList(var1);
+	}
+
+	public JsonNodeType getType() {
+		return JsonNodeType.ARRAY;
+	}
+
+	public List<JsonNode> getElements() {
+		return new ArrayList<>(this.elements);
+	}
+
+	public String getText() {
+		throw new IllegalStateException("Attempt to get text on a JsonNode without text.");
+	}
+
+	public Map<JsonStringNode, JsonNode> getFields() {
+		throw new IllegalStateException("Attempt to get fields on a JsonNode without fields.");
+	}
+
+	public boolean equals(Object var1) {
+		if(this == var1) {
+			return true;
+		} else if(var1 != null && this.getClass() == var1.getClass()) {
+			JsonArray var2 = (JsonArray)var1;
+			return this.elements.equals(var2.elements);
+		} else {
+			return false;
+		}
+	}
+
+	public int hashCode() {
+		return this.elements.hashCode();
+	}
+
+	public String toString() {
+		return "JsonArray elements:[" + this.elements + "]";
+	}
+
+	private static List<JsonNode> asList(Iterable<JsonNode> var0) {
+		return new NodeList(var0);
+	}
+
+	static final class NodeList extends ArrayList<JsonNode> {
+		final Iterable<JsonNode> field_27405_a;
+
+		NodeList(Iterable<JsonNode> var1) {
+			this.field_27405_a = var1;
+
+			for (JsonNode object : this.field_27405_a) {
+				this.add(object);
+			}
+		}
+	}
+}
--- net/minecraft/game/world/block/LogBlock.java
+++ net/minecraft/game/world/block/LogBlock.java
@@ -1,26 +1,30 @@
 package net.minecraft.game.world.block;
 
-import java.util.Random;
-import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.item.Item;
+import net.minecraft.game.item.SubtypedItem;
 import net.minecraft.game.world.World;
+import net.minecraft.game.world.block.properties.PropertyList;
+import net.minecraft.game.world.block.properties.SharedProperties;
+import net.minecraft.game.world.block.properties.StringProperty;
 import net.minecraft.game.world.material.Material;
 
 public class LogBlock extends Block {
+	private static final int[] TEX_TYPES = TerrainLayout.varyingTexCoord("log", SharedProperties.WOOD_NAMES);
+	private static final int[] TEX_TYPES_TOP = TerrainLayout.varyingTexCoord("log_top", SharedProperties.WOOD_NAMES);
+
+	public static final StringProperty TYPE = SharedProperties.woodProperty("type");
+
 	protected LogBlock(int var1) {
 		super(var1, Material.wood);
 		this.textureIndex = 20;
 	}
 
-	public int quantityDropped(Random var1) {
-		return 1;
-	}
-
-	public int idDropped(int var1, Random var2) {
-		return Block.log.blockID;
-	}
-
-	public void harvestBlock(World var1, PlayerEntity var2, int var3, int var4, int var5, int var6) {
-		super.harvestBlock(var1, var2, var3, var4, var5, var6);
+	protected PropertyList getProperties() {
+		return new PropertyList(TYPE);
+	}
+
+	protected Item getItem() {
+		return new SubtypedItem(this.blockID - 256);
 	}
 
 	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
@@ -32,10 +36,7 @@
 					for(int var9 = -var5; var9 <= var5; ++var9) {
 						int var10 = var1.getBlockId(var2 + var7, var3 + var8, var4 + var9);
 						if(var10 == Block.leaves.blockID) {
-							int var11 = var1.getBlockMetadata(var2 + var7, var3 + var8, var4 + var9);
-							if((var11 & 8) == 0) {
-								var1.setBlockMetadata(var2 + var7, var3 + var8, var4 + var9, var11 | 8);
-							}
+							var1.setBlockProperty(var2 + var7, var3 + var8, var4 + var9, LeavesBlock.DECAYING, true);
 						}
 					}
 				}
@@ -45,7 +46,9 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return var1 == 1 ? 21 : (var1 == 0 ? 21 : (var2 == 1 ? 116 : (var2 == 2 ? 117 : 20)));
+		var2 = this.properties.getInt(var2, TYPE);
+		if (var2 >= TEX_TYPES.length) var2 = 0;
+		return var1 < 2 ? TEX_TYPES_TOP[var2] : TEX_TYPES[var2];
 	}
 
 	protected int damageDropped(int var1) {
--- net/minecraft/game/item/SlabItem.java
+++ net/minecraft/game/item/SlabItem.java
@@ -1,17 +1,83 @@
 package net.minecraft.game.item;
 
+import net.minecraft.game.entity.player.PlayerEntity;
+import net.minecraft.game.world.World;
 import net.minecraft.game.world.block.Block;
 import net.minecraft.game.world.block.SlabBlock;
 
 public class SlabItem extends BlockItem {
-	public SlabItem(int var1) {
-		super(var1);
-		this.setMaxDamage(0);
-		this.setHasSubtypes(true);
+	private final SlabBlock singleSlab;
+	private final SlabBlock doubleSlab;
+
+	public SlabItem(SlabBlock singleSlab, SlabBlock doubleSlab) {
+		super(singleSlab.blockID - 256);
+		this.singleSlab = singleSlab;
+		this.doubleSlab = doubleSlab;
+	}
+
+	public boolean onItemUse(ItemStack var1, PlayerEntity var2, World var3, int var4, int var5, int var6, int var7) {
+		if(var1.count == 0) {
+			return false;
+		}
+
+		int var8 = var3.getBlockId(var4, var5, var6);
+		int var9 = var3.getBlockMetadata(var4, var5, var6);
+		int var10 = var3.getBlockIntProperty(var4, var5, var6, SlabBlock.TYPE);
+		boolean var11 = var3.getBlockBooleanProperty(var4, var5, var6, SlabBlock.HALF);
+		if((var7 == 1 && !var11 || var7 == 0 && var11) && var8 == this.itemID && var10 == var1.getItemDamage()) {
+			if(var3.checkIfAABBIsClear(this.doubleSlab.getCollisionBoundingBoxFromPool(var3, var4, var5, var6)) && var3.setBlockAndMetadataWithNotify(var4, var5, var6, this.doubleSlab.blockID, var10)) {
+				var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), this.doubleSlab.stepSound.stepSoundDir(), (this.doubleSlab.stepSound.getVolume() + 1.0F) / 2.0F, this.doubleSlab.stepSound.getPitch() * 0.8F);
+				--var1.count;
+			}
+
+			return true;
+		} else {
+			return this.func_50087_b(var1, var2, var3, var4, var5, var6, var7) || super.onItemUse(var1, var2, var3, var4, var5, var6, var7);
+		}
+	}
+
+	private boolean func_50087_b(ItemStack var0, PlayerEntity var1, World var2, int var3, int var4, int var5, int var6) {
+		if(var6 == 0) {
+			--var4;
+		}
+
+		if(var6 == 1) {
+			++var4;
+		}
+
+		if(var6 == 2) {
+			--var5;
+		}
+
+		if(var6 == 3) {
+			++var5;
+		}
+
+		if(var6 == 4) {
+			--var3;
+		}
+
+		if(var6 == 5) {
+			++var3;
+		}
+
+		int var7 = var2.getBlockId(var3, var4, var5);
+		int var8 = var2.getBlockMetadata(var3, var4, var5);
+		int var9 = var2.getBlockIntProperty(var3, var4, var5, SlabBlock.TYPE);
+		if(var7 == this.singleSlab.blockID && var9 == var0.getItemDamage()) {
+			if(var2.checkIfAABBIsClear(this.doubleSlab.getCollisionBoundingBoxFromPool(var2, var3, var4, var5)) && var2.setBlockAndMetadataWithNotify(var3, var4, var5, this.doubleSlab.blockID, var9)) {
+				var2.playSoundEffect((double)((float)var3 + 0.5F), (double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), this.doubleSlab.stepSound.stepSoundDir(), (this.doubleSlab.stepSound.getVolume() + 1.0F) / 2.0F, this.doubleSlab.stepSound.getPitch() * 0.8F);
+				--var0.count;
+			}
+
+			return true;
+		} else {
+			return false;
+		}
 	}
 
 	public int getTextureFromDamage(int var1) {
-		return Block.stoneSlab.getBlockTextureFromSideAndMetadata(2, var1);
+		return this.singleSlab.getBlockTextureFromSideAndMetadata(2, var1);
 	}
 
 	public int getPlacedBlockMetadata(int var1) {
@@ -19,6 +85,6 @@
 	}
 
 	public String getNameFromStack(ItemStack var1) {
-		return super.getName() + "." + SlabBlock.slabNames[var1.getItemDamage()];
+		return super.getName() + "." + var1.getItemDamage();
 	}
 }
--- net/minecraft/game/entity/Entity.java
+++ net/minecraft/game/entity/Entity.java
@@ -62,6 +62,7 @@
 	public float ySize = 0.0F;
 	public float stepHeight = 0.0F;
 	public boolean noClip = false;
+	public boolean flying = false;
 	public float entityCollisionReduction = 0.0F;
 	protected Random rand = new Random();
 	public int ticksExisted = 0;
@@ -91,7 +92,7 @@
 	public Entity(World var1) {
 		this.worldObj = var1;
 		this.setPosition(0.0D, 0.0D, 0.0D);
-		this.properties.addProperty(0, Byte.valueOf((byte)0));
+		this.properties.addProperty(0, (byte) 0);
 		this.entityInit();
 	}
 
@@ -101,6 +102,10 @@
 		return this.properties;
 	}
 
+	public boolean moveInRemoteWorld() {
+		return true;
+	}
+
 	public boolean equals(Object var1) {
 		return var1 instanceof Entity ? ((Entity)var1).entityId == this.entityId : false;
 	}
@@ -235,7 +240,7 @@
 			this.setOnFireFromLava();
 		}
 
-		if(this.posY < -64.0D) {
+		if(this.posY < -64.0D && this.posY < this.worldObj.getChunkFromBlockCoords(MathHelper.floor(this.posX), MathHelper.floor(this.posZ)).getMinLevel()) {
 			this.kill();
 		}
 
@@ -266,6 +271,8 @@
 	}
 
 	public void moveEntity(double var1, double var3, double var5) {
+		if (this.worldObj.remoteWorld && !this.moveInRemoteWorld()) return;
+
 		if(this.noClip) {
 			this.boundingBox.offset(var1, var3, var5);
 			this.posX = (this.boundingBox.minX + this.boundingBox.maxX) / 2.0D;
@@ -465,9 +472,9 @@
 					StepSound var29 = Block.blocksList[var28].stepSound;
 					if(this.worldObj.getBlockId(var38, var26 + 1, var39) == Block.snowLayer.blockID) {
 						var29 = Block.snowLayer.stepSound;
-						this.worldObj.playSoundAtEntity(this, var29.baseStepSoundDir(), var29.getVolume() * 0.15F, var29.getPitch());
+						this.worldObj.playSoundAtEntity(this, var29.baseSteppySoundDir(), var29.getVolume() * 0.15F, var29.getPitch());
 					} else if(!Block.blocksList[var28].material.isLiquid()) {
-						this.worldObj.playSoundAtEntity(this, var29.baseStepSoundDir(), var29.getVolume() * 0.15F, var29.getPitch());
+						this.worldObj.playSoundAtEntity(this, var29.baseSteppySoundDir(), var29.getVolume() * 0.15F, var29.getPitch());
 					}
 
 					Block.blocksList[var28].onEntityWalking(this.worldObj, var38, var26, var39, this);
@@ -557,7 +564,7 @@
 	}
 
 	public boolean handleWaterMovement() {
-		return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0D, (double)-0.4F, 0.0D).getInsetBoundingBox(0.001D, 0.001D, 0.001D), Material.water, this);
+		return !this.flying && this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0D, (double)-0.4F, 0.0D).getInsetBoundingBox(0.001D, 0.001D, 0.001D), Material.water, this);
 	}
 
 	public boolean isInsideOfMaterial(Material var1) {
@@ -580,7 +587,7 @@
 	}
 
 	public boolean handleLavaMovement() {
-		return this.worldObj.isMaterialInBB(this.boundingBox.expand((double)-0.1F, (double)-0.4F, (double)-0.1F), Material.lava);
+		return !this.flying && this.worldObj.isMaterialInBB(this.boundingBox.expand((double)-0.1F, (double)-0.4F, (double)-0.1F), Material.lava);
 	}
 
 	public void moveFlying(float var1, float var2, float var3) {
@@ -764,9 +771,9 @@
 	}
 
 	public void writeToNBT(CompoundTag var1) {
-		var1.setTag("Pos", this.newDoubleNBTList(new double[]{this.posX, this.posY + (double)this.ySize, this.posZ}));
-		var1.setTag("Motion", this.newDoubleNBTList(new double[]{this.motionX, this.motionY, this.motionZ}));
-		var1.setTag("Rotation", this.newFloatNBTList(new float[]{this.rotationYaw, this.rotationPitch}));
+		var1.setTag("Pos", this.newDoubleNBTList(this.posX, this.posY + (double)this.ySize, this.posZ));
+		var1.setTag("Motion", this.newDoubleNBTList(this.motionX, this.motionY, this.motionZ));
+		var1.setTag("Rotation", this.newFloatNBTList(this.rotationYaw, this.rotationPitch));
 		var1.setFloat("FallDistance", this.fallDistance);
 		var1.setShort("Fire", (short)this.fire);
 		var1.setShort("Air", (short)this.air);
@@ -865,6 +872,8 @@
 	}
 
 	public boolean isEntityInsideOpaqueBlock() {
+		if (this.noClip) return false;
+
 		for(int var1 = 0; var1 < 8; ++var1) {
 			float var2 = ((float)((var1 >> 0) % 2) - 0.5F) * this.width * 0.9F;
 			float var3 = ((float)((var1 >> 1) % 2) - 0.5F) * 0.1F;
@@ -1047,6 +1056,10 @@
 		return this.getEntityFlag(1);
 	}
 
+	public boolean isRunning() {
+		return false;
+	}
+
 	public void setSneaking(boolean var1) {
 		this.setEntityFlag(1, var1);
 	}
@@ -1058,9 +1071,9 @@
 	protected void setEntityFlag(int var1, boolean var2) {
 		byte var3 = this.properties.getByte(0);
 		if(var2) {
-			this.properties.updateProperty(0, Byte.valueOf((byte)(var3 | 1 << var1)));
+			this.properties.updateProperty(0, (byte) (var3 | 1 << var1));
 		} else {
-			this.properties.updateProperty(0, Byte.valueOf((byte)(var3 & ~(1 << var1))));
+			this.properties.updateProperty(0, (byte) (var3 & ~(1 << var1)));
 		}
 
 	}
--- net/minecraft/client/controller/CreativePlayerController.java
+++ net/minecraft/client/controller/CreativePlayerController.java
@@ -2,12 +2,15 @@
 
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.Session;
+import net.minecraft.client.sound.SoundManager;
 import net.minecraft.game.entity.player.PlayerEntity;
 import net.minecraft.game.item.ItemStack;
 import net.minecraft.game.world.World;
 import net.minecraft.game.world.block.Block;
 
 public class CreativePlayerController extends PlayerController {
+	private int blockHitWait;
+
 	public CreativePlayerController(Minecraft var1) {
 		super(var1);
 		this.field_1064_b = true;
@@ -16,7 +19,7 @@
 	public void func_6473_b(PlayerEntity var1) {
 		for(int var2 = 0; var2 < 9; ++var2) {
 			if(var1.inventory.mainInventory[var2] == null) {
-				this.mc.thePlayer.inventory.mainInventory[var2] = new ItemStack((Block)Session.registeredBlocksList.get(var2));
+				this.mc.thePlayer.inventory.mainInventory[var2] = ItemStack.copyItemStack((ItemStack)Session.hotbarList[var2]);
 			} else {
 				this.mc.thePlayer.inventory.mainInventory[var2].count = 1;
 			}
@@ -24,6 +27,33 @@
 
 	}
 
+	public static void clickBlockCreative(Minecraft var0, PlayerController var1, int var2, int var3, int var4, int var5) {
+		if (!var0.theWorld.isAirBlock(var2, var3, var4)) {
+			var0.theWorld.onBlockHit(var0.thePlayer, var2, var3, var4, var5);
+			var1.sendBlockRemoved(var2, var3, var4, var5);
+		}
+	}
+
+	public boolean sendPlaceBlock(PlayerEntity var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7) {
+		int var8 = var2.getBlockId(var4, var5, var6);
+		if(var8 > 0 && !var1.isSneaking() && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1)) {
+			return true;
+		} else if(var3 == null) {
+			return false;
+		} else {
+			int var9 = var3.getItemDamage();
+			int var10 = var3.count;
+			boolean var11 = var3.useItem(var1, var2, var4, var5, var6, var7);
+			var3.setItemDamage(var9);
+			var3.count = var10;
+			return var11;
+		}
+	}
+
+	public void clickBlock(int var1, int var2, int var3, int var4) {
+		clickBlockCreative(this.mc, this, var1, var2, var3, var4);
+	}
+
 	public boolean shouldDrawHUD() {
 		return false;
 	}
@@ -32,6 +62,13 @@
 		super.func_717_a(var1);
 	}
 
+	public PlayerEntity createPlayer(World var1) {
+		PlayerEntity player = super.createPlayer(var1);
+		player.creative = true;
+		return player;
+	}
+
 	public void updateController() {
+		this.mc.sndManager.playRandomMusicIfReady(SoundManager.MusicType.CREATIVE);
 	}
 }
--- net/minecraft/client/render/entity/RenderLiving.java
+++ net/minecraft/client/render/entity/RenderLiving.java
@@ -1,6 +1,5 @@
 package net.minecraft.client.render.entity;
 
-import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.model.EntityModel;
 import net.minecraft.client.render.Tessellator;
@@ -169,10 +168,6 @@
 	}
 
 	protected void passSpecialRender(LivingEntity var1, double var2, double var4, double var6) {
-		if(Minecraft.isDebugInfoEnabled()) {
-			this.renderLivingLabel(var1, Integer.toString(var1.entityId), var2, var4, var6, 64);
-		}
-
 	}
 
 	protected void renderLivingLabel(LivingEntity var1, String var2, double var3, double var5, double var7, int var9) {
--- net/minecraft/game/entity/animal/ChickenEntity.java
+++ net/minecraft/game/entity/animal/ChickenEntity.java
@@ -75,7 +75,4 @@
 		return "mob.chickenhurt";
 	}
 
-	protected int getDropItemId() {
-		return Item.feather.itemID;
-	}
 }
--- /dev/null
+++ net/minecraft/game/world/biome/layers/LayerLand.java
@@ -1,0 +1,51 @@
+package net.minecraft.game.world.biome.layers;
+
+import net.minecraft.game.world.terrain.noise.PerlinNoiseOctaves;
+import net.minecraft.util.IntArray2D;
+import net.minecraft.util.MathHelper;
+
+import java.util.Random;
+
+public class LayerLand extends Layer {
+	public static final int OCEAN_QUALITY = 10000;
+
+	private PerlinNoiseOctaves landNoise;
+	private PerlinNoiseOctaves borderNoise;
+	private final double landScale = 0.05D;
+	private final double landBoost = 0.5D;
+	private final double landMul = 2.5D;
+	private final double borderScale = 0.01D;
+	private final double borderThreshold = 10.0D;
+	private final double borderMul = 0.5D;
+
+	public LayerLand(long seed) {
+		super(seed);
+	}
+
+	public void setWorldSeed(long seed) {
+        super.setWorldSeed(seed);
+		Random noiseRandom = new Random(this.getWorldSeed());
+		this.landNoise = new PerlinNoiseOctaves(noiseRandom, 8);
+		this.borderNoise = new PerlinNoiseOctaves(noiseRandom, 8);
+	}
+
+	public IntArray2D getData(int x, int z, int width, int length) {
+		IntArray2D output = new IntArray2D(width, length);
+
+		for (int xx = 0; xx < width; xx++) {
+			for (int zz = 0; zz < length; zz++) {
+				double land = (this.landNoise.generateNoiseNormalized2D((xx + x) * landScale, (zz + z) * landScale) + this.landBoost) * this.landMul;
+				double border = this.borderNoise.generateNoiseNormalized2D((xx + x) * borderScale, (zz + z) * borderScale) * this.borderMul;
+				border = MathHelper.clamp(1.0D - Math.abs(border) * this.borderThreshold, 0.0D, 1.0D);
+				land -= border;
+				output.set(xx, zz, (int)(MathHelper.clamp(land, -1.0D, 1.0D) * OCEAN_QUALITY));
+			}
+		}
+
+		return output;
+	}
+
+	public IntArray2D getCachedData(int x, int z, int width, int length) {
+		return this.getData(x, z, width, length);
+	}
+}
--- net/minecraft/server/player/PlayerHashEntry.java
+++ net/minecraft/server/player/PlayerHashEntry.java
@@ -26,8 +26,8 @@
 			return false;
 		} else {
 			PlayerHashEntry var2 = (PlayerHashEntry)var1;
-			Long var3 = Long.valueOf(this.func_736_a());
-			Long var4 = Long.valueOf(var2.func_736_a());
+			Long var3 = this.func_736_a();
+			Long var4 = var2.func_736_a();
 			if(var3 == var4 || var3 != null && var3.equals(var4)) {
 				Object var5 = this.func_735_b();
 				Object var6 = var2.func_735_b();
--- net/minecraft/game/world/map/MapStorage.java
+++ net/minecraft/game/world/map/MapStorage.java
@@ -125,7 +125,7 @@
 						ShortTag var6 = (ShortTag)var5;
 						String var7 = var6.getKey();
 						short var8 = var6.shortValue;
-						this.idCounts.put(var7, Short.valueOf(var8));
+						this.idCounts.put(var7, var8);
 					}
 				}
 			}
@@ -138,9 +138,9 @@
 	public int getUniqueDataId(String var1) {
 		Short var2 = (Short)this.idCounts.get(var1);
 		if(var2 == null) {
-			var2 = Short.valueOf((short)0);
+			var2 = (short) 0;
 		} else {
-			var2 = Short.valueOf((short)(var2.shortValue() + 1));
+			var2 = (short) (var2.shortValue() + 1);
 		}
 
 		this.idCounts.put(var1, var2);
--- /dev/null
+++ net/minecraft/game/item/ToolType.java
@@ -1,0 +1,10 @@
+package net.minecraft.game.item;
+
+public enum ToolType {
+	SWORD,
+	SHOVEL,
+	PICKAXE,
+	AXE,
+	HOE,
+	SHEARS
+}
