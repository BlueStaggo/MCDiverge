--- /dev/null
+++ net/minecraft/src/Facing.java
@@ -1,0 +1,8 @@
+package net.minecraft.src;
+
+public class Facing {
+    public static final int[] oppositeSide = new int[] {1, 0, 3, 2, 5, 4};
+    public static final int[] offsetsXForSide = new int[] {0, 0, 0, 0, -1, 1};
+    public static final int[] offsetsYForSide = new int[] { -1, 1, 0, 0, 0, 0};
+    public static final int[] offsetsZForSide = new int[] {0, 0, -1, 1, 0, 0};
+}
--- net/minecraft/src/ItemBlock.java
+++ net/minecraft/src/ItemBlock.java
@@ -5,13 +5,13 @@
 
 	public ItemBlock(int var1) {
 		super(var1);
-		this.blockID = var1 + 256;
-		this.setIconIndex(Block.blocksList[var1 + 256].getBlockTextureFromSide(2));
+		this.blockID = var1 + 10000;
+		this.setIconIndex(Block.blocksList[var1 + 10000].getBlockTextureFromSide(2));
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var3.getBlockId(var4, var5, var6) == Block.snow.blockID) {
-			var7 = 0;
+			var7 = 1;
 		} else {
 			if(var7 == 0) {
 				--var5;
@@ -43,8 +43,9 @@
 		} else {
 			if(var3.canBlockBePlacedAt(this.blockID, var4, var5, var6, false)) {
 				Block var8 = Block.blocksList[this.blockID];
-				if(var3.setBlockWithNotify(var4, var5, var6, this.blockID)) {
-					Block.blocksList[this.blockID].onBlockPlaced(var3, var4, var5, var6, var7);
+				int meta = var8.onBlockPlaced(var3, var4, var5, var6, var7, hitx, hity, hitz, var1.itemMetadata);
+				if(var3.setBlockAndMetadataWithNotify(var4, var5, var6, this.blockID, meta)) {
+					var8.onBlockPlacedBy(var3, var4, var5, var6, var2, var1);
 					var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var8.stepSound.getStepSound(), (var8.stepSound.getVolume() + 1.0F) / 2.0F, var8.stepSound.getPitch() * 0.8F);
 					--var1.stackSize;
 				}
@@ -52,5 +53,9 @@
 
 			return true;
 		}
+	}
+
+	public int getIconIndex(ItemStack var1) {
+		return Block.blocksList[blockID].getBlockTextureFromSideAndMetadata(2, var1.itemMetadata);
 	}
 }
--- net/minecraft/src/GuiIngameMenu.java
+++ net/minecraft/src/GuiIngameMenu.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import java.util.Random;
+
 public class GuiIngameMenu extends GuiScreen {
 	private int updateCounter2 = 0;
 	private int updateCounter = 0;
@@ -14,6 +16,7 @@
 
 		this.controlList.add(new GuiButton(4, this.width / 2 - 100, this.height / 4 + 24, "Back to game"));
 		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 96, "Options..."));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 120, "Achievements..."));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
@@ -26,15 +29,20 @@
 				this.mc.theWorld.sendQuittingDisconnectingPacket();
 			}
 
+			GuiScreen.setBgType(new Random().nextInt(3));
 			this.mc.changeWorld1((World)null);
 			this.mc.displayGuiScreen(new GuiMainMenu());
 		}
 
+
+		if(var1.id == 2) {
+			this.mc.displayGuiScreen(new GuiAchievements(this));
+		}
+
 		if(var1.id == 4) {
 			this.mc.displayGuiScreen((GuiScreen)null);
 			this.mc.setIngameFocus();
 		}
-
 	}
 
 	public void updateScreen() {
@@ -43,7 +51,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		boolean var4 = !this.mc.theWorld.saveWorld(this.updateCounter2++);
 		if(var4 || this.updateCounter < 20) {
 			float var5 = ((float)(this.updateCounter % 10) + var3) / 10.0F;
--- net/minecraft/src/ThreadConnectToServer.java
+++ net/minecraft/src/ThreadConnectToServer.java
@@ -3,14 +3,13 @@
 import java.net.ConnectException;
 import java.net.UnknownHostException;
 import net.minecraft.client.Minecraft;
-
-class ThreadConnectToServer extends Thread {
-	final Minecraft mc;
-	final String ip;
-	final int port;
-	final GuiConnecting connectingGui;
-
-	ThreadConnectToServer(GuiConnecting var1, Minecraft var2, String var3, int var4) {
+public class ThreadConnectToServer extends Thread {
+	public final Minecraft mc;
+	public final String ip;
+	public final int port;
+	public final GuiConnecting connectingGui;
+
+	public ThreadConnectToServer(GuiConnecting var1, Minecraft var2, String var3, int var4) {
 		this.connectingGui = var1;
 		this.mc = var2;
 		this.ip = var3;
--- net/minecraft/src/ChunkProviderServer.java
+++ net/minecraft/src/ChunkProviderServer.java
@@ -2,33 +2,26 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 
 public class ChunkProviderServer implements IChunkProvider {
 	private Set droppedChunksSet = new HashSet();
-	private Chunk chunk;
 	private IChunkProvider serverChunkProvider;
 	private IChunkLoader serverChunkLoader;
-	private Map id2ChunkMap = new HashMap();
+	private MCHashTableLong id2ChunkMap = new MCHashTableLong();
 	private List loadedChunks = new ArrayList();
 	private WorldServer worldObj;
 
 	public ChunkProviderServer(WorldServer var1, IChunkLoader var2, IChunkProvider var3) {
-		this.chunk = new Chunk(var1, new byte[-Short.MIN_VALUE], 0, 0);
-		this.chunk.isChunkRendered = true;
-		this.chunk.neverSave = true;
 		this.worldObj = var1;
 		this.serverChunkLoader = var2;
 		this.serverChunkProvider = var3;
 	}
 
 	public boolean chunkExists(int var1, int var2) {
-		ChunkCoordinates var3 = new ChunkCoordinates(var1, var2);
-		return this.id2ChunkMap.containsKey(var3);
+		return this.id2ChunkMap.lookup(ChunkCoordIntPair.chunkXZ2Int(var1, var2)) != null;
 	}
 
 	public void dropChunk(int var1, int var2) {
@@ -36,26 +29,26 @@
 		int var4 = var2 * 16 + 8 - this.worldObj.spawnZ;
 		byte var5 = 20;
 		if(var3 < -var5 || var3 > var5 || var4 < -var5 || var4 > var5) {
-			this.droppedChunksSet.add(new ChunkCoordinates(var1, var2));
+			this.droppedChunksSet.add(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
 		}
 
 	}
 
 	public Chunk loadChunk(int var1, int var2) {
-		ChunkCoordinates var3 = new ChunkCoordinates(var1, var2);
-		this.droppedChunksSet.remove(new ChunkCoordinates(var1, var2));
-		Chunk var4 = (Chunk)this.id2ChunkMap.get(var3);
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		this.droppedChunksSet.remove(var3);
+		Chunk var4 = (Chunk)this.id2ChunkMap.lookup(var3);
 		if(var4 == null) {
 			var4 = this.loadAndSaveChunk(var1, var2);
 			if(var4 == null) {
 				if(this.serverChunkProvider == null) {
-					var4 = this.chunk;
+					var4 = this.worldObj.blankChunk;
 				} else {
 					var4 = this.serverChunkProvider.provideChunk(var1, var2);
 				}
 			}
 
-			this.id2ChunkMap.put(var3, var4);
+			this.id2ChunkMap.addKey(var3, var4);
 			this.loadedChunks.add(var4);
 			if(var4 != null) {
 				var4.onChunkLoad();
@@ -76,15 +69,30 @@
 			if(this.chunkExists(var1 - 1, var2 - 1) && !this.provideChunk(var1 - 1, var2 - 1).isTerrainPopulated && this.chunkExists(var1 - 1, var2 - 1) && this.chunkExists(var1, var2 - 1) && this.chunkExists(var1 - 1, var2)) {
 				this.populate(this, var1 - 1, var2 - 1);
 			}
+
+			if(!var4.isUnderworldPopulated && this.chunkExists(var1 + 1, var2 + 1) && this.chunkExists(var1, var2 + 1) && this.chunkExists(var1 + 1, var2)) {
+				this.populateUnderworld(this, var1, var2);
+			}
+
+			if(this.chunkExists(var1 - 1, var2) && !this.provideChunk(var1 - 1, var2).isUnderworldPopulated && this.chunkExists(var1 - 1, var2 + 1) && this.chunkExists(var1, var2 + 1) && this.chunkExists(var1 - 1, var2)) {
+				this.populateUnderworld(this, var1 - 1, var2);
+			}
+
+			if(this.chunkExists(var1, var2 - 1) && !this.provideChunk(var1, var2 - 1).isUnderworldPopulated && this.chunkExists(var1 + 1, var2 - 1) && this.chunkExists(var1, var2 - 1) && this.chunkExists(var1 + 1, var2)) {
+				this.populateUnderworld(this, var1, var2 - 1);
+			}
+
+			if(this.chunkExists(var1 - 1, var2 - 1) && !this.provideChunk(var1 - 1, var2 - 1).isUnderworldPopulated && this.chunkExists(var1 - 1, var2 - 1) && this.chunkExists(var1, var2 - 1) && this.chunkExists(var1 - 1, var2)) {
+				this.populateUnderworld(this, var1 - 1, var2 - 1);
+			}
 		}
 
 		return var4;
 	}
 
 	public Chunk provideChunk(int var1, int var2) {
-		ChunkCoordinates var3 = new ChunkCoordinates(var1, var2);
-		Chunk var4 = (Chunk)this.id2ChunkMap.get(var3);
-		return var4 == null ? (this.worldObj.worldChunkLoadOverride ? this.loadChunk(var1, var2) : this.chunk) : var4;
+		Chunk var4 = (Chunk)this.id2ChunkMap.lookup(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
+		return var4 == null ? (this.worldObj.worldChunkLoadOverride ? this.loadChunk(var1, var2) : this.worldObj.blankChunk) : var4;
 	}
 
 	private Chunk loadAndSaveChunk(int var1, int var2) {
@@ -140,6 +148,26 @@
 
 	}
 
+	public void populateUnderworld(IChunkProvider var1, int var2, int var3) {
+		Chunk var4 = this.provideChunk(var2, var3);
+		if(!var4.isUnderworldPopulated) {
+			var4.isUnderworldPopulated = true;
+			if(this.serverChunkProvider != null) {
+				this.serverChunkProvider.populateUnderworld(var1, var2, var3);
+				var4.setChunkModified();
+			}
+		}
+
+	}
+
+	public void upgradeHeight(IChunkProvider var1, Chunk var2, World var3) {
+		if(this.serverChunkProvider != null) {
+			this.serverChunkProvider.upgradeHeight(var1, var2, var3);
+			var2.setChunkModified();
+		}
+
+	}
+
 	public boolean saveChunks(boolean var1, IProgressUpdate var2) {
 		int var3 = 0;
 
@@ -174,13 +202,13 @@
 		if(!this.worldObj.levelSaving) {
 			for(int var1 = 0; var1 < 16; ++var1) {
 				if(!this.droppedChunksSet.isEmpty()) {
-					ChunkCoordinates var2 = (ChunkCoordinates)this.droppedChunksSet.iterator().next();
-					Chunk var3 = this.provideChunk(var2.posX, var2.posZ);
+					long var2 = (long)this.droppedChunksSet.iterator().next();
+					Chunk var3 = (Chunk)this.id2ChunkMap.lookup(var2);
 					var3.onChunkUnload();
 					this.saveChunk(var3);
 					this.saveExtraChunkData(var3);
 					this.droppedChunksSet.remove(var2);
-					this.id2ChunkMap.remove(var2);
+					this.id2ChunkMap.removeEntry(var2);
 					this.loadedChunks.remove(var3);
 				}
 			}
--- net/minecraft/src/GuiSlider.java
+++ net/minecraft/src/GuiSlider.java
@@ -1,6 +1,7 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
+
 import org.lwjgl.opengl.GL11;
 
 public class GuiSlider extends GuiButton {
--- /dev/null
+++ net/minecraft/src/FurnaceRecipeManager.java
@@ -1,0 +1,60 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class FurnaceRecipeManager {
+	private static final FurnaceRecipeManager instance = new FurnaceRecipeManager();
+	private List<FurnaceRecipe> recipes = new ArrayList<>();
+
+	public static final FurnaceRecipeManager getInstance() {
+		return instance;
+	}
+
+	private FurnaceRecipeManager() {
+		addRecipe(Block.oreCoal.blockID, Item.coal.shiftedIndex, -1, 0);
+		addRecipe(Block.oreIron.blockID, Item.ingotIron.shiftedIndex, -1, 0);
+		addRecipe(Block.oreGold.blockID, Item.ingotGold.shiftedIndex, -1, 0);
+		addRecipe(Block.oreRedstone.blockID, Item.redstone.shiftedIndex, -1, 0);
+		addRecipe(Block.oreDiamond.blockID, Item.diamond.shiftedIndex, -1, 0);
+		addRecipe(Block.oreRuby.blockID, Item.ruby.shiftedIndex, -1, 0);
+		addRecipe(Block.oreSapphire.blockID, Item.sapphire.shiftedIndex, -1, 0);
+		addRecipe(Item.rawIron.shiftedIndex, Item.ingotIron.shiftedIndex, 0, 0);
+		addRecipe(Item.rawGold.shiftedIndex, Item.ingotGold.shiftedIndex, 0, 0);
+		addRecipe(Block.sand.blockID, Block.glass.blockID, 0, 0);
+		addRecipe(Item.porkRaw.shiftedIndex, Item.porkCooked.shiftedIndex, 0, 0);
+		addRecipe(Item.beefRaw.shiftedIndex, Item.beefCooked.shiftedIndex, 0, 0);
+		addRecipe(Item.chickenRaw.shiftedIndex, Item.chickenCooked.shiftedIndex, 0, 0);
+		addRecipe(Item.muttonRaw.shiftedIndex, Item.muttonCooked.shiftedIndex, 0, 0);
+		addRecipe(Block.cobblestone.blockID, Block.stone.blockID, -1, -1);
+		addRecipe(Item.clay.shiftedIndex, Item.brick.shiftedIndex, 0, 0);
+		addRecipe(Item.starChunk.shiftedIndex, Item.starDust.shiftedIndex, 0, 0);
+	}
+
+	private void addRecipe(int input, int output, int inputMeta, int outputMeta) {
+		recipes.add(new FurnaceRecipe(new ItemStack(input, 1, -1, inputMeta),
+									  new ItemStack(output, 1, -1, outputMeta)));
+	}
+
+	public ItemStack findMatchingRecipe(ItemStack input) {
+		for (FurnaceRecipe recipe : recipes) {
+			if (recipe.canSmelt(input)) {
+				return recipe.getOutput(input);
+			}
+		}
+		return null;
+	}
+
+	public int count() {
+		return this.recipes.size();
+	}
+
+	public ItemStack[] getRecipeAsItems(int i) {
+		ItemStack in = this.recipes.get(i).getInput().copy();
+		ItemStack out = this.recipes.get(i).getOutput(in).copy();
+
+		return new ItemStack[] { in, new ItemStack(Block.stoneOvenIdle),
+								 null, null, null, null, null, null, null,
+								 out };
+	}
+}
--- /dev/null
+++ net/minecraft/src/ChunkBuffer.java
@@ -1,0 +1,21 @@
+package net.minecraft.src;
+
+import java.io.ByteArrayOutputStream;
+
+/* lets chunk writing be multithreaded by not locking the whole file as a
+   chunk is serializing -- only writes when serialization is over */
+public class ChunkBuffer extends ByteArrayOutputStream {
+	private int x, z;
+	public final RegionFile regionFile;
+
+	public ChunkBuffer(RegionFile regionFile, int x, int z) {
+		super(8096); // initialize to 8KB
+		this.regionFile = regionFile;
+		this.x = x;
+		this.z = z;
+	}
+
+	public void close() {
+		regionFile.write(x, z, buf, count);
+	}
+}
--- net/minecraft/src/WorldBlockPositionType.java
+++ net/minecraft/src/WorldBlockPositionType.java
@@ -1,13 +1,13 @@
 package net.minecraft.src;
 
-class WorldBlockPositionType {
-	int posX;
-	int posY;
-	int posZ;
-	int acceptCountdown;
-	int blockID;
-	int metadata;
-	final WorldClient worldClient;
+public class WorldBlockPositionType {
+	public int posX;
+	public int posY;
+	public int posZ;
+	public int acceptCountdown;
+	public int blockID;
+	public int metadata;
+	public final WorldClient worldClient;
 
 	public WorldBlockPositionType(WorldClient var1, int var2, int var3, int var4, int var5, int var6) {
 		this.worldClient = var1;
--- net/minecraft/src/NetLoginHandler.java
+++ net/minecraft/src/NetLoginHandler.java
@@ -4,8 +4,8 @@
 import java.net.Socket;
 import java.util.Random;
 import java.util.logging.Logger;
+
 import net.minecraft.server.MinecraftServer;
-
 public class NetLoginHandler extends NetHandler {
 	public static Logger logger = Logger.getLogger("Minecraft");
 	private static Random rand = new Random();
@@ -55,7 +55,7 @@
 
 	public void handleLogin(Packet1Login var1) {
 		this.username = var1.username;
-		if(var1.protocolVersion != 2) {
+		if(var1.protocolVersion != NetHandler.PROTOCOL_VERSION) {
 			this.kickUser("Outdated client!");
 		} else {
 			if(!this.mcServer.onlineMode) {
@@ -72,13 +72,15 @@
 		if(var2 != null) {
 			logger.info(this.getUserAndIPString() + " logged in");
 			NetServerHandler var3 = new NetServerHandler(this.mcServer, this.netManager, var2);
-			var3.sendPacket(new Packet1Login("", "", 0));
+			var3.sendPacket(new Packet1Login("", "", var2.entityID));
 			var3.sendPacket(new Packet6SpawnPosition(this.mcServer.worldMngr.spawnX, this.mcServer.worldMngr.spawnY, this.mcServer.worldMngr.spawnZ));
+			var3.sendPacket(new Packet70WorldType(this.mcServer.worldMngr.getCreateWorldInfo()));
+			this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("Â§e" + var1.username + " joined the game."));
 			this.mcServer.configManager.playerLoggedIn(var2);
 			var3.teleportTo(var2.posX, var2.posY, var2.posZ, var2.rotationYaw, var2.rotationPitch);
-			var3.sendInventoryPackets();
 			this.mcServer.networkServer.addPlayer(var3);
 			var3.sendPacket(new Packet4UpdateTime(this.mcServer.worldMngr.worldTime));
+			var2.addCrafter();
 		}
 
 		this.finishedProcessing = true;
@@ -97,11 +99,11 @@
 		return this.username != null ? this.username + " [" + this.netManager.getRemoteAddress().toString() + "]" : this.netManager.getRemoteAddress().toString();
 	}
 
-	static String getServerId(NetLoginHandler var0) {
+	public static String getServerId(NetLoginHandler var0) {
 		return var0.serverId;
 	}
 
-	static Packet1Login setLoginPacket(NetLoginHandler var0, Packet1Login var1) {
+	public static Packet1Login setLoginPacket(NetLoginHandler var0, Packet1Login var1) {
 		return var0.packet1login = var1;
 	}
 }
--- net/minecraft/src/TextureCompassFX.java
+++ net/minecraft/src/TextureCompassFX.java
@@ -4,7 +4,6 @@
 import java.io.IOException;
 import javax.imageio.ImageIO;
 import net.minecraft.client.Minecraft;
-
 public class TextureCompassFX extends TextureFX {
 	protected float[] currentFireFrame = new float[320];
 	protected float[] lastFireFrame = new float[320];
@@ -20,8 +19,8 @@
 
 		try {
 			BufferedImage var2 = ImageIO.read(Minecraft.class.getResource("/gui/items.png"));
-			int var3 = this.iconIndex % 16 * 16;
-			int var4 = this.iconIndex / 16 * 16;
+			int var3 = this.iconIndex % 32 * 16;
+			int var4 = this.iconIndex / 32 * 16;
 			var2.getRGB(var3, var4, 16, 16, this.compassIconImageData, 0, 16);
 		} catch (IOException var5) {
 			var5.printStackTrace();
--- net/minecraft/src/TerrainTextureManager.java
+++ net/minecraft/src/TerrainTextureManager.java
@@ -5,37 +5,39 @@
 import java.util.Arrays;
 import javax.imageio.ImageIO;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 public class TerrainTextureManager {
-	private float[] texCols = new float[768];
+	private float[] texCols = new float[3072];
 	private int[] pixels = new int[5120];
 	private int[] zBuf = new int[5120];
 	private int[] waterBuf = new int[5120];
 	private int[] waterBr = new int[5120];
 	private int[] yBuf = new int[34];
-	private int[] textures = new int[768];
+	private int[] textures = new int[30000];
 
 	public TerrainTextureManager() {
 		try {
 			BufferedImage var1 = ImageIO.read(TerrainTextureManager.class.getResource("/terrain.png"));
-			int[] var2 = new int[65536];
-			var1.getRGB(0, 0, 256, 256, var2, 0, 256);
+			int[] var2 = new int[262144];
+			var1.getRGB(0, 0, 512, 512, var2, 0, 512);
 
-			for(int var3 = 0; var3 < 256; ++var3) {
+			for(int var3 = 0; var3 < 1024; ++var3) {
 				int var4 = 0;
 				int var5 = 0;
 				int var6 = 0;
-				int var7 = var3 % 16 * 16;
-				int var8 = var3 / 16 * 16;
+				int var7 = var3 % 32 * 16;
+				int var8 = var3 / 32 * 16;
 				int var9 = 0;
 
-				for(int var10 = 0; var10 < 16; ++var10) {
-					for(int var11 = 0; var11 < 16; ++var11) {
-						int var12 = var2[var11 + var7 + (var10 + var8) * 256];
-						int var13 = var12 >> 24 & 255;
+				for(int var10 = 0; var10 < 32; ++var10) {
+					for(int var11 = 0; var11 < 32; ++var11) {
+						int var12 = var2[var11 + var7 + (var10 + var8) * 512];
+						int var13 = var12 >> 24 & 511;
 						if(var13 > 128) {
-							var4 += var12 >> 16 & 255;
-							var5 += var12 >> 8 & 255;
-							var6 += var12 & 255;
+							var4 += var12 >> 16 & 511;
+							var5 += var12 >> 8 & 511;
+							var6 += var12 & 511;
 							++var9;
 						}
 					}
@@ -53,7 +55,7 @@
 			var14.printStackTrace();
 		}
 
-		for(int var15 = 0; var15 < 256; ++var15) {
+		for(int var15 = 0; var15 < 10000; ++var15) {
 			if(Block.blocksList[var15] != null) {
 				this.textures[var15 * 3 + 0] = Block.blocksList[var15].getBlockTextureFromSide(1);
 				this.textures[var15 * 3 + 1] = Block.blocksList[var15].getBlockTextureFromSide(2);
@@ -90,7 +92,7 @@
 						int var12 = var10 + var11;
 						boolean var13 = true;
 
-						for(int var14 = 0; var14 < 128; ++var14) {
+						for(int var14 = 0; var14 < CHUNK_HEIGHT; ++var14) {
 							int var15 = var11 - var10 - var14 + 160 - 16;
 							if(var15 < this.yBuf[var12] || var15 < this.yBuf[var12 + 1]) {
 								Block var16 = Block.blocksList[var2.getBlockId(var9, var14, var8)];
--- net/minecraft/src/RecipesFood.java
+++ net/minecraft/src/RecipesFood.java
@@ -1,8 +1,9 @@
 package net.minecraft.src;
 
 public class RecipesFood {
-	public void addRecipes(CraftingManager var1) {
-		var1.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.mushroomBrown, Character.valueOf('Y'), Block.mushroomRed, Character.valueOf('#'), Item.bowlEmpty});
-		var1.addRecipe(new ItemStack(Item.bowlSoup), new Object[]{"Y", "X", "#", Character.valueOf('X'), Block.mushroomRed, Character.valueOf('Y'), Block.mushroomBrown, Character.valueOf('#'), Item.bowlEmpty});
+	public void addRecipes(CraftingManager craftingManager) {
+		craftingManager.addRecipe(new ItemStack(Item.bowlSoup), "Y", "X", "#", 'X', Block.mushroomBrown, 'Y', Block.mushroomRed, '#', Item.bowlEmpty);
+		craftingManager.addRecipe(new ItemStack(Item.bowlSoup), "Y", "X", "#", 'X', Block.mushroomRed, 'Y', Block.mushroomBrown, '#', Item.bowlEmpty);
+		craftingManager.addRecipe(new ItemStack(Item.cookie), "X#X", 'X', Item.sugar, '#', Item.wheat);
 	}
 }
--- net/minecraft/src/BlockLeavesBase.java
+++ net/minecraft/src/BlockLeavesBase.java
@@ -3,7 +3,7 @@
 public class BlockLeavesBase extends Block {
 	protected boolean graphicsLevel;
 
-	protected BlockLeavesBase(int var1, int var2, Material var3, boolean var4) {
+	public BlockLeavesBase(int var1, int var2, Material var3, boolean var4) {
 		super(var1, var2, var3);
 		this.graphicsLevel = var4;
 	}
--- net/minecraft/src/RenderSnowball.java
+++ net/minecraft/src/RenderSnowball.java
@@ -9,13 +9,13 @@
 		GL11.glTranslatef((float)var2, (float)var4, (float)var6);
 		GL11.glEnable(GL12.GL_RESCALE_NORMAL);
 		GL11.glScalef(0.5F, 0.5F, 0.5F);
-		int var10 = Item.snowball.getIconIndex((ItemStack)null);
+		int var10 = var1.getType().iconIndex;
 		this.loadTexture("/gui/items.png");
 		Tessellator var11 = Tessellator.instance;
-		float var12 = (float)(var10 % 16 * 16 + 0) / 256.0F;
-		float var13 = (float)(var10 % 16 * 16 + 16) / 256.0F;
-		float var14 = (float)(var10 / 16 * 16 + 0) / 256.0F;
-		float var15 = (float)(var10 / 16 * 16 + 16) / 256.0F;
+		float var12 = (float)(var10 % 32 * 16 + 0) / 512.0F;
+		float var13 = (float)(var10 % 32 * 16 + 16) / 512.0F;
+		float var14 = (float)(var10 / 32 * 16 + 0) / 512.0F;
+		float var15 = (float)(var10 / 32 * 16 + 16) / 512.0F;
 		float var16 = 1.0F;
 		float var17 = 0.5F;
 		float var18 = 0.25F;
--- net/minecraft/src/NBTTagList.java
+++ net/minecraft/src/NBTTagList.java
@@ -5,12 +5,13 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.stream.Collectors;
 
 public class NBTTagList extends NBTBase {
 	private List tagList = new ArrayList();
 	private byte tagType;
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		if(this.tagList.size() > 0) {
 			this.tagType = ((NBTBase)this.tagList.get(0)).getType();
 		} else {
@@ -26,7 +27,7 @@
 
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.tagType = var1.readByte();
 		int var2 = var1.readInt();
 		this.tagList = new ArrayList();
@@ -58,5 +59,12 @@
 
 	public int tagCount() {
 		return this.tagList.size();
+	}
+
+	public NBTBase copy() {
+		List list = (List)this.tagList.stream().map(x -> ((NBTBase)x).copy()).collect(Collectors.toList());
+		NBTTagList tag = new NBTTagList();
+		tag.tagList = list;
+		return tag.setKey(this.getKey());
 	}
 }
--- net/minecraft/src/BlockOre.java
+++ net/minecraft/src/BlockOre.java
@@ -2,16 +2,39 @@
 
 import java.util.Random;
 
-public class BlockOre extends Block {
+public class BlockOre extends BlockStone {
+	private final int dropExtra;
+
 	public BlockOre(int var1, int var2) {
-		super(var1, var2, Material.rock);
-	}
-
-	public int idDropped(int var1, Random var2) {
-		return this.blockID == Block.oreCoal.blockID ? Item.coal.shiftedIndex : (this.blockID == Block.oreDiamond.blockID ? Item.diamond.shiftedIndex : this.blockID);
+		this(var1, var2, var1, 0);
+	}
+
+	public BlockOre(int var1, int var2, int var3) {
+		this(var1, var2, var3, 0);
+	}
+
+	public BlockOre(int var1, int var2, int var3, int var4) {
+		super(var1, var2, var3);
+		this.dropExtra = var4;
 	}
 
 	public int quantityDropped(Random var1) {
+		return var1.nextInt(this.dropExtra + 1) + 1;
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return this.drop == this.blockID ? var1 : 0;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
 		return 1;
+	}
+
+	public int metadataDroppedSilk(int var1, int var2, Random var3) {
+		return var1;
+	}
+
+	public int[] availableMetadata() {
+		return Block.stone.availableMetadata();
 	}
 }
--- /dev/null
+++ net/minecraft/src/WorldGenCrystals.java
@@ -1,0 +1,52 @@
+package net.minecraft.src;
+
+import java.util.Random;
+
+public class WorldGenCrystals extends WorldGenerator {
+	private final Block block;
+
+	public WorldGenCrystals(Block block) {
+		this.block = block;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int height = var2.nextInt(6) + 6;
+		int radius = var2.nextInt(3) + 2;
+		float radiusSquare = radius * radius;
+		boolean ceiling = var2.nextInt(2) == 0;
+
+		for (int x = -radius; x <= radius; x++) {
+			for (int z = -radius; z <= radius; z++) {
+				float distSquare = x * x + z * z;
+				float slope = 1 - distSquare / radiusSquare;
+
+				if (slope < 0) continue;
+				if (slope > 1) slope = 1;
+
+				slope *= slope;
+				int intSlope = (int) (slope * height);
+
+				int anchor = ceiling ? findCeiling(var1, var3, var4, var5) : findFloor(var1, var3, var4, var5);
+				int xx = x + var3;
+				int zz = z + var5;
+				for (int y = 0; y < intSlope; y++) {
+					int yy = ceiling ? anchor - y : y + anchor;
+					if (var1.isBlockNormalCube(xx, yy, zz)) break;
+					var1.setBlockAndMetadata(xx, yy, zz, this.block.blockID, 0);
+				}
+			}
+		}
+
+		return true;
+	}
+
+	private static int findFloor(World world, int x, int y, int z) {
+		while (!world.isBlockNormalCube(x, y - 1, z) && y > 1) y--;
+		return y;
+	}
+
+	private static int findCeiling(World world, int x, int y, int z) {
+		while (!world.isBlockNormalCube(x, y + 1, z) && y < Constants.CHUNK_HEIGHT - 1) y--;
+		return y;
+	}
+}
--- net/minecraft/src/GuiInventory.java
+++ net/minecraft/src/GuiInventory.java
@@ -4,41 +4,16 @@
 import org.lwjgl.opengl.GL12;
 
 public class GuiInventory extends GuiContainer {
-	private CraftingInventoryPlayerCB craftingInventory;
 	private float xSize_lo;
 	private float ySize_lo;
 
-	public GuiInventory(IInventory var1, ItemStack[] var2) {
+	public GuiInventory(EntityPlayer var1) {
+		super(var1.inventorySlots);
 		this.allowUserInput = true;
-		this.craftingInventory = new CraftingInventoryPlayerCB(var2);
-		this.inventorySlots.add(new SlotCrafting(this, this.craftingInventory.craftMatrix, this.craftingInventory.craftResult, 0, 144, 36));
-
-		int var3;
-		int var4;
-		for(var3 = 0; var3 < 2; ++var3) {
-			for(var4 = 0; var4 < 2; ++var4) {
-				this.inventorySlots.add(new SlotInventory(this, this.craftingInventory.craftMatrix, var4 + var3 * 2, 88 + var4 * 18, 26 + var3 * 18));
-			}
-		}
-
-		for(var3 = 0; var3 < 4; ++var3) {
-			this.inventorySlots.add(new SlotArmor(this, this, var1, var1.getSizeInventory() - 1 - var3, 8, 8 + var3 * 18, var3));
-		}
-
-		for(var3 = 0; var3 < 3; ++var3) {
-			for(var4 = 0; var4 < 9; ++var4) {
-				this.inventorySlots.add(new SlotInventory(this, var1, var4 + (var3 + 1) * 9, 8 + var4 * 18, 84 + var3 * 18));
-			}
-		}
-
-		for(var3 = 0; var3 < 9; ++var3) {
-			this.inventorySlots.add(new SlotInventory(this, var1, var3, 8 + var3 * 18, 142));
-		}
-
 	}
 
 	protected void drawGuiContainerForegroundLayer() {
-		this.fontRenderer.drawString("Crafting", 86, 16, 4210752);
+		this.fontRenderer.drawString("Crafting", 106, 7, this.mc.options.getTextColor());
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
@@ -48,7 +23,7 @@
 	}
 
 	protected void drawGuiContainerBackgroundLayer(float var1) {
-		int var2 = this.mc.renderEngine.getTexture("/gui/inventory.png");
+		int var2 = this.mc.renderEngine.getTexture("@@/gui/inventory.png");
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		this.mc.renderEngine.bindTexture(var2);
 		int var3 = (this.width - this.xSize) / 2;
--- /dev/null
+++ net/minecraft/src/VanityModels.java
@@ -1,0 +1,44 @@
+package net.minecraft.src;
+
+public class VanityModels {
+	public static final ModelBiped[] models = new ModelBiped[55535];
+	public static final ModelBase[] modelOverrides = new ModelBase[55535];
+
+	private VanityModels() {
+	}
+
+	public static ModelBiped getModel(ItemVanity item) {
+		return models[item.shiftedIndex - 10000];
+	}
+
+	public static ModelBase getModelOverride(ItemVanity item) {
+		return modelOverrides[item.shiftedIndex - 10000];
+	}
+
+	public static void refresh() {
+		models[115] = new ModelFluffy(0.0F).earsOnly();
+		models[116] = new ModelFluffy(0.0F).snoutOnly();
+		models[117] = new ModelFluffy(0.0F).tailOnly();
+		models[118] = new ModelTopHat(0.01F);
+		models[122] = new ModelBiped(0.01F);
+		models[123] = new ModelBaseballCap(0.01F);
+		models[132] = new ModelFrogHat(0.01F);
+		models[138] = new ModelBiped(0.01F);
+		models[139] = new ModelBiped(0.01F);
+		models[140] = new ModelBiped(0.25F);
+		models[141] = new ModelBiped(0.005F);
+		models[142] = new ModelFluffy(0.0F).snoutOnly().longSnout(0.0F);
+		models[143] = new ModelBiped(1.0F);
+		models[144] = new ModelBiped(1.0F);
+		models[145] = new ModelBiped(0.5F);
+		models[146] = new ModelBiped(1.0F);
+		models[147] = new ModelBiped(0.5F);
+
+		modelOverrides[136] = new ModelCreeper();
+		modelOverrides[137] = new ModelSkeleton();
+	}
+
+	static {
+		refresh();
+	}
+}
--- /dev/null
+++ net/minecraft/src/WatchableObject.java
@@ -1,0 +1,39 @@
+package net.minecraft.src;
+
+public class WatchableObject {
+	private final int objectType;
+	private final int dataValueId;
+	private Object watchedObject;
+	private boolean isWatching;
+
+	public WatchableObject(int var1, int var2, Object var3) {
+		this.dataValueId = var2;
+		this.watchedObject = var3;
+		this.objectType = var1;
+		this.isWatching = true;
+	}
+
+	public int getDataValueId() {
+		return this.dataValueId;
+	}
+
+	public void setObject(Object var1) {
+		this.watchedObject = var1;
+	}
+
+	public Object getObject() {
+		return this.watchedObject;
+	}
+
+	public int getObjectType() {
+		return this.objectType;
+	}
+
+	public boolean getWatching() {
+		return this.isWatching;
+	}
+
+	public void setWatching(boolean var1) {
+		this.isWatching = var1;
+	}
+}
--- net/minecraft/src/WorldGenDungeons.java
+++ net/minecraft/src/WorldGenDungeons.java
@@ -3,47 +3,90 @@
 import java.util.Random;
 
 public class WorldGenDungeons extends WorldGenerator {
-	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
-		byte var6 = 3;
-		int var7 = var2.nextInt(2) + 2;
-		int var8 = var2.nextInt(2) + 2;
+	private static final int[] floorMaterials = {
+			Block.cobblestone.blockID,
+			Block.cobblestoneMossy.blockID,
+			Block.stoneBricks.blockID,
+			Block.polishedStone.blockID
+	};
+	private static final int[] wallMaterials = {
+			Block.cobblestone.blockID,
+			Block.stoneBricks.blockID
+	};
+	private boolean pickedCharm = false;
+	private boolean pickedVanity = false;
+
+	public boolean generate(World var1, Random var2, int spawnX, int spawnY, int spawnZ) {
+		this.pickedCharm = false;
+		this.pickedVanity = false;
+
+		// Variables
+		byte height = 3;
+		int width = var2.nextInt(4) + 2;
+		int depth = var2.nextInt(4) + 2;
 		int var9 = 0;
 
-		int var10;
-		int var11;
-		int var12;
-		for(var10 = var3 - var7 - 1; var10 <= var3 + var7 + 1; ++var10) {
-			for(var11 = var4 - 1; var11 <= var4 + var6 + 1; ++var11) {
-				for(var12 = var5 - var8 - 1; var12 <= var5 + var8 + 1; ++var12) {
-					Material var13 = var1.getBlockMaterial(var10, var11, var12);
-					if(var11 == var4 - 1 && !var13.isSolid()) {
-						return false;
-					}
-
-					if(var11 == var4 + var6 + 1 && !var13.isSolid()) {
-						return false;
-					}
-
-					if((var10 == var3 - var7 - 1 || var10 == var3 + var7 + 1 || var12 == var5 - var8 - 1 || var12 == var5 + var8 + 1) && var11 == var4 && var1.getBlockId(var10, var11, var12) == 0 && var1.getBlockId(var10, var11 + 1, var12) == 0) {
-						++var9;
+		int x;
+		int y;
+		int z;
+
+		int floor = floorMaterials[var2.nextInt(floorMaterials.length)];
+		int wall = wallMaterials[var2.nextInt(wallMaterials.length)];
+		int metadata = -1;
+
+		// Check for space
+		for(x = spawnX - width - 1; x <= spawnX + width + 1; ++x) {
+			for(y = spawnY - 1; y <= spawnY + height + 1; ++y) {
+				for(z = spawnZ - depth - 1; z <= spawnZ + depth + 1; ++z) {
+					Material var13 = var1.getBlockMaterial(x, y, z);
+					if(var13.getIsLiquid()) {
+						return false;
+					}
+
+					if(
+						(x == spawnX - width - 1
+						 || x == spawnX + width + 1
+						 || z == spawnZ - depth - 1
+						 || z == spawnZ + depth + 1)
+						&& y == spawnY && var1.getBlockId(x, y, z) == 0
+						&& var1.getBlockId(x, y + 1, z) == 0) {
+						++var9; // Suitable entrance found
+					}
+
+					if(var1.getBlockId(x, y, z) == Block.stone.blockID && metadata == -1) {
+						metadata = var1.getBlockMetadata(x, y, z);
 					}
 				}
 			}
+		}
+
+		if (metadata == -1) {
+			metadata = 0;
 		}
 
 		if(var9 >= 1 && var9 <= 5) {
-			for(var10 = var3 - var7 - 1; var10 <= var3 + var7 + 1; ++var10) {
-				for(var11 = var4 + var6; var11 >= var4 - 1; --var11) {
-					for(var12 = var5 - var8 - 1; var12 <= var5 + var8 + 1; ++var12) {
-						if(var10 != var3 - var7 - 1 && var11 != var4 - 1 && var12 != var5 - var8 - 1 && var10 != var3 + var7 + 1 && var11 != var4 + var6 + 1 && var12 != var5 + var8 + 1) {
-							var1.setBlockWithNotify(var10, var11, var12, 0);
-						} else if(var11 >= 0 && !var1.getBlockMaterial(var10, var11 - 1, var12).isSolid()) {
-							var1.setBlockWithNotify(var10, var11, var12, 0);
-						} else if(var1.getBlockMaterial(var10, var11, var12).isSolid()) {
-							if(var11 == var4 - 1 && var2.nextInt(4) != 0) {
-								var1.setBlockWithNotify(var10, var11, var12, Block.cobblestoneMossy.blockID);
+			// Walls + floor
+			for(x = spawnX - width - 1; x <= spawnX + width + 1; ++x) {
+				for(y = spawnY + height; y >= spawnY - 1; --y) {
+					for(z = spawnZ - depth - 1; z <= spawnZ + depth + 1; ++z) {
+						if(x != spawnX - width - 1
+						   && y != spawnY - 1
+						   && z != spawnZ - depth - 1
+						   && x != spawnX + width + 1
+						   && y != spawnY + height + 1
+						   && z != spawnZ + depth + 1) {
+							var1.setBlockWithNotify(x, y, z, 0);
+						} else if(y >= 0 && !var1.getBlockMaterial(x, y - 1, z).isSolid()) {
+							var1.setBlockWithNotify(x, y, z, 0);
+						} else if(var1.getBlockMaterial(x, y, z).isSolid()
+								  || y == spawnY + height + 1
+								  || y == spawnY - 1) {
+							if(y == spawnY - 1 || y == spawnY + height) {
+								var1.setBlockWithNotify(x, y, z, floor);
+								var1.setBlockMetadataWithNotify(x, y, z, metadata);
 							} else {
-								var1.setBlockWithNotify(var10, var11, var12, Block.cobblestone.blockID);
+								var1.setBlockWithNotify(x, y, z, wall);
+								var1.setBlockMetadataWithNotify(x, y, z, metadata);
 							}
 						}
 					}
@@ -51,41 +94,45 @@
 			}
 
 			label110:
-			for(var10 = 0; var10 < 2; ++var10) {
-				for(var11 = 0; var11 < 3; ++var11) {
-					var12 = var3 + var2.nextInt(var7 * 2 + 1) - var7;
-					int var14 = var5 + var2.nextInt(var8 * 2 + 1) - var8;
-					if(var1.getBlockId(var12, var4, var14) == 0) {
+			for(x = 0; x < 4; ++x) {
+				for(y = 0; y < 4; ++y) {
+					z = spawnX + var2.nextInt(width * 2 + 1) - width;
+					int var14 = spawnZ + var2.nextInt(depth * 2 + 1) - depth;
+					if(var1.getBlockId(z, spawnY, var14) == 0) {
 						int var15 = 0;
-						if(var1.getBlockMaterial(var12 - 1, var4, var14).isSolid()) {
-							++var15;
-						}
-
-						if(var1.getBlockMaterial(var12 + 1, var4, var14).isSolid()) {
-							++var15;
-						}
-
-						if(var1.getBlockMaterial(var12, var4, var14 - 1).isSolid()) {
-							++var15;
-						}
-
-						if(var1.getBlockMaterial(var12, var4, var14 + 1).isSolid()) {
+						if(var1.getBlockMaterial(z - 1, spawnY, var14).isSolid()) {
+							++var15;
+						}
+
+						if(var1.getBlockMaterial(z + 1, spawnY, var14).isSolid()) {
+							++var15;
+						}
+
+						if(var1.getBlockMaterial(z, spawnY, var14 - 1).isSolid()) {
+							++var15;
+						}
+
+						if(var1.getBlockMaterial(z, spawnY, var14 + 1).isSolid()) {
 							++var15;
 						}
 
 						if(var15 == 1) {
-							var1.setBlockWithNotify(var12, var4, var14, Block.chest.blockID);
-							TileEntityChest var16 = (TileEntityChest)var1.getBlockTileEntity(var12, var4, var14);
+							var1.setBlockWithNotify(z, spawnY, var14, Block.chest.blockID);
+							TileEntityChest tileEntityChest16 = (TileEntityChest)var1.getBlockTileEntity(z, spawnY, var14);
 							int var17 = 0;
 
 							while(true) {
-								if(var17 >= 8) {
+								if(var17 >= 16) {
 									continue label110;
 								}
 
 								ItemStack var18 = this.pickCheckLootItem(var2);
+								if(var18 == null) {
+									var18 = this.pickCheckLootItem(var2);
+								}
+
 								if(var18 != null) {
-									var16.setInventorySlotContents(var2.nextInt(var16.getSizeInventory()), var18);
+									tileEntityChest16.setInventorySlotItem(var2.nextInt(tileEntityChest16.getInventorySize()), var18);
 								}
 
 								++var17;
@@ -95,22 +142,84 @@
 				}
 			}
 
-			var1.setBlockWithNotify(var3, var4, var5, Block.mobSpawner.blockID);
-			TileEntityMobSpawner var19 = (TileEntityMobSpawner)var1.getBlockTileEntity(var3, var4, var5);
-			var19.mobID = this.pickMobSpawner(var2);
+			int spawners = var2.nextInt(2) + 1;
+			int spx;
+			int spz;
+			for (int spi = 0; spi < spawners; spi++) {
+				do {
+					spx = spawnX + var2.nextInt(width * 2 + 1) - width;
+					spz = spawnZ + var2.nextInt(depth * 2 + 1) - depth;
+				} while (var1.getBlockId(spx, spawnY, spz) == Block.chest.blockID);
+				var1.setBlockWithNotify(spx, spawnY, spz, Block.mobSpawner.blockID);
+				TileEntityMobSpawner tileEntityMobSpawner19 = (TileEntityMobSpawner)var1.getBlockTileEntity(spx, spawnY, spz);
+				tileEntityMobSpawner19.mobID = this.pickMobSpawner(var2);
+			}
 			return true;
 		} else {
 			return false;
 		}
 	}
 
+	private static final Item[] charms = {
+			Item.wardingRing,
+			Item.repairKit,
+			Item.slimeShoes
+	};
+
+	private static final ItemStack[] vanity = {
+			new ItemStack(Item.frogHat.shiftedIndex, 1, 0, 6),
+			new ItemStack(Item.topHat.shiftedIndex, 1, 0, 14),
+			new ItemStack(Item.cyberneticHeadgear.shiftedIndex, 1, 0, 0),
+			new ItemStack(Item.cloak.shiftedIndex, 1, 0, 8),
+	};
+
 	private ItemStack pickCheckLootItem(Random var1) {
-		int var2 = var1.nextInt(11);
-		return var2 == 0 ? new ItemStack(Item.saddle) : (var2 == 1 ? new ItemStack(Item.ingotIron, var1.nextInt(4) + 1) : (var2 == 2 ? new ItemStack(Item.bread) : (var2 == 3 ? new ItemStack(Item.wheat, var1.nextInt(4) + 1) : (var2 == 4 ? new ItemStack(Item.gunpowder, var1.nextInt(4) + 1) : (var2 == 5 ? new ItemStack(Item.silk, var1.nextInt(4) + 1) : (var2 == 6 ? new ItemStack(Item.bucketEmpty) : (var2 == 7 && var1.nextInt(100) == 0 ? new ItemStack(Item.appleGold) : (var2 == 8 && var1.nextInt(2) == 0 ? new ItemStack(Item.redstone, var1.nextInt(4) + 1) : (var2 == 9 && var1.nextInt(10) == 0 ? new ItemStack(Item.itemsList[Item.record13.shiftedIndex + var1.nextInt(2)]) : null)))))))));
+		int var2 = var1.nextInt(15);
+		switch (var2) {
+			case 0: return new ItemStack(Item.silk);
+			case 1: return new ItemStack(Item.ingotIron, var1.nextInt(3) + 1);
+			case 2: return new ItemStack(Item.bread);
+			case 3: return new ItemStack(Item.wheat, var1.nextInt(3) + 1);
+			case 4: return new ItemStack(Item.gunpowder, var1.nextInt(3) + 1);
+			case 5: return new ItemStack(Item.arrow, var1.nextInt(3) + 1);
+		}
+		if (var2 == 6 && var1.nextInt(5) == 0) {
+			return new ItemStack(Item.bucketEmpty);
+		}
+		if (var2 == 7 && var1.nextInt(100) == 0) {
+			return new ItemStack(Item.appleGold);
+		}
+		if (var2 == 8 && var1.nextInt(2) == 0) {
+			return new ItemStack(Item.redstone, var1.nextInt(3) + 1);
+		}
+		if (var2 == 9 && var1.nextInt(10) == 0) {
+			return new ItemStack(Item.itemsList[Item.record13.shiftedIndex + var1.nextInt(6)]);
+		}
+		if (var2 == 10 && var1.nextInt(10) == 0) {
+			return new ItemStack(Item.diamond, var1.nextInt(3) + 1);
+		}
+		if (var2 == 11 && var1.nextInt(10) == 0) {
+			return new ItemStack(Item.saddle);
+		}
+		if (var2 == 12 && !this.pickedCharm && var1.nextInt(10) == 0) {
+			this.pickedCharm = true;
+			return new ItemStack(charms[var1.nextInt(charms.length)]);
+		}
+		if (var2 == 13 && !this.pickedVanity && var1.nextInt(10) == 0) {
+			this.pickedVanity = true;
+			return vanity[var1.nextInt(vanity.length)].copy();
+		}
+		if (var2 == 14 && var1.nextInt(5) == 0) {
+			return new ItemStack(Block.sapling, var1.nextInt(3) + 1, var1.nextInt(4));
+		}
+		return null;
 	}
 
 	private String pickMobSpawner(Random var1) {
-		int var2 = var1.nextInt(4);
-		return var2 == 0 ? "Skeleton" : (var2 == 1 ? "Zombie" : (var2 == 2 ? "Zombie" : (var2 == 3 ? "Spider" : "")));
+		int var2 = var1.nextInt(5);
+		return var2 == 0 ? "Skeleton"
+				: (var2 == 1 || var2 == 2 ? "Zombie"
+				: (var2 == 3 ? "Spider"
+				: (var2 == 4 ? "Phantom" : "")));
 	}
 }
--- net/minecraft/src/GuiMainMenu.java
+++ net/minecraft/src/GuiMainMenu.java
@@ -1,46 +1,113 @@
 package net.minecraft.src;
 
 import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Random;
+
+import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.util.glu.GLU;
 
 public class GuiMainMenu extends GuiScreen {
 	private static final Random rand = new Random();
-	String[] logoBlockLayers = new String[]{" *   * * *   * *** *** *** *** *** ***", " ** ** * **  * *   *   * * * * *    * ", " * * * * * * * **  *   **  *** **   * ", " *   * * *  ** *   *   * * * * *    * ", " *   * * *   * *** *** * * * * *    * "};
+	private static final Pair[] titleBlocks = {
+			new Pair<>(Block.stone, 0),
+			new Pair<>(Block.stone, 2),
+			new Pair<>(Block.stone, 3),
+			new Pair<>(Block.cobblestone, 0),
+			new Pair<>(Block.cobblestone, 2),
+			new Pair<>(Block.cobblestone, 3),
+			new Pair<>(Block.wood, 0),
+			new Pair<>(Block.wood, 1),
+			new Pair<>(Block.wood, 2),
+			new Pair<>(Block.wood, 3),
+			new Pair<>(Block.planks, 0),
+			new Pair<>(Block.planks, 1),
+			new Pair<>(Block.planks, 2),
+			new Pair<>(Block.planks, 3),
+			new Pair<>(Block.cobblestoneMossy, 0),
+			new Pair<>(Block.cobblestoneMossy, 2),
+			new Pair<>(Block.cobblestoneMossy, 3),
+			new Pair<>(Block.dirt, 0),
+			new Pair<>(Block.gravel, 0),
+			new Pair<>(Block.blockClay, 0)
+	};
+	private static final Pair[] titleBlocksDiverge = {
+			new Pair<>(Block.stone, 4),
+			new Pair<>(Block.cobblestone, 4),
+			new Pair<>(Block.blockRuby, 0),
+			new Pair<>(Block.blockSapphire, 0),
+			new Pair<>(Block.blockDiamond, 0),
+			new Pair<>(Block.starLantern, 0),
+	};
+	private String[] logoBlockLayers = new String[]{" *   * * *   * *** *** *** *** *** ***",
+											        " ** ** * **  * *   *   * * * * *    * ",
+											        " * * * * * * * **  *   **  *** **   * ",
+											        " *   * * *  ** *   *   * * * * *    * ",
+											        " *   * * *   * *** *** * * * * *    * ",
+													"                                      ",
+													"      **  * *   * *** *** *** ***     ",
+													"      * * * *   * *   * * *   *       ",
+													"      * * *  * *  *** **  * * ***     ",
+													"      * * *  * *  *   * * * * *       ",
+													"      **  *   *   *** * * *** ***     "};
 	private LogoEffectRandomizer[][] logoEffects;
-	private float updateCounter = 0.0F;
 	private String splashString = "missingno";
+	private Block drawBlock;
+	private int drawMetadata;
+	private Block drawBlockDiverge;
+	private int drawMetadataDiverge;
 
 	public GuiMainMenu() {
+		if (rand.nextDouble() <= 0.0001D) {
+			logoBlockLayers = new String[]{" *   * * *   * *** *** *** *** *** ***",
+                                           " ** ** * **  * *   *   * * * * *    * ",
+                                           " * * * * * * * **  *   **  *** **   * ",
+                                           " *   * * *  ** *   *   * * * * *    * ",
+                                           " *   * * *   * *** *** * * * * *    * ",
+										   "                                      ",
+										   "      **  * *   * *** *** *** ***     ",
+										   "      * * * *   * *   *   * * *       ",
+										   "      * * *  * *  *** * * **  ***     ",
+										   "      * * *  * *  *   * * * * *       ",
+										   "      **  *   *   *** *** * * ***     "};
+		}
+
 		try {
 			ArrayList var1 = new ArrayList();
 			BufferedReader var2 = new BufferedReader(new InputStreamReader(GuiMainMenu.class.getResourceAsStream("/title/splashes.txt")));
 			String var3 = "";
 
-			while(true) {
-				var3 = var2.readLine();
-				if(var3 == null) {
-					this.splashString = (String)var1.get(rand.nextInt(var1.size()));
-					break;
-				}
-
+			while((var3 = var2.readLine()) != null) {
 				var3 = var3.trim();
 				if(var3.length() > 0) {
 					var1.add(var3);
 				}
 			}
+
+			this.splashString = (String)var1.get(rand.nextInt(var1.size()));
+			Pair<Block, Integer> drawBlock = (Pair<Block, Integer>)titleBlocks[rand.nextInt(titleBlocks.length)];
+//			this.drawBlock = drawBlock.var0;
+//			this.drawMetadata = drawBlock.var1;
+			this.drawBlock = Block.stone;
+			Pair<Block, Integer> drawBlockDiverge = (Pair<Block, Integer>)titleBlocksDiverge[rand.nextInt(titleBlocksDiverge.length)];
+//			this.drawBlockDiverge = drawBlockDiverge.var0;
+//			this.drawMetadataDiverge = drawBlockDiverge.var1;
+			this.drawBlockDiverge = Block.blockSapphire;
 		} catch (Exception var4) {
 		}
 
 	}
 
 	public void updateScreen() {
-		++this.updateCounter;
+		this.mc.sndManager.tickMusic();
+		this.mc.sndManager.playRandomTitleMusicIfReady();
+
 		if(this.logoEffects != null) {
 			for(int var1 = 0; var1 < this.logoEffects.length; ++var1) {
 				for(int var2 = 0; var2 < this.logoEffects[var1].length; ++var2) {
@@ -55,71 +122,99 @@
 	}
 
 	public void initGui() {
-		Calendar var1 = Calendar.getInstance();
-		var1.setTime(new Date());
-		if(var1.get(2) + 1 == 11 && var1.get(5) == 9) {
-			this.splashString = "Happy birthday, ez!";
-		} else if(var1.get(2) + 1 == 6 && var1.get(5) == 1) {
-			this.splashString = "Happy birthday, Notch!";
-		} else if(var1.get(2) + 1 == 12 && var1.get(5) == 24) {
-			this.splashString = "Merry X-mas!";
-		} else if(var1.get(2) + 1 == 1 && var1.get(5) == 1) {
-			this.splashString = "Happy new year!";
+		this.mc.sndManager.stopBackgroundMusic();
+
+		if(rand.nextInt(2) == 0) {
+			Calendar var1 = Calendar.getInstance();
+			var1.setTime(new Date());
+
+			if(var1.get(Calendar.MONTH) == Calendar.NOVEMBER && var1.get(Calendar.DATE) == 9) {
+				this.splashString = "Happy birthday, ez!";
+			} else if(var1.get(Calendar.MONTH) == Calendar.JUNE && var1.get(Calendar.DATE) == 1) {
+				this.splashString = "Happy birthday, Notch!";
+			} else if(var1.get(Calendar.MONTH) == Calendar.DECEMBER && (var1.get(Calendar.DATE) == 24 || var1.get(Calendar.DATE) == 25)) {
+				this.splashString = "Merry X-mas!";
+			} else if(var1.get(Calendar.MONTH) == Calendar.JANUARY && var1.get(Calendar.DATE) == 1) {
+				this.splashString = "Happy new year!";
+			} else if(var1.get(Calendar.MONTH) == Calendar.MAY && var1.get(Calendar.DATE) == 17) {
+				this.splashString = "Happy birthday, Minecraft!";
+			}
 		}
 
 		this.controlList.clear();
-		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 48, "Singleplayer"));
-		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 72, "Multiplayer"));
-		this.controlList.add(new GuiButton(3, this.width / 2 - 100, this.height / 4 + 96, "Play tutorial level"));
-		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 120 + 12, "Options..."));
-		((GuiButton)this.controlList.get(2)).enabled = false;
-		if(this.mc.session == null) {
+		this.controlList.add(new GuiButton(1, this.width / 2 - 100, this.height / 4 + 60, 200, 20, "Singleplayer"));
+		this.controlList.add(new GuiButton(2, this.width / 2 - 100, this.height / 4 + 84, 200, 20, "Multiplayer"));
+		this.controlList.add(new GuiButton(0, this.width / 2 - 100, this.height / 4 + 108, 98, 20, "Options"));
+		this.controlList.add(new GuiButton(3, this.width / 2 + 2, this.height / 4 + 108, 98, 20, "Achievements"));
+		if (this.mc.options.creativeDebug) {
+			this.controlList.add(new GuiButton(-1, 4, this.height - 24, 100, 20, "Biome map"));
+		}
+		if (this.mc.session == null) {
 			((GuiButton)this.controlList.get(1)).enabled = false;
 		}
-
 	}
 
 	protected void actionPerformed(GuiButton var1) {
-		if(var1.id == 0) {
-			this.mc.displayGuiScreen(new GuiOptions(this, this.mc.options));
-		}
-
-		if(var1.id == 1) {
-			this.mc.displayGuiScreen(new GuiSelectWorld(this));
-		}
-
-		if(var1.id == 2) {
-			this.mc.displayGuiScreen(new GuiMultiplayer(this));
-		}
-
+		switch (var1.id) {
+			case 0:
+				this.mc.displayGuiScreen(new GuiOptions(this, this.mc.options));
+				break;
+
+			case 1:
+				this.mc.displayGuiScreen(new GuiSelectWorldNew(this));
+				break;
+
+			case 2:
+				this.mc.displayGuiScreen(new GuiMultiplayer(this));
+				break;
+
+			case 3:
+				this.mc.displayGuiScreen(new GuiAchievements(this));
+				break;
+
+			case -1:
+				try {
+					Biome.generateBiomeMap();
+					Biome.generateWorldBiomeMap();
+					Biome.generateWorldTerrainMap();
+				} catch (IOException e) {
+					// Don't care
+				}
+				break;
+		}
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
+		this.drawString(this.fontRenderer, Minecraft.version, 2, 2,
+				Minecraft.developmentVersion ? 0xFFFF3F3F : 0xFFFFFFFF);
 		Tessellator var4 = Tessellator.instance;
 		this.drawLogo(var3);
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/logo.png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		var4.setColorOpaque_I(16777215);
+		super.drawScreen(var1, var2, var3);
 		GL11.glPushMatrix();
-		GL11.glTranslatef((float)(this.width / 2 + 90), 70.0F, 0.0F);
-		GL11.glRotatef(-20.0F, 0.0F, 0.0F, 1.0F);
-		float var5 = 1.8F - MathHelper.abs(MathHelper.sin((float)(System.currentTimeMillis() % 1000L) / 1000.0F * (float)Math.PI * 2.0F) * 0.1F);
-		var5 = var5 * 100.0F / (float)(this.fontRenderer.getStringWidth(this.splashString) + 32);
-		GL11.glScalef(var5, var5, var5);
+		GL11.glTranslatef((float)(this.width / 2 + 100), 100.0F, 0.0F);
+		float var5 = MathHelper.sin((float)(System.currentTimeMillis() % 1000L) / 1000.0F * (float)Math.PI * 2.0F);
+		float var6 = (1.5F - MathHelper.abs(var5) * 0.1F) * 100.0F / (float)(this.fontRenderer.getStringWidth(this.splashString) + 32);
+		float var7 = -15.0F;
+		GL11.glScalef(var6, var6, var6);
+		GL11.glRotatef(var7, 0.0F, 0.0F, 1.0F);
 		this.drawCenteredString(this.fontRenderer, this.splashString, 0, -8, 16776960);
 		GL11.glPopMatrix();
-		String var6 = "Copyright Mojang Specifications. Do not distribute.";
-		this.drawString(this.fontRenderer, var6, this.width - this.fontRenderer.getStringWidth(var6) - 2, this.height - 10, 16777215);
-		long var7 = Runtime.getRuntime().maxMemory();
+		long var7x = Runtime.getRuntime().maxMemory();
 		long var9 = Runtime.getRuntime().totalMemory();
 		long var11 = Runtime.getRuntime().freeMemory();
-		long var13 = var7 - var11;
-		var6 = "Free memory: " + var13 * 100L / var7 + "% of " + var7 / 1024L / 1024L + "MB";
-		this.drawString(this.fontRenderer, var6, this.width - this.fontRenderer.getStringWidth(var6) - 2, 2, 8421504);
-		var6 = "Allocated memory: " + var9 * 100L / var7 + "% (" + var9 / 1024L / 1024L + "MB)";
-		this.drawString(this.fontRenderer, var6, this.width - this.fontRenderer.getStringWidth(var6) - 2, 12, 8421504);
-		super.drawScreen(var1, var2, var3);
+		long var13 = var7x - var11;
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		String var6x = "Copyright Mojang Specifications. Do not distribute.";
+		this.fontRenderer.drawString(var6x, this.width - this.fontRenderer.getStringWidth(var6x) - 2, this.height - 10, 0x7FFFFFFF);
+		var6x = "Free memory: " + var13 * 100L / var7x + "% of " + var7x / 1024L / 1024L + "MB";
+		this.fontRenderer.drawString(var6x, this.width - this.fontRenderer.getStringWidth(var6x) - 2, 2, 0x7FFFFFFF);
+		var6x = "Allocated memory: " + var9 * 100L / var7x + "% (" + var9 / 1024L / 1024L + "MB)";
+		this.fontRenderer.drawString(var6x, this.width - this.fontRenderer.getStringWidth(var6x) - 2, 12, 0x7FFFFFFF);
+		GL11.glDisable(GL11.GL_BLEND);
 	}
 
 	private void drawLogo(float var1) {
@@ -137,9 +232,9 @@
 		GL11.glMatrixMode(GL11.GL_PROJECTION);
 		GL11.glPushMatrix();
 		GL11.glLoadIdentity();
-		ScaledResolution var14 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
+		ScaledResolution var14 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight, this.mc.options.guiScale);
 		var3 = 120 * var14.scaleFactor;
-		GLU.gluPerspective(70.0F, (float)this.mc.displayWidth / (float)var3, 0.05F, 100.0F);
+		GLU.gluPerspective(50.0F, (float)this.mc.displayWidth / (float)var3, 0.05F, 100.0F);
 		GL11.glViewport(0, this.mc.displayHeight - var3, this.mc.displayWidth, var3);
 		GL11.glMatrixMode(GL11.GL_MODELVIEW);
 		GL11.glPushMatrix();
@@ -150,7 +245,7 @@
 
 		for(int var4 = 0; var4 < 3; ++var4) {
 			GL11.glPushMatrix();
-			GL11.glTranslatef(0.4F, 0.6F, -12.0F);
+			GL11.glTranslatef(0.4F, -1.5F, -15.0F);
 			if(var4 == 0) {
 				GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
 				GL11.glTranslatef(0.0F, -0.4F, 0.0F);
@@ -184,12 +279,16 @@
 				for(int var7 = 0; var7 < this.logoBlockLayers[var6].length(); ++var7) {
 					char var8 = this.logoBlockLayers[var6].charAt(var7);
 					if(var8 != 32) {
+						boolean diverge = var6 > 5;
 						GL11.glPushMatrix();
+						if (diverge) {
+							GL11.glRotatef(-35.0F, 1.0F, 0.0F, 0.0F);
+							GL11.glTranslatef(0.0F, 0.5F, 0.0F);
+						}
 						LogoEffectRandomizer var9 = this.logoEffects[var7][var6];
 						float var10 = (float)(var9.prevHeight + (var9.height - var9.prevHeight) * (double)var1);
 						float var11 = 1.0F;
 						float var12 = 1.0F;
-						float var13 = 0.0F;
 						if(var4 == 0) {
 							var11 = var10 * 0.04F + 1.0F;
 							var12 = 1.0F / var11;
@@ -198,8 +297,7 @@
 
 						GL11.glTranslatef((float)var7, (float)var6, var10);
 						GL11.glScalef(var11, var11, var11);
-						GL11.glRotatef(var13, 0.0F, 1.0F, 0.0F);
-						var5.renderBlockAsItem(Block.stone, var12);
+						var5.renderBlockAsItem(diverge ? this.drawBlockDiverge : this.drawBlock, diverge ? this.drawMetadataDiverge : this.drawMetadata, var12);
 						GL11.glPopMatrix();
 					}
 				}
@@ -217,7 +315,7 @@
 		GL11.glEnable(GL11.GL_CULL_FACE);
 	}
 
-	static Random getRandom() {
+	public static Random getRandom() {
 		return rand;
 	}
 }
--- net/minecraft/src/ChunkCache.java
+++ net/minecraft/src/ChunkCache.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 public class ChunkCache implements IBlockAccess {
 	private int chunkX;
 	private int chunkZ;
@@ -25,7 +27,7 @@
 	public int getBlockId(int var1, int var2, int var3) {
 		if(var2 < 0) {
 			return 0;
-		} else if(var2 >= 128) {
+		} else if(var2 >= CHUNK_HEIGHT) {
 			return 0;
 		} else {
 			int var4 = (var1 >> 4) - this.chunkX;
@@ -41,7 +43,7 @@
 	}
 
 	public float getBrightness(int var1, int var2, int var3) {
-		return World.lightBrightnessTable[this.getLightValue(var1, var2, var3)];
+		return World.lightBrightnessTable[this.getSkyBlockTypeBrightness(var1, var2, var3)];
 	}
 
 	public int getLightValue(int var1, int var2, int var3) {
@@ -54,7 +56,8 @@
 			int var6;
 			if(var4) {
 				var5 = this.getBlockId(var1, var2, var3);
-				if(var5 == Block.stairSingle.blockID || var5 == Block.tilledField.blockID) {
+				Block b = Block.blocksList[var5];
+				if((b instanceof BlockStep && !((BlockStep) b).blockType) || var5 == Block.tilledField.blockID) {
 					var6 = this.getLightValueExt(var1, var2 + 1, var3, false);
 					int var7 = this.getLightValueExt(var1 + 1, var2, var3, false);
 					int var8 = this.getLightValueExt(var1 - 1, var2, var3, false);
@@ -82,7 +85,7 @@
 
 			if(var2 < 0) {
 				return 0;
-			} else if(var2 >= 128) {
+			} else if(var2 >= CHUNK_HEIGHT) {
 				var5 = 15 - this.worldObj.skylightSubtracted;
 				if(var5 < 0) {
 					var5 = 0;
@@ -99,10 +102,73 @@
 		}
 	}
 
+	public int getSkyBlockTypeBrightness(int var2, int var3, int var4) {
+		if(var3 < 0) {
+			var3 = 0;
+		}
+
+		if(var3 >= CHUNK_HEIGHT) {
+			var3 = CHUNK_HEIGHT - 1;
+		}
+
+		if(var2 >= -32000000 && var4 >= -32000000 && var2 < 32000000 && var4 <= 32000000) {
+			int var5;
+			int var6;
+			if(Block.canBlockGrass[this.getBlockId(var2, var3, var4)]) {
+				var5 = this.getSpecialBlockBrightness(var2, var3 + 1, var4);
+				var6 = this.getSpecialBlockBrightness(var2 + 1, var3, var4);
+				int var7 = this.getSpecialBlockBrightness(var2 - 1, var3, var4);
+				int var8 = this.getSpecialBlockBrightness(var2, var3, var4 + 1);
+				int var9 = this.getSpecialBlockBrightness(var2, var3, var4 - 1);
+				if(var6 > var5) {
+					var5 = var6;
+				}
+
+				if(var7 > var5) {
+					var5 = var7;
+				}
+
+				if(var8 > var5) {
+					var5 = var8;
+				}
+
+				if(var9 > var5) {
+					var5 = var9;
+				}
+
+				return var5;
+			} else {
+				var5 = (var2 >> 4) - this.chunkX;
+				var6 = (var4 >> 4) - this.chunkZ;
+				return this.chunkArray[var5][var6].getBlockLightValue(var2 & 15, var3, var4 & 15, this.worldObj.skylightSubtracted);
+			}
+		} else {
+			return 15 - this.worldObj.skylightSubtracted;
+		}
+	}
+
+	public int getSpecialBlockBrightness(int var2, int var3, int var4) {
+		if(var3 < 0) {
+			var3 = 0;
+		}
+
+		if(var3 >= CHUNK_HEIGHT) {
+			var3 = CHUNK_HEIGHT - 1;
+		}
+
+		if(var2 >= -32000000 && var4 >= -32000000 && var2 < 32000000 && var4 <= 32000000) {
+			int var5 = (var2 >> 4) - this.chunkX;
+			int var6 = (var4 >> 4) - this.chunkZ;
+			return this.chunkArray[var5][var6].getBlockLightValue(var2 & 15, var3, var4 & 15, this.worldObj.skylightSubtracted);
+		} else {
+			return 15 - this.worldObj.skylightSubtracted;
+		}
+	}
+
 	public int getBlockMetadata(int var1, int var2, int var3) {
 		if(var2 < 0) {
 			return 0;
-		} else if(var2 >= 128) {
+		} else if(var2 >= CHUNK_HEIGHT) {
 			return 0;
 		} else {
 			int var4 = (var1 >> 4) - this.chunkX;
--- net/minecraft/src/IWorldAccess.java
+++ net/minecraft/src/IWorldAccess.java
@@ -3,6 +3,8 @@
 public interface IWorldAccess {
 	void markBlockAndNeighborsNeedsUpdate(int var1, int var2, int var3);
 
+	void markBlockNeedsRenderUpdate(int var1, int var2, int var3);
+
 	void markBlockRangeNeedsUpdate(int var1, int var2, int var3, int var4, int var5, int var6);
 
 	void playSound(String var1, double var2, double var4, double var6, float var8, float var9);
@@ -15,7 +17,9 @@
 
 	void updateAllRenderers();
 
-	void playRecord(String var1, int var2, int var3, int var4);
+	void playRecord(String var1, int var2, int var3, int var4, String author);
 
 	void doNothingWithTileEntity(int var1, int var2, int var3, TileEntity var4);
+
+	void performAction(EntityPlayer var1, int var2, int var3, int var4, int var5, int var6);
 }
--- net/minecraft/src/GuiConnectFailed.java
+++ net/minecraft/src/GuiConnectFailed.java
@@ -28,7 +28,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.message, this.width / 2, this.height / 2 - 50, 16777215);
 		this.drawCenteredString(this.fontRenderer, this.description, this.width / 2, this.height / 2 - 10, 16777215);
 		super.drawScreen(var1, var2, var3);
--- net/minecraft/src/RenderManager.java
+++ net/minecraft/src/RenderManager.java
@@ -3,6 +3,7 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+
 import org.lwjgl.opengl.GL11;
 
 public class RenderManager {
@@ -24,34 +25,7 @@
 	public double viewerPosZ;
 
 	private RenderManager() {
-		this.entityRenderMap.put(EntitySpider.class, new RenderSpider());
-		this.entityRenderMap.put(EntityPig.class, new RenderPig(new ModelPig(), new ModelPig(0.5F), 0.7F));
-		this.entityRenderMap.put(EntitySheep.class, new RenderSheep(new ModelSheep(), new ModelSheepFur(), 0.7F));
-		this.entityRenderMap.put(EntityCow.class, new RenderCow(new ModelCow(), 0.7F));
-		this.entityRenderMap.put(EntityChicken.class, new RenderChicken(new ModelChicken(), 0.3F));
-		this.entityRenderMap.put(EntityCreeper.class, new RenderCreeper());
-		this.entityRenderMap.put(EntitySkeleton.class, new RenderLiving(new ModelSkeleton(), 0.5F));
-		this.entityRenderMap.put(EntityZombie.class, new RenderLiving(new ModelZombie(), 0.5F));
-		this.entityRenderMap.put(EntitySlime.class, new RenderSlime(new ModelSlime(16), new ModelSlime(0), 0.25F));
-		this.entityRenderMap.put(EntityPlayer.class, new RenderPlayer());
-		this.entityRenderMap.put(EntityGiantZombie.class, new RenderGiantZombie(new ModelZombie(), 0.5F, 6.0F));
-		this.entityRenderMap.put(EntityLiving.class, new RenderLiving(new ModelBiped(), 0.5F));
-		this.entityRenderMap.put(Entity.class, new RenderEntity());
-		this.entityRenderMap.put(EntityPainting.class, new RenderPainting());
-		this.entityRenderMap.put(EntityArrow.class, new RenderArrow());
-		this.entityRenderMap.put(EntitySnowball.class, new RenderSnowball());
-		this.entityRenderMap.put(EntityItem.class, new RenderItem());
-		this.entityRenderMap.put(EntityTNTPrimed.class, new RenderTNTPrimed());
-		this.entityRenderMap.put(EntityFallingSand.class, new RenderFallingSand());
-		this.entityRenderMap.put(EntityMinecart.class, new RenderMinecart());
-		this.entityRenderMap.put(EntityBoat.class, new RenderBoat());
-		Iterator var1 = this.entityRenderMap.values().iterator();
-
-		while(var1.hasNext()) {
-			Render var2 = (Render)var1.next();
-			var2.setRenderManager(this);
-		}
-
+		this.refresh();
 	}
 
 	public Render getEntityClassRenderObject(Class var1) {
@@ -113,5 +87,38 @@
 
 	public FontRenderer getFontRenderer() {
 		return this.fontRenderer;
+	}
+
+	public void refresh() {
+		this.entityRenderMap.clear();
+		this.entityRenderMap.put(EntitySpider.class, new RenderSpider());
+		this.entityRenderMap.put(EntityPig.class, new RenderPig(new ModelPig(), new ModelPig(0.5F), 0.7F));
+		this.entityRenderMap.put(EntitySheep.class, new RenderSheep(new ModelSheep(), new ModelSheepFur(), 0.7F));
+		this.entityRenderMap.put(EntityCow.class, new RenderCow(new ModelCow(), 0.7F));
+		this.entityRenderMap.put(EntityChicken.class, new RenderChicken(new ModelChicken(), 0.3F));
+		this.entityRenderMap.put(EntityFox.class, new RenderLiving(new ModelFox(), 0.4F));
+		this.entityRenderMap.put(EntityCreeper.class, new RenderCreeper());
+		this.entityRenderMap.put(EntitySkeleton.class, new RenderLiving(new ModelSkeleton(), 0.5F));
+		this.entityRenderMap.put(EntityZombie.class, new RenderLiving(new ModelZombie(), 0.5F));
+		this.entityRenderMap.put(EntitySlime.class, new RenderSlime(new ModelSlime(16), new ModelSlime(0), 0.25F));
+		this.entityRenderMap.put(EntityPhantom.class, new RenderPhantom(new ModelBiped(), 0.5F));
+		this.entityRenderMap.put(EntityPlayer.class, new RenderPlayer());
+		this.entityRenderMap.put(EntityGiantZombie.class, new RenderGiantZombie(new ModelZombie(), 0.5F, 6.0F));
+		this.entityRenderMap.put(EntityLiving.class, new RenderLiving(new ModelBiped(), 0.5F));
+		this.entityRenderMap.put(Entity.class, new RenderEntity());
+		this.entityRenderMap.put(EntityPainting.class, new RenderPainting());
+		this.entityRenderMap.put(EntityArrow.class, new RenderArrow());
+		this.entityRenderMap.put(EntitySnowball.class, new RenderSnowball());
+		this.entityRenderMap.put(EntityItem.class, new RenderItem());
+		this.entityRenderMap.put(EntityTNTPrimed.class, new RenderTNTPrimed());
+		this.entityRenderMap.put(EntityFallingSand.class, new RenderFallingSand());
+		this.entityRenderMap.put(EntityMinecart.class, new RenderMinecart());
+		this.entityRenderMap.put(EntityBoat.class, new RenderBoat());
+		Iterator var1 = this.entityRenderMap.values().iterator();
+
+		while(var1.hasNext()) {
+			Render var2 = (Render)var1.next();
+			var2.setRenderManager(this);
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/src/BlockWool.java
@@ -1,0 +1,24 @@
+package net.minecraft.src;
+
+import java.util.Random;
+import java.util.stream.IntStream;
+
+public class BlockWool extends Block {
+	public final EnumBitField<DyeColor> fieldColor = this.fields.addBitField("color", DyeColor.class, 8);
+
+	public BlockWool(int id, int tex, Material material) {
+		super(id, tex, material);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int side, int metadata) {
+		return this.blockIndexInTexture + (metadata % 4) + (metadata / 4 * 32);
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, DyeColor.values().length).toArray();
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var1;
+	}
+}
--- /dev/null
+++ net/minecraft/src/Packet103SetSlot.java
@@ -1,0 +1,56 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet103SetSlot extends Packet {
+	public int windowId;
+	public int itemSlot;
+	public ItemStack myItemStack;
+
+	public Packet103SetSlot() {
+	}
+
+	public Packet103SetSlot(int var1, int var2, ItemStack var3) {
+		this.windowId = var1;
+		this.itemSlot = var2;
+		this.myItemStack = var3 == null ? null : var3.copy();
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleSetSlot(this);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.windowId = var1.readByte();
+		this.itemSlot = var1.readShort();
+		short var2 = var1.readShort();
+		if (var2 >= 0) {
+			byte var3 = var1.readByte();
+			short var4 = var1.readShort();
+			byte var5 = var1.readByte();
+			this.myItemStack = new ItemStack(var2, var3, var4, var5 & 0xFF).withStorage(Packet.readNBT(var1));
+		} else {
+			this.myItemStack = null;
+		}
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeByte(this.windowId);
+		var1.writeShort(this.itemSlot);
+		if (this.myItemStack == null) {
+			var1.writeShort(-1);
+		} else {
+			var1.writeShort(this.myItemStack.itemID);
+			var1.writeByte(this.myItemStack.stackSize);
+			var1.writeShort(this.myItemStack.itemDmg);
+			var1.writeByte(this.myItemStack.itemMetadata);
+			Packet.writeNBT(this.myItemStack.storage, var1);
+		}
+	}
+
+	public int getPacketSize() {
+		return 10;
+	}
+}
--- net/minecraft/src/ScaledResolution.java
+++ net/minecraft/src/ScaledResolution.java
@@ -5,17 +5,21 @@
 	private int scaledHeight;
 	public int scaleFactor;
 
-	public ScaledResolution(int var1, int var2) {
+	public ScaledResolution(int var1, int var2, int var3) {
 		this.scaledWidth = var1;
 		this.scaledHeight = var2;
+		if (var3 <= 0)
+			var3 = 1000;
 
-		for(this.scaleFactor = 1; this.scaledWidth / (this.scaleFactor + 1) >= 320 && this.scaledHeight / (this.scaleFactor + 1) >= 240; ++this.scaleFactor) {
+		while(this.scaleFactor < var3 && this.scaledWidth / (this.scaleFactor + 1) >= 320 && this.scaledHeight / (this.scaleFactor + 1) >= 240) {
+			++this.scaleFactor;
 		}
 
+		if (this.scaleFactor < 1) this.scaleFactor = 1;
+
 		this.scaledWidth /= this.scaleFactor;
 		this.scaledHeight /= this.scaleFactor;
 	}
-
 	public int getScaledWidth() {
 		return this.scaledWidth;
 	}
--- net/minecraft/src/CanvasIsomPreview.java
+++ net/minecraft/src/CanvasIsomPreview.java
@@ -44,24 +44,24 @@
 	public File getWorkingDirectory(String var1) {
 		String var2 = System.getProperty("user.home", ".");
 		File var3;
-		switch(OSMapIsom.osValues[getPlatform().ordinal()]) {
-		case 1:
-		case 2:
-			var3 = new File(var2, '.' + var1 + '/');
-			break;
-		case 3:
-			String var4 = System.getenv("APPDATA");
-			if(var4 != null) {
-				var3 = new File(var4, "." + var1 + '/');
-			} else {
+		switch(getPlatform()) {
+			case linux:
+			case solaris:
 				var3 = new File(var2, '.' + var1 + '/');
-			}
-			break;
-		case 4:
-			var3 = new File(var2, "Library/Application Support/" + var1);
-			break;
-		default:
-			var3 = new File(var2, var1 + '/');
+				break;
+			case windows:
+				String var4 = System.getenv("APPDATA");
+				if(var4 != null) {
+					var3 = new File(var4, "." + var1 + '/');
+				} else {
+					var3 = new File(var2, '.' + var1 + '/');
+				}
+				break;
+			case macos:
+				var3 = new File(var2, "Library/Application Support/" + var1);
+				break;
+			default:
+				var3 = new File(var2, var1 + '/');
 		}
 
 		if(!var3.exists() && !var3.mkdirs()) {
@@ -372,7 +372,7 @@
 	public void keyTyped(KeyEvent var1) {
 	}
 
-	static boolean isRunning(CanvasIsomPreview var0) {
+	public static boolean isRunning(CanvasIsomPreview var0) {
 		return var0.running;
 	}
 }
--- /dev/null
+++ net/minecraft/src/BooleanHookRenderBlockOnInventory.java
@@ -1,0 +1,5 @@
+package net.minecraft.src;
+
+public interface BooleanHookRenderBlockOnInventory {
+	boolean call(BaseMod mod, Tessellator tesselator, Block block, int metadata, int type);
+}
--- /dev/null
+++ net/minecraft/src/ModelFox.java
@@ -1,0 +1,95 @@
+package net.minecraft.src;
+
+// Hippity hoppity ReIndev's code is now my property!
+// Seriously, I don't know how models work ._.
+
+public class ModelFox extends ModelBase {
+	public ModelRenderer foxHeadMain;
+	public ModelRenderer foxBody;
+	public ModelRenderer foxLeg1;
+	public ModelRenderer foxLeg2;
+	public ModelRenderer foxLeg3;
+	public ModelRenderer foxLeg4;
+	ModelRenderer foxRightEar;
+	ModelRenderer foxLeftEar;
+	ModelRenderer foxSnout;
+	ModelRenderer foxFloofyTail;
+
+	public ModelFox() {
+		float translation = 0.0F;
+		float unused = 14.5F + 17;
+		this.foxHeadMain = new ModelRenderer(0, 0);
+		this.foxHeadMain.addBox(-3.0F, -3.0F, -3.0F - 1, 8, 6, 6, translation);
+		this.foxBody = new ModelRenderer(40, 0);
+		this.foxBody.addBox(-4.0F, -7.125F, -3.0F, 6, 11, 6, translation);
+		this.foxLeg1 = new ModelRenderer(0, 18);
+		this.foxLeg1.addBox(-1.0F, 1.0F, -1.0F, 2, 6, 2, translation);
+		this.foxLeg2 = new ModelRenderer(0, 18);
+		this.foxLeg2.addBox(-1.0F, 1.0F, -1.0F, 2, 6, 2, translation);
+		this.foxLeg3 = new ModelRenderer(0, 18);
+		this.foxLeg3.addBox(-1.0F, 1.0F, -1.0F, 2, 6, 2, translation);
+		this.foxLeg4 = new ModelRenderer(0, 18);
+		this.foxLeg4.addBox(-1.0F, 1.0F, -1.0F, 2, 6, 2, translation);
+		this.foxFloofyTail = new ModelRenderer(46, 18);
+		this.foxFloofyTail.addBox(-2.0F, -2.0F, -5.0F, 4, 9, 5, translation);
+		this.foxRightEar = new ModelRenderer(16, 14);
+		this.foxRightEar.addBox(-2.5F, -4.875F, -1.0F - 1, 2, 2, 1, translation);
+		this.foxLeftEar = new ModelRenderer(23, 14);
+		this.foxLeftEar.addBox(2.5F, -4.875F, -1.0F - 1, 2, 2, 1, translation);
+		this.foxSnout = new ModelRenderer(0, 12);
+		this.foxSnout.addBox(-1.0F, 1.0F, -5.25F - 1, 4, 2, 3, translation);
+		this.foxSnout.setRotationPoint(-2.0F, unused, -6.5F);
+		this.foxHeadMain.setRotationPoint(-2.0F, unused, -6.5F);
+		this.foxRightEar.setRotationPoint(-2.0F, unused, -6.5F);
+		this.foxLeftEar.setRotationPoint(-2.0F, unused, -6.5F);
+	}
+
+	public void render(float var1, float var2, float var3, float var4, float var5, float translation) {
+		super.render(var1, var2, var3, var4, var5, translation);
+		this.setRotationAngles(var1, var2, var3, var4, var5, translation);
+		this.foxHeadMain.render(translation);
+		this.foxRightEar.render(translation);
+		this.foxLeftEar.render(translation);
+		this.foxSnout.render(translation);
+		this.foxBody.render(translation);
+		this.foxLeg1.render(translation);
+		this.foxLeg2.render(translation);
+		this.foxLeg3.render(translation);
+		this.foxLeg4.render(translation);
+		this.foxFloofyTail.render(translation);
+	}
+
+	public void setRotationAngles(float var1, float var2, float xAngle, float yAngle, float zAngle, float var6) {
+		super.setRotationAngles(var1, var2, xAngle, yAngle, zAngle, var6);
+
+		this.foxHeadMain.rotateAngleX = zAngle / (180.0F / (float)Math.PI);
+		this.foxRightEar.rotateAngleY = this.foxHeadMain.rotateAngleY = yAngle / (180.0F / (float)Math.PI);
+		this.foxRightEar.rotateAngleX = this.foxHeadMain.rotateAngleX;
+		this.foxLeftEar.rotateAngleY = this.foxHeadMain.rotateAngleY;
+		this.foxLeftEar.rotateAngleX = this.foxHeadMain.rotateAngleX;
+		this.foxSnout.rotateAngleY = this.foxHeadMain.rotateAngleY;
+		this.foxSnout.rotateAngleX = this.foxHeadMain.rotateAngleX;
+		this.foxFloofyTail.rotateAngleX = 1.5F;
+
+		this.foxSnout.setRotationPoint(-2.0F, 17.0F, -6.5F);
+		this.foxHeadMain.setRotationPoint(-2.0F, 17.0F, -6.5F);
+		this.foxRightEar.setRotationPoint(-2.0F, 17.0F, -6.5F);
+		this.foxLeftEar.setRotationPoint(-2.0F, 17.0F, -6.5F);
+		this.foxBody.setRotationPoint(0.0F, 16.0F, 2.0F);
+		this.foxBody.rotateAngleX = 1.5707964F;
+		this.foxBody.rotateAngleY = 0.0F;
+		this.foxFloofyTail.setRotationPoint(-1.0F, 14.0F, 8.0F);
+		this.foxLeg1.setRotationPoint(-2.5F, 17.0F, 5.0F);
+		this.foxLeg2.setRotationPoint(0.5F, 17.0F, 5.0F);
+		this.foxLeg3.setRotationPoint(-2.5F, 17.0F, -4.0F);
+		this.foxLeg4.setRotationPoint(0.5F, 17.0F, -4.0F);
+		this.foxLeg1.rotateAngleY = 0.0F;
+		this.foxLeg2.rotateAngleY = 0.0F;
+		this.foxLeg3.rotateAngleY = 0.0F;
+		this.foxLeg4.rotateAngleY = 0.0F;
+		this.foxLeg1.rotateAngleX = MathHelper.cos(var1 * 0.6662F) * 1.4F * var2;
+		this.foxLeg2.rotateAngleX = MathHelper.cos(var1 * 0.6662F + (float)Math.PI) * 1.4F * var2;
+		this.foxLeg3.rotateAngleX = MathHelper.cos(var1 * 0.6662F + (float)Math.PI) * 1.4F * var2;
+		this.foxLeg4.rotateAngleX = MathHelper.cos(var1 * 0.6662F) * 1.4F * var2;
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemWardingRing.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+public class ItemWardingRing extends ItemCharm {
+	public ItemWardingRing(int id) {
+		super(id);
+	}
+
+	public void updateCharm(EntityPlayer player, ItemStack stack) {
+		player.slowHealing = true;
+	}
+}
--- net/minecraft/src/MinecraftImpl.java
+++ net/minecraft/src/MinecraftImpl.java
@@ -5,9 +5,8 @@
 import java.awt.Frame;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.MinecraftApplet;
-
 public final class MinecraftImpl extends Minecraft {
-	final Frame mcFrame;
+	public final Frame mcFrame;
 
 	public MinecraftImpl(Component var1, Canvas var2, MinecraftApplet var3, int var4, int var5, boolean var6, Frame var7) {
 		super(var1, var2, var3, var4, var5, var6);
--- net/minecraft/src/BlockTorch.java
+++ net/minecraft/src/BlockTorch.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockTorch extends Block {
-	protected BlockTorch(int var1, int var2) {
+	public BlockTorch(int var1, int var2) {
 		super(var1, var2, Material.circuits);
 		this.setTickOnLoad(true);
 	}
@@ -25,32 +25,53 @@
 	}
 
 	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
-		return var1.isBlockNormalCube(var2 - 1, var3, var4) ? true : (var1.isBlockNormalCube(var2 + 1, var3, var4) ? true : (var1.isBlockNormalCube(var2, var3, var4 - 1) ? true : (var1.isBlockNormalCube(var2, var3, var4 + 1) ? true : var1.isBlockNormalCube(var2, var3 - 1, var4))));
+		return var1.isBlockNormalCube(var2 - 1, var3, var4)
+				|| var1.isBlockNormalCube(var2 + 1, var3, var4)
+				|| var1.isBlockNormalCube(var2, var3, var4 - 1)
+				|| var1.isBlockNormalCube(var2, var3, var4 + 1)
+				|| var1.isBlockNormalCube(var2, var3 - 1, var4);
 	}
 
-	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = var1.getBlockMetadata(var2, var3, var4);
-		if(var5 == 1 && var1.isBlockNormalCube(var2, var3 - 1, var4)) {
-			var6 = 5;
-		}
-
-		if(var5 == 2 && var1.isBlockNormalCube(var2, var3, var4 + 1)) {
-			var6 = 4;
-		}
-
-		if(var5 == 3 && var1.isBlockNormalCube(var2, var3, var4 - 1)) {
-			var6 = 3;
-		}
-
-		if(var5 == 4 && var1.isBlockNormalCube(var2 + 1, var3, var4)) {
-			var6 = 2;
-		}
-
-		if(var5 == 5 && var1.isBlockNormalCube(var2 - 1, var3, var4)) {
-			var6 = 1;
-		}
-
-		var1.setBlockMetadataWithNotify(var2, var3, var4, var6);
+	public int onBlockPlaced(World var1, int var2, int var3, int var4, int var5, float hitx, float hity, float hitz, int meta) {
+		if(var5 == 1) {
+			if (var1.isBlockNormalCube(var2, var3 - 1, var4)) {
+				meta = 5;
+			} else {
+				var5 = 2;
+			}
+		}
+
+		if(var5 == 2) {
+			if (var1.isBlockNormalCube(var2, var3, var4 + 1)) {
+				meta = 4;
+			} else {
+				var5 = 3;
+			}
+		}
+
+		if(var5 == 3) {
+			if (var1.isBlockNormalCube(var2, var3, var4 - 1)) {
+				meta = 3;
+			} else {
+				var5 = 4;
+			}
+		}
+
+		if(var5 == 4) {
+			if (var1.isBlockNormalCube(var2 + 1, var3, var4)) {
+				meta = 2;
+			} else {
+				var5 = 5;
+			}
+		}
+
+		if(var5 == 5) {
+			if (var1.isBlockNormalCube(var2 - 1, var3, var4)) {
+				meta = 1;
+			}
+		}
+
+		return meta;
 	}
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
@@ -62,18 +83,6 @@
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
-		if(var1.isBlockNormalCube(var2 - 1, var3, var4)) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 1);
-		} else if(var1.isBlockNormalCube(var2 + 1, var3, var4)) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 2);
-		} else if(var1.isBlockNormalCube(var2, var3, var4 - 1)) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 3);
-		} else if(var1.isBlockNormalCube(var2, var3, var4 + 1)) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 4);
-		} else if(var1.isBlockNormalCube(var2, var3 - 1, var4)) {
-			var1.setBlockMetadataWithNotify(var2, var3, var4, 5);
-		}
-
 		this.checkIfAttachedToBlock(var1, var2, var3, var4);
 	}
 
@@ -97,7 +106,7 @@
 				var7 = true;
 			}
 
-			if(!var1.isBlockNormalCube(var2, var3 - 1, var4) && var6 == 5) {
+			if(!var1.isBlockNormalCube(var2, var3 - 1, var4) && (var6 == 5 || var6 == 0)) {
 				var7 = true;
 			}
 
--- /dev/null
+++ net/minecraft/src/ItemEquipable.java
@@ -1,0 +1,16 @@
+package net.minecraft.src;
+
+public class ItemEquipable extends Item {
+	public final int armorType;
+
+	public ItemEquipable(int var1, int var2) {
+		this(var1, var2, 0);
+	}
+
+	public ItemEquipable(int var1, int var2, int var3) {
+		super(var1);
+		this.maxStackSize = 1;
+		this.armorType = var2;
+		this.maxDamage = var3;
+	}
+}
--- net/minecraft/src/GuiLogFormatter.java
+++ net/minecraft/src/GuiLogFormatter.java
@@ -6,10 +6,10 @@
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 
-class GuiLogFormatter extends Formatter {
-	final GuiLogOutputHandler handler;
+public class GuiLogFormatter extends Formatter {
+	public final GuiLogOutputHandler handler;
 
-	GuiLogFormatter(GuiLogOutputHandler var1) {
+	public GuiLogFormatter(GuiLogOutputHandler var1) {
 		this.handler = var1;
 	}
 
@@ -28,8 +28,6 @@
 			var2.append("[WARNING] ");
 		} else if(var3 == Level.SEVERE) {
 			var2.append("[SEVERE] ");
-		} else if(var3 == Level.SEVERE) {
-			var2.append("[" + var3.getLocalizedName() + "] ");
 		}
 
 		var2.append(var1.getMessage());
--- /dev/null
+++ net/minecraft/src/ProfilerResult.java
@@ -1,0 +1,25 @@
+package net.minecraft.src;
+
+public final class ProfilerResult implements Comparable {
+	public double sectionPercentage;
+	public double globalPercentage;
+	public String name;
+
+	public ProfilerResult(String var1, double var2, double var4) {
+		this.name = var1;
+		this.sectionPercentage = var2;
+		this.globalPercentage = var4;
+	}
+
+	public int compareProfilerResult(ProfilerResult var1) {
+		return var1.sectionPercentage < this.sectionPercentage ? -1 : (var1.sectionPercentage > this.sectionPercentage ? 1 : var1.name.compareTo(this.name));
+	}
+
+	public int getDisplayColor() {
+		return (this.name.hashCode() & 11184810) + 4473924;
+	}
+
+	public int compareTo(Object var1) {
+		return this.compareProfilerResult((ProfilerResult)var1);
+	}
+}
--- net/minecraft/src/MathHelper.java
+++ net/minecraft/src/MathHelper.java
@@ -1,7 +1,9 @@
 package net.minecraft.src;
 
 public class MathHelper {
+	public static final double SQRT_2 = Math.sqrt(2);
 	private static float[] SIN_TABLE = new float[65536];
+	private static final double LOG_2 = Math.log(2);
 
 	public static final float sin(float var0) {
 		return SIN_TABLE[(int)(var0 * 10430.378F) & '\uffff'];
@@ -29,6 +31,11 @@
 		return var0 < (double)var2 ? var2 - 1 : var2;
 	}
 
+	public static long floor_double_long(double var0) {
+		long var2 = (long)var0;
+		return var0 < (double)var2 ? var2 - 1L : var2;
+	}
+
 	public static float abs(float var0) {
 		return var0 >= 0.0F ? var0 : -var0;
 	}
@@ -47,6 +54,42 @@
 
 	public static int bucketInt(int var0, int var1) {
 		return var0 < 0 ? -((-var0 - 1) / var1) - 1 : var0 / var1;
+	}
+
+	public static float clamp(float x, float min, float max) {
+		return Math.min(Math.max(x, min), max);
+	}
+
+	public static double clamp(double x, double min, double max) {
+		return Math.min(Math.max(x, min), max);
+	}
+
+	public static float lerp(float a, float b, float t) {
+		return a + (b - a) * t;
+	}
+
+	public static double lerp(double a, double b, double t) {
+		return a + (b - a) * t;
+	}
+
+	public static float log2(float x) {
+		return (float)(Math.log(x) / LOG_2);
+	}
+
+	public static String formatFloat(float n) {
+		return String.valueOf(Math.floor(n * 100.0F) / 100.0F);
+	}
+
+	public static String formatDouble(double n) {
+		return String.valueOf(Math.floor(n * 100.0D) / 100.0D);
+	}
+
+	public static float floorMod(float x, float y) {
+		float mod = x % y;
+		if (mod < 0) {
+			mod += y;
+		}
+		return mod;
 	}
 
 	static {
--- net/minecraft/src/ItemPainting.java
+++ net/minecraft/src/ItemPainting.java
@@ -3,10 +3,9 @@
 public class ItemPainting extends Item {
 	public ItemPainting(int var1) {
 		super(var1);
-		this.maxDamage = 64;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var7 == 0) {
 			return false;
 		} else if(var7 == 1) {
@@ -27,7 +26,9 @@
 
 			EntityPainting var9 = new EntityPainting(var3, var4, var5, var6, var8);
 			if(var9.onValidSurface()) {
-				var3.spawnEntityInWorld(var9);
+				if (var3.canDoClientAction()) {
+					var3.spawnEntityInWorld(var9);
+				}
 				--var1.stackSize;
 			}
 
--- net/minecraft/src/RenderPlayer.java
+++ net/minecraft/src/RenderPlayer.java
@@ -1,34 +1,135 @@
 package net.minecraft.src;
 
+import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 
+import java.util.Arrays;
+import java.util.List;
+
 public class RenderPlayer extends RenderLiving {
+	private ModelBase mainModelOverride;
+	private String textureOverride;
 	private ModelBiped modelBipedMain = (ModelBiped)this.mainModel;
+	private ModelBiped modelStaggo = new ModelFluffy(0.0F);
 	private ModelBiped modelArmorChestplate = new ModelBiped(1.0F);
 	private ModelBiped modelArmor = new ModelBiped(0.5F);
-	private static final String[] armorFilenamePrefix = new String[]{"cloth", "chain", "iron", "diamond", "gold"};
+	private ModelBiped modelCharmUpper = new ModelBiped(1.1F);
+	private ModelBiped modelCharmLower = new ModelBiped(0.6F);
+	public static final List<String> armorFilenamePrefix = Arrays.asList("cloth", "chain", "iron", "diamond", "gold");
 
 	public RenderPlayer() {
 		super(new ModelBiped(0.0F), 0.5F);
 	}
 
+	// 00: Staggo
+	// 01: Helmet
+	// 02: Chestplate
+	// 03: Leggings
+	// 04: Boots
+	// 05: Vanity 1
+	// 06: Vanity 2
+	// 07: Vanity 3
+	// 08: Vanity 4
+	// 09: Charm 1 Lower
+	// 10: Charm 1 Upper
+	// 11: Charm 2 Lower
+	// 12: Charm 2 Upper
+	// 13: Charm 3 Lower
+	// 14: Charm 3 Upper
+	// 15: Total
+
 	protected boolean setArmorModel(EntityPlayer var1, int var2) {
-		ItemStack var3 = var1.inventory.armorItemInSlot(3 - var2);
-		if(var3 != null) {
-			Item var4 = var3.getItem();
-			if(var4 instanceof ItemArmor) {
-				ItemArmor var5 = (ItemArmor)var4;
-				this.loadTexture("/armor/" + armorFilenamePrefix[var5.renderIndex] + "_" + (var2 == 2 ? 2 : 1) + ".png");
-				ModelBiped var6 = var2 == 2 ? this.modelArmor : this.modelArmorChestplate;
-				var6.bipedHead.showModel = var2 == 0;
-				var6.bipedHeadwear.showModel = var2 == 0;
-				var6.bipedBody.showModel = var2 == 1 || var2 == 2;
-				var6.bipedRightArm.showModel = var2 == 1;
-				var6.bipedLeftArm.showModel = var2 == 1;
-				var6.bipedRightLeg.showModel = var2 == 2 || var2 == 3;
-				var6.bipedLeftLeg.showModel = var2 == 2 || var2 == 3;
-				this.setRenderPassModel(var6);
-				return true;
+		if (this.mainModelOverride != null && !(this.mainModelOverride instanceof ModelBiped)) return false;
+
+		if (var2 == 0) {
+			if (!var1.blueStaggo) return false;
+			this.loadTexture("/mob/staggo2.png");
+			this.modelStaggo.swingProgress = this.modelBipedMain.swingProgress;
+			this.modelStaggo.isSneak = this.modelBipedMain.isSneak;
+			this.modelStaggo.heldItemLeft = this.modelBipedMain.heldItemLeft;
+			this.modelStaggo.heldItemRight = this.modelBipedMain.heldItemRight;
+			this.modelStaggo.isRiding = this.modelBipedMain.isRiding;
+			this.setRenderPassModel(this.modelStaggo);
+			return true;
+		}
+
+		boolean charmUpper = var2 == 10 || var2 == 12 || var2 == 14;
+		if (charmUpper) {
+			var2 -= 1;
+		}
+
+		if (var2 > 8) {
+			ItemStack var3 = var1.inventory.armorItemInSlot(8 + (var2 - 9) / 2);
+			if (var3 != null) {
+				Item var4 = var3.getItem();
+				if(var4 instanceof ItemCharm && ((ItemCharm) var4).textureName != null) {
+					this.loadTexture("/charm/" + ((ItemCharm) var4).textureName + (charmUpper ? "_upper.png" : "_lower.png"));
+					ModelBiped modelCharm = charmUpper ? modelCharmUpper : modelCharmLower;
+					modelCharm.swingProgress = this.modelBipedMain.swingProgress;
+					modelCharm.isSneak = this.modelBipedMain.isSneak;
+					modelCharm.heldItemLeft = this.modelBipedMain.heldItemLeft;
+					modelCharm.heldItemRight = this.modelBipedMain.heldItemRight;
+	                modelCharm.isRiding = this.modelBipedMain.isRiding;
+					this.setRenderPassModel(modelCharm);
+					return true;
+				}
+			}
+		} else if (var2 > 4) {
+			ItemStack var3 = var1.inventory.armorItemInSlot(12 - var2);
+			if (var3 != null) {
+				Item var4 = var3.getItem();
+				if(var4 instanceof ItemVanity) {
+					ItemVanity var5 = (ItemVanity)var4;
+					var2 = var5.vanityType;
+					this.loadTexture("/vanity/" + (var5.dyable ? var5.texturePath + var3.itemMetadata : var5.texturePath) + ".png");
+					ModelBiped var6 = VanityModels.getModel(var5);
+					if (var6 == null) return false;
+					var6.swingProgress = this.modelBipedMain.swingProgress;
+					var6.isSneak = this.modelBipedMain.isSneak;
+					var6.heldItemLeft = this.modelBipedMain.heldItemLeft;
+					var6.heldItemRight = this.modelBipedMain.heldItemRight;
+                    var6.isRiding = this.modelBipedMain.isRiding;
+					var6.showHead(var2 == 0 || var2 == -1);
+					var6.showBody(var2 == 1 || var2 == 2 || var2 == -1);
+					var6.showRightArm(var2 == 1 || var2 == -1);
+					var6.showLeftArm(var2 == 1 || var2 == -1);
+					var6.showRightLeg(var2 == 2 || var2 == 3 || var2 == -1);
+					var6.showLeftLeg(var2 == 2 || var2 == 3 || var2 == -1);
+					this.setRenderPassModel(var6);
+					return true;
+				}
+			}
+		} else {
+			ItemStack var3 = var1.inventory.armorItemInSlot(4 - var2);
+			if(var3 != null) {
+				Item var4 = var3.getItem();
+				if(var4 instanceof ItemArmor) {
+					for (int i = 4; i < 8; i++) {
+						ItemStack vanity = var1.inventory.armorItemInSlot(i);
+						if (vanity != null && vanity.getItem() instanceof ItemVanity) {
+							ItemVanity item = (ItemVanity)vanity.getItem();
+							if (item.vanityType == (var2 - 1) && item.overrideArmor)
+								return false;
+						}
+					}
+
+					ItemArmor var5 = (ItemArmor)var4;
+					this.loadTexture("/armor/" + armorFilenamePrefix.get(var5.renderIndex) + "_" + (var2 == 3 ? 2 : 1) + ".png");
+					ModelBiped var6 = var2 == 3 ? this.modelArmor : this.modelArmorChestplate;
+					var6.swingProgress = this.modelBipedMain.swingProgress;
+					var6.isSneak = this.modelBipedMain.isSneak;
+					var6.heldItemLeft = this.modelBipedMain.heldItemLeft;
+					var6.heldItemRight = this.modelBipedMain.heldItemRight;
+                    var6.isRiding = this.modelBipedMain.isRiding;
+					var6.showHead(var2 == 1);
+					var6.showBody(var2 == 2 || var2 == 3);
+					var6.showRightArm(var2 == 2);
+					var6.showLeftArm(var2 == 2);
+					var6.showRightLeg(var2 == 3 || var2 == 4);
+					var6.showLeftLeg(var2 == 3 || var2 == 4);
+					this.setRenderPassModel(var6);
+					return true;
+				}
 			}
 		}
 
@@ -36,48 +137,74 @@
 	}
 
 	public void renderPlayer(EntityPlayer var1, double var2, double var4, double var6, float var8, float var9) {
+		this.mainModelOverride = null;
+		this.textureOverride = null;
+
+		for (int i = 4; i < 8; i++) {
+			ItemStack vanity = var1.inventory.armorItemInSlot(i);
+			if (vanity != null && vanity.getItem() instanceof ItemVanity) {
+				this.mainModelOverride = VanityModels.getModelOverride((ItemVanity)vanity.getItem());
+				this.textureOverride = ((ItemVanity)vanity.getItem()).texturePath;
+				if (this.mainModelOverride != null) {
+					break;
+				}
+			}
+		}
+
 		ItemStack var10 = var1.inventory.getCurrentItem();
+		String oldSkinUrl = var1.skinUrl;
+		String oldTexture = var1.getTexture();
+		if (this.mainModelOverride != null) {
+			this.mainModel = this.mainModelOverride;
+			var1.onMainModelOverride(this.textureOverride);
+		}
 		this.modelArmorChestplate.heldItemRight = this.modelArmor.heldItemRight = this.modelBipedMain.heldItemRight = var10 != null;
 		this.modelArmorChestplate.isSneak = this.modelArmor.isSneak = this.modelBipedMain.isSneak = var1.isSneaking();
 		super.doRenderLiving(var1, var2, var4 - (double)var1.yOffset, var6, var8, var9);
 		this.modelArmorChestplate.isSneak = this.modelArmor.isSneak = this.modelBipedMain.isSneak = false;
 		this.modelArmorChestplate.heldItemRight = this.modelArmor.heldItemRight = this.modelBipedMain.heldItemRight = false;
-		FontRenderer var11 = this.getFontRendererFromRenderManager();
-		float var12 = 1.6F;
-		float var13 = (float)(1.0D / 60.0D) * var12;
-		GL11.glPushMatrix();
-		GL11.glTranslatef((float)var2 + 0.0F, (float)var4 + 2.3F, (float)var6);
-		GL11.glNormal3f(0.0F, 1.0F, 0.0F);
-		GL11.glRotatef(-this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
-		GL11.glRotatef(this.renderManager.playerViewX, 1.0F, 0.0F, 0.0F);
-		float var14 = var1.getDistanceToEntity(this.renderManager.player);
-		var13 = (float)((double)var13 * (Math.sqrt((double)var14) / 2.0D));
-		GL11.glScalef(-var13, -var13, var13);
-		String var15 = var1.username;
-		GL11.glDisable(GL11.GL_LIGHTING);
-		GL11.glDepthMask(false);
-		GL11.glDisable(GL11.GL_DEPTH_TEST);
-		GL11.glEnable(GL11.GL_BLEND);
-		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
-		Tessellator var16 = Tessellator.instance;
-		GL11.glDisable(GL11.GL_TEXTURE_2D);
-		var16.startDrawingQuads();
-		int var17 = var11.getStringWidth(var15) / 2;
-		var16.setColorRGBA_F(0.0F, 0.0F, 0.0F, 0.25F);
-		var16.addVertex((double)(-var17 - 1), -1.0D, 0.0D);
-		var16.addVertex((double)(-var17 - 1), 8.0D, 0.0D);
-		var16.addVertex((double)(var17 + 1), 8.0D, 0.0D);
-		var16.addVertex((double)(var17 + 1), -1.0D, 0.0D);
-		var16.draw();
-		GL11.glEnable(GL11.GL_TEXTURE_2D);
-		var11.drawString(var15, -var11.getStringWidth(var15) / 2, 0, 553648127);
-		GL11.glEnable(GL11.GL_DEPTH_TEST);
-		GL11.glDepthMask(true);
-		var11.drawString(var15, -var11.getStringWidth(var15) / 2, 0, -1);
-		GL11.glEnable(GL11.GL_LIGHTING);
-		GL11.glDisable(GL11.GL_BLEND);
-		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-		GL11.glPopMatrix();
+		if (this.mainModelOverride != null) {
+			this.mainModel = this.modelBipedMain;
+			var1.onMainModelUnoverride(oldSkinUrl, oldTexture);
+		}
+		if (this.mainModelOverride == null && Minecraft.getInstance().showHud) {
+			FontRenderer var11 = this.getFontRendererFromRenderManager();
+			float var12 = 1.6F;
+			float var13 = (float)(1.0D / 60.0D) * var12;
+			GL11.glPushMatrix();
+			GL11.glTranslatef((float)var2 + 0.0F, (float)var4 + 2.3F, (float)var6);
+			GL11.glNormal3f(0.0F, 1.0F, 0.0F);
+			GL11.glRotatef(-this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
+			GL11.glRotatef(this.renderManager.playerViewX, 1.0F, 0.0F, 0.0F);
+			float var14 = var1.getDistanceToEntity(this.renderManager.player);
+			var13 = (float)((double)var13 * (Math.sqrt((double)var14) / 2.0D));
+			GL11.glScalef(-var13, -var13, var13);
+			String var15 = var1.username;
+			GL11.glDisable(GL11.GL_LIGHTING);
+			GL11.glDepthMask(false);
+			GL11.glDisable(GL11.GL_DEPTH_TEST);
+			GL11.glEnable(GL11.GL_BLEND);
+			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+			Tessellator var16 = Tessellator.instance;
+			GL11.glDisable(GL11.GL_TEXTURE_2D);
+			var16.startDrawingQuads();
+			int var17 = var11.getStringWidth(var15) / 2;
+			var16.setColorRGBA_F(0.0F, 0.0F, 0.0F, 0.25F);
+			var16.addVertex((double)(-var17 - 1), -1.0D, 0.0D);
+			var16.addVertex((double)(-var17 - 1), 8.0D, 0.0D);
+			var16.addVertex((double)(var17 + 1), 8.0D, 0.0D);
+			var16.addVertex((double)(var17 + 1), -1.0D, 0.0D);
+			var16.draw();
+			GL11.glEnable(GL11.GL_TEXTURE_2D);
+			var11.drawString(var15, -var11.getStringWidth(var15) / 2, 0, 553648127);
+			GL11.glEnable(GL11.GL_DEPTH_TEST);
+			GL11.glDepthMask(true);
+			var11.drawString(var15, -var11.getStringWidth(var15) / 2, 0, -1);
+			GL11.glEnable(GL11.GL_LIGHTING);
+			GL11.glDisable(GL11.GL_BLEND);
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			GL11.glPopMatrix();
+		}
 	}
 
 	protected void renderSpecials(EntityPlayer var1, float var2) {
@@ -87,7 +214,7 @@
 			this.modelBipedMain.bipedRightArm.renderWithRotation(1.0F / 16.0F);
 			GL11.glTranslatef(-(1.0F / 16.0F), 7.0F / 16.0F, 1.0F / 16.0F);
 			float var4;
-			if(var3.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var3.itemID].getRenderType())) {
+			if(var3.itemID < 10000 && RenderBlocks.renderItemIn3d(Block.blocksList[var3.itemID].getRenderType())) {
 				var4 = 0.5F;
 				GL11.glTranslatef(0.0F, 3.0F / 16.0F, -(5.0F / 16.0F));
 				var4 *= 12.0F / 16.0F;
@@ -120,10 +247,17 @@
 		GL11.glScalef(var3, var3, var3);
 	}
 
-	public void drawFirstPersonHand() {
+	public void drawFirstPersonHand(EntityPlayer var1) {
 		this.modelBipedMain.swingProgress = 0.0F;
 		this.modelBipedMain.setRotationAngles(0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F / 16.0F);
 		this.modelBipedMain.bipedRightArm.render(1.0F / 16.0F);
+		for (int i = 0; i < this.maxRenderPasses(); i++) {
+			if (this.setArmorModel(var1, i)) {
+				this.renderPassModel.swingProgress = 0.0F;
+				this.renderPassModel.setRotationAngles(0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F / 16.0F);
+				((ModelBiped)this.renderPassModel).bipedRightArm.render(1.0F / 16.0F);
+			}
+		}
 	}
 
 	protected void preRenderCallback(EntityLiving var1, float var2) {
@@ -144,5 +278,9 @@
 
 	public void doRender(Entity var1, double var2, double var4, double var6, float var8, float var9) {
 		this.renderPlayer((EntityPlayer)var1, var2, var4, var6, var8, var9);
+	}
+
+	protected float maxRenderPasses() {
+		return 15;
 	}
 }
--- net/minecraft/src/EntityCow.java
+++ net/minecraft/src/EntityCow.java
@@ -33,14 +33,14 @@
 		return 0.4F;
 	}
 
-	protected int getDropItemId() {
-		return Item.leather.shiftedIndex;
+	protected int[] getDropItems() {
+		return new int[] { Item.leather.shiftedIndex, Item.beefRaw.shiftedIndex };
 	}
 
 	public boolean interact(EntityPlayer var1) {
 		ItemStack var2 = var1.inventory.getCurrentItem();
 		if(var2 != null && var2.itemID == Item.bucketEmpty.shiftedIndex) {
-			var1.inventory.setInventorySlotContents(var1.inventory.currentItem, new ItemStack(Item.bucketMilk));
+			var1.inventory.setInventorySlotItem(var1.inventory.currentItem, new ItemStack(Item.bucketMilk));
 			return true;
 		} else {
 			return false;
--- /dev/null
+++ net/minecraft/src/ItemFuryTrinket.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+import java.util.stream.Stream;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+public class ItemFuryTrinket extends ItemTrinket {
+	public final float damageIncrease;
+
+	public ItemFuryTrinket(int var1, String var2, float var3) {
+		super(var1, var2);
+		this.damageIncrease = var3;
+	}
+
+	public int getColor() {
+		return 0xBB4444;
+	}
+
+	public boolean isApplicable(Item item) {
+		return item instanceof ItemSword;
+	}
+
+	public int modifyAttackDamage(int damage) {
+		return (int)(damage * this.damageIncrease);
+	}
+
+	public Object[] getTooltipInfo() {
+		return Stream.of(new Object[] {
+				"Increases sword damage by " + (int)(this.damageIncrease * 100.0F - 100.0F) + "%", DESCRIPTION_COL,
+		}, super.getTooltipInfo()).flatMap(Stream::of).toArray();
+	}
+}
--- net/minecraft/src/EntityCreeper.java
+++ net/minecraft/src/EntityCreeper.java
@@ -1,39 +1,90 @@
 package net.minecraft.src;
 
-public class EntityCreeper extends EntityMob {
-	int timeSinceIgnited;
-	int lastActiveTime;
-	int fuseDuration = 30;
-	int creeperState = -1;
+public class EntityCreeper extends EntityLeveledMob {
+	protected int timeSinceIgnited;
+	protected int lastActiveTime;
+	protected int ignitionTime = 30;
 
 	public EntityCreeper(World var1) {
-		super(var1);
-		this.texture = "/mob/creeper.png";
-	}
-
-	public void writeEntityToNBT(NBTTagCompound var1) {
-		super.writeEntityToNBT(var1);
-	}
-
-	public void readEntityFromNBT(NBTTagCompound var1) {
-		super.readEntityFromNBT(var1);
-	}
-
-	protected void updateEntityActionState() {
+		super(var1, "/mob/creeper");
+		this.dataWatcher.addObject(17, (byte)-1);
+	}
+
+	public void setLevel(int level) {
+		super.setLevel(level);
+		this.moveSpeed = 0.7F + level * 0.15F;
+		this.ignitionTime = 30 - level * 5;
+		this.heartsHalvesLife = 20 + level * 5;
+	}
+
+	protected void attackBlockedEntity(Entity var1, float var2) {
+		if(!this.worldObj.multiplayerWorld) {
+			if(this.timeSinceIgnited > 0) {
+				this.setCreeperState(-1);
+				--this.timeSinceIgnited;
+				if(this.timeSinceIgnited < 0) {
+					this.timeSinceIgnited = 0;
+				}
+			}
+
+		}
+	}
+
+	public void onUpdate() {
 		this.lastActiveTime = this.timeSinceIgnited;
-		if(this.timeSinceIgnited > 0 && this.creeperState < 0) {
+		if(this.worldObj.multiplayerWorld) {
+			int var1 = this.getCreeperState();
+			if(var1 > 0 && this.timeSinceIgnited == 0) {
+				this.worldObj.playSoundAtEntity(this, "random.fuse", 1.0F, 0.5F);
+			}
+
+			this.timeSinceIgnited += var1;
+			if(this.timeSinceIgnited < 0) {
+				this.timeSinceIgnited = 0;
+			}
+
+			if(this.timeSinceIgnited >= this.ignitionTime) {
+				this.timeSinceIgnited = this.ignitionTime;
+			}
+		}
+
+		super.onUpdate();
+		if(this.entityToAttack == null && this.timeSinceIgnited > 0) {
+			this.setCreeperState(-1);
 			--this.timeSinceIgnited;
-		}
-
-		if(this.creeperState >= 0) {
-			this.creeperState = 2;
-		}
-
-		super.updateEntityActionState();
-		if(this.creeperState != 1) {
-			this.creeperState = -1;
-		}
-
+			if(this.timeSinceIgnited < 0) {
+				this.timeSinceIgnited = 0;
+			}
+		}
+
+	}
+
+	protected void attackEntity(Entity var1, float var2) {
+		if(!this.worldObj.multiplayerWorld) {
+			int var3 = this.getCreeperState();
+			if(var3 <= 0 && var2 < 3.0F || var3 > 0 && var2 < 7.0F) {
+				if(this.timeSinceIgnited == 0) {
+					this.worldObj.playSoundAtEntity(this, "random.fuse", 1.0F, 0.5F);
+				}
+
+				this.setCreeperState(1);
+				++this.timeSinceIgnited;
+				if(this.timeSinceIgnited >= this.ignitionTime) {
+					this.worldObj.createExplosion(this, this.posX, this.posY, this.posZ, 3.0F + this.getLevel() * 2.0F);
+
+					this.setEntityDead();
+				}
+
+				this.hasAttacked = true;
+			} else {
+				this.setCreeperState(-1);
+				--this.timeSinceIgnited;
+				if(this.timeSinceIgnited < 0) {
+					this.timeSinceIgnited = 0;
+				}
+			}
+
+		}
 	}
 
 	protected String getHurtSound() {
@@ -44,37 +95,36 @@
 		return "mob.creeperdeath";
 	}
 
+	@Override
+	protected float getSoundPitch() {
+		return 1.0F + this.getLevel() * 0.5F;
+	}
+
 	public void onDeath(Entity var1) {
 		super.onDeath(var1);
 		if(var1 instanceof EntitySkeleton) {
-			this.dropItem(Item.record13.shiftedIndex + this.rand.nextInt(2), 1);
+			this.dropItem(Item.record13.shiftedIndex + this.rand.nextInt(6), 1);
 		}
 
-	}
-
-	protected void attackEntity(Entity var1, float var2) {
-		if(this.creeperState <= 0 && var2 < 3.0F || this.creeperState > 0 && var2 < 7.0F) {
-			if(this.timeSinceIgnited == 0) {
-				this.worldObj.playSoundAtEntity(this, "random.fuse", 1.0F, 0.5F);
-			}
-
-			this.creeperState = 1;
-			++this.timeSinceIgnited;
-			if(this.timeSinceIgnited == this.fuseDuration) {
-				this.worldObj.createExplosion(this, this.posX, this.posY, this.posZ, 3.0F);
-				this.setEntityDead();
-			}
-
-			this.hasAttacked = true;
+		if(this.rand.nextInt(250) == 0) {
+			this.dropItem(Item.creeperSpirit.shiftedIndex, 1);
 		}
 
 	}
 
 	public float getCreeperFlashTime(float var1) {
-		return ((float)this.lastActiveTime + (float)(this.timeSinceIgnited - this.lastActiveTime) * var1) / (float)(this.fuseDuration - 2);
+		return ((float)this.lastActiveTime + (float)(this.timeSinceIgnited - this.lastActiveTime) * var1) / (float)(ignitionTime - 2);
 	}
 
 	protected int getDropItemId() {
 		return Item.gunpowder.shiftedIndex;
+	}
+
+	private int getCreeperState() {
+		return this.dataWatcher.getWatchableObjectByte(17);
+	}
+
+	private void setCreeperState(int var1) {
+		this.dataWatcher.updateObject(17, Byte.valueOf((byte)var1));
 	}
 }
--- net/minecraft/src/EntityMob.java
+++ net/minecraft/src/EntityMob.java
@@ -27,7 +27,7 @@
 
 	protected Entity findPlayerToAttack() {
 		EntityPlayer var1 = this.worldObj.getClosestPlayerToEntity(this, 16.0D);
-		return var1 != null && this.canEntityBeSeen(var1) ? var1 : null;
+		return var1 != null && this.canEntityBeSeen(var1) && !var1.creative ? var1 : null;
 	}
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
--- net/minecraft/src/BlockFlower.java
+++ net/minecraft/src/BlockFlower.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockFlower extends Block {
-	protected BlockFlower(int var1, int var2) {
+	public BlockFlower(int var1, int var2) {
 		super(var1, Material.plants);
 		this.blockIndexInTexture = var2;
 		this.setTickOnLoad(true);
@@ -28,14 +28,6 @@
 		this.checkFlowerChange(var1, var2, var3, var4);
 	}
 
-	protected final void g(World var1, int var2, int var3, int var4) {
-		if(!this.canBlockStay(var1, var2, var3, var4)) {
-			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
-			var1.setBlockWithNotify(var2, var3, var4, 0);
-		}
-
-	}
-
 	protected final void checkFlowerChange(World var1, int var2, int var3, int var4) {
 		if(!this.canBlockStay(var1, var2, var3, var4)) {
 			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
@@ -45,7 +37,7 @@
 	}
 
 	public boolean canBlockStay(World var1, int var2, int var3, int var4) {
-		return (var1.getBlockLightValue(var2, var3, var4) >= 8 || var1.canBlockSeeTheSky(var2, var3, var4)) && this.canThisPlantGrowOnThisBlockID(var1.getBlockId(var2, var3 - 1, var4));
+		return this.canThisPlantGrowOnThisBlockID(var1.getBlockId(var2, var3 - 1, var4));
 	}
 
 	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
--- /dev/null
+++ net/minecraft/src/Packet104WindowItems.java
@@ -1,0 +1,65 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.List;
+
+public class Packet104WindowItems extends Packet {
+	public int windowId;
+	public ItemStack[] itemStack;
+
+	public Packet104WindowItems() {
+	}
+
+	public Packet104WindowItems(int var1, List var2) {
+		this.windowId = var1;
+		this.itemStack = new ItemStack[var2.size()];
+
+		for(int var3 = 0; var3 < this.itemStack.length; ++var3) {
+			ItemStack var4 = (ItemStack)var2.get(var3);
+			this.itemStack[var3] = var4 == null ? null : var4.copy();
+		}
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.windowId = var1.readByte();
+		short var2 = var1.readShort();
+		this.itemStack = new ItemStack[var2];
+
+		for(int var3 = 0; var3 < var2; ++var3) {
+			short var4 = var1.readShort();
+			if (var4 >= 0) {
+				byte var5 = var1.readByte();
+				short var6 = var1.readShort();
+				byte var7 = var1.readByte();
+				this.itemStack[var3] = new ItemStack(var4, var5, var6, var7 & 0xFF).withStorage(Packet.readNBT(var1));
+			}
+		}
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeByte(this.windowId);
+		var1.writeShort(this.itemStack.length);
+
+		for(int var2 = 0; var2 < this.itemStack.length; ++var2) {
+			if (this.itemStack[var2] == null) {
+				var1.writeShort(-1);
+			} else {
+				var1.writeShort((short)this.itemStack[var2].itemID);
+				var1.writeByte((byte)this.itemStack[var2].stackSize);
+				var1.writeShort((short)this.itemStack[var2].itemDmg);
+				var1.writeByte((byte)this.itemStack[var2].itemMetadata);
+				Packet.writeNBT(this.itemStack[var2].storage, var1);
+			}
+		}
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleWindowItems(this);
+	}
+
+	public int getPacketSize() {
+		return 3 + this.itemStack.length * 8;
+	}
+}
--- /dev/null
+++ net/minecraft/src/Achievement.java
@@ -1,0 +1,77 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class Achievement {
+	public static final Map<String, Achievement> map = new HashMap<>();
+	public static final List<Achievement> list = new ArrayList<>();
+
+	public static final Achievement CRAFTING_TIME = new Achievement("crafting_time",
+			"It's Crafting Time", "Craft a Crafting Table, the main utility for crafting.");
+	public static final Achievement OOH_SHINY = new Achievement("ooh_shiny",
+			"Ooh, Shiny!", "Obtain a diamond found underground.");
+	public static final Achievement OOH_EXTRA_SHINY = new Achievement("ooh_extra_shiny",
+			"Ooh! Extra Shiny!", "Mine delicate ruby or sapphire ore found deep in the overworld.");
+	public static final Achievement VAMPIRIC_DEMISE = new Achievement("vampiric_demise",
+			"Vampiric Demise", "Witness a Phantom perish in light.");
+	public static final Achievement WISH_GRANTED = new Achievement("wish_granted",
+			"Wish Granted", "Pick up a star chunk that has fallen out of the night sky.");
+	public static final Achievement ALAKAZAM = new Achievement("alakazam",
+			"Alakazam", "Obtain a magic staff.");
+	public static final Achievement CHARMING_UPGRADE = new Achievement("charming_upgrade",
+			"Charming Upgrade", "Equip your first charm.");
+	public static final Achievement REFABRICATING_TIME = new Achievement("refabricating_time",
+			"It's Refabricating Time", "Craft a Refabricator and harness its repairing ability.");
+	public static final Achievement MANTLE_DISRUPTION = new Achievement("mantle_disruption",
+			"Mantle Disruption", "Break the obsidian barrier separating the overworld from the Umbralands.");
+	public static final Achievement OOH_TOO_SHINY = new Achievement("ooh_too_shiny",
+			"OOH! TOO SHINY!", "Mine umbrashard crystals found in the Umbralands.");
+	public static final Achievement TRINKET_ME_THIS = new Achievement("trinket_me_this",
+			"Trinket Me This", "Apply a trinket to an item using a Refabricator");
+	public static final Achievement DRESS_TO_IMPRESS = new Achievement("dress_to_impress",
+			"Dress to Impress", "Equip any vanity item.");
+	public static final Achievement FURSUITER = new Achievement("fursuiter",
+			"Fursuiter", "Equip all of the fluffy vanity items crafted from fox fur.", 4);
+	public static final Achievement MEET_THE_STAGGO = new Achievement("secret_01",
+			"Meet the Staggo", "Play on a server with Staggo, the creator of Minecraft Diverge.")
+			.setCreativeUnlockable();
+
+	public final String id;
+	public final String title;
+	public final String description;
+	public final int maxProgress;
+	public final boolean secret;
+	public int progress = 0;
+	private boolean creativeUnlockable;
+
+	public Achievement(String id, String title, String description) {
+		this(id, title, description, 1);
+	}
+
+	public Achievement(String id, String title, String description, int maxProgress) {
+		list.add(this);
+		map.put(id, this);
+		this.id = id;
+		this.title = title;
+		this.description = description;
+		this.maxProgress = maxProgress;
+		this.secret = this.id.startsWith("secret");
+		this.creativeUnlockable = false;
+	}
+
+	public float getProgressFloat() {
+		return MathHelper.clamp(this.progress / (float)this.maxProgress, 0.0F, 1.0F);
+	}
+
+	public Achievement setCreativeUnlockable() {
+		this.creativeUnlockable = true;
+		return this;
+	}
+
+	public boolean isCreativeUnlockable() {
+		return creativeUnlockable;
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiDevelopmentWarning.java
@@ -1,0 +1,40 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+public class GuiDevelopmentWarning extends GuiScreen {
+	private static final String[] WARNING_TEXT = {
+			"WARNING!",
+			"",
+			"This is a development version of Minecraft Diverge.",
+			"Please backup worlds before playing.",
+			"Everything seen here is subject to change.",
+			"",
+			"Extra debug features, including a creative inventory in",
+			"survival mode, have been enabled.",
+			"",
+			"HERE BE DRAGONS!"
+	};
+
+	public GuiDevelopmentWarning(Minecraft mc) {
+		this.mc = mc;
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(1, this.width / 2 - 50, this.height - 30, 100, 20, "Continue"));
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		this.mc.displayGuiScreen(new GuiMainMenu());
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		double time = (System.currentTimeMillis() / 1000.0D) % 1.0D;
+		int tint = (int)(128 * time) + 127;
+		this.drawBackground(0, 255 << 16 | tint << 8 | tint, var3);
+		for (int i = 0; i < WARNING_TEXT.length; i++) {
+			int y = (this.height + (i - WARNING_TEXT.length / 2) * 20) / 2;
+			this.drawCenteredString(this.fontRenderer, WARNING_TEXT[i], this.width / 2, y, 0xFFFFFF);
+		}
+		super.drawScreen(var1, var2, var3);
+	}
+}
--- net/minecraft/src/WorldGenTrees.java
+++ net/minecraft/src/WorldGenTrees.java
@@ -1,12 +1,35 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.util.Random;
 
 public class WorldGenTrees extends WorldGenerator {
+	private int trunkHeight = 4;
+	private int trunkVariation = 3;
+	private int leavesHeight = 3;
+
+	private int altMetadata = 0;
+	private double altChance = 0.0D;
+
+	public void setScale(double var1, double var3, double var5) {
+		trunkHeight = (int)var1 + 4;
+		trunkVariation = (int)var3 + 3;
+		leavesHeight = (int)var5 + 3;
+	}
+
+	public WorldGenTrees withAltForm(int altMetadata, double altChance) {
+		this.altMetadata = altMetadata;
+		this.altChance = altChance;
+		return this;
+	}
+
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
-		int var6 = var2.nextInt(3) + 4;
+		int meta = var2.nextDouble() < altChance ? altMetadata : 0;
+
+		int var6 = var2.nextInt(trunkVariation) + trunkHeight;
 		boolean var7 = true;
-		if(var4 >= 1 && var4 + var6 + 1 <= 128) {
+		if(var4 >= 1 && var4 + var6 + 1 <= CHUNK_HEIGHT) {
 			int var8;
 			int var10;
 			int var11;
@@ -23,7 +46,7 @@
 
 				for(var10 = var3 - var9; var10 <= var3 + var9 && var7; ++var10) {
 					for(var11 = var5 - var9; var11 <= var5 + var9 && var7; ++var11) {
-						if(var8 >= 0 && var8 < 128) {
+						if(var8 >= 0 && var8 < CHUNK_HEIGHT) {
 							var12 = var1.getBlockId(var10, var8, var11);
 							if(var12 != 0 && var12 != Block.leaves.blockID) {
 								var7 = false;
@@ -39,13 +62,14 @@
 				return false;
 			} else {
 				var8 = var1.getBlockId(var3, var4 - 1, var5);
-				if((var8 == Block.grass.blockID || var8 == Block.dirt.blockID) && var4 < 128 - var6 - 1) {
+				if((var8 == Block.grass.blockID || var8 == Block.dirt.blockID) && var4 < CHUNK_HEIGHT - var6 - 1) {
 					var1.setBlock(var3, var4 - 1, var5, Block.dirt.blockID);
 
 					int var16;
-					for(var16 = var4 - 3 + var6; var16 <= var4 + var6; ++var16) {
+					for(var16 = var4 - leavesHeight + var6; var16 <= var4 + var6; ++var16) {
 						var10 = var16 - (var4 + var6);
 						var11 = 1 - var10 / 2;
+						if (var11 > 2) var11 = 2;
 
 						for(var12 = var3 - var11; var12 <= var3 + var11; ++var12) {
 							int var13 = var12 - var3;
@@ -53,7 +77,7 @@
 							for(int var14 = var5 - var11; var14 <= var5 + var11; ++var14) {
 								int var15 = var14 - var5;
 								if((Math.abs(var13) != var11 || Math.abs(var15) != var11 || var2.nextInt(2) != 0 && var10 != 0) && !Block.opaqueCubeLookup[var1.getBlockId(var12, var16, var14)]) {
-									var1.setBlock(var12, var16, var14, Block.leaves.blockID);
+									var1.setBlockAndMetadata(var12, var16, var14, Block.leaves.blockID, meta);
 								}
 							}
 						}
@@ -62,7 +86,7 @@
 					for(var16 = 0; var16 < var6; ++var16) {
 						var10 = var1.getBlockId(var3, var4 + var16, var5);
 						if(var10 == 0 || var10 == Block.leaves.blockID) {
-							var1.setBlock(var3, var4 + var16, var5, Block.wood.blockID);
+							var1.setBlockAndMetadata(var3, var4 + var16, var5, Block.wood.blockID, meta);
 						}
 					}
 
--- net/minecraft/src/NBTTagFloat.java
+++ net/minecraft/src/NBTTagFloat.java
@@ -14,11 +14,11 @@
 		this.floatValue = var1;
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeFloat(this.floatValue);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.floatValue = var1.readFloat();
 	}
 
@@ -27,6 +27,10 @@
 	}
 
 	public String toString() {
-		return "" + this.floatValue;
+		return String.valueOf(this.floatValue);
+	}
+
+	public NBTBase copy() {
+		return new NBTTagFloat(this.floatValue).setKey(this.getKey());
 	}
 }
--- net/minecraft/src/ThreadSleepForeverServer.java
+++ net/minecraft/src/ThreadSleepForeverServer.java
@@ -3,7 +3,7 @@
 import net.minecraft.server.MinecraftServer;
 
 public class ThreadSleepForeverServer extends Thread {
-	final MinecraftServer mcServer;
+	public final MinecraftServer mcServer;
 
 	public ThreadSleepForeverServer(MinecraftServer var1) {
 		this.mcServer = var1;
--- net/minecraft/src/Packet14BlockDig.java
+++ net/minecraft/src/Packet14BlockDig.java
@@ -25,7 +25,7 @@
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.status = var1.read();
 		this.xPosition = var1.readInt();
-		this.yPosition = var1.read();
+		this.yPosition = var1.readShort();
 		this.zPosition = var1.readInt();
 		this.face = var1.read();
 	}
@@ -33,7 +33,7 @@
 	public void writePacket(DataOutputStream var1) throws IOException {
 		var1.write(this.status);
 		var1.writeInt(this.xPosition);
-		var1.write(this.yPosition);
+		var1.writeShort(this.yPosition);
 		var1.writeInt(this.zPosition);
 		var1.write(this.face);
 	}
@@ -43,6 +43,6 @@
 	}
 
 	public int getPacketSize() {
-		return 11;
+		return 12;
 	}
 }
--- /dev/null
+++ net/minecraft/src/RecipesBlocks.java
@@ -1,0 +1,105 @@
+package net.minecraft.src;
+
+public class RecipesBlocks {
+	public void addRecipes(CraftingManager craftingManager) {
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 0), "###", '#', new Pair<>(Block.cobblestone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 1), "###", '#', new Pair<>(Block.cobblestone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 2), "###", '#', new Pair<>(Block.cobblestone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 3), "###", '#', new Pair<>(Block.stone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 4), "###", '#', new Pair<>(Block.stone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 5), "###", '#', new Pair<>(Block.stone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 6), "###", '#', new Pair<>(Block.polishedStone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 7), "###", '#', new Pair<>(Block.polishedStone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 8), "###", '#', new Pair<>(Block.polishedStone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 9), "###", '#', new Pair<>(Block.stone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 10), "###", '#', new Pair<>(Block.cobblestone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 11), "###", '#', new Pair<>(Block.polishedStone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 12), "###", '#', new Pair<>(Block.stoneBricks, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 13), "###", '#', new Pair<>(Block.stoneBricks, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 14), "###", '#', new Pair<>(Block.stoneBricks, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 15), "###", '#', new Pair<>(Block.stoneBricks, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 16), "###", '#', Block.brick);
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 17), "###", '#', new Pair<>(Block.cobblestone, 4));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 18), "###", '#', new Pair<>(Block.stone, 4));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 19), "###", '#', new Pair<>(Block.polishedStone, 4));
+		craftingManager.addRecipe(new ItemStack(Block.stairSingle, 6, 20), "###", '#', new Pair<>(Block.stoneBricks, 4));
+
+		craftingManager.addRecipe(new ItemStack(Block.woodStairSingle, 6, 0), "###", '#', new Pair<>(Block.planks, 0));
+		craftingManager.addRecipe(new ItemStack(Block.woodStairSingle, 6, 1), "###", '#', new Pair<>(Block.planks, 1));
+		craftingManager.addRecipe(new ItemStack(Block.woodStairSingle, 6, 2), "###", '#', new Pair<>(Block.planks, 2));
+		craftingManager.addRecipe(new ItemStack(Block.woodStairSingle, 6, 3), "###", '#', new Pair<>(Block.planks, 3));
+
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactWood, 8, 0), "#  ", "## ", "###", '#', new Pair<>(Block.planks, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactWood, 8, 4), "#  ", "## ", "###", '#', new Pair<>(Block.planks, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactWood, 8, 8), "#  ", "## ", "###", '#', new Pair<>(Block.planks, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactWood, 8, 12), "#  ", "## ", "###", '#', new Pair<>(Block.planks, 3));
+
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactCobblestone, 8, 0), "#  ", "## ", "###", '#', new Pair<>(Block.cobblestone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactCobblestone, 8, 4), "#  ", "## ", "###", '#', new Pair<>(Block.cobblestone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactCobblestone, 8, 8), "#  ", "## ", "###", '#', new Pair<>(Block.cobblestone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactCobblestone, 8, 12), "#  ", "## ", "###", '#', new Pair<>(Block.cobblestone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactCobblestone, 8, 16), "#  ", "## ", "###", '#', new Pair<>(Block.cobblestone, 4));
+
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStone, 8, 0), "#  ", "## ", "###", '#', new Pair<>(Block.stone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStone, 8, 4), "#  ", "## ", "###", '#', new Pair<>(Block.stone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStone, 8, 8), "#  ", "## ", "###", '#', new Pair<>(Block.stone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStone, 8, 12), "#  ", "## ", "###", '#', new Pair<>(Block.stone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStone, 8, 16), "#  ", "## ", "###", '#', new Pair<>(Block.stone, 4));
+
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactPolishedStone, 8, 0), "#  ", "## ", "###", '#', new Pair<>(Block.polishedStone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactPolishedStone, 8, 4), "#  ", "## ", "###", '#', new Pair<>(Block.polishedStone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactPolishedStone, 8, 8), "#  ", "## ", "###", '#', new Pair<>(Block.polishedStone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactPolishedStone, 8, 12), "#  ", "## ", "###", '#', new Pair<>(Block.polishedStone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactPolishedStone, 8, 16), "#  ", "## ", "###", '#', new Pair<>(Block.polishedStone, 4));
+
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStoneBricks, 8, 0), "#  ", "## ", "###", '#', new Pair<>(Block.stoneBricks, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStoneBricks, 8, 4), "#  ", "## ", "###", '#', new Pair<>(Block.stoneBricks, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStoneBricks, 8, 8), "#  ", "## ", "###", '#', new Pair<>(Block.stoneBricks, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStoneBricks, 8, 12), "#  ", "## ", "###", '#', new Pair<>(Block.stoneBricks, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stairCompactStoneBricks, 8, 16), "#  ", "## ", "###", '#', new Pair<>(Block.stoneBricks, 4));
+
+		craftingManager.addRecipe(new ItemStack(Block.planks, 4, 0), "#", '#', new Pair<>(Block.wood, 0));
+		craftingManager.addRecipe(new ItemStack(Block.planks, 4, 1), "#", '#', new Pair<>(Block.wood, 1));
+		craftingManager.addRecipe(new ItemStack(Block.planks, 4, 2), "#", '#', new Pair<>(Block.wood, 2));
+		craftingManager.addRecipe(new ItemStack(Block.planks, 4, 3), "#", '#', new Pair<>(Block.wood, 3));
+
+		craftingManager.addRecipe(new ItemStack(Block.polishedStone, 4, 0), "##", "##", '#', new Pair<>(Block.stone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.polishedStone, 4, 1), "##", "##", '#', new Pair<>(Block.stone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.polishedStone, 4, 2), "##", "##", '#', new Pair<>(Block.stone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.polishedStone, 4, 3), "##", "##", '#', new Pair<>(Block.stone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.polishedStone, 4, 4), "##", "##", '#', new Pair<>(Block.stone, 4));
+
+		craftingManager.addRecipe(new ItemStack(Block.stoneBricks, 4, 0), "##", "##", '#', new Pair<>(Block.polishedStone, 0));
+		craftingManager.addRecipe(new ItemStack(Block.stoneBricks, 4, 1), "##", "##", '#', new Pair<>(Block.polishedStone, 1));
+		craftingManager.addRecipe(new ItemStack(Block.stoneBricks, 4, 2), "##", "##", '#', new Pair<>(Block.polishedStone, 2));
+		craftingManager.addRecipe(new ItemStack(Block.stoneBricks, 4, 3), "##", "##", '#', new Pair<>(Block.polishedStone, 3));
+		craftingManager.addRecipe(new ItemStack(Block.stoneBricks, 4, 4), "##", "##", '#', new Pair<>(Block.polishedStone, 4));
+
+		craftingManager.addRecipe(new ItemStack(Block.fence, 3, 0), "x#x", "x#x", 'x', Item.stick, '#', new Pair<>(Block.planks, 0));
+		craftingManager.addRecipe(new ItemStack(Block.fence, 3, 1), "x#x", "x#x", 'x', Item.stick, '#', new Pair<>(Block.planks, 1));
+		craftingManager.addRecipe(new ItemStack(Block.fence, 3, 2), "x#x", "x#x", 'x', Item.stick, '#', new Pair<>(Block.planks, 2));
+		craftingManager.addRecipe(new ItemStack(Block.fence, 3, 3), "x#x", "x#x", 'x', Item.stick, '#', new Pair<>(Block.planks, 3));
+
+		addOreRecipe(craftingManager, Block.oreCoal, Item.coal);
+		addOreRecipe(craftingManager, Block.oreIron, Item.rawIron);
+		addOreRecipe(craftingManager, Block.oreGold, Item.rawGold);
+		addOreRecipe(craftingManager, Block.oreDiamond, Item.diamond);
+		addOreRecipe(craftingManager, Block.oreRuby, Item.ruby);
+		addOreRecipe(craftingManager, Block.oreSapphire, Item.sapphire);
+		addLargeOreRecipe(craftingManager, Block.oreRedstone, Item.redstone);
+
+		craftingManager.addRecipe(new ItemStack(Block.starLantern, 8), "xxx", "x#x", "xxx", 'x', Block.glass, '#', Item.starDust);
+	}
+
+	public static void addOreRecipe(CraftingManager craftingManager, Block ore, Item rawOre) {
+		for (int i = 0; i < BlockStone.stoneTypeNames.size(); i++) {
+			craftingManager.addRecipe(new ItemStack(ore, 2, i), "#x", "x#", '#', new Pair<>(Block.stone, i), 'x', rawOre);
+		}
+	}
+
+	public static void addLargeOreRecipe(CraftingManager craftingManager, Block ore, Item rawOre) {
+		for (int i = 0; i < BlockStone.stoneTypeNames.size(); i++) {
+			craftingManager.addRecipe(new ItemStack(ore, 1, i), "#x#", "x#x", "#x#", '#', new Pair<>(Block.stone, i), 'x', rawOre);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/EmptyChunk.java
@@ -1,0 +1,130 @@
+package net.minecraft.src;
+
+import java.util.List;
+
+public class EmptyChunk extends Chunk {
+	public EmptyChunk(World var1, int var2, int var3) {
+		super(var1, var2, var3);
+		this.neverSave = true;
+		this.isLightPopulated = true;
+	}
+
+	public EmptyChunk(World var1, short[] var2, int var3, int var4) {
+		super(var1, var2, var3, var4);
+		this.neverSave = true;
+		this.isLightPopulated = true;
+	}
+
+	public boolean isAtLocation(int var1, int var2) {
+		return var1 == this.xPosition && var2 == this.zPosition;
+	}
+
+	public int getHeightValue(int var1, int var2) {
+		return 0;
+	}
+
+	public void generateBiomes(World worldObj) {
+	}
+
+	public Biome getBiome(int x, int y) {
+		return Biome.forest;
+	}
+
+	public void generateHeightMap() {
+	}
+
+	public void generateSkylightMap() {
+	}
+
+	public int getBlockID(int var1, int var2, int var3) {
+		return 0;
+	}
+
+	public boolean setBlockIDWithMetadata(int var1, int var2, int var3, int var4, int var5) {
+		return true;
+	}
+
+	public boolean setBlockID(int var1, int var2, int var3, int var4) {
+		return true;
+	}
+
+	public int getBlockMetadata(int var1, int var2, int var3) {
+		return 0;
+	}
+
+	public void setBlockMetadata(int var1, int var2, int var3, int var4) {
+	}
+
+	public int getSavedLightValue(EnumSkyBlock var1, int var2, int var3, int var4) {
+		return 0;
+	}
+
+	public void setLightValue(EnumSkyBlock var1, int var2, int var3, int var4, int var5) {
+	}
+
+	public int getBlockLightValue(int var1, int var2, int var3, int var4) {
+		return 0;
+	}
+
+	public void addEntity(Entity var1) {
+	}
+
+	public void removeEntity(Entity var1) {
+	}
+
+	public void removeEntityAtIndex(Entity var1, int var2) {
+	}
+
+	public boolean canBlockSeeTheSky(int var1, int var2, int var3) {
+		return false;
+	}
+
+	public TileEntity getChunkBlockTileEntity(int var1, int var2, int var3) {
+		return null;
+	}
+
+	public void addTileEntity(TileEntity var1) {
+	}
+
+	public void setChunkBlockTileEntity(int var1, int var2, int var3, TileEntity var4) {
+	}
+
+	public void removeChunkBlockTileEntity(int var1, int var2, int var3) {
+	}
+
+	public void onChunkLoad() {
+	}
+
+	public void onChunkUnload() {
+	}
+
+	public void setChunkModified() {
+	}
+
+	public void getEntitiesWithinAABBForEntity(Entity var1, AxisAlignedBB var2, List var3) {
+	}
+
+	public void getEntitiesOfTypeWithinAAAB(Class var1, AxisAlignedBB var2, List var3) {
+	}
+
+	public boolean needsSaving(boolean var1) {
+		return false;
+	}
+
+	public int setChunkData(byte[] var1, int var2, int var3, int var4, int var5, int var6, int var7, int var8) {
+		int var9 = var5 - var2;
+		int var10 = var6 - var3;
+		int var11 = var7 - var4;
+		int var12 = var9 * var10 * var11;
+		return var12 + var12 / 2 * 3;
+	}
+
+	public void updateSkylight() {
+	}
+
+	public void enqueueRelightChecks() {
+	}
+
+	public void populateLightNeighbors() {
+	}
+}
--- net/minecraft/src/ItemDoor.java
+++ net/minecraft/src/ItemDoor.java
@@ -6,11 +6,10 @@
 	public ItemDoor(int var1, Material var2) {
 		super(var1);
 		this.material = var2;
-		this.maxDamage = 64;
 		this.maxStackSize = 1;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var7 != 1) {
 			return false;
 		} else {
--- net/minecraft/src/RenderMinecart.java
+++ net/minecraft/src/RenderMinecart.java
@@ -44,7 +44,7 @@
 		GL11.glRotatef(180.0F - var8, 0.0F, 1.0F, 0.0F);
 		GL11.glRotatef(-var19, 0.0F, 0.0F, 1.0F);
 		float var23 = (float)var1.timeSinceHit - var9;
-		float var24 = (float)var1.damageTaken - var9;
+		float var24 = (float)var1.damageTaken / 4.0F - var9;
 		if(var24 < 0.0F) {
 			var24 = 0.0F;
 		}
@@ -60,13 +60,13 @@
 			GL11.glTranslatef(0.0F, 5.0F / 16.0F, 0.0F);
 			GL11.glRotatef(90.0F, 0.0F, 1.0F, 0.0F);
 			if(var1.minecartType == 1) {
-				(new RenderBlocks()).renderBlockOnInventory(Block.chest);
+				(new RenderBlocks()).renderBlockOnInventory(Block.chest, 0);
 			} else if(var1.minecartType == 2) {
-				(new RenderBlocks()).renderBlockOnInventory(Block.stoneOvenIdle);
+				(new RenderBlocks()).renderBlockOnInventory(Block.stoneOvenIdle, 0);
 			}
 
 			GL11.glRotatef(-90.0F, 0.0F, 1.0F, 0.0F);
-			GL11.glTranslatef(0.0F, -(5.0F / 16.0F), 0.0F);
+			GL11.glTranslatef(0.0F, -(5.0F - 16.0F), 0.0F);
 			GL11.glScalef(1.0F / var25, 1.0F / var25, 1.0F / var25);
 		}
 
--- net/minecraft/src/NibbleArray.java
+++ net/minecraft/src/NibbleArray.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_BIT_OFFSET;
+
 public class NibbleArray {
 	public final byte[] data;
 
@@ -12,14 +14,14 @@
 	}
 
 	public int get(int var1, int var2, int var3) {
-		int var4 = var1 << 11 | var3 << 7 | var2;
+		int var4 = var1 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET | var2;
 		int var5 = var4 >> 1;
 		int var6 = var4 & 1;
 		return var6 == 0 ? this.data[var5] & 15 : this.data[var5] >> 4 & 15;
 	}
 
 	public void set(int var1, int var2, int var3, int var4) {
-		int var5 = var1 << 11 | var3 << 7 | var2;
+		int var5 = var1 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET | var2;
 		int var6 = var5 >> 1;
 		int var7 = var5 & 1;
 		if(var7 == 0) {
--- net/minecraft/src/BlockDirt.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package net.minecraft.src;
-
-public class BlockDirt extends Block {
-	protected BlockDirt(int var1, int var2) {
-		super(var1, var2, Material.grass);
-	}
-}
--- net/minecraft/src/GuiDownloadTerrain.java
+++ net/minecraft/src/GuiDownloadTerrain.java
@@ -31,7 +31,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawBackground(0);
+		this.drawBackground(0, var3);
 		this.drawCenteredString(this.fontRenderer, "Downloading terrain", this.width / 2, this.height / 2 - 50, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
--- net/minecraft/src/TileEntityFurnace.java
+++ net/minecraft/src/TileEntityFurnace.java
@@ -2,54 +2,66 @@
 
 public class TileEntityFurnace extends TileEntity implements IInventory {
 	private ItemStack[] furnaceItemStacks = new ItemStack[3];
-	private int furnaceBurnTime = 0;
-	private int currentItemBurnTime = 0;
-	private int furnaceCookTime = 0;
-
-	public int getSizeInventory() {
+	public int furnaceBurnTime = 0;
+	public int currentItemBurnTime = 0;
+	public int furnaceCookTime = 0;
+	private int furnaceMaxTime;
+	private int furnaceBurnTick;
+
+	public TileEntityFurnace() {
+		this(200, 1);
+	}
+
+	public TileEntityFurnace(int speed) {
+		this(speed, 1);
+	}
+
+	public TileEntityFurnace(int speed, int burnTick) {
+		this.furnaceMaxTime = speed;
+		this.furnaceBurnTick = burnTick;
+	}
+
+	public int getInventorySize() {
 		return this.furnaceItemStacks.length;
 	}
 
-	public ItemStack getStackInSlot(int var1) {
+	public ItemStack getStack(int var1) {
 		return this.furnaceItemStacks[var1];
 	}
 
-	public ItemStack decrStackSize(int var1, int var2) {
+	public ItemStack decrStack(int var1, int var2) {
 		if(this.furnaceItemStacks[var1] != null) {
 			ItemStack var3;
 			if(this.furnaceItemStacks[var1].stackSize <= var2) {
 				var3 = this.furnaceItemStacks[var1];
 				this.furnaceItemStacks[var1] = null;
-				return var3;
 			} else {
 				var3 = this.furnaceItemStacks[var1].splitStack(var2);
 				if(this.furnaceItemStacks[var1].stackSize == 0) {
 					this.furnaceItemStacks[var1] = null;
 				}
-
-				return var3;
 			}
+			return var3;
 		} else {
 			return null;
 		}
 	}
 
-	public void setInventorySlotContents(int var1, ItemStack var2) {
+	public void setInventorySlotItem(int var1, ItemStack var2) {
 		this.furnaceItemStacks[var1] = var2;
-		if(var2 != null && var2.stackSize > this.getInventoryStackLimit()) {
-			var2.stackSize = this.getInventoryStackLimit();
+		if(var2 != null && var2.stackSize > this.getStackLimit()) {
+			var2.stackSize = this.getStackLimit();
 		}
-
 	}
 
-	public String getInvName() {
-		return "Chest";
+	public String getInventoryName() {
+		return "Furnace";
 	}
 
 	public void readFromNBT(NBTTagCompound var1) {
 		super.readFromNBT(var1);
 		NBTTagList var2 = var1.getTagList("Items");
-		this.furnaceItemStacks = new ItemStack[this.getSizeInventory()];
+		this.furnaceItemStacks = new ItemStack[3];
 
 		for(int var3 = 0; var3 < var2.tagCount(); ++var3) {
 			NBTTagCompound var4 = (NBTTagCompound)var2.tagAt(var3);
@@ -60,14 +72,25 @@
 		}
 
 		this.furnaceBurnTime = var1.getShort("BurnTime");
+		this.furnaceBurnTick = var1.getShort("BurnTick");
 		this.furnaceCookTime = var1.getShort("CookTime");
+		this.furnaceMaxTime = var1.getShort("MaxTime");
 		this.currentItemBurnTime = this.getItemBurnTime(this.furnaceItemStacks[1]);
+
+		if (this.furnaceMaxTime <= 0) {
+			this.furnaceMaxTime = 200;
+		}
+		if (this.furnaceBurnTick <= 0) {
+			this.furnaceBurnTick = 0;
+		}
 	}
 
 	public void writeToNBT(NBTTagCompound var1) {
 		super.writeToNBT(var1);
 		var1.setShort("BurnTime", (short)this.furnaceBurnTime);
+		var1.setShort("BurnTick", (short)this.furnaceBurnTick);
 		var1.setShort("CookTime", (short)this.furnaceCookTime);
+		var1.setShort("MaxTime", (short)this.furnaceMaxTime);
 		NBTTagList var2 = new NBTTagList();
 
 		for(int var3 = 0; var3 < this.furnaceItemStacks.length; ++var3) {
@@ -82,17 +105,17 @@
 		var1.setTag("Items", var2);
 	}
 
-	public int getInventoryStackLimit() {
+	public int getStackLimit() {
 		return 64;
 	}
 
 	public int getCookProgressScaled(int var1) {
-		return this.furnaceCookTime * var1 / 200;
+		return this.furnaceCookTime * var1 / this.furnaceMaxTime;
 	}
 
 	public int getBurnTimeRemainingScaled(int var1) {
-		if(this.currentItemBurnTime == 0) {
-			this.currentItemBurnTime = 200;
+		if (this.currentItemBurnTime == 0) {
+			this.currentItemBurnTime = this.furnaceMaxTime;
 		}
 
 		return this.furnaceBurnTime * var1 / this.currentItemBurnTime;
@@ -106,10 +129,10 @@
 		boolean var1 = this.furnaceBurnTime > 0;
 		boolean var2 = false;
 		if(this.furnaceBurnTime > 0) {
-			--this.furnaceBurnTime;
+			this.furnaceBurnTime -= this.furnaceBurnTick;
 		}
 
-		if(!this.worldObj.multiplayerWorld) {
+		if(this.worldObj.canDoClientAction()) {
 			if(this.furnaceBurnTime == 0 && this.canSmelt()) {
 				this.currentItemBurnTime = this.furnaceBurnTime = this.getItemBurnTime(this.furnaceItemStacks[1]);
 				if(this.furnaceBurnTime > 0) {
@@ -125,7 +148,7 @@
 
 			if(this.isBurning() && this.canSmelt()) {
 				++this.furnaceCookTime;
-				if(this.furnaceCookTime == 200) {
+				if(this.furnaceCookTime == this.furnaceMaxTime) {
 					this.furnaceCookTime = 0;
 					this.smeltItem();
 					var2 = true;
@@ -136,12 +159,12 @@
 
 			if(var1 != this.furnaceBurnTime > 0) {
 				var2 = true;
-				BlockFurnace.updateFurnaceBlockState(this.furnaceBurnTime > 0, this.worldObj, this.xCoord, this.yCoord, this.zCoord);
+				((BlockFurnace)this.getBlockType()).updateFurnaceBlockState(this.furnaceBurnTime > 0, this.worldObj, this.xCoord, this.yCoord, this.zCoord);
 			}
 		}
 
 		if(var2) {
-			this.onInventoryChanged();
+			this.onInventoryChange();
 		}
 
 	}
@@ -149,18 +172,25 @@
 	private boolean canSmelt() {
 		if(this.furnaceItemStacks[0] == null) {
 			return false;
-		} else {
-			int var1 = this.getCookedItem(this.furnaceItemStacks[0].getItem().shiftedIndex);
-			return var1 < 0 ? false : (this.furnaceItemStacks[2] == null ? true : (this.furnaceItemStacks[2].itemID != var1 ? false : (this.furnaceItemStacks[2].stackSize < this.getInventoryStackLimit() && this.furnaceItemStacks[2].stackSize < this.furnaceItemStacks[2].getMaxStackSize() ? true : this.furnaceItemStacks[2].stackSize < Item.itemsList[var1].getItemStackLimit())));
 		}
+		ItemStack var1 = this.getCookedItem(this.furnaceItemStacks[0]);
+		ItemStack outSlot = this.furnaceItemStacks[2];
+		return var1 != null
+			   && (outSlot == null
+				   || (outSlot.itemID == var1.itemID
+					   && outSlot.itemMetadata == var1.itemMetadata
+					   && outSlot.stackSize < this.getStackLimit()
+					   && outSlot.stackSize < outSlot.getMaxStackSize()
+					   && outSlot.stackSize < var1.getMaxStackSize() ) );
 	}
 
 	public void smeltItem() {
 		if(this.canSmelt()) {
-			int var1 = this.getCookedItem(this.furnaceItemStacks[0].getItem().shiftedIndex);
+			ItemStack var1 = this.getCookedItem(this.furnaceItemStacks[0]);
 			if(this.furnaceItemStacks[2] == null) {
-				this.furnaceItemStacks[2] = new ItemStack(var1, 1);
-			} else if(this.furnaceItemStacks[2].itemID == var1) {
+				this.furnaceItemStacks[2] = new ItemStack(var1.itemID, 1, -1, var1.itemMetadata);
+			} else if(this.furnaceItemStacks[2].itemID == var1.itemID
+					  && this.furnaceItemStacks[2].itemMetadata == var1.itemMetadata) {
 				++this.furnaceItemStacks[2].stackSize;
 			}
 
@@ -168,20 +198,38 @@
 			if(this.furnaceItemStacks[0].stackSize <= 0) {
 				this.furnaceItemStacks[0] = null;
 			}
-
 		}
 	}
 
-	private int getCookedItem(int var1) {
-		return var1 == Block.oreIron.blockID ? Item.ingotIron.shiftedIndex : (var1 == Block.oreGold.blockID ? Item.ingotGold.shiftedIndex : (var1 == Block.oreDiamond.blockID ? Item.diamond.shiftedIndex : (var1 == Block.sand.blockID ? Block.glass.blockID : (var1 == Item.porkRaw.shiftedIndex ? Item.porkCooked.shiftedIndex : (var1 == Block.cobblestone.blockID ? Block.stone.blockID : (var1 == Item.clay.shiftedIndex ? Item.brick.shiftedIndex : -1))))));
+	private ItemStack getCookedItem(ItemStack var1) {
+		return FurnaceRecipeManager.getInstance().findMatchingRecipe(var1);
 	}
 
 	private int getItemBurnTime(ItemStack var1) {
 		if(var1 == null) {
 			return 0;
 		} else {
+			if (var1.getItem() == null) return 0;
 			int var2 = var1.getItem().shiftedIndex;
-			return var2 < 256 && Block.blocksList[var2].material == Material.wood ? 300 : (var2 == Item.stick.shiftedIndex ? 100 : (var2 == Item.coal.shiftedIndex ? 1600 : (var2 == Item.bucketLava.shiftedIndex ? 20000 : 0)));
-		}
+			return var2 < 256 && Block.blocksList[var2].material == Material.wood ? 300
+					: var2 == Item.stick.shiftedIndex ? 100
+					: var2 == Item.coal.shiftedIndex ? 1600
+					: var2 == Item.bucketLava.shiftedIndex ? 20000
+					: var2 == Item.starDust.shiftedIndex ? 6400
+					: var2 == Block.blockCoal.blockID ? 14400
+					: 0;
+		}
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return this.worldObj.getBlockTileEntity(this.xCoord, this.yCoord, this.zCoord) == this && var1.getDistanceSq((double) this.xCoord + 0.5D, (double) this.yCoord + 0.5D, (double) this.zCoord + 0.5D) <= 64.0D;
+	}
+
+	public Block getBlockType() {
+		Block type = super.getBlockType();
+		if (type == null) {
+			type = Block.stoneOvenIdle;
+		}
+		return type;
 	}
 }
--- /dev/null
+++ net/minecraft/src/SlotShadowed.java
@@ -1,0 +1,30 @@
+package net.minecraft.src;
+
+public class SlotShadowed extends Slot {
+	public SlotShadowed(IInventory var1, int var2, int var3, int var4) {
+		super(var1, var2, var3, var4);
+	}
+
+	public void putStack(ItemStack var1) {
+	}
+
+	public ItemStack decrStackSize(int var1) {
+		return this.getStack();
+	}
+
+	public float getColorR() {
+		return 0.0F;
+	}
+
+	public float getColorG() {
+		return 0.0F;
+	}
+
+	public float getColorB() {
+		return 0.0F;
+	}
+
+	public float getColorA() {
+		return 0.5F;
+	}
+}
--- net/minecraft/src/LogoEffectRandomizer.java
+++ net/minecraft/src/LogoEffectRandomizer.java
@@ -1,10 +1,10 @@
 package net.minecraft.src;
 
-class LogoEffectRandomizer {
+public class LogoEffectRandomizer {
 	public double height;
 	public double prevHeight;
 	public double dropSpeed;
-	final GuiMainMenu mainMenu;
+	public final GuiMainMenu mainMenu;
 
 	public LogoEffectRandomizer(GuiMainMenu var1, int var2, int var3) {
 		this.mainMenu = var1;
--- net/minecraft/src/ServerGuiFocusadapter.java
+++ net/minecraft/src/ServerGuiFocusadapter.java
@@ -3,10 +3,10 @@
 import java.awt.event.FocusAdapter;
 import java.awt.event.FocusEvent;
 
-class ServerGuiFocusadapter extends FocusAdapter {
-	final ServerGUI mcServerGui;
+public class ServerGuiFocusadapter extends FocusAdapter {
+	public final ServerGUI mcServerGui;
 
-	ServerGuiFocusadapter(ServerGUI var1) {
+	public ServerGuiFocusadapter(ServerGUI var1) {
 		this.mcServerGui = var1;
 	}
 
--- /dev/null
+++ net/minecraft/src/SpawnerMobs.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+public class SpawnerMobs extends SpawnerAnimals {
+	public SpawnerMobs(int var2, Class var3) {
+		super(var2, var3);
+	}
+
+	public Class<? extends EntityLiving> getEntity(World world, Biome biome) {
+		return biome.spawnableMonsters.get(world.rand.nextInt(biome.spawnableMonsters.size()));
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemRepairKit.java
@@ -1,0 +1,22 @@
+package net.minecraft.src;
+
+public class ItemRepairKit extends ItemCharm {
+	public ItemRepairKit(int id) {
+		super(id, 1024);
+	}
+
+	public void updateCharm(EntityPlayer player, ItemStack stack) {
+		if (player.isSneaking()) {
+			ItemStack heldItem = player.inventory.getCurrentItem();
+			if (player.ticksExisted % 2 != 0
+				|| heldItem == null
+				|| heldItem.itemDmg == 0
+				|| !Item.itemsList[heldItem.itemID].allowRepair()) {
+				return;
+			}
+			--heldItem.itemDmg;
+			player.playSound("random.wood click", 1.0F, 1.0F);
+			stack.damageItem(1);
+		}
+	}
+}
--- net/minecraft/src/EntityFlameFX.java
+++ net/minecraft/src/EntityFlameFX.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import net.minecraft.server.MinecraftServer;
 public class EntityFlameFX extends EntityFX {
 	private float flameScale;
 
@@ -35,6 +36,9 @@
 		}
 
 		float var3 = super.getBrightness(var1);
+		if (MinecraftServer.getInstance() == null) {
+			var3 *= (1 - RenderGlobal.globalBrightness) + RenderGlobal.globalBrightness;
+		}
 		return var3 * var2 + (1.0F - var2);
 	}
 
--- /dev/null
+++ net/minecraft/src/WorldGenSpruceTrees.java
@@ -1,0 +1,131 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
+import java.util.Random;
+
+public class WorldGenSpruceTrees extends WorldGenerator {
+	private int trunkHeight = 6;
+	private int trunkVariation = 4;
+	private int leavesWidth = 2;
+	private boolean big = false;
+
+	public WorldGenSpruceTrees makeBig() {
+		this.big = true;
+		return this;
+	}
+
+	public void setScale(double var1, double var3, double var5) {
+		trunkHeight = (int)var1 + 6;
+		trunkVariation = (int)var3 + 4;
+		leavesWidth = (int)var5 + 2;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int var6 = var2.nextInt(trunkVariation) + trunkHeight;
+		int var7 = 1 + var2.nextInt(leavesWidth);
+		int var8 = var6 - var7;
+		int var9 = 2 + var2.nextInt(leavesWidth);
+		int squareSize = big ? 2 : 1;
+		boolean var10 = true;
+
+		if (var1.getBlockId(var3, var4, var5) == Block.snow.blockID) {
+			var1.setBlock(var3, var4--, var5, 0);
+		}
+
+		if(var4 >= 1 && var4 + var6 + 1 <= CHUNK_HEIGHT) {
+			int var11;
+			int var13;
+			int var15;
+			int var21;
+			for(var11 = var4; var11 <= var4 + 1 + var6 && var10; ++var11) {
+				if(var11 - var4 < var7) {
+					var21 = 0;
+				} else {
+					var21 = var9;
+				}
+
+				for(var13 = var3 - var21; var13 <= var3 + var21 && var10; ++var13) {
+					for(int var14 = var5 - var21; var14 <= var5 + var21 && var10; ++var14) {
+						if (var11 >= 0 && var11 < CHUNK_HEIGHT) {
+							var15 = var1.getBlockId(var13, var11, var14);
+							if(var15 != 0 && var15 != Block.leaves.blockID && var15 != Block.snow.blockID) {
+								var10 = false;
+							}
+						} else {
+							var10 = false;
+						}
+					}
+				}
+			}
+
+			if(!var10) {
+				return false;
+			} else {
+				var11 = var1.getBlockId(var3, var4 - 1, var5);
+				if((var11 == Block.grass.blockID || var11 == Block.dirt.blockID) && var4 < CHUNK_HEIGHT - var6 - 1) {
+					placeBlockSquare(var1, var3, var4 - 1, var5, Block.dirt.blockID, 0, squareSize);
+					var21 = var2.nextInt(2);
+					var13 = 1;
+					byte var22 = 0;
+
+					int var16;
+					int var17;
+					for(var15 = 0; var15 <= var8; ++var15) {
+						var16 = var4 + var6 - var15;
+
+						for(var17 = var3 - var21; var17 <= var3 + var21; ++var17) {
+							int var18 = var17 - var3;
+
+							for(int var19 = var5 - var21; var19 <= var5 + var21; ++var19) {
+								int var20 = var19 - var5;
+
+								int leafX = var17;
+								int leafZ = var19;
+								int leafSize = squareSize;
+
+								if((Math.abs(var18) != var21 || Math.abs(var20) != var21 || var21 <= 0) && !Block.opaqueCubeLookup[var1.getBlockId(var17, var16, var19)]) {
+									placeBlockSquare(var1, leafX, var16, leafZ, Block.leaves.blockID, 1, leafSize);
+								}
+							}
+						}
+
+						if(var21 >= var13) {
+							var21 = var22;
+							var22 = 1;
+							++var13;
+							if(var13 > var9) {
+								var13 = var9;
+							}
+						} else {
+							++var21;
+						}
+					}
+
+					var15 = var2.nextInt(3);
+
+					for(var16 = 0; var16 < var6 - var15; ++var16) {
+						var17 = var1.getBlockId(var3, var4 + var16, var5);
+						if(var17 == 0 || var17 == Block.leaves.blockID) {
+							placeBlockSquare(var1, var3, var4 + var16, var5, Block.wood.blockID, 1, squareSize);
+						}
+					}
+
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} else {
+			return false;
+		}
+	}
+
+	private static void placeBlockSquare(World world, int x, int y, int z, int id, int metadata, int size) {
+		for (int sx = 0; sx < size; sx++) {
+			for (int sz = 0; sz < size; sz++) {
+				world.setBlockAndMetadata(x + sx, y, z + sz, id, metadata);
+			}
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/EffectSugarRush.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+public class EffectSugarRush extends EffectType {
+	public EffectSugarRush(int id, String name) {
+		super(id, name);
+	}
+
+	public void doEffect(EntityPlayer player, Effect effect) {
+		player.energyBoost += effect.duration / 5000.0F;
+	}
+}
--- net/minecraft/src/PropertyManager.java
+++ net/minecraft/src/PropertyManager.java
@@ -3,7 +3,9 @@
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.util.Arrays;
 import java.util.Properties;
+import java.util.Random;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -54,19 +56,50 @@
 
 	public int getIntProperty(String var1, int var2) {
 		try {
-			return Integer.parseInt(this.getStringProperty(var1, "" + var2));
+			return Integer.parseInt(this.getStringProperty(var1, String.valueOf(var2)));
 		} catch (Exception var4) {
-			this.serverProperties.setProperty(var1, "" + var2);
+			this.serverProperties.setProperty(var1, String.valueOf(var2));
 			return var2;
 		}
 	}
 
 	public boolean getBooleanProperty(String var1, boolean var2) {
 		try {
-			return Boolean.parseBoolean(this.getStringProperty(var1, "" + var2));
+			return Boolean.parseBoolean(this.getStringProperty(var1, String.valueOf(var2)));
 		} catch (Exception var4) {
-			this.serverProperties.setProperty(var1, "" + var2);
+			this.serverProperties.setProperty(var1, String.valueOf(var2));
 			return var2;
 		}
+	}
+
+	public long getSeedProperty(String var1) {
+		if (!this.serverProperties.containsKey(var1)) {
+			long seed = new Random().nextLong();
+			this.serverProperties.setProperty(var1, String.valueOf(seed));
+			this.saveProperties();
+			return seed;
+		}
+
+		String seed = this.serverProperties.getProperty(var1);
+		if (seed.isEmpty()) {
+			return new Random().nextLong();
+		}
+
+		try {
+			return Long.parseLong(seed);
+		} catch (Exception e) {
+			return seed.hashCode();
+		}
+	}
+
+	public CreateWorldInfo getCreateWorldInfo() {
+		return new CreateWorldInfo()
+			.withName(this.getStringProperty("level-display-name", "World"))
+			.withSeed(this.getSeedProperty("seed"))
+			.withWorldType(Arrays.stream(WorldType.values())
+					.filter(worldType -> worldType.getName().equalsIgnoreCase(this.getStringProperty("world-type", "normal")))
+					.findAny()
+					.orElse(WorldType.NORMAL))
+			.withCreative(this.getBooleanProperty("creative", false));
 	}
 }
--- net/minecraft/src/ClippingHelper.java
+++ net/minecraft/src/ClippingHelper.java
@@ -15,4 +15,24 @@
 
 		return true;
 	}
+
+	public boolean isBoxInFrustumFully(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
+		for(int i = 0; i < 6; ++i) {
+			float minXf = (float)minX;
+			float minYf = (float)minY;
+			float minZf = (float)minZ;
+			float maxXf = (float)maxX;
+			float maxYf = (float)maxY;
+			float maxZf = (float)maxZ;
+			if(i < 4) {
+				if(this.frustum[i][0] * minXf + this.frustum[i][1] * minYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F || this.frustum[i][0] * maxXf + this.frustum[i][1] * minYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F || this.frustum[i][0] * minXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F || this.frustum[i][0] * maxXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F || this.frustum[i][0] * minXf + this.frustum[i][1] * minYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F || this.frustum[i][0] * maxXf + this.frustum[i][1] * minYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F || this.frustum[i][0] * minXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F || this.frustum[i][0] * maxXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F) {
+					return false;
+				}
+			} else if(this.frustum[i][0] * minXf + this.frustum[i][1] * minYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F && this.frustum[i][0] * maxXf + this.frustum[i][1] * minYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F && this.frustum[i][0] * minXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F && this.frustum[i][0] * maxXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * minZf + this.frustum[i][3] <= 0.0F && this.frustum[i][0] * minXf + this.frustum[i][1] * minYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F && this.frustum[i][0] * maxXf + this.frustum[i][1] * minYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F && this.frustum[i][0] * minXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F && this.frustum[i][0] * maxXf + this.frustum[i][1] * maxYf + this.frustum[i][2] * maxZf + this.frustum[i][3] <= 0.0F) {
+				return false;
+			}
+		}
+
+		return true;
+	}
 }
--- net/minecraft/src/NBTBase.java
+++ net/minecraft/src/NBTBase.java
@@ -7,12 +7,14 @@
 public abstract class NBTBase {
 	private String key = null;
 
-	abstract void writeTagContents(DataOutput var1) throws IOException;
+	protected abstract void writeTagContents(DataOutput var1) throws IOException;
 
-	abstract void readTagContents(DataInput var1) throws IOException;
+	protected abstract void readTagContents(DataInput var1) throws IOException;
 
 	public abstract byte getType();
 
+	public abstract NBTBase copy();
+
 	public String getKey() {
 		return this.key == null ? "" : this.key;
 	}
@@ -66,6 +68,10 @@
 			return new NBTTagList();
 		case 10:
 			return new NBTTagCompound();
+		case 11:
+			return new NBTTagIntArray();
+		case 12:
+			return new NBTTagShortArray();
 		default:
 			return null;
 		}
@@ -95,6 +101,10 @@
 			return "TAG_List";
 		case 10:
 			return "TAG_Compound";
+		case 11:
+			return "TAG_Int_Array";
+		case 12:
+			return "TAG_Short_Array";
 		default:
 			return "UNKNOWN";
 		}
--- /dev/null
+++ net/minecraft/src/BenchmarkTimer.java
@@ -1,0 +1,52 @@
+package net.minecraft.src;
+
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class BenchmarkTimer {
+	private static Map<String, List<Long>> times = new HashMap<>();
+	private static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));
+
+	private final String name;
+	private final long startTime;
+
+	public BenchmarkTimer(String name) {
+		this.name = name;
+		this.startTime = System.nanoTime();
+	}
+
+	public void end() {
+		try {
+			long time = System.nanoTime() - this.startTime;
+			if (!times.containsKey(this.name)) {
+				times.put(this.name, new ArrayList<>());
+			}
+			times.get(this.name).add(time);
+			log.write("[BENCHMARK] " + this.name + ": " + time + "ns\n");
+			log.flush();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public static void printResults() {
+		if (times.size() == 0) return;
+
+		try {
+			System.out.println("=== BENCHMARKS ===");
+			for (Map.Entry<String, List<Long>> kv : times.entrySet()) {
+				List<Long> time = kv.getValue();
+				long mean = time.stream().mapToLong(x -> x).sum() / (long)time.size();
+				System.out.print(kv.getKey() + ": " + mean + "ns\n");
+			}
+			log.flush();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/ContainerCrate.java
@@ -1,0 +1,29 @@
+package net.minecraft.src;
+
+public class ContainerCrate extends Container {
+	private final IInventory inventory;
+
+	public ContainerCrate(IInventory var1, IInventory var2) {
+		this.inventory = var1;
+
+		int x;
+
+		for (x = 0; x < 9; x++) {
+			this.addSlot(new Slot(var2, x, 8 + x * 18, 18));
+		}
+
+		for(int y = 0; y < 3; ++y) {
+			for(x = 0; x < 9; ++x) {
+				this.addSlot(new Slot(var1, x + y * 9 + 9, 8 + x * 18, 50 + y * 18));
+			}
+		}
+
+		for(x = 0; x < 9; ++x) {
+			this.addSlot(new Slot(var1, x, 8 + x * 18, 108));
+		}
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return this.inventory.isNearPlayer(var1);
+	}
+}
--- /dev/null
+++ net/minecraft/src/ModLoaderRegistryClient.java
@@ -1,0 +1,72 @@
+package net.minecraft.src;
+
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.Objects;
+
+public class ModLoaderRegistryClient extends ModLoaderRegistry {
+	protected int nextBlockTex = 0;
+	protected int nextItemTex = 0;
+	
+	private final BufferedImage imgTerrain;
+	private final BufferedImage imgItems;
+
+	public ModLoaderRegistryClient() throws IOException {
+		imgTerrain = ImageIO.read(Objects.requireNonNull(RenderEngine.class.getResourceAsStream("/terrain.png")));
+		imgItems = ImageIO.read(Objects.requireNonNull(RenderEngine.class.getResourceAsStream("/gui/items.png")));
+	}
+
+	public void addAchievement(Achievement achievement) {
+		ModLoader.mc.achievements.updateMiscProgress(achievement);
+	}
+
+	public int addArmor(String name) {
+		RenderPlayer.armorFilenamePrefix.add(name);
+		return RenderPlayer.armorFilenamePrefix.size() - 1;
+	}
+
+	public int addBlockTexture(String path) {
+		while (textureOccupied(imgTerrain, nextBlockTex)) {
+			nextBlockTex++;
+			if (nextBlockTex >= 32 * 32) {
+				throw new RuntimeException("Ran out of block texture slots!");
+			}
+		}
+
+		return overrideWorldTexture(nextBlockTex, path, false) ? nextBlockTex : -1;
+	}
+
+	public int addItemTexture(String path) {
+		while (textureOccupied(imgItems, nextItemTex)) {
+			nextItemTex++;
+			if (nextItemTex >= 32 * 32) {
+				throw new RuntimeException("Ran out of item texture slots!");
+			}
+		}
+
+		return overrideWorldTexture(nextItemTex, path, true) ? nextItemTex : -1;
+	}
+
+	public boolean overrideWorldTexture(int index, String path, boolean isItem) {
+		try {
+			BufferedImage image = ModLoader.loadImage(path);
+			if (image.getWidth() != 16 || image.getHeight() != 16) {
+				throw new RuntimeException("Image \"" + path + "\" is not 16x16!");
+			}
+
+			ModTexture fx = new ModTexture(index, isItem, image);
+			ModLoader.mc.renderEngine.registerTextureFX(fx);
+			return true;
+		} catch (Exception e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private static boolean textureOccupied(BufferedImage img, int index) {
+		int x = index % 32 * 16;
+		int y = index / 32 * 16;
+		return (img.getRGB(x, y) & 0x00FFFFFF) != 0xFF00FF;
+	}
+}
--- net/minecraft/src/MovementInput.java
+++ net/minecraft/src/MovementInput.java
@@ -6,6 +6,7 @@
 	public boolean unused = false;
 	public boolean jump = false;
 	public boolean sneak = false;
+	public boolean run = false;
 
 	public void updatePlayerMoveState(EntityPlayer var1) {
 	}
--- /dev/null
+++ net/minecraft/src/RegionFile.java
@@ -1,0 +1,336 @@
+package net.minecraft.src;
+
+/*
+** 2011 January 5
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**/
+
+// Interfaces with region files on the disk
+
+/*
+
+Region File Format
+
+Concept: The minimum unit of storage on hard drives is 4KB. 90% of Minecraft
+ chunks are smaller than 4KB. 99% are smaller than 8KB. Write a simple
+ container to store chunks in single files in runs of 4KB sectors.
+
+Each region file represents a 32x32 group of chunks. The conversion from
+chunk number to region number is floor(coord / 32): a chunk at (30, -3)
+would be in region (0, -1), and one at (70, -30) would be at (3, -1).
+Region files are named "r.x.z.data", where x and z are the region coordinates.
+
+A region file begins with a 4KB header that describes where chunks are stored
+in the file. A 4-byte big-endian integer represents sector offsets and sector
+counts. The chunk offset for a chunk (x, z) begins at byte 4*(x+z*32) in the
+file. The bottom byte of the chunk offset indicates the number of sectors the
+chunk takes up, and the top 3 bytes represent the sector number of the chunk.
+Given a chunk offset o, the chunk data begins at byte 4096*(o/256) and takes up
+at most 4096*(o%256) bytes. A chunk cannot exceed 1MB in size. If a chunk
+offset is 0, the corresponding chunk is not stored in the region file.
+
+Chunk data begins with a 4-byte big-endian integer representing the chunk data
+length in bytes, not counting the length field. The length must be smaller than
+4096 times the number of sectors. The next byte is a version field, to allow
+backwards-compatible updates to how chunks are encoded.
+
+A version of 1 represents a gzipped NBT file. The gzipped data is the chunk
+length - 1.
+
+A version of 2 represents a deflated (zlib compressed) NBT file. The deflated
+data is the chunk length - 1.
+
+ */
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.InflaterInputStream;
+
+public class RegionFile {
+	private static final int CHUNK_HEADER_SIZE = 5;
+	private static final byte[] emptySector = new byte[4096];
+
+	private final File fileName;
+	private RandomAccessFile file;
+	private final int[] offsets;
+	private final int[] chunkTimestamps;
+	private ArrayList<Boolean> sectorFree;
+	private int sizeDelta;
+	private long lastModified = 0;
+
+	public RegionFile(File path) {
+		offsets = new int[1024];
+		chunkTimestamps = new int[1024];
+
+		fileName = path;
+		debugln("REGION LOAD " + fileName);
+
+		sizeDelta = 0;
+
+		try {
+			if (path.exists())
+				lastModified = path.lastModified();
+
+			file = new RandomAccessFile(path, "rw");
+
+			if (file.length() < 4096) {
+				/* we need to write the chunk offset table */
+				for (int i = 0; i < 1024; ++i)
+					file.writeInt(0);
+
+				for (int i = 0; i < 1024; ++i)
+					file.writeInt(0);
+
+				sizeDelta += 8192;
+			}
+
+			if ((file.length() & 0xfff) != 0) {
+				/* the file size is not a multiple of 4KB, grow it */
+				for (int i = 0; i < (file.length() & 0xfff); ++i)
+					file.write(0);
+			}
+
+			/* set up the available sector map */
+			int nSectors = (int)file.length() / 4096;
+			sectorFree = new ArrayList<Boolean>(nSectors);
+
+			for (int i = 0; i < nSectors; ++i) {
+				sectorFree.add(true);
+			}
+
+			sectorFree.set(0, false); // chunk offset table
+			sectorFree.set(1, false); // chunk timestamp table
+
+			file.seek(0);
+
+			for (int i = 0; i < 1024; ++i) {
+				int offset = file.readInt();
+				offsets[i] = offset;
+				if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.size()) {
+					for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {
+						sectorFree.set((offset >> 8) + sectorNum, false);
+					}
+				}
+			}
+
+			for (int i = 0; i < 1024; ++i) {
+				int timestamp = file.readInt();
+				chunkTimestamps[i] = timestamp;
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	/* the modification date of the region file when it was first opened */
+	public long lastModified() {
+		return lastModified;
+	}
+
+	/* gets how much the region file has grown since it was last checked */
+	public synchronized int getSizeDelta() {
+		int ret = sizeDelta;
+		sizeDelta = 0;
+		return ret;
+	}
+
+	// various small debug printing helpers
+	private void debug(String in) {
+		//System.out.print(in);
+	}
+
+	private void debugln(String in) {
+		debug(in + "\n");
+	}
+
+	private void debug(String mode, int x, int z, String in) {
+		debug("REGION " + mode + " " + fileName.getName() + "[" + x + "," + z + "] = " + in);
+	}
+
+	private void debug(String mode, int x, int z, int count, String in) {
+		debug("REGION " + mode + " " + fileName.getName() + "[" + x + "," + z + "] " + count + "B = " + in);
+	}
+
+	private void debugln(String mode, int x, int z, String in) {
+		debug(mode, x, z, in + "\n");
+	}
+
+	/* gets an (uncompressed) stream representing the chunk data
+	   returns null if the chunk is not found or an error occurs  */
+	public synchronized DataInputStream getChunkDataInputStream(int x, int z) {
+		if (outOfBounds(x, z)) {
+			debugln("READ", x, z, "out of bounds");
+			return null;
+		}
+
+		try {
+			int offset = getOffset(x, z);
+			if (offset == 0) {
+				// debugln("READ", x, z, "miss");
+				return null;
+			}
+
+			int sectorNumber = offset >> 8;
+			int numSectors = offset & 0xFF;
+
+			if (sectorNumber + numSectors > sectorFree.size()) {
+				debugln("READ", x, z, "invalid sector");
+				return null;
+			}
+
+			file.seek(sectorNumber * 4096);
+			int length = file.readInt();
+
+			if (length > 4096 * numSectors) {
+				debugln("READ", x, z, "invalid length: " + length + " > 4096 * " + numSectors);
+				return null;
+			}
+
+			byte version = file.readByte();
+			if (version == 1) {
+				byte[] data = new byte[length - 1];
+				file.read(data);
+				DataInputStream ret = new DataInputStream(new GZIPInputStream(
+						new ByteArrayInputStream(data)
+				));
+				// debug("READ", x, z, " = found");
+				return ret;
+			} else if (version == 2) {
+			   byte[] data = new byte[length - 1];
+				file.read(data);
+				DataInputStream ret = new DataInputStream(new InflaterInputStream(
+						new ByteArrayInputStream(data)
+				));
+				// debug("READ", x, z, " = found");
+				return ret;
+			}
+
+			debugln("READ", x, z, "unknown version " + version);
+			return null;
+		} catch (IOException e) {
+			debugln("READ", x, z, "exception");
+			return null;
+		}
+	}
+
+	public DataOutputStream getChunkDataOutputStream(int x, int z) {
+		if (outOfBounds(x, z))
+			return null;
+
+		return new DataOutputStream(new DeflaterOutputStream(
+										new ChunkBuffer(this, x, z)));
+	}
+
+	/* write a chunk at (x,z) with length bytes of data to disk */
+	protected synchronized void write(int x, int z, byte[] data, int length) {
+		try {
+			int offset = getOffset(x, z);
+			int sectorNumber = offset >> 8;
+			int sectorsAllocated = offset & 0xFF;
+			int sectorsNeeded = (length + CHUNK_HEADER_SIZE) / 4096 + 1;
+
+			if (sectorsNeeded >= 256) // maximum chunk size is 1MB
+				return;
+
+			if (sectorNumber != 0 && sectorsAllocated == sectorsNeeded) {
+				/* we can simply overwrite the old sectors */
+				debug("SAVE", x, z, length, "rewrite");
+				write(sectorNumber, data, length);
+			} else {
+				/* we need to allocate new sectors */
+
+				/* mark the sectors previously used for this chunk as free */
+				for (int i = 0; i < sectorsAllocated; ++i)
+					sectorFree.set(sectorNumber + i, true);
+
+				/* scan for a free space large enough to store this chunk */
+				int runStart = sectorFree.indexOf(true);
+				int runLength = 0;
+				if (runStart != -1) {
+					for (int i = runStart; i < sectorFree.size(); ++i) {
+						if (runLength != 0) {
+							if (sectorFree.get(i))
+								runLength++;
+							else
+								runLength = 0;
+						} else if (sectorFree.get(i)) {
+							runStart = i;
+							runLength = 1;
+						}
+						if (runLength >= sectorsNeeded)
+							break;
+					}
+				}
+
+				if (runLength >= sectorsNeeded) {
+					/* we found a free space large enough */
+					debug("SAVE", x, z, length, "reuse");
+					sectorNumber = runStart;
+					setOffset(x, z, (runStart << 8) | sectorsNeeded);
+					for (int i = 0; i < sectorsNeeded; ++i)
+						sectorFree.set(sectorNumber + i, false);
+					write(sectorNumber, data, length);
+				} else {
+					/* no free space large enough found -- we need to grow the file */
+					debug("SAVE", x, z, length, "grow");
+					file.seek(file.length());
+					sectorNumber = sectorFree.size();
+					for (int i = 0; i < sectorsNeeded; ++i) {
+						file.write(emptySector);
+						sectorFree.add(false);
+					}
+					sizeDelta += 4096 * sectorsNeeded;
+
+					write(sectorNumber, data, length);
+					setOffset(x, z, (sectorNumber << 8) | sectorsNeeded);
+				}
+			}
+
+			setTimestamp(x, z, (int)(System.currentTimeMillis() / 1000L));
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	/* write a chunk data to the region file at specified sector number */
+	private void write(int sectorNumber, byte[] data, int length) throws IOException {
+		debugln(" " + sectorNumber);
+		file.seek(sectorNumber * 4096);
+		file.writeInt(length + 1);   // chunk length
+		file.writeByte(2);          // chunk version number
+		file.write(data, 0, length); // chunk data
+	}
+
+	/* is this an invalid chunk coordinate? */
+	private boolean outOfBounds(int x, int z) {
+		return x < 0 || x >= 32 || z < 0 || z >= 32;
+	}
+
+	private int getOffset(int x, int z) {
+		return offsets[x + z * 32];
+	}
+
+	private void setOffset(int x, int z, int offset) throws IOException {
+		offsets[x + z * 32] = offset;
+		file.seek((x + z * 32) * 4);
+		file.writeInt(offset);
+	}
+
+	private void setTimestamp(int x, int z, int timestamp) throws IOException {
+		chunkTimestamps[x + z * 32] = timestamp;
+		file.seek(4096 + (x + z * 32) * 4);
+		file.writeInt(timestamp);
+	}
+
+	public void close() throws IOException {
+		file.close();
+	}
+}
--- net/minecraft/src/EntityBoat.java
+++ net/minecraft/src/EntityBoat.java
@@ -46,20 +46,16 @@
 	}
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
-		this.forwardDirection = -this.forwardDirection;
-		this.timeSinceHit = 10;
-		this.damageTaken += var2 * 10;
-		if(this.damageTaken > 40) {
-			int var3;
-			for(var3 = 0; var3 < 3; ++var3) {
-				this.entityDropItem(Block.planks.blockID, 1, 0.0F);
-			}
-
-			for(var3 = 0; var3 < 2; ++var3) {
-				this.entityDropItem(Item.stick.shiftedIndex, 1, 0.0F);
-			}
-
-			this.setEntityDead();
+		if (this.worldObj.canDoClientAction() && !this.isDead) {
+			this.forwardDirection = -this.forwardDirection;
+			this.timeSinceHit = 10;
+			this.damageTaken += var2 * 10;
+			if(this.damageTaken > 40) {
+				int var3;
+
+				this.entityDropItem(Item.boat.shiftedIndex, 1, 0.0F);
+				this.setEntityDead();
+			}
 		}
 
 		return true;
@@ -97,11 +93,11 @@
 		double var23 = var2 * 2.0D - 1.0D;
 		this.motionY += (double)0.04F * var23;
 		if(this.riddenByEntity != null) {
-			this.motionX += this.riddenByEntity.motionX * 0.2D;
-			this.motionZ += this.riddenByEntity.motionZ * 0.2D;
+			this.motionX += this.riddenByEntity.motionX * 0.5D;
+			this.motionZ += this.riddenByEntity.motionZ * 0.5D;
 		}
 
-		double var6 = 0.4D;
+		double var6 = 1.5D;
 		if(this.motionX < -var6) {
 			this.motionX = -var6;
 		}
@@ -150,16 +146,8 @@
 		}
 
 		if(this.isCollidedHorizontally && var8 > 0.15D) {
-			this.setEntityDead();
-
-			int var24;
-			for(var24 = 0; var24 < 3; ++var24) {
-				this.entityDropItem(Block.planks.blockID, 1, 0.0F);
-			}
-
-			for(var24 = 0; var24 < 2; ++var24) {
-				this.entityDropItem(Item.stick.shiftedIndex, 1, 0.0F);
-			}
+			this.motionX = 0.0D;
+			this.motionZ = 0.0D;
 		} else {
 			this.motionX *= (double)0.99F;
 			this.motionY *= (double)0.95F;
@@ -208,10 +196,12 @@
 
 	}
 
-	protected void updateRiderPosition() {
-		double var1 = Math.cos((double)this.rotationYaw * Math.PI / 180.0D) * 0.4D;
-		double var3 = Math.sin((double)this.rotationYaw * Math.PI / 180.0D) * 0.4D;
-		this.riddenByEntity.setPosition(this.posX + var1, this.posY + this.getMountedYOffset() + this.riddenByEntity.getYOffset(), this.posZ + var3);
+	public void updateRiderPosition() {
+		if (this.riddenByEntity != null) {
+			double var1 = Math.cos((double)this.rotationYaw * Math.PI / 180.0D) * 0.4D;
+			double var3 = Math.sin((double)this.rotationYaw * Math.PI / 180.0D) * 0.4D;
+			this.riddenByEntity.setPosition(this.posX + var1, this.posY + this.getMountedYOffset() + this.riddenByEntity.getYOffset(), this.posZ + var3);
+		}
 	}
 
 	protected void writeEntityToNBT(NBTTagCompound var1) {
@@ -225,7 +215,12 @@
 	}
 
 	public boolean interact(EntityPlayer var1) {
-		var1.mountEntity(this);
+		if (this.riddenByEntity != null && this.riddenByEntity instanceof EntityPlayer && this.riddenByEntity != var1) {
+			return true;
+		}
+		if (this.worldObj.canDoClientAction()) {
+			var1.mountEntity(this);
+		}
 		return true;
 	}
 }
--- net/minecraft/src/ChunkProviderGenerate.java
+++ net/minecraft/src/ChunkProviderGenerate.java
@@ -1,63 +1,86 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_BIT_OFFSET;
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.util.Random;
 
 public class ChunkProviderGenerate implements IChunkProvider {
 	private Random rand;
+	private final long seed;
+	private final long seedLandHeight;
+	private final long seedHills;
+	private final long seedOcean;
+	private final long seedRiver;
+	private final boolean classic;
+	private final boolean amplified;
+	private final boolean superflat;
 	private NoiseGeneratorOctaves noiseGen1;
 	private NoiseGeneratorOctaves noiseGen2;
 	private NoiseGeneratorOctaves noiseGen3;
-	private NoiseGeneratorOctaves noiseGen4;
-	private NoiseGeneratorOctaves noiseGen5;
 	public NoiseGeneratorOctaves noiseGen6;
 	public NoiseGeneratorOctaves noiseGen7;
 	public NoiseGeneratorOctaves mobSpawnerNoise;
 	private World worldObj;
 	private double[] noiseArray;
-	private double[] sandNoise = new double[256];
-	private double[] gravelNoise = new double[256];
-	private double[] stoneNoise = new double[256];
+	private double[] uwnoiseArray;
 	private MapGenBase caveGenerator = new MapGenCaves();
+	private MapGenBase underworldCaveGenerator = new MapGenUnderworldCaves();
 	double[] noise3;
 	double[] noise1;
 	double[] noise2;
 	double[] noise6;
 	double[] noise7;
+	double[] uwnoise3;
+	double[] uwnoise1;
+	double[] uwnoise2;
+	double[] uwnoise6;
+	double[] uwnoise7;
 	int[][] unused = new int[32][32];
 
 	public ChunkProviderGenerate(World var1, long var2) {
 		this.worldObj = var1;
 		this.rand = new Random(var2);
+		this.seed = var2;
+		this.seedLandHeight = this.rand.nextLong();
+		this.seedHills = this.rand.nextLong();
+		this.seedOcean = this.rand.nextLong();
+		this.seedRiver = this.rand.nextLong();
+		this.classic = var1 != null && var1.worldType == WorldType.CLASSIC;
+		this.amplified = var1 != null && var1.worldType == WorldType.AMPLIFIED;
+		this.superflat = var1 != null && var1.worldType == WorldType.SUPERFLAT;
 		this.noiseGen1 = new NoiseGeneratorOctaves(this.rand, 16);
 		this.noiseGen2 = new NoiseGeneratorOctaves(this.rand, 16);
 		this.noiseGen3 = new NoiseGeneratorOctaves(this.rand, 8);
-		this.noiseGen4 = new NoiseGeneratorOctaves(this.rand, 4);
-		this.noiseGen5 = new NoiseGeneratorOctaves(this.rand, 4);
 		this.noiseGen6 = new NoiseGeneratorOctaves(this.rand, 10);
 		this.noiseGen7 = new NoiseGeneratorOctaves(this.rand, 16);
-		this.mobSpawnerNoise = new NoiseGeneratorOctaves(this.rand, 8);
+		this.mobSpawnerNoise = new NoiseGeneratorOctaves(this.rand, 1);
 	}
 
-	public void generateTerrain(int var1, int var2, byte[] var3) {
+	public void generateTerrain(int var1, int var2, short[] var3, byte[] biomes) {
+		byte height = (byte)(this.classic ? 24 : 32);
 		byte var4 = 4;
-		byte var5 = 64;
+		short var5 = 128;
 		int var6 = var4 + 1;
-		byte var7 = 17;
+		byte var7 = (byte)(this.classic ? 17 : 25);
 		int var8 = var4 + 1;
 		this.noiseArray = this.initializeNoiseField(this.noiseArray, var1 * var4, 0, var2 * var4, var6, var7, var8);
 
 		for(int var9 = 0; var9 < var4; ++var9) {
 			for(int var10 = 0; var10 < var4; ++var10) {
-				for(int var11 = 0; var11 < 16; ++var11) {
+				for(int var11 = 0; var11 < height; ++var11) {
 					double var12 = 0.125D;
-					double var14 = this.noiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 + 0];
-					double var16 = this.noiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 + 0];
-					double var18 = this.noiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 + 0];
-					double var20 = this.noiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 + 0];
-					double var22 = (this.noiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 + 1] - var14) * var12;
-					double var24 = (this.noiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 + 1] - var16) * var12;
-					double var26 = (this.noiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 + 1] - var18) * var12;
-					double var28 = (this.noiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 + 1] - var20) * var12;
+					double var14 = 0, var16 = 0, var18 = 0, var20 = 0, var22 = 0, var24 = 0, var26 = 0, var28 = 0;
+					if (var11 >= 8) {
+						var14 = this.noiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 - 8];
+						var16 = this.noiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 - 8];
+						var18 = this.noiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 - 8];
+						var20 = this.noiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 - 8];
+						var22 = (this.noiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 - 7] - var14) * var12;
+						var24 = (this.noiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 - 7] - var16) * var12;
+						var26 = (this.noiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 - 7] - var18) * var12;
+						var28 = (this.noiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 - 7] - var20) * var12;
+					}
 
 					for(int var30 = 0; var30 < 8; ++var30) {
 						double var31 = 0.25D;
@@ -67,128 +90,304 @@
 						double var39 = (var20 - var16) * var31;
 
 						for(int var41 = 0; var41 < 4; ++var41) {
-							int var42 = var41 + var9 * 4 << 11 | 0 + var10 * 4 << 7 | var11 * 8 + var30;
-							short var43 = 128;
+							int var42 = var41 + var9 * 4 << CHUNK_BIT_OFFSET + 4 | 0 + var10 * 4 << CHUNK_BIT_OFFSET | var11 * 8 + var30;
 							double var44 = 0.25D;
 							double var46 = var33;
 							double var48 = (var35 - var33) * var44;
 
 							for(int var50 = 0; var50 < 4; ++var50) {
+								byte biome = biomes[(var10 * 4 + var50) << 4 | (var9 * 4) + var41];
+
 								int var51 = 0;
 								if(var11 * 8 + var30 < var5) {
-									if(this.worldObj.snowCovered && var11 * 8 + var30 >= var5 - 1) {
+									if (Biome.biomesList[biome].isSnowy() && var11 * 8 + var30 == var5 - 1) {
 										var51 = Block.ice.blockID;
-									} else {
+									} else if (this.worldObj.worldType != WorldType.ARID) {
 										var51 = Block.waterStill.blockID;
 									}
 								}
 
-								if(var46 > 0.0D) {
-									var51 = Block.stone.blockID;
-								}
-
-								var3[var42] = (byte)var51;
-								var42 += var43;
-								var46 += var48;
-							}
-
-							var33 += var37;
-							var35 += var39;
-						}
-
-						var14 += var22;
-						var16 += var24;
-						var18 += var26;
-						var20 += var28;
-					}
-				}
-			}
-		}
-
-	}
-
-	public void replaceSurfaceBlocks(int var1, int var2, byte[] var3) {
-		byte var4 = 64;
-		double var5 = 1.0D / 32.0D;
-		this.sandNoise = this.noiseGen4.generateNoiseOctaves(this.sandNoise, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var5, var5, 1.0D);
-		this.gravelNoise = this.noiseGen4.generateNoiseOctaves(this.gravelNoise, (double)(var2 * 16), 109.0134D, (double)(var1 * 16), 16, 1, 16, var5, 1.0D, var5);
-		this.stoneNoise = this.noiseGen5.generateNoiseOctaves(this.stoneNoise, (double)(var1 * 16), (double)(var2 * 16), 0.0D, 16, 16, 1, var5 * 2.0D, var5 * 2.0D, var5 * 2.0D);
+								if(var46 > 0.0D || var11 < 8) {
+									var51 = Block.stone.blockID;
+								}
+
+								var3[var42] = (short)var51;
+								var42 += (short)CHUNK_HEIGHT;
+								var46 += var48;
+							}
+
+							var33 += var37;
+							var35 += var39;
+						}
+
+						var14 += var22;
+						var16 += var24;
+						var18 += var26;
+						var20 += var28;
+					}
+				}
+			}
+		}
+	}
+
+	public void generateSuperflat(short[] var1) {
+		for (int x = 0; x < 16; x++) {
+			for (int z = 0; z < 16; z++) {
+				for (int y = 0; y < CHUNK_HEIGHT; y++) {
+					int offset = x << CHUNK_BIT_OFFSET + 4 | z << CHUNK_BIT_OFFSET | y;
+					var1[offset] = (short)(y == 0 ? 7
+							: y < 60 ? 1
+							: y < 63 ? 3
+							: y == 63 ? 2
+							: 0);
+				}
+			}
+		}
+	}
+
+	public void generateUnderworld(int var1, int var2, short[] var3) {
+		byte var4 = 4;
+		int var6 = var4 + 1;
+		byte var7 = 9;
+		int var8 = var4 + 1;
+		this.uwnoiseArray = this.initializeUnderworldNoiseField(this.uwnoiseArray, var1 * var4, 0, var2 * var4, var6, var7, var8);
+
+		for(int var9 = 0; var9 < var4; ++var9) {
+			for(int var10 = 0; var10 < var4; ++var10) {
+				for(int var11 = 0; var11 < 4; ++var11) {
+					double var12 = 0.125D;
+					double var14, var16, var18, var20, var22, var24, var26, var28;
+					var14 = this.uwnoiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 + 2];
+					var16 = this.uwnoiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 + 2];
+					var18 = this.uwnoiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 + 2];
+					var20 = this.uwnoiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 + 2];
+					var22 = (this.uwnoiseArray[((var9 + 0) * var8 + var10 + 0) * var7 + var11 + 3] - var14) * var12;
+					var24 = (this.uwnoiseArray[((var9 + 0) * var8 + var10 + 1) * var7 + var11 + 3] - var16) * var12;
+					var26 = (this.uwnoiseArray[((var9 + 1) * var8 + var10 + 0) * var7 + var11 + 3] - var18) * var12;
+					var28 = (this.uwnoiseArray[((var9 + 1) * var8 + var10 + 1) * var7 + var11 + 3] - var20) * var12;
+
+					for(int var30 = 0; var30 < 8; ++var30) {
+						double var31 = 0.25D;
+						double var33 = var14;
+						double var35 = var16;
+						double var37 = (var18 - var14) * var31;
+						double var39 = (var20 - var16) * var31;
+
+						for(int var41 = 0; var41 < 4; ++var41) {
+							int var42 = var41 + var9 * 4 << CHUNK_BIT_OFFSET + 4 | 0 + var10 * 4 << CHUNK_BIT_OFFSET | var11 * 8 + var30;
+							double var44 = 0.25D;
+							double var46 = var33;
+							double var48 = (var35 - var33) * var44;
+
+							for(int var50 = 0; var50 < 4; ++var50) {
+								int var51 = 0;
+								if(var46 > 0.0D || var11 == 7) {
+									var51 = Block.stone.blockID;
+								}
+
+								var3[var42] = (short)var51;
+								var42 += (short) CHUNK_HEIGHT;
+								var46 += var48;
+							}
+
+							var33 += var37;
+							var35 += var39;
+						}
+
+						var14 += var22;
+						var16 += var24;
+						var18 += var26;
+						var20 += var28;
+					}
+				}
+			}
+		}
+	}
+
+	public void replaceSurfaceBlocks(int var1, int var2, short[] var3, byte[] metadata, byte[] biomes) {
+		short var4 = 128;
 
 		for(int var7 = 0; var7 < 16; ++var7) {
 			for(int var8 = 0; var8 < 16; ++var8) {
-				boolean var9 = this.sandNoise[var7 + var8 * 16] + this.rand.nextDouble() * 0.2D > 0.0D;
-				boolean var10 = this.gravelNoise[var7 + var8 * 16] + this.rand.nextDouble() * 0.2D > 3.0D;
-				int var11 = (int)(this.stoneNoise[var7 + var8 * 16] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);
+				Biome biome = Biome.biomesList[biomes[var8 << 4 | var7]];
+				if (biome == null) {
+					biome = Biome.forest;
+				}
+
+				boolean var9 = !this.classic || SimplexOctaves.noise2(seed, (var7 + var1 * 16) * 0.01D, (var8 + var2 * 16) * 0.01D, 4)
+						+ this.rand.nextFloat() * 0.2F > 0.0F;
+				boolean var10 = SimplexOctaves.noise3_ImproveXY(seed,
+						(var7 + var1 * 16) / 200.0D, (var8 + var2 * 16) / 200.0D, 109.0134D, 4)
+						+ this.rand.nextFloat() * 0.1F > 0.7F;
+				float var11 = SimplexOctaves.noise2(seed, (var7 + var1 * 16) / 200.0D, (var8 + var2 * 16) / 200.0D, 4)
+						* 3.0F + 3.0F + this.rand.nextFloat() * 0.5F;
+
 				int var12 = -1;
-				byte var13 = (byte)Block.grass.blockID;
-				byte var14 = (byte)Block.dirt.blockID;
-
-				for(int var15 = 127; var15 >= 0; --var15) {
-					int var16 = (var7 * 16 + var8) * 128 + var15;
-					if(var15 <= 0 + this.rand.nextInt(6) - 1) {
-						var3[var16] = (byte)Block.bedrock.blockID;
-					} else {
-						byte var17 = var3[var16];
-						if(var17 == 0) {
-							var12 = -1;
-						} else if(var17 == Block.stone.blockID) {
-							if(var12 == -1) {
-								if(var11 <= 0) {
-									var13 = 0;
-									var14 = (byte)Block.stone.blockID;
-								} else if(var15 >= var4 - 4 && var15 <= var4 + 1) {
-									var13 = (byte)Block.grass.blockID;
-									var14 = (byte)Block.dirt.blockID;
-									if(var10) {
-										var13 = 0;
-									}
-
-									if(var10) {
-										var14 = (byte)Block.gravel.blockID;
-									}
-
-									if(var9) {
-										var13 = (byte)Block.sand.blockID;
-									}
-
-									if(var9) {
-										var14 = (byte)Block.sand.blockID;
-									}
-								}
-
-								if(var15 < var4 && var13 == 0) {
-									var13 = (byte)Block.waterStill.blockID;
-								}
-
-								var12 = var11;
-								if(var15 >= var4 - 1) {
-									var3[var16] = var13;
-								} else {
-									var3[var16] = var14;
-								}
-							} else if(var12 > 0) {
-								--var12;
+				short var13 = (short)biome.getSurface().blockID;
+				short var14 = (short)biome.getSoil().blockID;
+
+				for(int var15 = 255; var15 >= 64; --var15) {
+					int var16 = var7 << CHUNK_BIT_OFFSET + 4 | var8 << CHUNK_BIT_OFFSET | var15;
+					short var17 = var3[var16];
+					if(var17 == 0) {
+						var12 = -1;
+					} else if(var17 == Block.stone.blockID) {
+						int stoneMetadata = biome.getStoneMetadata();
+						if(var15 <= 80 - this.rand.nextInt(8)) {
+							metadata[var16] = 2;
+						} else if(var12 == -1) {
+							if(var11 <= Math.max((var15 - 160) / 24.0F, 0.0F)) {
+								var13 = 0;
+								var14 = (short)Block.stone.blockID;
+							} else if(var15 >= var4 - 4 && var15 <= var4 + 1 + this.rand.nextInt(1)) {
+								var13 = (short)biome.getSurface().blockID;
+								var14 = (short)biome.getSoil().blockID;
+
+								if(var9) {
+									var13 = (short)Block.sand.blockID;
+									var14 = (short)Block.sand.blockID;
+								}
+
+								if(var10) {
+									var13 = var15 < var4 ? (short)Block.gravel.blockID : 0;
+									var14 = (short)Block.gravel.blockID;
+								}
+							}
+
+							if(var15 < var4 && var13 == 0 && this.worldObj.worldType != WorldType.ARID) {
+								var13 = (byte)(biome.isSnowy() ? Block.ice : Block.waterStill).blockID;
+							}
+
+							var12 = Math.max((int)var11, 0);
+							if(var15 >= var4 - 1) {
+								var3[var16] = var13;
+								if (var13 == biome.getSurface().blockID) {
+									metadata[var16] = (byte)biome.getSurfaceMetadata();
+								}
+							} else {
 								var3[var16] = var14;
+								if (var14 == 1) {
+									metadata[var16] = (byte)biome.getStoneMetadata();
+								}
 							}
-						}
-					}
-				}
-			}
-		}
-
+						} else if(var12 > 0) {
+							--var12;
+							var3[var16] = var14;
+						} else if(stoneMetadata != 0) {
+							metadata[var16] = (byte)stoneMetadata;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public void replaceUnderworldBlocks(int var1, int var2, short[] var3, byte[] metadata) {
+		for (int x = 0; x < 16; x++) {
+			for (int z = 0; z < 16; z++) {
+				for (int y = 0; y < 64; y++) {
+					int offset = (x * 16 + z) * CHUNK_HEIGHT + y;
+					short block = 0;
+					byte meta = 0;
+
+					if (y >= 32) {
+						meta = 2;
+
+						if (y <= this.rand.nextInt(3) + 32) {
+							block = (short)Block.obsidian.blockID;
+							meta = 0;
+						}
+					} else {
+						meta = 4;
+
+						if (y >= 32 - this.rand.nextInt(3)) {
+							block = (short)Block.obsidian.blockID;
+							meta = 0;
+						}
+
+						if (y <= this.rand.nextInt(4)) {
+							block = (short)Block.bedrock.blockID;
+						}
+					}
+
+					if (block == 0 && var3[offset] == 1) {
+						block = 1;
+					}
+
+					if (block != 0) {
+						var3[offset] = block;
+						metadata[offset] = meta;
+					}
+				}
+			}
+		}
 	}
 
 	public Chunk provideChunk(int var1, int var2) {
+		BlockSand.fallInstantly = true;
 		this.rand.setSeed((long)var1 * 341873128712L + (long)var2 * 132897987541L);
-		byte[] var3 = new byte[-Short.MIN_VALUE];
-		Chunk var4 = new Chunk(this.worldObj, var3, var1, var2);
-		this.generateTerrain(var1, var2, var3);
-		this.replaceSurfaceBlocks(var1, var2, var3);
-		this.caveGenerator.generate(this, this.worldObj, var1, var2, var3);
+		Chunk var4 = new Chunk(this.worldObj, new short[65536], var1, var2);
+		var4.generateBiomes(this.worldObj);
+		if (this.superflat) {
+			this.generateSuperflat(var4.blocks);
+		} else {
+			this.generateTerrain(var1, var2, var4.blocks, var4.biomes);
+			this.generateUnderworld(var1, var2, var4.blocks);
+			this.replaceSurfaceBlocks(var1, var2, var4.blocks, var4.data, var4.biomes);
+			this.replaceUnderworldBlocks(var1, var2, var4.blocks, var4.data);
+			this.caveGenerator.generate(this, this.worldObj, var1, var2, var4.blocks);
+			this.underworldCaveGenerator.generate(this, this.worldObj, var1, var2, var4.blocks);
+		}
 		var4.generateSkylightMap();
+		BlockSand.fallInstantly = false;
 		return var4;
 	}
 
+	private double getLandHeight(int x, int z) {
+		return SimplexOctaves.noise2(this.seedLandHeight, x / 150.0D, z / 150.0D, 8) / 4.0D;
+	}
+
+	private double getHills(int x, int z) {
+		return SimplexNoise.noise2(this.seedHills, x / 200.0D, z / 200.0D);
+	}
+
+	private double getOcean(double x, double z) {
+		double ocean = (SimplexOctaves.noise2(this.seedOcean, x / 200.0D, z / 200.0D, 8) - 0.2D);
+		if (ocean < 0.0D) {
+			ocean *= 3.0D;
+		}
+		if (Math.abs(ocean) < 1.0D) {
+			ocean *= ocean * Math.signum(ocean);
+		}
+		return MathHelper.clamp(ocean, -1.0D, 1.0D);
+	}
+
+	private double getRiver(double x, double z) {
+//		double riverNoise = this.classic ? 0.0D : Math.min(Math.abs(SimplexOctaves.noise2(this.seedRiver, x / 350.0D, z / 350.0D, 1))
+//					- Math.max(SimplexNoise.noise2(~this.seedRiver, x / 25.0D, z / 25.0D), 0.0D) * 0.08D, 1.0F);
+//		return this.classic ? 0.0D : MathHelper.clamp((Math.cos(Math.min(riverNoise * 20.0D, Math.PI)) + 1.0D) / 2.0D, 0.0D, 1.0D);
+		return 0.0D;
+	}
+
+	public String[] getDebugInfo(int x, int y, int z) {
+		int nx = x >> 2;
+		int nz = z >> 2;
+		return new String[] {
+				"LH: " + MathHelper.formatDouble(this.getLandHeight(nx, nz))
+				+ ". H: " + MathHelper.formatDouble(this.getHills(nx, nz)),
+				"O: " + MathHelper.formatDouble(this.getOcean(nx, nz))
+				+ ". R: " + MathHelper.formatDouble(this.getRiver(nx, nz))
+		};
+	}
+
+	public boolean isOcean(int x, int z) {
+		return !this.superflat && !this.classic && this.getOcean(x / 4.0D, z / 4.0D) >= 0.0D;
+	}
+
+	public boolean isRiver(int x, int z) {
+		return !this.superflat && !this.classic && this.getRiver(x / 4.0D, z / 4.0D) > 0.0D;
+	}
+
 	private double[] initializeNoiseField(double[] var1, int var2, int var3, int var4, int var5, int var6, int var7) {
 		if(var1 == null) {
 			var1 = new double[var5 * var6 * var7];
@@ -204,45 +403,77 @@
 		int var12 = 0;
 		int var13 = 0;
 
-		for(int var14 = 0; var14 < var5; ++var14) {
-			for(int var15 = 0; var15 < var7; ++var15) {
-				double var16 = (this.noise6[var13] + 256.0D) / 512.0D;
-				if(var16 > 1.0D) {
-					var16 = 1.0D;
-				}
-
-				double var18 = 0.0D;
-				double var20 = this.noise7[var13] / 8000.0D;
-				if(var20 < 0.0D) {
-					var20 = -var20;
-				}
-
-				var20 = var20 * 3.0D - 3.0D;
-				if(var20 < 0.0D) {
-					var20 /= 2.0D;
-					if(var20 < -1.0D) {
-						var20 = -1.0D;
-					}
-
-					var20 /= 1.4D;
-					var20 /= 2.0D;
+		for(int x = 0; x < var5; ++x) {
+			for(int z = 0; z < var7; ++z) {
+				double var16;
+				double var20;
+
+				if (this.classic) {
+					var16 = (this.noise6[var13] + 256.0D) / 512.0D;
+					if(var16 > 1.0D) {
+						var16 = 1.0D;
+					}
+
+					var20 = this.noise7[var13] / 8000.0D;
+					if(var20 < 0.0D) {
+						var20 = -var20;
+					}
+
+					var20 = var20 * 3.0D - 2.0D;
+					if(var20 < 0.0D) {
+						var20 /= 2.0D;
+						if(var20 < -1.0D) {
+							var20 = -1.0D;
+						}
+
+						var20 /= 1.4D;
+						var20 /= 2.0D;
+						var16 = 0.0D;
+					} else {
+						if(var20 > 1.0D) {
+							var20 = 1.0D;
+						}
+
+						var20 /= 6.0D;
+					}
+				} else {
+					double height = this.getLandHeight(x + var2, z + var4);
+					double hills = this.getHills(x + var2, z + var4);
+					double ocean = this.getOcean(x + var2, z + var4);
+					double river = this.getRiver(x + var2, z + var4);
+
+					var16 = 0.5D + Math.max(hills * 0.5D, -0.3D);
+					var20 = height + 0.15D;
+					var20 *= Math.max(-ocean, -0.5D);
+					var20 -= MathHelper.clamp(ocean + 0.15D, 0.0D, 0.75D);
+					var16 += Math.max(var20, 0.0D) * 2.0D * Math.max(-ocean, 0.0D);
+					var16 -= 0.1D;
+					var16 *= Math.max(-ocean, 0.01D);
+					var16 += 0.1D;
+					var16 *= 1.0D - river * 0.99D;
+					if (var20 > -0.5D) {
+						var20 = MathHelper.lerp(var20, -0.5D, river);
+					}
+					var16 -= 0.5D;
+
+					if (this.amplified) {
+						var16 += 1.0D;
+						var16 *= 4.0D;
+						var20 *= 4.0D;
+					}
+				}
+
+				if (this.classic && var16 < 0.0D) {
 					var16 = 0.0D;
-				} else {
-					if(var20 > 1.0D) {
-						var20 = 1.0D;
-					}
-
-					var20 /= 6.0D;
 				}
 
 				var16 += 0.5D;
-				var20 = var20 * (double)var6 / 16.0D;
-				double var22 = (double)var6 / 2.0D + var20 * 4.0D;
+				var20 = var20 * 17.0D / 16.0D;
+				double var22 = 8.5D + var20 * 4.0D;
 				++var13;
-
 				for(int var24 = 0; var24 < var6; ++var24) {
-					double var25 = 0.0D;
-					double var27 = ((double)var24 - var22) * 12.0D / var16;
+					double var25;
+					double var27 = (var24 - var22) * 12.0D / var16;
 					if(var27 < 0.0D) {
 						var27 *= 4.0D;
 					}
@@ -260,21 +491,8 @@
 
 					var25 -= var27;
 					double var35;
-					if(var24 > var6 - 4) {
-						var35 = (double)((float)(var24 - (var6 - 4)) / 3.0F);
-						var25 = var25 * (1.0D - var35) + -10.0D * var35;
-					}
-
-					if((double)var24 < var18) {
-						var35 = (var18 - (double)var24) / 4.0D;
-						if(var35 < 0.0D) {
-							var35 = 0.0D;
-						}
-
-						if(var35 > 1.0D) {
-							var35 = 1.0D;
-						}
-
+					if((double)var24 > var6 - 4) {
+						var35 = ((float)((double) var24 - (var6 - 4)) / 3.0F);
 						var25 = var25 * (1.0D - var35) + -10.0D * var35;
 					}
 
@@ -287,177 +505,254 @@
 		return var1;
 	}
 
+	private double[] initializeUnderworldNoiseField(double[] var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+		if(var1 == null) {
+			var1 = new double[var5 * var6 * var7];
+		}
+
+		double var8 = 1368.824D;
+		double var10 = 684.412D;
+		this.uwnoise6 = SimplexOctaves.noiseArray(this.uwnoise6, this.seed, 10, var2, var3, var4, var5, 1, var7, 1.0D, 1.0D, 1.0D);
+		this.uwnoise7 = SimplexOctaves.noiseArray(this.uwnoise7, this.seed, 16, var2, var3, var4, var5, 1, var7, 100.0D, 1.0D, 100.0D);
+		this.uwnoise3 = SimplexOctaves.noiseArray(this.uwnoise3, this.seed, 8, var2, var3, var4, var5, var6, var7, var8 / 80.0D, var10 / 240.0D, var8 / 80.0D);
+		this.uwnoise1 = SimplexOctaves.noiseArray(this.uwnoise1, this.seed, 16, var2, var3, var4, var5, var6, var7, var8, var10, var8);
+		this.uwnoise2 = SimplexOctaves.noiseArray(this.uwnoise2, this.seed, 16, var2, var3, var4, var5, var6, var7, var8, var10, var8);
+		int var12 = 0;
+		int var13 = 0;
+		double[] var14 = new double[var6];
+
+		int var15;
+		for(var15 = 0; var15 < var6; ++var15) {
+			var14[var15] = Math.cos((double)var15 * Math.PI * 6.0D / (double)var6) * 2.0D;
+			double var16 = (double)var15;
+			if(var15 > var6 / 2) {
+				var16 = (double)(var6 - 1 - var15);
+			}
+
+			if(var16 < 4.0D) {
+				var16 = 4.0D - var16;
+				var14[var15] -= var16 * var16 * var16 * 10.0D;
+			}
+		}
+
+		for(var15 = 0; var15 < var5; ++var15) {
+			for(int var36 = 0; var36 < var7; ++var36) {
+				double var17 = (this.uwnoise6[var13] + 256.0D) / 512.0D;
+				if(var17 > 1.0D) {
+					var17 = 1.0D;
+				}
+
+				double var19 = 0.0D;
+				double var21 = this.uwnoise7[var13] / 8000.0D;
+				if(var21 < 0.0D) {
+					var21 = -var21;
+				}
+
+				var21 = var21 * 3.0D - 3.0D;
+				if(var21 < 0.0D) {
+					var21 /= 2.0D;
+					if(var21 < -1.0D) {
+						var21 = -1.0D;
+					}
+
+					var21 /= 1.4D;
+					var21 /= 2.0D;
+					var17 = 0.0D;
+				} else {
+					if(var21 > 1.0D) {
+						var21 = 1.0D;
+					}
+
+					var21 /= 6.0D;
+				}
+
+				var17 += 0.5D;
+				var21 = var21 * (double)var6 / 16.0D;
+				++var13;
+
+				for(int var23 = 0; var23 < var6; ++var23) {
+					double var24 = 0.0D;
+					double var26 = var14[var23];
+					double var28 = this.uwnoise1[var12] / 512.0D;
+					double var30 = this.uwnoise2[var12] / 512.0D;
+					double var32 = (this.uwnoise3[var12] / 10.0D + 1.0D) / 2.0D;
+					if(var32 < 0.0D) {
+						var24 = var28;
+					} else if(var32 > 1.0D) {
+						var24 = var30;
+					} else {
+						var24 = var28 + (var30 - var28) * var32;
+					}
+
+					var24 -= var26;
+					double var34;
+					if(var23 > var6 - 4) {
+						var34 = (double)((float)(var23 - (var6 - 4)) / 3.0F);
+						var24 = var24 * (1.0D - var34) + -10.0D * var34;
+					}
+
+					if((double)var23 < var19) {
+						var34 = (var19 - (double)var23) / 4.0D;
+						if(var34 < 0.0D) {
+							var34 = 0.0D;
+						}
+
+						if(var34 > 1.0D) {
+							var34 = 1.0D;
+						}
+
+						var24 = var24 * (1.0D - var34) + -10.0D * var34;
+					}
+
+					var1[var12] = var24;
+					++var12;
+				}
+			}
+		}
+
+		return var1;
+	}
+
 	public boolean chunkExists(int var1, int var2) {
 		return true;
 	}
 
 	public void populate(IChunkProvider var1, int var2, int var3) {
-		BlockSand.fallInstantly = true;
-		int var4 = var2 * 16;
-		int var5 = var3 * 16;
-		this.rand.setSeed(this.worldObj.randomSeed);
-		long var6 = this.rand.nextLong() / 2L * 2L + 1L;
-		long var8 = this.rand.nextLong() / 2L * 2L + 1L;
-		this.rand.setSeed((long)var2 * var6 + (long)var3 * var8 ^ this.worldObj.randomSeed);
-		double var10 = 0.25D;
-
-		int var12;
-		int var13;
-		int var14;
-		int var15;
-		for(var12 = 0; var12 < 8; ++var12) {
-			var13 = var4 + this.rand.nextInt(16) + 8;
-			var14 = this.rand.nextInt(128);
-			var15 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenDungeons()).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 10; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(128);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenClay(32)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 20; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(128);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenMinable(Block.dirt.blockID, 32)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 10; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(128);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenMinable(Block.gravel.blockID, 32)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 20; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(128);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenMinable(Block.oreCoal.blockID, 16)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 20; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(64);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenMinable(Block.oreIron.blockID, 8)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 2; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(32);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenMinable(Block.oreGold.blockID, 8)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 8; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(16);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenMinable(Block.oreRedstone.blockID, 7)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		for(var12 = 0; var12 < 1; ++var12) {
-			var13 = var4 + this.rand.nextInt(16);
-			var14 = this.rand.nextInt(16);
-			var15 = var5 + this.rand.nextInt(16);
-			(new WorldGenMinable(Block.oreDiamond.blockID, 7)).generate(this.worldObj, this.rand, var13, var14, var15);
-		}
-
-		var10 = 0.5D;
-		var12 = (int)((this.mobSpawnerNoise.generateNoiseOctaves((double)var4 * var10, (double)var5 * var10) / 8.0D + this.rand.nextDouble() * 4.0D + 4.0D) / 3.0D);
-		if(var12 < 0) {
-			var12 = 0;
-		}
-
-		if(this.rand.nextInt(10) == 0) {
-			++var12;
-		}
-
-		Object var18 = new WorldGenTrees();
-		if(this.rand.nextInt(10) == 0) {
-			var18 = new WorldGenBigTree();
-		}
-
-		int var16;
-		for(var14 = 0; var14 < var12; ++var14) {
-			var15 = var4 + this.rand.nextInt(16) + 8;
-			var16 = var5 + this.rand.nextInt(16) + 8;
-			((WorldGenerator)var18).setScale(1.0D, 1.0D, 1.0D);
-			((WorldGenerator)var18).generate(this.worldObj, this.rand, var15, this.worldObj.getHeightValue(var15, var16), var16);
-		}
-
-		int var17;
-		for(var14 = 0; var14 < 2; ++var14) {
-			var15 = var4 + this.rand.nextInt(16) + 8;
-			var16 = this.rand.nextInt(128);
-			var17 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenFlowers(Block.plantYellow.blockID)).generate(this.worldObj, this.rand, var15, var16, var17);
-		}
-
-		if(this.rand.nextInt(2) == 0) {
-			var14 = var4 + this.rand.nextInt(16) + 8;
-			var15 = this.rand.nextInt(128);
-			var16 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenFlowers(Block.plantRed.blockID)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		if(this.rand.nextInt(4) == 0) {
-			var14 = var4 + this.rand.nextInt(16) + 8;
-			var15 = this.rand.nextInt(128);
-			var16 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenFlowers(Block.mushroomBrown.blockID)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		if(this.rand.nextInt(8) == 0) {
-			var14 = var4 + this.rand.nextInt(16) + 8;
-			var15 = this.rand.nextInt(128);
-			var16 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenFlowers(Block.mushroomRed.blockID)).generate(this.worldObj, this.rand, var14, var15, var16);
-		}
-
-		for(var14 = 0; var14 < 10; ++var14) {
-			var15 = var4 + this.rand.nextInt(16) + 8;
-			var16 = this.rand.nextInt(128);
-			var17 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenReed()).generate(this.worldObj, this.rand, var15, var16, var17);
-		}
-
-		for(var14 = 0; var14 < 1; ++var14) {
-			var15 = var4 + this.rand.nextInt(16) + 8;
-			var16 = this.rand.nextInt(128);
-			var17 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenCactus()).generate(this.worldObj, this.rand, var15, var16, var17);
-		}
-
-		for(var14 = 0; var14 < 50; ++var14) {
-			var15 = var4 + this.rand.nextInt(16) + 8;
-			var16 = this.rand.nextInt(this.rand.nextInt(120) + 8);
-			var17 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenLiquids(Block.waterMoving.blockID)).generate(this.worldObj, this.rand, var15, var16, var17);
-		}
-
-		for(var14 = 0; var14 < 20; ++var14) {
-			var15 = var4 + this.rand.nextInt(16) + 8;
-			var16 = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(112) + 8) + 8);
-			var17 = var5 + this.rand.nextInt(16) + 8;
-			(new WorldGenLiquids(Block.lavaMoving.blockID)).generate(this.worldObj, this.rand, var15, var16, var17);
-		}
-
-		for(var14 = var4 + 8 + 0; var14 < var4 + 8 + 16; ++var14) {
-			for(var15 = var5 + 8 + 0; var15 < var5 + 8 + 16; ++var15) {
-				var16 = this.worldObj.getTopSolidOrLiquidBlock(var14, var15);
-				if(this.worldObj.snowCovered && var16 > 0 && var16 < 128 && this.worldObj.getBlockId(var14, var16, var15) == 0 && this.worldObj.getBlockMaterial(var14, var16 - 1, var15).getIsSolid() && this.worldObj.getBlockMaterial(var14, var16 - 1, var15) != Material.ice) {
-					this.worldObj.setBlockWithNotify(var14, var16, var15, Block.snow.blockID);
-				}
-			}
-		}
-
-		BlockSand.fallInstantly = false;
+		if (this.superflat) return;
+
+		Profiler.startSection("populate");
+		BlockSand.fallInstantly = true;
+		int var4 = var2 * 16;
+		int var5 = var3 * 16;
+		this.rand.setSeed(this.worldObj.randomSeed);
+		long var6 = this.rand.nextLong() / 2L * 2L + 1L;
+		long var8 = this.rand.nextLong() / 2L * 2L + 1L;
+		this.rand.setSeed((long)var2 * var6 + (long)var3 * var8 ^ this.worldObj.randomSeed);
+
+		PopulatorHost host = new PopulatorHost(this, var4, var5, worldObj, rand, null);
+
+		int maxDungeons = this.rand.nextInt(2) + 1;
+		host.generate(new WorldGenDungeons(), maxDungeons, 64, 112, 8);
+		host.generate(new WorldGenClay(32), 10, 110, 130);
+		host.generate(new WorldGenSpeleothems(32, 128), 96, 32, 128, 8);
+
+		host.generateMinable(Block.dirt, 32, 20, 64, 192);
+		host.generateMinable(Block.gravel, 32, 10, 64, 192);
+		host.generateMinable(Block.stone, 32, 10, 96, 192, 1);
+		host.generateMinableInStone(Block.oreCoal, 16, 24, 32, 192);
+		host.generateMinableInStone(Block.oreIron, 8, 24, 32, 128);
+		host.generateMinableInStone(Block.oreGold, 8, 8, 32, 96);
+		host.generateMinableInStone(Block.oreRedstone, 7, 6, 32, 80);
+		host.generateMinableInStone(Block.oreDiamond, 7, 3, 32, 72);
+		host.generateMinableInStone(Block.oreRuby, 4, 2, 32, 88);
+		host.generateMinableInStone(Block.oreSapphire, 4, 2, 32, 88);
+
+		if (this.classic) {
+			double treeRes = 0.5D;
+			int treeCount = (int)((this.mobSpawnerNoise.generateNoiseOctaves((double)var4 * treeRes, (double)var5 * treeRes) / 8.0D + this.rand.nextDouble() * 4.0D + 4.0D) / 3.0D);
+			if (treeCount < 0) {
+				treeCount = 0;
+			}
+
+			if (this.rand.nextInt(10) == 0) {
+				++treeCount;
+			}
+
+			WorldGenerator tree = new WorldGenTrees();
+			if (this.rand.nextInt(10) == 0) {
+				tree = new WorldGenBigTree();
+			}
+
+			host.generateSurface(tree, treeCount, 8);
+			host.generateFlowers(1);
+		} else {
+			this.worldObj.getBiome(var2 * 16, var3 * 16).populate(host);
+		}
+
+		host.generate(new WorldGenReed(), 10, 64, 192, 8);
+		host.generate(new WorldGenCactus(), 1, 64, 192, 8);
+
+		for(int i = 0; i < 50; ++i) {
+			int x = var4 + this.rand.nextInt(16) + 8;
+			int y = this.rand.nextInt(this.rand.nextInt(120) + 8) + 64;
+			int z = var5 + this.rand.nextInt(16) + 8;
+			(new WorldGenLiquids(Block.waterMoving.blockID)).generate(this.worldObj, this.rand, x, y, z);
+		}
+
+		for(int i = 0; i < 20; ++i) {
+			int x = var4 + this.rand.nextInt(16) + 8;
+			int y = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(112) + 8) + 8) + 64;
+			int z = var5 + this.rand.nextInt(16) + 8;
+			(new WorldGenLiquids(Block.lavaMoving.blockID)).generate(this.worldObj, this.rand, x, y, z);
+		}
+
+		for(int x = var4 + 8; x < var4 + 24; ++x) {
+			for(int z = var5 + 8; z < var5 + 24; ++z) {
+				int y = this.worldObj.getTopSolidOrLiquidBlock(x, z);
+				if(this.worldObj.getBiome(x, z).isSnowy()
+						&& y > 0 && y < CHUNK_HEIGHT && this.worldObj.getBlockId(x, y, z) == 0
+						&& this.worldObj.getBlockMaterial(x, y - 1, z).getIsSolid()
+						&& this.worldObj.getBlockMaterial(x, y - 1, z) != Material.ice) {
+					this.worldObj.setBlock(x, y, z, Block.snow.blockID);
+ 				}
+ 			}
+ 		}
+
+		for(int x = var4 + 8; x < var4 + 24; ++x)
+			for(int z = var5 + 8; z < var5 + 24; ++z)
+				for (int y = 0; y < 6; y++) {
+					if (!this.worldObj.isBlockNormalCube(x, y, z)) {
+						this.worldObj.setBlock(x, y, z, Block.lavaStill.blockID);
+					}
+				}
+
+		BlockSand.fallInstantly = false;
+		Profiler.endSection();
+	}
+
+	public void populateUnderworld(IChunkProvider var1, int var2, int var3) {
+		if (this.superflat) return;
+
+		Profiler.startSection("populateUnderworld");
+		BlockSand.fallInstantly = true;
+		int var4 = var2 * 16;
+		int var5 = var3 * 16;
+		this.rand.setSeed(this.worldObj.randomSeed);
+		long var6 = this.rand.nextLong() / 2L * 2L + 1L;
+		long var8 = this.rand.nextLong() / 2L * 2L + 1L;
+		this.rand.setSeed((long)var2 * var6 + (long)var3 * var8 ^ this.worldObj.randomSeed);
+
+		PopulatorHost host = new PopulatorHost(this, var4, var5, worldObj, rand, mobSpawnerNoise);
+
+		host.generate(new WorldGenSpeleothems(0, 32), 16, 32, 64, 8);
+
+		host.generateMinableInStone(Block.oreGold, 10, 2, 0, 32);
+		host.generateMinableInStone(Block.oreDiamond, 7, 2, 0, 32);
+		host.generateMinableInStone(Block.oreRedstone, 7, 4, 0, 32);
+		host.generateMinableInStone(Block.oreRuby, 7, 3, 0, 32);
+		host.generateMinableInStone(Block.oreSapphire, 7, 3, 0, 32);
+
+		if (this.rand.nextInt(25) == 0) host.generate(new WorldGenCrystals(Block.umbrashardCrystal), 20, 16, 16, 8);
+
+		BlockSand.fallInstantly = false;
+		Profiler.endSection();
+	}
+
+	public void upgradeHeight(IChunkProvider var1, Chunk var2, World var3) {
+		for (int x = 0; x < 16; x++) {
+			for (int z = 0; z < 16; z++) {
+				for (int y = 64; y < 68; y++) {
+					if (var2.getBlockID(x, y, z) == Block.bedrock.blockID) {
+						var2.setBlockIDWithMetadata(x, y, z, Block.stone.blockID, 2);
+					}
+				}
+			}
+		}
+
+		this.generateUnderworld(var2.xPosition, var2.zPosition, var2.blocks);
+		this.replaceUnderworldBlocks(var2.xPosition, var2.zPosition, var2.blocks, var2.data);
+		this.underworldCaveGenerator.generate(this, this.worldObj, var2.xPosition, var2.zPosition, var2.blocks);
+		var2.generateSkylightMap();
 	}
 
 	public boolean saveChunks(boolean var1, IProgressUpdate var2) {
--- net/minecraft/src/NBTTagShort.java
+++ net/minecraft/src/NBTTagShort.java
@@ -14,11 +14,11 @@
 		this.shortValue = var1;
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeShort(this.shortValue);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.shortValue = var1.readShort();
 	}
 
@@ -27,6 +27,10 @@
 	}
 
 	public String toString() {
-		return "" + this.shortValue;
+		return String.valueOf(this.shortValue);
+	}
+
+	public NBTBase copy() {
+		return new NBTTagShort(this.shortValue).setKey(this.getKey());
 	}
 }
--- net/minecraft/src/ItemFlintAndSteel.java
+++ net/minecraft/src/ItemFlintAndSteel.java
@@ -7,7 +7,7 @@
 		this.maxDamage = 64;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var7 == 0) {
 			--var5;
 		}
--- net/minecraft/src/MusInputStream.java
+++ net/minecraft/src/MusInputStream.java
@@ -4,11 +4,11 @@
 import java.io.InputStream;
 import java.net.URL;
 
-class MusInputStream extends InputStream {
+public class MusInputStream extends InputStream {
 	private int hash;
 	private InputStream inputStream;
-	byte[] buffer;
-	final CodecMus codec;
+	public byte[] buffer;
+	public final CodecMus codec;
 
 	public MusInputStream(CodecMus var1, URL var2, InputStream var3) {
 		this.codec = var1;
--- net/minecraft/src/EntitySnowball.java
+++ net/minecraft/src/EntitySnowball.java
@@ -9,7 +9,7 @@
 	private int inTile = 0;
 	private boolean inGround = false;
 	public int throwableShake = 0;
-	private EntityLiving thrower;
+	public EntityLiving thrower;
 	private int ticksInGround;
 	private int ticksInAir = 0;
 
@@ -18,17 +18,11 @@
 		this.setSize(0.25F, 0.25F);
 	}
 
-	public boolean isInRangeToRenderDist(double var1) {
-		double var3 = this.boundingBox.getAverageEdgeLength() * 4.0D;
-		var3 *= 64.0D;
-		return var1 < var3 * var3;
-	}
-
-	public EntitySnowball(World var1, EntityLiving var2) {
+	public EntitySnowball(World var1, EntityLiving var2, EntitySnowballType type) {
 		super(var1);
 		this.thrower = var2;
-		this.setSize(0.25F, 0.25F);
-		this.setLocationAndAngles(var2.posX, var2.posY, var2.posZ, var2.rotationYaw, var2.rotationPitch);
+		this.dataWatcher.addObject(16, (byte)type.id);
+		this.setLocationAndAngles(var2.posX, var2.posY + var2.getEyeHeight(), var2.posZ, var2.rotationYaw, var2.rotationPitch);
 		this.posX -= (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
 		this.posY -= (double)0.1F;
 		this.posZ -= (double)(MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
@@ -41,6 +35,23 @@
 		this.setThrowableHeading(this.motionX, this.motionY, this.motionZ, 1.5F, 1.0F);
 	}
 
+	public EntitySnowball(World var1, double var2, double var4, double var6, EntitySnowballType type) {
+		super(var1);
+		this.dataWatcher.addObject(16, (byte)type.id);
+		this.setPosition(var2, var4, var6);
+		this.yOffset = 0.0F;
+	}
+
+	public EntitySnowballType getType() {
+		return EntitySnowballType.list[this.dataWatcher.getWatchableObjectByte(16)];
+	}
+
+	public boolean isInRangeToRenderDist(double var1) {
+		double var3 = this.boundingBox.getAverageEdgeLength() * 4.0D;
+		var3 *= 64.0D;
+		return var1 < var3 * var3;
+	}
+
 	public void setThrowableHeading(double var1, double var3, double var5, float var7, float var8) {
 		float var9 = MathHelper.sqrt_double(var1 * var1 + var3 * var3 + var5 * var5);
 		var1 /= (double)var9;
@@ -63,6 +74,8 @@
 
 	public void onUpdate() {
 		super.onUpdate();
+		EntitySnowballType type = this.getType();
+
 		if(this.throwableShake > 0) {
 			--this.throwableShake;
 		}
@@ -123,15 +136,45 @@
 			var3 = new MovingObjectPosition(var4);
 		}
 
+		float cf16;
 		if(var3 != null) {
-			if(var3.entityHit != null && var3.entityHit.attackEntityFrom(this.thrower, 0)) {
-			}
-
-			for(var8 = 0; var8 < 8; ++var8) {
-				this.worldObj.spawnParticle("snowballpoof", this.posX, this.posY, this.posZ, 0.0D, 0.0D, 0.0D);
-			}
-
-			this.setEntityDead();
+			if(var3.entityHit != null) {
+				if(var3.entityHit.attackEntityFrom(this.thrower, type.damage)) {
+					if (type.burn > 0) {
+						var3.entityHit.fire = type.burn;
+					}
+					if (EntityLiving.class.isInstance(var3.entityHit) && type.pierce > 1.0F) {
+						((EntityLiving) var3.entityHit).hurtTime /= type.pierce;
+						((EntityLiving) var3.entityHit).maxHurtTime /= type.pierce;
+						((EntityLiving) var3.entityHit).heartsLife /= type.pierce;
+					}
+					this.setEntityDead();
+				} else {
+					this.motionX *= -0.1D;
+					this.motionY *= -0.1D;
+					this.motionZ *= -0.1D;
+					this.prevRotationYaw += 180.0F;
+					this.ticksInAir = 0;
+				}
+			} else {
+				this.xTile = var3.blockX;
+				this.yTile = var3.blockY;
+				this.zTile = var3.blockZ;
+				this.inTile = this.worldObj.getBlockId(this.xTile, this.yTile, this.zTile);
+				this.motionX = (double)((float)(var3.hitVec.xCoord - this.posX));
+				this.motionY = (double)((float)(var3.hitVec.yCoord - this.posY));
+				this.motionZ = (double)((float)(var3.hitVec.zCoord - this.posZ));
+				cf16 = MathHelper.sqrt_double(
+						this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
+				this.posX -= this.motionX / (double)cf16 * (double)0.05F;
+				this.posY -= this.motionY / (double)cf16 * (double)0.05F;
+				this.posZ -= this.motionZ / (double)cf16 * (double)0.05F;
+				// this.worldObj.playSoundAtEntity(this, "random.drr", 1.0F, 1.2F /
+				// (this.rand.nextFloat() * 0.2F + 0.9F));
+				this.inGround = true;
+				this.throwableShake = 7;
+				this.setEntityDead();
+			}
 		}
 
 		this.posX += this.motionX;
@@ -182,6 +225,7 @@
 		var1.setByte("inTile", (byte)this.inTile);
 		var1.setByte("shake", (byte)this.throwableShake);
 		var1.setByte("inGround", (byte)(this.inGround ? 1 : 0));
+		var1.setByte("type", this.dataWatcher.getWatchableObjectByte(16));
 	}
 
 	public void readEntityFromNBT(NBTTagCompound var1) {
@@ -191,18 +235,26 @@
 		this.inTile = var1.getByte("inTile") & 255;
 		this.throwableShake = var1.getByte("shake") & 255;
 		this.inGround = var1.getByte("inGround") == 1;
+		this.dataWatcher.addObject(16, var1.getByte("type"));
 	}
 
 	public void onCollideWithPlayer(EntityPlayer var1) {
 		if(this.inGround && this.thrower == var1 && this.throwableShake <= 0 && var1.inventory.addItemStackToInventory(new ItemStack(Item.arrow.shiftedIndex, 1))) {
 			this.worldObj.playSoundAtEntity(this, "random.pop", 0.2F, ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.7F + 1.0F) * 2.0F);
-			var1.onItemPickup(this, 1);
 			this.setEntityDead();
 		}
-
 	}
 
 	public float getShadowSize() {
 		return 0.0F;
+	}
+
+	public void setVelocity(double var1, double var3, double var5) {
+		super.setVelocity(var1, var3, var5);
+		if(this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F) {
+			float var7 = MathHelper.sqrt_double(var1 * var1 + var5 * var5);
+			this.prevRotationYaw = this.rotationYaw = (float)(Math.atan2(var1, var5) * 180.0D / (double)((float)Math.PI));
+			this.prevRotationPitch = this.rotationPitch = (float)(Math.atan2(var3, (double)var7) * 180.0D / (double)((float)Math.PI));
+		}
 	}
 }
--- net/minecraft/src/ICamera.java
+++ net/minecraft/src/ICamera.java
@@ -3,5 +3,7 @@
 public interface ICamera {
 	boolean isBoundingBoxInFrustum(AxisAlignedBB var1);
 
+	boolean isBoundingBoxInFrustumFully(AxisAlignedBB var1);
+
 	void setPosition(double var1, double var3, double var5);
 }
--- net/minecraft/src/EntityList.java
+++ net/minecraft/src/EntityList.java
@@ -9,20 +9,24 @@
 	private static Map IDtoClassMapping = new HashMap();
 	private static Map classToIDMapping = new HashMap();
 
-	private static void addMapping(Class var0, String var1, int var2) {
+	public static void addMapping(Class var0, String var1, int var2) {
 		stringToClassMapping.put(var1, var0);
 		classToStringMapping.put(var0, var1);
-		IDtoClassMapping.put(Integer.valueOf(var2), var0);
-		classToIDMapping.put(var0, Integer.valueOf(var2));
+		IDtoClassMapping.put(var2, var0);
+		classToIDMapping.put(var0, var2);
+	}
+
+	public static boolean idTaken(int id) {
+		return IDtoClassMapping.containsKey(id);
 	}
 
 	public static Entity createEntityByName(String var0, World var1) {
 		Entity var2 = null;
 
 		try {
-			Class var3 = (Class)stringToClassMapping.get(var0);
-			if(var3 != null) {
-				var2 = (Entity)var3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
+			Class class3 = (Class)stringToClassMapping.get(var0);
+			if(class3 != null) {
+				var2 = (Entity)class3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
 			}
 		} catch (Exception var4) {
 			var4.printStackTrace();
@@ -35,9 +39,9 @@
 		Entity var2 = null;
 
 		try {
-			Class var3 = (Class)stringToClassMapping.get(var0.getString("id"));
-			if(var3 != null) {
-				var2 = (Entity)var3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
+			Class class3 = (Class)stringToClassMapping.get(var0.getString("id"));
+			if(class3 != null) {
+				var2 = (Entity)class3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
 			}
 		} catch (Exception var4) {
 			var4.printStackTrace();
@@ -56,9 +60,9 @@
 		Entity var2 = null;
 
 		try {
-			Class var3 = (Class)IDtoClassMapping.get(Integer.valueOf(var0));
-			if(var3 != null) {
-				var2 = (Entity)var3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
+			Class class3 = (Class)IDtoClassMapping.get(var0);
+			if(class3 != null) {
+				var2 = (Entity)class3.getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
 			}
 		} catch (Exception var4) {
 			var4.printStackTrace();
@@ -80,10 +84,18 @@
 	}
 
 	static {
-		addMapping(EntityArrow.class, "Arrow", 10);
-		addMapping(EntitySnowball.class, "Snowball", 11);
 		addMapping(EntityItem.class, "Item", 1);
+
 		addMapping(EntityPainting.class, "Painting", 9);
+		addMapping(EntityArrow.class, "Arrow", 10);
+		addMapping(EntitySnowball.class, "Snowball", 11);
+
+		addMapping(EntityTNTPrimed.class, "PrimedTnt", 20);
+		addMapping(EntityFallingSand.class, "FallingSand", 21);
+
+		addMapping(EntityMinecart.class, "Minecart", 40);
+		addMapping(EntityBoat.class, "Boat", 41);
+
 		addMapping(EntityLiving.class, "Mob", 48);
 		addMapping(EntityMob.class, "Monster", 49);
 		addMapping(EntityCreeper.class, "Creeper", 50);
@@ -92,13 +104,12 @@
 		addMapping(EntityGiantZombie.class, "Giant", 53);
 		addMapping(EntityZombie.class, "Zombie", 54);
 		addMapping(EntitySlime.class, "Slime", 55);
+		addMapping(EntityPhantom.class, "Phantom", 56);
+
 		addMapping(EntityPig.class, "Pig", 90);
 		addMapping(EntitySheep.class, "Sheep", 91);
-		addMapping(EntityCow.class, "Cow", 91);
-		addMapping(EntityChicken.class, "Chicken", 91);
-		addMapping(EntityTNTPrimed.class, "PrimedTnt", 20);
-		addMapping(EntityFallingSand.class, "FallingSand", 21);
-		addMapping(EntityMinecart.class, "Minecart", 40);
-		addMapping(EntityBoat.class, "Boat", 41);
+		addMapping(EntityCow.class, "Cow", 92);
+		addMapping(EntityChicken.class, "Chicken", 93);
+		addMapping(EntityFox.class, "Fox", 94);
 	}
 }
--- net/minecraft/src/RecipeSorter.java
+++ net/minecraft/src/RecipeSorter.java
@@ -2,10 +2,10 @@
 
 import java.util.Comparator;
 
-class RecipeSorter implements Comparator {
-	final CraftingManager craftingManager;
+public class RecipeSorter implements Comparator {
+	public final CraftingManager craftingManager;
 
-	RecipeSorter(CraftingManager var1) {
+	public RecipeSorter(CraftingManager var1) {
 		this.craftingManager = var1;
 	}
 
--- net/minecraft/src/GuiContainer.java
+++ net/minecraft/src/GuiContainer.java
@@ -1,49 +1,74 @@
 package net.minecraft.src;
 
-import java.util.ArrayList;
-import java.util.List;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
 
 public abstract class GuiContainer extends GuiScreen {
-	private static RenderItem itemRenderer = new RenderItem();
-	protected int xSize = 176;
-	protected int ySize = 166;
-	protected List inventorySlots = new ArrayList();
+	private static final RenderItem itemRenderer = new RenderItem();
+	public int xSize = 176;
+	public int ySize = 166;
+	protected Container inventorySlots;
+	private int mouseX;
+	private int mouseY;
+
+	public GuiContainer(Container var1) {
+		this.inventorySlots = var1;
+	}
+
+	public void initGui() {
+		super.initGui();
+		if (this.mc.thePlayer != null)
+			this.mc.thePlayer.craftingInventory = this.inventorySlots;
+	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		int var4 = (this.width - this.xSize) / 2;
 		int var5 = (this.height - this.ySize) / 2;
 		this.drawGuiContainerBackgroundLayer(var3);
-		GL11.glPushMatrix();
-		GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
-		RenderHelper.enableStandardItemLighting();
-		GL11.glPopMatrix();
+		super.drawScreen(var1, var2, var3);
+		RenderHelper.enableGUIStandardItemLighting();
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)var4, (float)var5, 0.0F);
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		GL11.glEnable(GL12.GL_RESCALE_NORMAL);
+		Slot var6 = null;
 
-		for(int var6 = 0; var6 < this.inventorySlots.size(); ++var6) {
-			SlotInventory var7 = (SlotInventory)this.inventorySlots.get(var6);
-			this.drawSlotInventory(var7);
-			if(var7.getIsMouseOverSlot(var1, var2)) {
+		int var9;
+		int var10a;
+		for(int var7 = 0; var7 < this.inventorySlots.slots.size(); ++var7) {
+			Slot var8 = (Slot)this.inventorySlots.slots.get(var7);
+			this.drawSlotInventory(var8, var1, var2);
+			if(this.func_20081_a(var8, var1, var2)) {
+				var6 = var8;
+				var9 = var8.x;
+				var10a = var8.y;
+				GL11.glColor4f(2.5F, 2.5F, 2.5F, 1.0F);
+				this.zLevel = 300.0F;
+				itemRenderer.zLevel = 300.0F;
+				itemRenderer.renderItemHoverOverlayIntoGUI(this.fontRenderer, this.mc.renderEngine, var8.getStack(), var9, var10a);
+				this.zLevel = 0.0F;
+				itemRenderer.zLevel = 0.0F;
 				GL11.glDisable(GL11.GL_LIGHTING);
 				GL11.glDisable(GL11.GL_DEPTH_TEST);
-				int var8 = var7.xDisplayPosition;
-				int var9 = var7.yDisplayPosition;
-				this.drawGradientRect(var8, var9, var8 + 16, var9 + 16, -2130706433, -2130706433);
+				this.drawGradientRect(var9, var10a, var9 + 16, var10a + 16, -2130706433, -2130706433);
 				GL11.glEnable(GL11.GL_LIGHTING);
 				GL11.glEnable(GL11.GL_DEPTH_TEST);
 			}
 		}
 
-		InventoryPlayer var10 = this.mc.thePlayer.inventory;
-		if(var10.draggedItemStack != null) {
-			GL11.glTranslatef(0.0F, 0.0F, 32.0F);
-			itemRenderer.renderItemIntoGUI(this.fontRenderer, this.mc.renderEngine, var10.draggedItemStack, var1 - var4 - 8, var2 - var5 - 8);
-			itemRenderer.renderItemOverlayIntoGUI(this.fontRenderer, this.mc.renderEngine, var10.draggedItemStack, var1 - var4 - 8, var2 - var5 - 8);
+		InventoryPlayer var10 = null;
+		if (this.mc.thePlayer != null) {
+			var10 = this.mc.thePlayer.inventory;
+			if(var10.getDraggedItemStack() != null) {
+				GL11.glTranslatef(0.0F, 0.0F, 32.0F);
+				this.zLevel = 200.0F;
+				itemRenderer.zLevel = 200.0F;
+				itemRenderer.renderItemIntoGUI(this.fontRenderer, this.mc.renderEngine, var10.getDraggedItemStack(), var1 - var4 - 8, var2 - var5 - 8);
+				itemRenderer.renderItemOverlayIntoGUI(this.fontRenderer, this.mc.renderEngine, var10.getDraggedItemStack(), var1 - var4 - 8, var2 - var5 - 8);
+				this.zLevel = 0.0F;
+				itemRenderer.zLevel = 0.0F;
+			}
 		}
 
 		GL11.glDisable(GL12.GL_RESCALE_NORMAL);
@@ -51,9 +76,23 @@
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glDisable(GL11.GL_DEPTH_TEST);
 		this.drawGuiContainerForegroundLayer();
+		if((var10 == null || var10.getDraggedItemStack() == null) && var6 != null && var6.func_20005_c()) {
+			drawSlotTooltip(var6, var1, var2);
+		}
 		GL11.glEnable(GL11.GL_LIGHTING);
 		GL11.glEnable(GL11.GL_DEPTH_TEST);
 		GL11.glPopMatrix();
+
+		this.mouseX = var1;
+		this.mouseY = var2;
+	}
+
+	private boolean func_20081_a(Slot var1, int var2, int var3) {
+		int var4 = (this.width - this.xSize) / 2;
+		int var5 = (this.height - this.ySize) / 2;
+		var2 -= var4;
+		var3 -= var5;
+		return var2 >= var1.x - 1 && var2 < var1.x + 16 + 1 && var3 >= var1.y - 1 && var3 < var1.y + 16 + 1;
 	}
 
 	protected void drawGuiContainerForegroundLayer() {
@@ -61,31 +100,60 @@
 
 	protected abstract void drawGuiContainerBackgroundLayer(float var1);
 
-	private void drawSlotInventory(SlotInventory var1) {
-		IInventory var2 = var1.inventory;
-		int var3 = var1.slotIndex;
-		int var4 = var1.xDisplayPosition;
-		int var5 = var1.yDisplayPosition;
-		ItemStack var6 = var2.getStackInSlot(var3);
-		if(var6 == null) {
-			int var7 = var1.getBackgroundIconIndex();
-			if(var7 >= 0) {
+	private void drawSlotInventory(Slot var1, int mx, int my) {
+		this.zLevel = 100.0F;
+		itemRenderer.zLevel = 100.0F;
+
+		boolean blend = false;
+		if (var1.getColorA() < 1.0F) {
+			blend = true;
+			GL11.glEnable(GL11.GL_BLEND);
+		}
+		GL11.glColor4f(var1.getColorR(), var1.getColorG(), var1.getColorB(), var1.getColorA());
+
+		int var2 = var1.x;
+		int var3 = var1.y;
+		ItemStack var4 = var1.getStack();
+		if(var4 == null) {
+			int var5 = var1.getBackgroundIconIndex();
+			if(var5 >= 0) {
 				GL11.glDisable(GL11.GL_LIGHTING);
 				this.mc.renderEngine.bindTexture(this.mc.renderEngine.getTexture("/gui/items.png"));
-				this.drawTexturedModalRect(var4, var5, var7 % 16 * 16, var7 / 16 * 16, 16, 16);
+				this.drawTexturedModalRect(var2, var3, var5 % 32 * 16, var5 / 32 * 16, 16, 16, 512.0F);
 				GL11.glEnable(GL11.GL_LIGHTING);
 				return;
 			}
 		}
 
-		itemRenderer.renderItemIntoGUI(this.fontRenderer, this.mc.renderEngine, var6, var4, var5);
-		itemRenderer.renderItemOverlayIntoGUI(this.fontRenderer, this.mc.renderEngine, var6, var4, var5);
-	}
-
-	private Slot getSlotAtPosition(int var1, int var2) {
-		for(int var3 = 0; var3 < this.inventorySlots.size(); ++var3) {
-			SlotInventory var4 = (SlotInventory)this.inventorySlots.get(var3);
-			if(var4.getIsMouseOverSlot(var1, var2)) {
+		itemRenderer.renderItemIntoGUI(this.fontRenderer, this.mc.renderEngine, var4, var2, var3);
+		itemRenderer.renderItemOverlayIntoGUI(this.fontRenderer, this.mc.renderEngine, var4, var2, var3);
+
+		itemRenderer.zLevel = 0.0F;
+		this.zLevel = 0.0F;
+
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		if (blend) {
+			GL11.glDisable(GL11.GL_BLEND);
+		}
+	}
+
+	private void drawSlotTooltip(Slot var1, int x, int y) {
+		x -= (this.width - this.xSize) / 2;
+		y -= (this.height - this.ySize) / 2;
+		if (var1 == null || var1.getStack() == null) {
+			return;
+		}
+
+		ItemTooltip tooltip = var1.getTooltip();
+		if (tooltip != null) {
+			this.drawTooltip(tooltip, x, y);
+		}
+	}
+
+	protected Slot getSlotAtPosition(int var1, int var2) {
+		for(int var3 = 0; var3 < this.inventorySlots.slots.size(); ++var3) {
+			Slot var4 = (Slot)this.inventorySlots.slots.get(var3);
+			if(this.func_20081_a(var4, var1, var2)) {
 				return var4;
 			}
 		}
@@ -93,132 +161,48 @@
 		return null;
 	}
 
+	protected void handleControls(int var1, int var2, int var3) {
+		super.mouseClicked(var1, var2, var3);
+	}
+
 	protected void mouseClicked(int var1, int var2, int var3) {
 		if(var3 == 0 || var3 == 1) {
 			Slot var4 = this.getSlotAtPosition(var1, var2);
-			InventoryPlayer var5 = this.mc.thePlayer.inventory;
-			int var7;
+			int var5 = (this.width - this.xSize) / 2;
+			int var6 = (this.height - this.ySize) / 2;
+			boolean var7 = var1 < var5 || var2 < var6 || var1 >= var5 + this.xSize || var2 >= var6 + this.ySize;
+			int var8 = -1;
 			if(var4 != null) {
-				ItemStack var6 = var4.getStack();
-				if(var6 != null || var5.draggedItemStack != null) {
-					if(var6 != null && var5.draggedItemStack == null) {
-						var7 = var3 == 0 ? var6.stackSize : (var6.stackSize + 1) / 2;
-						var5.draggedItemStack = var4.inventory.decrStackSize(var4.slotIndex, var7);
-						if(var6.stackSize == 0) {
-							var4.putStack((ItemStack)null);
-						}
-
-						var4.onPickupFromSlot();
-					} else if(var6 == null && var5.draggedItemStack != null && var4.isItemValid(var5.draggedItemStack)) {
-						var7 = var3 == 0 ? var5.draggedItemStack.stackSize : 1;
-						if(var7 > var4.inventory.getInventoryStackLimit()) {
-							var7 = var4.inventory.getInventoryStackLimit();
-						}
-
-						var4.putStack(var5.draggedItemStack.splitStack(var7));
-						if(var5.draggedItemStack.stackSize == 0) {
-							var5.draggedItemStack = null;
-						}
-					} else if(var6 != null && var5.draggedItemStack != null) {
-						if(var4.isItemValid(var5.draggedItemStack)) {
-							if(var6.itemID != var5.draggedItemStack.itemID) {
-								if(var5.draggedItemStack.stackSize <= var4.inventory.getInventoryStackLimit()) {
-									var4.putStack(var5.draggedItemStack);
-									var5.draggedItemStack = var6;
-								}
-							} else if(var6.itemID == var5.draggedItemStack.itemID) {
-								if(var3 == 0) {
-									var7 = var5.draggedItemStack.stackSize;
-									if(var7 > var4.inventory.getInventoryStackLimit() - var6.stackSize) {
-										var7 = var4.inventory.getInventoryStackLimit() - var6.stackSize;
-									}
-
-									if(var7 > var5.draggedItemStack.getMaxStackSize() - var6.stackSize) {
-										var7 = var5.draggedItemStack.getMaxStackSize() - var6.stackSize;
-									}
-
-									var5.draggedItemStack.splitStack(var7);
-									if(var5.draggedItemStack.stackSize == 0) {
-										var5.draggedItemStack = null;
-									}
-
-									var6.stackSize += var7;
-								} else if(var3 == 1) {
-									var7 = 1;
-									if(var7 > var4.inventory.getInventoryStackLimit() - var6.stackSize) {
-										var7 = var4.inventory.getInventoryStackLimit() - var6.stackSize;
-									}
-
-									if(var7 > var5.draggedItemStack.getMaxStackSize() - var6.stackSize) {
-										var7 = var5.draggedItemStack.getMaxStackSize() - var6.stackSize;
-									}
-
-									var5.draggedItemStack.splitStack(var7);
-									if(var5.draggedItemStack.stackSize == 0) {
-										var5.draggedItemStack = null;
-									}
-
-									var6.stackSize += var7;
-								}
-							}
-						} else if(var6.itemID == var5.draggedItemStack.itemID && var5.draggedItemStack.getMaxStackSize() > 1) {
-							var7 = var6.stackSize;
-							if(var7 > 0 && var7 + var5.draggedItemStack.stackSize <= var5.draggedItemStack.getMaxStackSize()) {
-								var5.draggedItemStack.stackSize += var7;
-								var6.splitStack(var7);
-								if(var6.stackSize == 0) {
-									var4.putStack((ItemStack)null);
-								}
-
-								var4.onPickupFromSlot();
-							}
-						}
-					}
-				}
-
-				var4.onSlotChanged();
-			} else if(var5.draggedItemStack != null) {
-				int var9 = (this.width - this.xSize) / 2;
-				var7 = (this.height - this.ySize) / 2;
-				if(var1 < var9 || var2 < var7 || var1 >= var9 + this.xSize || var2 >= var7 + this.xSize) {
-					EntityPlayerSP var8 = this.mc.thePlayer;
-					if(var3 == 0) {
-						var8.dropPlayerItem(var5.draggedItemStack);
-						var5.draggedItemStack = null;
-					}
-
-					if(var3 == 1) {
-						var8.dropPlayerItem(var5.draggedItemStack.splitStack(1));
-						if(var5.draggedItemStack.stackSize == 0) {
-							var5.draggedItemStack = null;
-						}
-					}
-				}
-			}
-		}
-
-	}
-
-	protected void mouseMovedOrUp(int var1, int var2, int var3) {
-		if(var3 == 0) {
-		}
-
+				var8 = var4.id;
+			}
+
+			if(var7) {
+				var8 = -999;
+			}
+
+			if(var8 != -1) {
+				this.mc.playerController.func_20085_a(this.inventorySlots.windowId, var8, var3, this.mc.thePlayer);
+			}
+		}
+
+		this.mc.thePlayer.inventory.updateAchievementProgress(this.mc.achievements);
+		this.handleControls(var1, var2, var3);
 	}
 
 	protected void keyTyped(char var1, int var2) {
-		if(var2 == 1 || var2 == this.mc.options.keyBindInventory.keyCode) {
-			this.mc.displayGuiScreen((GuiScreen)null);
+		if (var2 == 1 || var2 == this.mc.options.keyBindInventory.keyCode) {
+			this.mc.thePlayer.closeCurrentInventory();
+		} else if (var2 == this.mc.options.keyBindRecipeGuide.keyCode) {
+			Slot hoverSlot = getSlotAtPosition(this.mouseX, this.mouseY);
+			if (hoverSlot != null)
+				mc.thePlayer.displayGUIRecipeGuide(hoverSlot.getStack());
 		}
-
 	}
 
 	public void onGuiClosed() {
-		InventoryPlayer var1 = this.mc.thePlayer.inventory;
-		if(var1.draggedItemStack != null) {
-			this.mc.thePlayer.dropPlayerItem(var1.draggedItemStack);
-			var1.draggedItemStack = null;
+		if(this.mc.thePlayer != null) {
+			this.mc.playerController.func_20086_a(this.inventorySlots.windowId, this.mc.thePlayer);
 		}
-
 	}
 
 	public boolean doesGuiPauseGame() {
--- /dev/null
+++ net/minecraft/src/ContainerRecipeGuide.java
@@ -1,0 +1,25 @@
+package net.minecraft.src;
+
+public class ContainerRecipeGuide extends Container {
+	private int row = 0;
+
+	public ContainerRecipeGuide() {
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return true;
+	}
+
+	public void clear() {
+		this.slots.clear();
+		row = 0;
+	}
+
+	public void addRecipe(IInventory inventory) {
+		for (int i = 0; i < 9; i++) {
+			this.addSlot(new Slot(inventory, i, 30 + (i % 3) * 18, 17 + (i / 3) * 18 + 63 * row));
+		}
+		this.addSlot(new Slot(inventory, 9, 124, 35 + 63 * row));
+		row++;
+	}
+}
--- net/minecraft/src/BlockFence.java
+++ net/minecraft/src/BlockFence.java
@@ -1,10 +1,26 @@
 package net.minecraft.src;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Random;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 
 public class BlockFence extends Block {
-	public BlockFence(int var1, int var2) {
-		super(var1, var2, Material.wood);
+	public final BitField fieldType;
+
+	private final ModelBlock[] modelBlocks;
+
+	public BlockFence(int var1, int var2, Material var3, ModelBlock[] var4) {
+		super(var1, var2, var3);
+		if (var4.length > 256) {
+			throw new IllegalArgumentException("Too many fence types! 256 maximum!");
+		}
+		this.modelBlocks = var4;
+
+		this.fieldType = this.fields.addBitField("type", 7, Arrays.stream(var4)
+				.map(t -> t.name)
+				.collect(Collectors.toList()));
 	}
 
 	public void getCollidingBoundingBoxes(World var1, int var2, int var3, int var4, AxisAlignedBB var5, ArrayList var6) {
@@ -12,7 +28,7 @@
 	}
 
 	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
-		return var1.getBlockId(var2, var3 - 1, var4) == this.blockID ? false : (!var1.getBlockMaterial(var2, var3 - 1, var4).isSolid() ? false : super.canPlaceBlockAt(var1, var2, var3, var4));
+		return true;
 	}
 
 	public boolean isOpaqueCube() {
@@ -25,5 +41,25 @@
 
 	public int getRenderType() {
 		return 11;
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return this.modelBlocks[var2].texture;
+	}
+
+	public boolean canAttachToBlock(IBlockAccess var1, int var2, int var3, int var4) {
+		int id = var1.getBlockId(var2, var3, var4);
+		Block block = Block.blocksList[id];
+		return block != null &&
+				(id == this.blockID
+				|| block.isOpaqueCube());
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var1;
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, this.modelBlocks.length).toArray();
 	}
 }
--- net/minecraft/src/ThreadSleepForever.java
+++ net/minecraft/src/ThreadSleepForever.java
@@ -3,7 +3,7 @@
 import net.minecraft.client.Minecraft;
 
 public class ThreadSleepForever extends Thread {
-	final Minecraft mc;
+	public final Minecraft mc;
 
 	public ThreadSleepForever(Minecraft var1, String var2) {
 		super(var2);
--- net/minecraft/src/Explosion.java
+++ net/minecraft/src/Explosion.java
@@ -33,7 +33,7 @@
 						var27 = var5;
 						var29 = var7;
 
-						for(float var31 = 0.3F; var24 > 0.0F; var24 -= var31 * (12.0F / 16.0F)) {
+						for(float var31 = 0.3F; var24 > 0.0F; var24 -= var31 * 0.75F) {
 							int var32 = MathHelper.floor_double(var25);
 							int var33 = MathHelper.floor_double(var27);
 							int var34 = MathHelper.floor_double(var29);
--- net/minecraft/src/ThreadMonitorConnection.java
+++ net/minecraft/src/ThreadMonitorConnection.java
@@ -1,9 +1,9 @@
 package net.minecraft.src;
 
-class ThreadMonitorConnection extends Thread {
-	final NetworkManager netManager;
+public class ThreadMonitorConnection extends Thread {
+	public final NetworkManager netManager;
 
-	ThreadMonitorConnection(NetworkManager var1) {
+	public ThreadMonitorConnection(NetworkManager var1) {
 		this.netManager = var1;
 	}
 
--- /dev/null
+++ net/minecraft/src/TileEntityCrate.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+public class TileEntityCrate extends TileEntityChest {
+	public int getInventorySize() {
+		return 9;
+	}
+
+	public String getInventoryName() {
+		return "Crate";
+	}
+}
--- /dev/null
+++ net/minecraft/src/EnumBitField.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+public class EnumBitField<E extends Enum<E>> implements IBitField {
+	public final Class<E> type;
+	private final BitField base;
+
+	public EnumBitField(String name, Class<E> type, int offset, int size) {
+		this.type = type;
+		this.base = new BitField(name, offset, size);
+	}
+
+	public E get(int number) {
+		int result = this.base.get(number);
+		return type.getEnumConstants()[result];
+	}
+
+	public int geti(int number) {
+		return this.base.get(number);
+	}
+
+	public int set(int number, E value) {
+		return this.base.set(number, value.ordinal());
+	}
+
+	public String getName() {
+		return this.base.getName();
+	}
+
+	public String getString(int number) {
+		return this.get(number).toString();
+	}
+}
--- net/minecraft/src/NoiseGeneratorOctaves.java
+++ net/minecraft/src/NoiseGeneratorOctaves.java
@@ -28,6 +28,18 @@
 		return var5;
 	}
 
+	public double generateNoiseOctaves(double var1, double var3, double var5) {
+		double var7 = 0.0D;
+		double var9 = 1.0D;
+
+		for(int var11 = 0; var11 < this.octaves; ++var11) {
+			var7 += this.generatorCollection[var11].generateNoise(var1 / var9, var3 / var9, var5 / var9) * var9;
+			var9 *= 2.0D;
+		}
+
+		return var7;
+	}
+
 	public double[] generateNoiseOctaves(double[] var1, double var2, double var4, double var6, int var8, int var9, int var10, double var11, double var13, double var15) {
 		if(var1 == null) {
 			var1 = new double[var8 * var9 * var10];
--- /dev/null
+++ net/minecraft/src/SimplexNoise.java
@@ -1,0 +1,757 @@
+package net.minecraft.src;
+
+/**
+ * K.jpg's OpenSimplex 2, faster variant
+ */
+
+public class SimplexNoise {
+
+	private static final long PRIME_X = 0x5205402B9270C86FL;
+	private static final long PRIME_Y = 0x598CD327003817B5L;
+	private static final long PRIME_Z = 0x5BCC226E9FA0BACBL;
+	private static final long PRIME_W = 0x56CC5227E58F554BL;
+	private static final long HASH_MULTIPLIER = 0x53A3F72DEEC546F5L;
+	private static final long SEED_FLIP_3D = -0x52D547B2E96ED629L;
+	private static final long SEED_OFFSET_4D = 0xE83DC3E0DA7164DL;
+
+	private static final double ROOT2OVER2 = 0.7071067811865476;
+	private static final double SKEW_2D = 0.366025403784439;
+	private static final double UNSKEW_2D = -0.21132486540518713;
+
+	private static final double ROOT3OVER3 = 0.577350269189626;
+	private static final double FALLBACK_ROTATE_3D = 2.0 / 3.0;
+	private static final double ROTATE_3D_ORTHOGONALIZER = UNSKEW_2D;
+
+	private static final float SKEW_4D = -0.138196601125011f;
+	private static final float UNSKEW_4D = 0.309016994374947f;
+	private static final float LATTICE_STEP_4D = 0.2f;
+
+	private static final int N_GRADS_2D_EXPONENT = 7;
+	private static final int N_GRADS_3D_EXPONENT = 8;
+	private static final int N_GRADS_4D_EXPONENT = 9;
+	private static final int N_GRADS_2D = 1 << N_GRADS_2D_EXPONENT;
+	private static final int N_GRADS_3D = 1 << N_GRADS_3D_EXPONENT;
+	private static final int N_GRADS_4D = 1 << N_GRADS_4D_EXPONENT;
+
+	private static final double NORMALIZER_2D = 0.01001634121365712;
+	private static final double NORMALIZER_3D = 0.07969837668935331;
+	private static final double NORMALIZER_4D = 0.0220065933241897;
+
+	private static final float RSQUARED_2D = 0.5f;
+	private static final float RSQUARED_3D = 0.6f;
+	private static final float RSQUARED_4D = 0.6f;
+
+
+	/*
+	 * Noise Evaluators
+	 */
+
+	/**
+	 * 2D Simplex noise, standard lattice orientation.
+	 */
+	public static float noise2(long seed, double x, double y) {
+
+		// Get points for A2* lattice
+		double s = SKEW_2D * (x + y);
+		double xs = x + s, ys = y + s;
+
+		return noise2_UnskewedBase(seed, xs, ys);
+	}
+
+	/**
+	 * 2D Simplex noise, with Y pointing down the main diagonal.
+	 * Might be better for a 2D sandbox style game, where Y is vertical.
+	 * Probably slightly less optimal for heightmaps or continent maps,
+	 * unless your map is centered around an equator. It's a subtle
+	 * difference, but the option is here to make it an easy choice.
+	 */
+	public static float noise2_ImproveX(long seed, double x, double y) {
+
+		// Skew transform and rotation baked into one.
+		double xx = x * ROOT2OVER2;
+		double yy = y * (ROOT2OVER2 * (1 + 2 * SKEW_2D));
+
+		return noise2_UnskewedBase(seed, yy + xx, yy - xx);
+	}
+
+	/**
+	 * 2D Simplex noise base.
+	 */
+	private static float noise2_UnskewedBase(long seed, double xs, double ys) {
+
+		// Get base points and offsets.
+		int xsb = fastFloor(xs), ysb = fastFloor(ys);
+		float xi = (float)(xs - xsb), yi = (float)(ys - ysb);
+
+		// Prime pre-multiplication for hash.
+		long xsbp = xsb * PRIME_X, ysbp = ysb * PRIME_Y;
+
+		// Unskew.
+		float t = (xi + yi) * (float)UNSKEW_2D;
+		float dx0 = xi + t, dy0 = yi + t;
+
+		// First vertex.
+		float value = 0;
+		float a0 = RSQUARED_2D - dx0 * dx0 - dy0 * dy0;
+		if (a0 > 0) {
+			value = (a0 * a0) * (a0 * a0) * grad(seed, xsbp, ysbp, dx0, dy0);
+		}
+
+		// Second vertex.
+		float a1 = (float)(2 * (1 + 2 * UNSKEW_2D) * (1 / UNSKEW_2D + 2)) * t + ((float)(-2 * (1 + 2 * UNSKEW_2D) * (1 + 2 * UNSKEW_2D)) + a0);
+		if (a1 > 0) {
+			float dx1 = dx0 - (float)(1 + 2 * UNSKEW_2D);
+			float dy1 = dy0 - (float)(1 + 2 * UNSKEW_2D);
+			value += (a1 * a1) * (a1 * a1) * grad(seed, xsbp + PRIME_X, ysbp + PRIME_Y, dx1, dy1);
+		}
+
+		// Third vertex.
+		if (dy0 > dx0) {
+			float dx2 = dx0 - (float)UNSKEW_2D;
+			float dy2 = dy0 - (float)(UNSKEW_2D + 1);
+			float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
+			if (a2 > 0) {
+				value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp, ysbp + PRIME_Y, dx2, dy2);
+			}
+		}
+		else
+		{
+			float dx2 = dx0 - (float)(UNSKEW_2D + 1);
+			float dy2 = dy0 - (float)UNSKEW_2D;
+			float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
+			if (a2 > 0) {
+				value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp + PRIME_X, ysbp, dx2, dy2);
+			}
+		}
+
+		return value;
+	}
+
+	/**
+	 * 3D OpenSimplex2 noise, with better visual isotropy in (X, Y).
+	 * Recommended for 3D terrain and time-varied animations.
+	 * The Z coordinate should always be the "different" coordinate in whatever your use case is.
+	 * If Y is vertical in world coordinates, call noise3_ImproveXZ(x, z, Y) or use noise3_XZBeforeY.
+	 * If Z is vertical in world coordinates, call noise3_ImproveXZ(x, y, Z).
+	 * For a time varied animation, call noise3_ImproveXY(x, y, T).
+	 */
+	public static float noise3_ImproveXY(long seed, double x, double y, double z) {
+
+		// Re-orient the cubic lattices without skewing, so Z points up the main lattice diagonal,
+		// and the planes formed by XY are moved far out of alignment with the cube faces.
+		// Orthonormal rotation. Not a skew transform.
+		double xy = x + y;
+		double s2 = xy * ROTATE_3D_ORTHOGONALIZER;
+		double zz = z * ROOT3OVER3;
+		double xr = x + s2 + zz;
+		double yr = y + s2 + zz;
+		double zr = xy * -ROOT3OVER3 + zz;
+
+		// Evaluate both lattices to form a BCC lattice.
+		return noise3_UnrotatedBase(seed, xr, yr, zr);
+	}
+
+	/**
+	 * 3D OpenSimplex2 noise, with better visual isotropy in (X, Z).
+	 * Recommended for 3D terrain and time-varied animations.
+	 * The Y coordinate should always be the "different" coordinate in whatever your use case is.
+	 * If Y is vertical in world coordinates, call noise3_ImproveXZ(x, Y, z).
+	 * If Z is vertical in world coordinates, call noise3_ImproveXZ(x, Z, y) or use noise3_ImproveXY.
+	 * For a time varied animation, call noise3_ImproveXZ(x, T, y) or use noise3_ImproveXY.
+	 */
+	public static float noise3_ImproveXZ(long seed, double x, double y, double z) {
+
+		// Re-orient the cubic lattices without skewing, so Y points up the main lattice diagonal,
+		// and the planes formed by XZ are moved far out of alignment with the cube faces.
+		// Orthonormal rotation. Not a skew transform.
+		double xz = x + z;
+		double s2 = xz * ROTATE_3D_ORTHOGONALIZER;
+		double yy = y * ROOT3OVER3;
+		double xr = x + s2 + yy;
+		double zr = z + s2 + yy;
+		double yr = xz * -ROOT3OVER3 + yy;
+
+		// Evaluate both lattices to form a BCC lattice.
+		return noise3_UnrotatedBase(seed, xr, yr, zr);
+	}
+
+	/**
+	 * 3D OpenSimplex2 noise, fallback rotation option
+	 * Use noise3_ImproveXY or noise3_ImproveXZ instead, wherever appropriate.
+	 * They have less diagonal bias. This function's best use is as a fallback.
+	 */
+	public static float noise3_Fallback(long seed, double x, double y, double z) {
+
+		// Re-orient the cubic lattices via rotation, to produce a familiar look.
+		// Orthonormal rotation. Not a skew transform.
+		double r = FALLBACK_ROTATE_3D * (x + y + z);
+		double xr = r - x, yr = r - y, zr = r - z;
+
+		// Evaluate both lattices to form a BCC lattice.
+		return noise3_UnrotatedBase(seed, xr, yr, zr);
+	}
+
+	/**
+	 * Generate overlapping cubic lattices for 3D OpenSimplex2 noise.
+	 */
+	private static float noise3_UnrotatedBase(long seed, double xr, double yr, double zr) {
+
+		// Get base points and offsets.
+		int xrb = fastRound(xr), yrb = fastRound(yr), zrb = fastRound(zr);
+		float xri = (float)(xr - xrb), yri = (float)(yr - yrb), zri = (float)(zr - zrb);
+
+		// -1 if positive, 1 if negative.
+		int xNSign = (int)(-1.0f - xri) | 1, yNSign = (int)(-1.0f - yri) | 1, zNSign = (int)(-1.0f - zri) | 1;
+
+		// Compute absolute values, using the above as a shortcut. This was faster in my tests for some reason.
+		float ax0 = xNSign * -xri, ay0 = yNSign * -yri, az0 = zNSign * -zri;
+
+		// Prime pre-multiplication for hash.
+		long xrbp = xrb * PRIME_X, yrbp = yrb * PRIME_Y, zrbp = zrb * PRIME_Z;
+
+		// Loop: Pick an edge on each lattice copy.
+		float value = 0;
+		float a = (RSQUARED_3D - xri * xri) - (yri * yri + zri * zri);
+		for (int l = 0; ; l++) {
+
+			// Closest point on cube.
+			if (a > 0) {
+				value += (a * a) * (a * a) * grad(seed, xrbp, yrbp, zrbp, xri, yri, zri);
+			}
+
+			// Second-closest point.
+			if (ax0 >= ay0 && ax0 >= az0) {
+				float b = a + ax0 + ax0;
+				if (b > 1) {
+					b -= 1;
+					value += (b * b) * (b * b) * grad(seed, xrbp - xNSign * PRIME_X, yrbp, zrbp, xri + xNSign, yri, zri);
+				}
+			}
+			else if (ay0 > ax0 && ay0 >= az0) {
+				float b = a + ay0 + ay0;
+				if (b > 1) {
+					b -= 1;
+					value += (b * b) * (b * b) * grad(seed, xrbp, yrbp - yNSign * PRIME_Y, zrbp, xri, yri + yNSign, zri);
+				}
+			}
+			else
+			{
+				float b = a + az0 + az0;
+				if (b > 1) {
+					b -= 1;
+					value += (b * b) * (b * b) * grad(seed, xrbp, yrbp, zrbp - zNSign * PRIME_Z, xri, yri, zri + zNSign);
+				}
+			}
+
+			// Break from loop if we're done, skipping updates below.
+			if (l == 1) break;
+
+			// Update absolute value.
+			ax0 = 0.5f - ax0;
+			ay0 = 0.5f - ay0;
+			az0 = 0.5f - az0;
+
+			// Update relative coordinate.
+			xri = xNSign * ax0;
+			yri = yNSign * ay0;
+			zri = zNSign * az0;
+
+			// Update falloff.
+			a += (0.75f - ax0) - (ay0 + az0);
+
+			// Update prime for hash.
+			xrbp += (xNSign >> 1) & PRIME_X;
+			yrbp += (yNSign >> 1) & PRIME_Y;
+			zrbp += (zNSign >> 1) & PRIME_Z;
+
+			// Update the reverse sign indicators.
+			xNSign = -xNSign;
+			yNSign = -yNSign;
+			zNSign = -zNSign;
+
+			// And finally update the seed for the other lattice copy.
+			seed ^= SEED_FLIP_3D;
+		}
+
+		return value;
+	}
+
+	/**
+	 * 4D OpenSimplex2 noise, with XYZ oriented like noise3_ImproveXY
+	 * and W for an extra degree of freedom. W repeats eventually.
+	 * Recommended for time-varied animations which texture a 3D object (W=time)
+	 * in a space where Z is vertical
+	 */
+	public static float noise4_ImproveXYZ_ImproveXY(long seed, double x, double y, double z, double w) {
+
+		double xy = x + y;
+		double s2 = xy * -0.21132486540518699998;
+		double zz = z * 0.28867513459481294226;
+		double ww = w * 0.2236067977499788;
+		double xr = x + (zz + ww + s2), yr = y + (zz + ww + s2);
+		double zr = xy * -0.57735026918962599998 + (zz + ww);
+		double wr = z * -0.866025403784439 + ww;
+
+		return noise4_UnskewedBase(seed, xr, yr, zr, wr);
+	}
+
+	/**
+	 * 4D OpenSimplex2 noise, with XYZ oriented like noise3_ImproveXZ
+	 * and W for an extra degree of freedom. W repeats eventually.
+	 * Recommended for time-varied animations which texture a 3D object (W=time)
+	 * in a space where Y is vertical
+	 */
+	public static float noise4_ImproveXYZ_ImproveXZ(long seed, double x, double y, double z, double w) {
+
+		double xz = x + z;
+		double s2 = xz * -0.21132486540518699998;
+		double yy = y * 0.28867513459481294226;
+		double ww = w * 0.2236067977499788;
+		double xr = x + (yy + ww + s2), zr = z + (yy + ww + s2);
+		double yr = xz * -0.57735026918962599998 + (yy + ww);
+		double wr = y * -0.866025403784439 + ww;
+
+		return noise4_UnskewedBase(seed, xr, yr, zr, wr);
+	}
+
+	/**
+	 * 4D OpenSimplex2 noise, with XYZ oriented like noise3_Fallback
+	 * and W for an extra degree of freedom. W repeats eventually.
+	 * Recommended for time-varied animations which texture a 3D object (W=time)
+	 * where there isn't a clear distinction between horizontal and vertical
+	 */
+	public static float noise4_ImproveXYZ(long seed, double x, double y, double z, double w) {
+
+		double xyz = x + y + z;
+		double ww = w * 0.2236067977499788;
+		double s2 = xyz * -0.16666666666666666 + ww;
+		double xs = x + s2, ys = y + s2, zs = z + s2, ws = -0.5 * xyz + ww;
+
+		return noise4_UnskewedBase(seed, xs, ys, zs, ws);
+	}
+
+	/**
+	 * 4D OpenSimplex2 noise, with XY and ZW forming orthogonal triangular-based planes.
+	 * Recommended for 3D terrain, where X and Y (or Z and W) are horizontal.
+	 * Recommended for noise(x, y, sin(time), cos(time)) trick.
+	 */
+	public static float noise4_ImproveXY_ImproveZW(long seed, double x, double y, double z, double w) {
+
+		double s2 = (x + y) * -0.178275657951399372 + (z + w) * 0.215623393288842828;
+		double t2 = (z + w) * -0.403949762580207112 + (x + y) * -0.375199083010075342;
+		double xs = x + s2, ys = y + s2, zs = z + t2, ws = w + t2;
+
+		return noise4_UnskewedBase(seed, xs, ys, zs, ws);
+	}
+
+	/**
+	 * 4D OpenSimplex2 noise, fallback lattice orientation.
+	 */
+	public static float noise4_Fallback(long seed, double x, double y, double z, double w) {
+
+		// Get points for A4 lattice
+		double s = SKEW_4D * (x + y + z + w);
+		double xs = x + s, ys = y + s, zs = z + s, ws = w + s;
+
+		return noise4_UnskewedBase(seed, xs, ys, zs, ws);
+	}
+
+	/**
+	 * 4D OpenSimplex2 noise base.
+	 */
+	private static float noise4_UnskewedBase(long seed, double xs, double ys, double zs, double ws) {
+
+		// Get base points and offsets
+		int xsb = fastFloor(xs), ysb = fastFloor(ys), zsb = fastFloor(zs), wsb = fastFloor(ws);
+		float xsi = (float)(xs - xsb), ysi = (float)(ys - ysb), zsi = (float)(zs - zsb), wsi = (float)(ws - wsb);
+
+		// Determine which lattice we can be confident has a contributing point its corresponding cell's base simplex.
+		// We only look at the spaces between the diagonal planes. This proved effective in all of my tests.
+		float siSum = (xsi + ysi) + (zsi + wsi);
+		int startingLattice = (int)(siSum * 1.25);
+
+		// Offset for seed based on first lattice copy.
+		seed += startingLattice * SEED_OFFSET_4D;
+
+		// Offset for lattice point relative positions (skewed)
+		float startingLatticeOffset = startingLattice * -LATTICE_STEP_4D;
+		xsi += startingLatticeOffset; ysi += startingLatticeOffset; zsi += startingLatticeOffset; wsi += startingLatticeOffset;
+
+		// Prep for vertex contributions.
+		float ssi = (siSum + startingLatticeOffset * 4) * UNSKEW_4D;
+
+		// Prime pre-multiplication for hash.
+		long xsvp = xsb * PRIME_X, ysvp = ysb * PRIME_Y, zsvp = zsb * PRIME_Z, wsvp = wsb * PRIME_W;
+
+		// Five points to add, total, from five copies of the A4 lattice.
+		float value = 0;
+		for (int i = 0; ; i++) {
+
+			// Next point is the closest vertex on the 4-simplex whose base vertex is the aforementioned vertex.
+			double score0 = 1.0 + ssi * (-1.0 / UNSKEW_4D); // Seems slightly faster than 1.0-xsi-ysi-zsi-wsi
+			if (xsi >= ysi && xsi >= zsi && xsi >= wsi && xsi >= score0) {
+				xsvp += PRIME_X;
+				xsi -= 1;
+				ssi -= UNSKEW_4D;
+			}
+			else if (ysi > xsi && ysi >= zsi && ysi >= wsi && ysi >= score0) {
+				ysvp += PRIME_Y;
+				ysi -= 1;
+				ssi -= UNSKEW_4D;
+			}
+			else if (zsi > xsi && zsi > ysi && zsi >= wsi && zsi >= score0) {
+				zsvp += PRIME_Z;
+				zsi -= 1;
+				ssi -= UNSKEW_4D;
+			}
+			else if (wsi > xsi && wsi > ysi && wsi > zsi && wsi >= score0) {
+				wsvp += PRIME_W;
+				wsi -= 1;
+				ssi -= UNSKEW_4D;
+			}
+
+			// gradient contribution with falloff.
+			float dx = xsi + ssi, dy = ysi + ssi, dz = zsi + ssi, dw = wsi + ssi;
+			float a = (dx * dx + dy * dy) + (dz * dz + dw * dw);
+			if (a < RSQUARED_4D) {
+				a -= RSQUARED_4D;
+				a *= a;
+				value += a * a * grad(seed, xsvp, ysvp, zsvp, wsvp, dx, dy, dz, dw);
+			}
+
+			// Break from loop if we're done, skipping updates below.
+			if (i == 4) break;
+
+			// Update for next lattice copy shifted down by <-0.2, -0.2, -0.2, -0.2>.
+			xsi += LATTICE_STEP_4D; ysi += LATTICE_STEP_4D; zsi += LATTICE_STEP_4D; wsi += LATTICE_STEP_4D;
+			ssi += LATTICE_STEP_4D * 4 * UNSKEW_4D;
+			seed -= SEED_OFFSET_4D;
+
+			// Because we don't always start on the same lattice copy, there's a special reset case.
+			if (i == startingLattice) {
+				xsvp -= PRIME_X;
+				ysvp -= PRIME_Y;
+				zsvp -= PRIME_Z;
+				wsvp -= PRIME_W;
+				seed += SEED_OFFSET_4D * 5;
+			}
+		}
+
+		return value;
+	}
+
+	/*
+	 * Utility
+	 */
+
+	private static float grad(long seed, long xsvp, long ysvp, float dx, float dy) {
+		long hash = seed ^ xsvp ^ ysvp;
+		hash *= HASH_MULTIPLIER;
+		hash ^= hash >> (64 - N_GRADS_2D_EXPONENT + 1);
+		int gi = (int)hash & ((N_GRADS_2D - 1) << 1);
+		return GRADIENTS_2D[gi | 0] * dx + GRADIENTS_2D[gi | 1] * dy;
+	}
+
+	private static float grad(long seed, long xrvp, long yrvp, long zrvp, float dx, float dy, float dz) {
+		long hash = (seed ^ xrvp) ^ (yrvp ^ zrvp);
+		hash *= HASH_MULTIPLIER;
+		hash ^= hash >> (64 - N_GRADS_3D_EXPONENT + 2);
+		int gi = (int)hash & ((N_GRADS_3D - 1) << 2);
+		return GRADIENTS_3D[gi | 0] * dx + GRADIENTS_3D[gi | 1] * dy + GRADIENTS_3D[gi | 2] * dz;
+	}
+
+	private static float grad(long seed, long xsvp, long ysvp, long zsvp, long wsvp, float dx, float dy, float dz, float dw) {
+		long hash = seed ^ (xsvp ^ ysvp) ^ (zsvp ^ wsvp);
+		hash *= HASH_MULTIPLIER;
+		hash ^= hash >> (64 - N_GRADS_4D_EXPONENT + 2);
+		int gi = (int)hash & ((N_GRADS_4D - 1) << 2);
+		return (GRADIENTS_4D[gi | 0] * dx + GRADIENTS_4D[gi | 1] * dy) + (GRADIENTS_4D[gi | 2] * dz + GRADIENTS_4D[gi | 3] * dw);
+	}
+
+	private static int fastFloor(double x) {
+		int xi = (int)x;
+		return x < xi ? xi - 1 : xi;
+	}
+
+	private static int fastRound(double x) {
+		return x < 0 ? (int)(x - 0.5) : (int)(x + 0.5);
+	}
+
+	/*
+	 * gradients
+	 */
+
+	private static float[] GRADIENTS_2D;
+	private static float[] GRADIENTS_3D;
+	private static float[] GRADIENTS_4D;
+	static {
+
+		GRADIENTS_2D = new float[N_GRADS_2D * 2];
+		float[] grad2 = {
+			 0.38268343236509f,   0.923879532511287f,
+			 0.923879532511287f,  0.38268343236509f,
+			 0.923879532511287f, -0.38268343236509f,
+			 0.38268343236509f,  -0.923879532511287f,
+			-0.38268343236509f,  -0.923879532511287f,
+			-0.923879532511287f, -0.38268343236509f,
+			-0.923879532511287f,  0.38268343236509f,
+			-0.38268343236509f,   0.923879532511287f,
+			//-------------------------------------//
+			 0.130526192220052f,  0.99144486137381f,
+			 0.608761429008721f,  0.793353340291235f,
+			 0.793353340291235f,  0.608761429008721f,
+			 0.99144486137381f,   0.130526192220051f,
+			 0.99144486137381f,  -0.130526192220051f,
+			 0.793353340291235f, -0.60876142900872f,
+			 0.608761429008721f, -0.793353340291235f,
+			 0.130526192220052f, -0.99144486137381f,
+			-0.130526192220052f, -0.99144486137381f,
+			-0.608761429008721f, -0.793353340291235f,
+			-0.793353340291235f, -0.608761429008721f,
+			-0.99144486137381f,  -0.130526192220052f,
+			-0.99144486137381f,   0.130526192220051f,
+			-0.793353340291235f,  0.608761429008721f,
+			-0.608761429008721f,  0.793353340291235f,
+			-0.130526192220052f,  0.99144486137381f,
+		};
+		for (int i = 0; i < grad2.length; i++) {
+			grad2[i] = (float)(grad2[i] / NORMALIZER_2D);
+		}
+		for (int i = 0, j = 0; i < GRADIENTS_2D.length; i++, j++) {
+			if (j == grad2.length) j = 0;
+			GRADIENTS_2D[i] = grad2[j];
+		}
+
+		GRADIENTS_3D = new float[N_GRADS_3D * 4];
+		float[] grad3 = {
+			 2.22474487139f,	   2.22474487139f,	  -1.0f,				 0.0f,
+			 2.22474487139f,	   2.22474487139f,	   1.0f,				 0.0f,
+			 3.0862664687972017f,  1.1721513422464978f,  0.0f,				 0.0f,
+			 1.1721513422464978f,  3.0862664687972017f,  0.0f,				 0.0f,
+			-2.22474487139f,	   2.22474487139f,	  -1.0f,				 0.0f,
+			-2.22474487139f,	   2.22474487139f,	   1.0f,				 0.0f,
+			-1.1721513422464978f,  3.0862664687972017f,  0.0f,				 0.0f,
+			-3.0862664687972017f,  1.1721513422464978f,  0.0f,				 0.0f,
+			-1.0f,				-2.22474487139f,	  -2.22474487139f,	   0.0f,
+			 1.0f,				-2.22474487139f,	  -2.22474487139f,	   0.0f,
+			 0.0f,				-3.0862664687972017f, -1.1721513422464978f,  0.0f,
+			 0.0f,				-1.1721513422464978f, -3.0862664687972017f,  0.0f,
+			-1.0f,				-2.22474487139f,	   2.22474487139f,	   0.0f,
+			 1.0f,				-2.22474487139f,	   2.22474487139f,	   0.0f,
+			 0.0f,				-1.1721513422464978f,  3.0862664687972017f,  0.0f,
+			 0.0f,				-3.0862664687972017f,  1.1721513422464978f,  0.0f,
+			//--------------------------------------------------------------------//
+			-2.22474487139f,	  -2.22474487139f,	  -1.0f,				 0.0f,
+			-2.22474487139f,	  -2.22474487139f,	   1.0f,				 0.0f,
+			-3.0862664687972017f, -1.1721513422464978f,  0.0f,				 0.0f,
+			-1.1721513422464978f, -3.0862664687972017f,  0.0f,				 0.0f,
+			-2.22474487139f,	  -1.0f,				-2.22474487139f,	   0.0f,
+			-2.22474487139f,	   1.0f,				-2.22474487139f,	   0.0f,
+			-1.1721513422464978f,  0.0f,				-3.0862664687972017f,  0.0f,
+			-3.0862664687972017f,  0.0f,				-1.1721513422464978f,  0.0f,
+			-2.22474487139f,	  -1.0f,				 2.22474487139f,	   0.0f,
+			-2.22474487139f,	   1.0f,				 2.22474487139f,	   0.0f,
+			-3.0862664687972017f,  0.0f,				 1.1721513422464978f,  0.0f,
+			-1.1721513422464978f,  0.0f,				 3.0862664687972017f,  0.0f,
+			-1.0f,				 2.22474487139f,	  -2.22474487139f,	   0.0f,
+			 1.0f,				 2.22474487139f,	  -2.22474487139f,	   0.0f,
+			 0.0f,				 1.1721513422464978f, -3.0862664687972017f,  0.0f,
+			 0.0f,				 3.0862664687972017f, -1.1721513422464978f,  0.0f,
+			-1.0f,				 2.22474487139f,	   2.22474487139f,	   0.0f,
+			 1.0f,				 2.22474487139f,	   2.22474487139f,	   0.0f,
+			 0.0f,				 3.0862664687972017f,  1.1721513422464978f,  0.0f,
+			 0.0f,				 1.1721513422464978f,  3.0862664687972017f,  0.0f,
+			 2.22474487139f,	  -2.22474487139f,	  -1.0f,				 0.0f,
+			 2.22474487139f,	  -2.22474487139f,	   1.0f,				 0.0f,
+			 1.1721513422464978f, -3.0862664687972017f,  0.0f,				 0.0f,
+			 3.0862664687972017f, -1.1721513422464978f,  0.0f,				 0.0f,
+			 2.22474487139f,	  -1.0f,				-2.22474487139f,	   0.0f,
+			 2.22474487139f,	   1.0f,				-2.22474487139f,	   0.0f,
+			 3.0862664687972017f,  0.0f,				-1.1721513422464978f,  0.0f,
+			 1.1721513422464978f,  0.0f,				-3.0862664687972017f,  0.0f,
+			 2.22474487139f,	  -1.0f,				 2.22474487139f,	   0.0f,
+			 2.22474487139f,	   1.0f,				 2.22474487139f,	   0.0f,
+			 1.1721513422464978f,  0.0f,				 3.0862664687972017f,  0.0f,
+			 3.0862664687972017f,  0.0f,				 1.1721513422464978f,  0.0f,
+		};
+		for (int i = 0; i < grad3.length; i++) {
+			grad3[i] = (float)(grad3[i] / NORMALIZER_3D);
+		}
+		for (int i = 0, j = 0; i < GRADIENTS_3D.length; i++, j++) {
+			if (j == grad3.length) j = 0;
+			GRADIENTS_3D[i] = grad3[j];
+		}
+
+		GRADIENTS_4D = new float[N_GRADS_4D * 4];
+		float[] grad4 = {
+			-0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,	0.5794684678643381f,
+			-0.7504883828755602f,   -0.4004672082940195f,	0.15296486218853164f,   0.5029860367700724f,
+			-0.7504883828755602f,	0.15296486218853164f,  -0.4004672082940195f,	0.5029860367700724f,
+			-0.8828161875373585f,	0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,
+			-0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,
+			-0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,	0.7504883828755602f,
+			-0.5029860367700724f,	0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,
+			-0.5794684678643381f,	0.3239847771997537f,	0.3239847771997537f,	0.6740059517812944f,
+			-0.6740059517812944f,   -0.3239847771997537f,	0.5794684678643381f,   -0.3239847771997537f,
+			-0.7504883828755602f,   -0.4004672082940195f,	0.5029860367700724f,	0.15296486218853164f,
+			-0.7504883828755602f,	0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,
+			-0.8828161875373585f,	0.08164729285680945f,   0.4553054119602712f,	0.08164729285680945f,
+			-0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,
+			-0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,	0.4004672082940195f,
+			-0.5029860367700724f,	0.4004672082940195f,	0.7504883828755602f,   -0.15296486218853164f,
+			-0.5794684678643381f,	0.3239847771997537f,	0.6740059517812944f,	0.3239847771997537f,
+			-0.6740059517812944f,	0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,
+			-0.7504883828755602f,	0.5029860367700724f,   -0.4004672082940195f,	0.15296486218853164f,
+			-0.7504883828755602f,	0.5029860367700724f,	0.15296486218853164f,  -0.4004672082940195f,
+			-0.8828161875373585f,	0.4553054119602712f,	0.08164729285680945f,   0.08164729285680945f,
+			-0.4553054119602712f,	0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,
+			-0.5029860367700724f,	0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,
+			-0.5029860367700724f,	0.7504883828755602f,	0.4004672082940195f,   -0.15296486218853164f,
+			-0.5794684678643381f,	0.6740059517812944f,	0.3239847771997537f,	0.3239847771997537f,
+			 0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,
+			 0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,	0.15296486218853164f,
+			 0.5029860367700724f,   -0.7504883828755602f,	0.15296486218853164f,  -0.4004672082940195f,
+			 0.4553054119602712f,   -0.8828161875373585f,	0.08164729285680945f,   0.08164729285680945f,
+			 0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,
+			 0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,
+			 0.7504883828755602f,   -0.5029860367700724f,	0.4004672082940195f,   -0.15296486218853164f,
+			 0.6740059517812944f,   -0.5794684678643381f,	0.3239847771997537f,	0.3239847771997537f,
+			//------------------------------------------------------------------------------------------//
+			-0.753341017856078f,	-0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,
+			-0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,	0.12128480194602098f,
+			-0.7821684431180708f,   -0.4321472685365301f,	0.12128480194602098f,  -0.4321472685365301f,
+			-0.7821684431180708f,	0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,
+			-0.8586508742123365f,   -0.508629699630796f,	 0.044802370851755174f,  0.044802370851755174f,
+			-0.8586508742123365f,	0.044802370851755174f, -0.508629699630796f,	 0.044802370851755174f,
+			-0.8586508742123365f,	0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,
+			-0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,
+			-0.37968289875261624f,  -0.753341017856078f,	-0.37968289875261624f,  -0.37968289875261624f,
+			-0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,	0.12128480194602098f,
+			-0.4321472685365301f,   -0.7821684431180708f,	0.12128480194602098f,  -0.4321472685365301f,
+			 0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,
+			-0.508629699630796f,	-0.8586508742123365f,	0.044802370851755174f,  0.044802370851755174f,
+			 0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,	 0.044802370851755174f,
+			 0.044802370851755174f, -0.8586508742123365f,	0.044802370851755174f, -0.508629699630796f,
+			-0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,
+			-0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,	-0.37968289875261624f,
+			-0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,	0.12128480194602098f,
+			-0.4321472685365301f,	0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,
+			 0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,
+			-0.508629699630796f,	 0.044802370851755174f, -0.8586508742123365f,	0.044802370851755174f,
+			 0.044802370851755174f, -0.508629699630796f,	-0.8586508742123365f,	0.044802370851755174f,
+			 0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,
+			-0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,
+			-0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,
+			-0.4321472685365301f,   -0.4321472685365301f,	0.12128480194602098f,  -0.7821684431180708f,
+			-0.4321472685365301f,	0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,
+			 0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,
+			-0.508629699630796f,	 0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,
+			 0.044802370851755174f, -0.508629699630796f,	 0.044802370851755174f, -0.8586508742123365f,
+			 0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,	-0.8586508742123365f,
+			-0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,
+			-0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,	0.5794684678643381f,
+			-0.4004672082940195f,   -0.7504883828755602f,	0.15296486218853164f,   0.5029860367700724f,
+			 0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,	0.5029860367700724f,
+			 0.08164729285680945f,  -0.8828161875373585f,	0.08164729285680945f,   0.4553054119602712f,
+			-0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,
+			-0.15296486218853164f,  -0.5029860367700724f,	0.4004672082940195f,	0.7504883828755602f,
+			 0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,
+			 0.3239847771997537f,   -0.5794684678643381f,	0.3239847771997537f,	0.6740059517812944f,
+			-0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,	0.5794684678643381f,
+			-0.4004672082940195f,	0.15296486218853164f,  -0.7504883828755602f,	0.5029860367700724f,
+			 0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,	0.5029860367700724f,
+			 0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,	0.4553054119602712f,
+			-0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,	0.8828161875373585f,
+			-0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,	0.7504883828755602f,
+			 0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,	0.7504883828755602f,
+			 0.3239847771997537f,	0.3239847771997537f,   -0.5794684678643381f,	0.6740059517812944f,
+			-0.3239847771997537f,   -0.6740059517812944f,	0.5794684678643381f,   -0.3239847771997537f,
+			-0.4004672082940195f,   -0.7504883828755602f,	0.5029860367700724f,	0.15296486218853164f,
+			 0.15296486218853164f,  -0.7504883828755602f,	0.5029860367700724f,   -0.4004672082940195f,
+			 0.08164729285680945f,  -0.8828161875373585f,	0.4553054119602712f,	0.08164729285680945f,
+			-0.08164729285680945f,  -0.4553054119602712f,	0.8828161875373585f,   -0.08164729285680945f,
+			-0.15296486218853164f,  -0.5029860367700724f,	0.7504883828755602f,	0.4004672082940195f,
+			 0.4004672082940195f,   -0.5029860367700724f,	0.7504883828755602f,   -0.15296486218853164f,
+			 0.3239847771997537f,   -0.5794684678643381f,	0.6740059517812944f,	0.3239847771997537f,
+			-0.3239847771997537f,   -0.3239847771997537f,	0.5794684678643381f,   -0.6740059517812944f,
+			-0.4004672082940195f,	0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,
+			 0.15296486218853164f,  -0.4004672082940195f,	0.5029860367700724f,   -0.7504883828755602f,
+			 0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,
+			-0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,
+			-0.15296486218853164f,   0.4004672082940195f,	0.7504883828755602f,   -0.5029860367700724f,
+			 0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,
+			 0.3239847771997537f,	0.3239847771997537f,	0.6740059517812944f,   -0.5794684678643381f,
+			-0.3239847771997537f,	0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,
+			-0.4004672082940195f,	0.5029860367700724f,   -0.7504883828755602f,	0.15296486218853164f,
+			 0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,
+			 0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,	0.08164729285680945f,
+			-0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,
+			-0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,	0.4004672082940195f,
+			 0.4004672082940195f,	0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,
+			 0.3239847771997537f,	0.6740059517812944f,   -0.5794684678643381f,	0.3239847771997537f,
+			-0.3239847771997537f,	0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,
+			-0.4004672082940195f,	0.5029860367700724f,	0.15296486218853164f,  -0.7504883828755602f,
+			 0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,
+			 0.08164729285680945f,   0.4553054119602712f,	0.08164729285680945f,  -0.8828161875373585f,
+			-0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,
+			-0.15296486218853164f,   0.7504883828755602f,	0.4004672082940195f,   -0.5029860367700724f,
+			 0.4004672082940195f,	0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,
+			 0.3239847771997537f,	0.6740059517812944f,	0.3239847771997537f,   -0.5794684678643381f,
+			 0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,
+			 0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,	0.15296486218853164f,
+			 0.5029860367700724f,	0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,
+			 0.4553054119602712f,	0.08164729285680945f,  -0.8828161875373585f,	0.08164729285680945f,
+			 0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,
+			 0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,	0.4004672082940195f,
+			 0.7504883828755602f,	0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,
+			 0.6740059517812944f,	0.3239847771997537f,   -0.5794684678643381f,	0.3239847771997537f,
+			 0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,
+			 0.5029860367700724f,   -0.4004672082940195f,	0.15296486218853164f,  -0.7504883828755602f,
+			 0.5029860367700724f,	0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,
+			 0.4553054119602712f,	0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,
+			 0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,
+			 0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,
+			 0.7504883828755602f,	0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,
+			 0.6740059517812944f,	0.3239847771997537f,	0.3239847771997537f,   -0.5794684678643381f,
+			 0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,
+			-0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,	 0.8586508742123365f,
+			-0.044802370851755174f,  0.508629699630796f,	-0.044802370851755174f,  0.8586508742123365f,
+			-0.12128480194602098f,   0.4321472685365301f,	0.4321472685365301f,	0.7821684431180708f,
+			 0.508629699630796f,	-0.044802370851755174f, -0.044802370851755174f,  0.8586508742123365f,
+			 0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,	0.7821684431180708f,
+			 0.4321472685365301f,	0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,
+			 0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,
+			 0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,	0.03381941603233842f,
+			-0.044802370851755174f,  0.044802370851755174f,  0.8586508742123365f,	0.508629699630796f,
+			-0.044802370851755174f,  0.508629699630796f,	 0.8586508742123365f,   -0.044802370851755174f,
+			-0.12128480194602098f,   0.4321472685365301f,	0.7821684431180708f,	0.4321472685365301f,
+			 0.508629699630796f,	-0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,
+			 0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,	0.4321472685365301f,
+			 0.4321472685365301f,	0.4321472685365301f,	0.7821684431180708f,   -0.12128480194602098f,
+			 0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,	 0.37968289875261624f,
+			 0.03381941603233842f,   0.9982828964265062f,	0.03381941603233842f,   0.03381941603233842f,
+			-0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,
+			-0.044802370851755174f,  0.8586508742123365f,	0.508629699630796f,	-0.044802370851755174f,
+			-0.12128480194602098f,   0.7821684431180708f,	0.4321472685365301f,	0.4321472685365301f,
+			 0.508629699630796f,	 0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,
+			 0.4321472685365301f,	0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,
+			 0.4321472685365301f,	0.7821684431180708f,	0.4321472685365301f,   -0.12128480194602098f,
+			 0.37968289875261624f,   0.753341017856078f,	 0.37968289875261624f,   0.37968289875261624f,
+			 0.9982828964265062f,	0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,
+			 0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,
+			 0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,	-0.044802370851755174f,
+			 0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,	0.4321472685365301f,
+			 0.8586508742123365f,	0.508629699630796f,	-0.044802370851755174f, -0.044802370851755174f,
+			 0.7821684431180708f,	0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,
+			 0.7821684431180708f,	0.4321472685365301f,	0.4321472685365301f,   -0.12128480194602098f,
+			 0.753341017856078f,	 0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,
+		};
+		for (int i = 0; i < grad4.length; i++) {
+			grad4[i] = (float)(grad4[i] / NORMALIZER_4D);
+		}
+		for (int i = 0, j = 0; i < GRADIENTS_4D.length; i++, j++) {
+			if (j == grad4.length) j = 0;
+			GRADIENTS_4D[i] = grad4[j];
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemCharm.java
@@ -1,0 +1,41 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+public class ItemCharm extends ItemEquipable {
+	public final String textureName;
+
+	public ItemCharm(int id) {
+		super(id, 4);
+		this.textureName = null;
+	}
+
+	public ItemCharm(int id, String renderName) {
+		super(id, 4);
+		this.textureName = renderName;
+	}
+
+	public ItemCharm(int id, int durability) {
+		super(id, 4, durability);
+		this.textureName = null;
+	}
+
+	public ItemCharm(int id, int durability, String renderName) {
+		super(id, 4, durability);
+		this.textureName = renderName;
+	}
+
+	public void updateCharm(EntityPlayer player, ItemStack stack) {
+	}
+
+	public boolean incompatibleWith(ItemCharm otherCharm) {
+		return this.shiftedIndex == otherCharm.shiftedIndex;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				"Can be equipped in", INFO_COL,
+				"the charm slot", INFO_COL
+		};
+	}
+}
--- net/minecraft/src/WorldServer.java
+++ net/minecraft/src/WorldServer.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import net.minecraft.server.MinecraftServer;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
@@ -9,25 +10,49 @@
 	public boolean disableSpawnProtection = false;
 	public boolean levelSaving;
 	private boolean monsters;
-	private SpawnerAnimals monsterSpawner = new SpawnerServer(this, 200, IMobs.class, new Class[]{EntityZombie.class, EntitySkeleton.class, EntityCreeper.class, EntitySpider.class, EntitySlime.class});
-	private SpawnerAnimals animalSpawner = new SpawnerAnimals(15, EntityAnimal.class, new Class[]{EntitySheep.class, EntityPig.class, EntityCow.class, EntityChicken.class});
-
-	public WorldServer(File var1, String var2, boolean var3) {
-		super(var1, var2);
+	private MCHashTableInteger entityHashTable;
+	private MinecraftServer mcServer;
+
+	public WorldServer(MinecraftServer mcServer, File var1, String var2, boolean var3) {
+		this(mcServer, var1, var2, var3, null);
+	}
+
+	public WorldServer(MinecraftServer mcServer, File var1, String var2, boolean var3, CreateWorldInfo info) {
+		super(var1, var2, 0, info, null);
 		this.monsters = var3;
+		this.entityHashTable = new MCHashTableInteger();
+		this.mcServer = mcServer;
+
+		if (!this.monsters) {
+			this.monsterSpawner = null;
+			this.underworldSpawner = null;
+		}
+	}
+
+	public boolean canDoClientAction() {
+		return MinecraftServer.getInstance() != null;
 	}
 
 	public void tick() {
 		super.tick();
-		if(this.monsters) {
-			this.monsterSpawner.onUpdate(this);
-		}
-
-		this.animalSpawner.onUpdate(this);
-	}
-
-	protected IChunkProvider getChunkProvider(File var1) {
-		this.chunkProviderServer = new ChunkProviderServer(this, new ChunkLoader(var1, true), new ChunkProviderGenerate(this, this.randomSeed));
+	}
+
+	protected void obtainEntitySkin(Entity var1) {
+		super.obtainEntitySkin(var1);
+		this.entityHashTable.addKey(var1.entityID, var1);
+	}
+
+	protected void releaseEntitySkin(Entity var1) {
+		super.releaseEntitySkin(var1);
+		this.entityHashTable.removeObject(var1.entityID);
+	}
+
+	public Entity getEntityFromId(int id) {
+		return (Entity) this.entityHashTable.lookup(id);
+	}
+
+	public IChunkProvider getChunkProvider(File var1) {
+		this.chunkProviderServer = new ChunkProviderServer(this, new McRegionChunkLoader(var1), new ChunkProviderGenerate(this, this.randomSeed));
 		return this.chunkProviderServer;
 	}
 
@@ -42,5 +67,10 @@
 		}
 
 		return var7;
+	}
+
+	public void sendTrackedEntityStatusUpdatePacket(Entity var1, byte var2) {
+		Packet38EntityStatus packet38EntityStatus3 = new Packet38EntityStatus(var1.entityID, var2);
+		this.mcServer.entityTracker.sendPacketToTrackedPlayersAndTrackedEntity(var1, packet38EntityStatus3);
 	}
 }
--- net/minecraft/src/PlayerListBox.java
+++ net/minecraft/src/PlayerListBox.java
@@ -2,8 +2,8 @@
 
 import java.util.Vector;
 import javax.swing.JList;
-import net.minecraft.server.MinecraftServer;
 
+import net.minecraft.server.MinecraftServer;
 public class PlayerListBox extends JList implements IUpdatePlayerListBox {
 	private MinecraftServer mcServer;
 	private int playerCount = 0;
--- /dev/null
+++ net/minecraft/src/BlockCrate.java
@@ -1,0 +1,69 @@
+package net.minecraft.src;
+
+import java.util.Random;
+import java.util.stream.IntStream;
+
+public class BlockCrate extends BlockContainer {
+	public final BitField fieldType = this.fields.addBitField("type", 8, BlockWood.woodTypeNames);
+	private final Random random = new Random();
+
+	public BlockCrate(int var1) {
+		super(var1, Material.wood);
+		this.maxStackSize = 1;
+		this.blockIndexInTexture = textureXY(9, 8);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return this.blockIndexInTexture + var2 * 32;
+	}
+
+	protected TileEntity getBlockEntity() {
+		return new TileEntityCrate();
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		TileEntityCrate var6 = (TileEntityCrate)var1.getBlockTileEntity(var2, var3, var4);
+		var5.displayGUICrate(var6);
+		return true;
+	}
+
+	public int quantityDropped(Random var1) {
+		return 0;
+	}
+
+	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
+		if (!var1.canDoClientAction()) return;
+		TileEntityCrate crate = (TileEntityCrate)var1.getBlockTileEntity(var2, var3, var4);
+
+		ItemStack stack = new ItemStack(this.blockID, 1, -1, var1.getBlockMetadata(var2, var3, var4));
+		stack.withStorage(new NBTTagCompound());
+		crate.writeItemsToNBT(stack.storage);
+
+		float var8 = this.random.nextFloat() * 0.8F + 0.1F;
+		float var9 = this.random.nextFloat() * 0.8F + 0.1F;
+		float var10 = this.random.nextFloat() * 0.8F + 0.1F;
+
+		EntityItem var12 = new EntityItem(var1, (float)var2 + var8, (float)var3 + var9, (float)var4 + var10, stack);
+		float var13 = 0.05F;
+		var12.motionX = (float)this.random.nextGaussian() * var13;
+		var12.motionY = (float)this.random.nextGaussian() * var13 + 0.2F;
+		var12.motionZ = (float)this.random.nextGaussian() * var13;
+		var12.delayBeforeCanPickup = 10;
+		var1.spawnEntityInWorld(var12);
+	}
+
+	public void onBlockPlacedBy(World var1, int var2, int var3, int var4, EntityPlayer var5, ItemStack var6) {
+		NBTTagCompound storage = var6.storage;
+		if (storage == null) return;
+
+		NBTTagList items = storage.getTagList("Items");
+		if (items.tagCount() == 0) return;
+
+		TileEntityCrate crate = (TileEntityCrate)var1.getBlockTileEntity(var2, var3, var4);
+		crate.readItemsFromNBT(storage);
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, BlockWood.woodTypeNames.size()).toArray();
+	}
+}
--- net/minecraft/src/EntityFX.java
+++ net/minecraft/src/EntityFX.java
@@ -71,10 +71,10 @@
 	}
 
 	public void renderParticle(Tessellator var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-		float var8 = (float)(this.particleTextureIndex % 16) / 16.0F;
-		float var9 = var8 + 0.999F / 16.0F;
-		float var10 = (float)(this.particleTextureIndex / 16) / 16.0F;
-		float var11 = var10 + 0.999F / 16.0F;
+		float var8 = (float)(this.particleTextureIndex % 32) / 32.0F;
+		float var9 = var8 + 0.999F / 32.0F;
+		float var10 = (float)(this.particleTextureIndex / 32) / 32.0F;
+		float var11 = var10 + 0.999F / 32.0F;
 		float var12 = 0.1F * this.particleScale;
 		float var13 = (float)(this.prevPosX + (this.posX - this.prevPosX) * (double)var2 - interpPosX);
 		float var14 = (float)(this.prevPosY + (this.posY - this.prevPosY) * (double)var2 - interpPosY);
--- net/minecraft/src/BlockBreakable.java
+++ net/minecraft/src/BlockBreakable.java
@@ -3,7 +3,7 @@
 public class BlockBreakable extends Block {
 	private boolean localFlag;
 
-	protected BlockBreakable(int var1, int var2, Material var3, boolean var4) {
+	public BlockBreakable(int var1, int var2, Material var3, boolean var4) {
 		super(var1, var2, var3);
 		this.localFlag = var4;
 	}
@@ -14,6 +14,6 @@
 
 	public boolean shouldSideBeRendered(IBlockAccess var1, int var2, int var3, int var4, int var5) {
 		int var6 = var1.getBlockId(var2, var3, var4);
-		return !this.localFlag && var6 == this.blockID ? false : super.shouldSideBeRendered(var1, var2, var3, var4, var5);
+		return (this.localFlag || var6 != this.blockID) && super.shouldSideBeRendered(var1, var2, var3, var4, var5);
 	}
 }
--- net/minecraft/src/RenderLiving.java
+++ net/minecraft/src/RenderLiving.java
@@ -47,7 +47,7 @@
 			GL11.glEnable(GL12.GL_RESCALE_NORMAL);
 			GL11.glScalef(-1.0F, -1.0F, 1.0F);
 			this.preRenderCallback(var1, var9);
-			GL11.glTranslatef(0.0F, -24.0F * var14 - 0.0078125F, 0.0F);
+			GL11.glTranslatef(0.0F, -24.0F * var14 - 1.0F / 128.0F, 0.0F);
 			float var15 = var1.prevLimbYaw + (var1.limbYaw - var1.prevLimbYaw) * var9;
 			float var16 = var1.limbSwing - var1.limbYaw * (1.0F - var9);
 			if(var15 > 1.0F) {
@@ -58,7 +58,7 @@
 			GL11.glEnable(GL11.GL_ALPHA_TEST);
 			this.mainModel.render(var16, var15, var13, var11 - var10, var12, var14);
 
-			for(int var17 = 0; var17 < 4; ++var17) {
+			for(int var17 = 0; var17 < maxRenderPasses(); ++var17) {
 				if(this.shouldRenderPass(var1, var17)) {
 					this.renderPassModel.render(var16, var15, var13, var11 - var10, var12, var14);
 					GL11.glDisable(GL11.GL_BLEND);
@@ -79,7 +79,7 @@
 					GL11.glColor4f(var25, 0.0F, 0.0F, 0.4F);
 					this.mainModel.render(var16, var15, var13, var11 - var10, var12, var14);
 
-					for(int var19 = 0; var19 < 4; ++var19) {
+					for(int var19 = 0; var19 < maxRenderPasses(); ++var19) {
 						if(this.shouldRenderPass(var1, var19)) {
 							GL11.glColor4f(var25, 0.0F, 0.0F, 0.4F);
 							this.renderPassModel.render(var16, var15, var13, var11 - var10, var12, var14);
@@ -95,7 +95,7 @@
 					GL11.glColor4f(var26, var20, var21, var22);
 					this.mainModel.render(var16, var15, var13, var11 - var10, var12, var14);
 
-					for(int var23 = 0; var23 < 4; ++var23) {
+					for(int var23 = 0; var23 < maxRenderPasses(); ++var23) {
 						if(this.shouldRenderPass(var1, var23)) {
 							GL11.glColor4f(var26, var20, var21, var22);
 							this.renderPassModel.render(var16, var15, var13, var11 - var10, var12, var14);
@@ -146,5 +146,9 @@
 
 	public void doRender(Entity var1, double var2, double var4, double var6, float var8, float var9) {
 		this.doRenderLiving((EntityLiving)var1, var2, var4, var6, var8, var9);
+	}
+
+	protected float maxRenderPasses() {
+		return 4;
 	}
 }
--- net/minecraft/src/WorldClient.java
+++ net/minecraft/src/WorldClient.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.io.File;
 import java.util.HashSet;
 import java.util.LinkedList;
@@ -10,15 +12,16 @@
 	private NetClientHandler sendQueue;
 	private ChunkProviderClient clientChunkProvider;
 	private boolean noTileEntityUpdates = false;
-	private MCHashTable entityHashTable = new MCHashTable();
+	private MCHashTableInteger entityHashTable = new MCHashTableInteger();
 	private Set entityList = new HashSet();
 	private Set entitySpawnQueue = new HashSet();
 
-	public WorldClient(NetClientHandler var1) {
+	public WorldClient(NetClientHandler var1, GameAchievements var2) {
 		super("MpServer");
 		this.sendQueue = var1;
+		this.achievements = var2;
 		this.spawnX = 8;
-		this.spawnY = 64;
+		this.spawnY = 128;
 		this.spawnZ = 8;
 	}
 
@@ -62,14 +65,14 @@
 
 	}
 
-	protected IChunkProvider getChunkProvider(File var1) {
+	public IChunkProvider getChunkProvider(File var1) {
 		this.clientChunkProvider = new ChunkProviderClient(this);
 		return this.clientChunkProvider;
 	}
 
 	public void setSpawnLocation() {
 		this.spawnX = 8;
-		this.spawnY = 64;
+		this.spawnY = 128;
 		this.spawnZ = 8;
 	}
 
@@ -91,15 +94,16 @@
 		}
 
 		if(!var3) {
-			this.markBlocksDirty(var1 * 16, 0, var2 * 16, var1 * 16 + 15, 128, var2 * 16 + 15);
+			this.markBlocksDirty(var1 * 16, 0, var2 * 16, var1 * 16 + 15, CHUNK_HEIGHT, var2 * 16 + 15);
 		}
 
 	}
 
 	public boolean spawnEntityInWorld(Entity var1) {
 		boolean var2 = super.spawnEntityInWorld(var1);
-		if(var1 instanceof EntityPlayerSP) {
-			this.entityList.add(var1);
+		this.entityList.add(var1);
+		if (!var2) {
+			this.entitySpawnQueue.add(var1);
 		}
 
 		return var2;
@@ -107,10 +111,7 @@
 
 	public void setEntityDead(Entity var1) {
 		super.setEntityDead(var1);
-		if(var1 instanceof EntityPlayerSP) {
-			this.entityList.remove(var1);
-		}
-
+		this.entityList.remove(var1);
 	}
 
 	protected void obtainEntitySkin(Entity var1) {
@@ -130,7 +131,13 @@
 	}
 
 	public void addEntityToWorld(int var1, Entity var2) {
+		Entity var3 = this.getEntityByID(var1);
+		if (var3 != null) {
+			this.setEntityDead(var3);
+		}
+
 		this.entityList.add(var2);
+		var2.entityID = var1;
 		if(!this.spawnEntityInWorld(var2)) {
 			this.entitySpawnQueue.add(var2);
 		}
@@ -192,12 +199,6 @@
 			return true;
 		} else {
 			return false;
-		}
-	}
-
-	public void updateTileEntityChunkAndDoNothing(int var1, int var2, int var3, TileEntity var4) {
-		if(!this.noTileEntityUpdates) {
-			this.sendQueue.addToSendQueue(new Packet59ComplexEntity(var1, var2, var3, var4));
 		}
 	}
 
--- net/minecraft/src/EntityOtherPlayerMP.java
+++ net/minecraft/src/EntityOtherPlayerMP.java
@@ -7,16 +7,20 @@
 	private double otherPlayerMPZ;
 	private double otherPlayerMPYaw;
 	private double otherPlayerMPPitch;
-	float unusedFloat = 0.0F;
 
 	public EntityOtherPlayerMP(World var1, String var2) {
 		super(var1);
 		this.username = var2;
 		this.yOffset = 0.0F;
 		this.stepHeight = 0.0F;
-		if(var2 != null && var2.length() > 0) {
-			this.skinUrl = "http://www.minecraft.net/skin/" + var2 + ".png";
-			System.out.println("Loading texture " + this.skinUrl);
+		if (var2 != null && var2.length() > 0) {
+			this.blueStaggo = this.username.equals("BlueStag256");
+			if (this.blueStaggo) {
+				this.texture = "/mob/staggo.png";
+				var1.achievements.updateProgress(Achievement.MEET_THE_STAGGO, 1);
+			} else {
+				this.skinUrl = "http://www.minecraft.net/skin/" + var2 + ".png";
+			}
 		}
 
 		this.noClip = true;
@@ -94,5 +98,19 @@
 
 		this.cameraYaw += (var9 - this.cameraYaw) * 0.4F;
 		this.cameraPitch += (var2 - this.cameraPitch) * 0.8F;
+	}
+
+	public void outfitWithItem(int var1, int var2, int var3, int var4) {
+		ItemStack var0 = null;
+		if(var2 >= 0) {
+			var0 = new ItemStack(var2, 1, var3, var4);
+		}
+
+		if(var1 == 0) {
+			this.inventory.mainInventory[this.inventory.currentItem] = var0;
+		} else {
+			this.inventory.armorInventory[var1 - 1] = var0;
+		}
+
 	}
 }
--- /dev/null
+++ net/minecraft/src/NBTTagShortArray.java
@@ -1,0 +1,50 @@
+package net.minecraft.src;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+public class NBTTagShortArray extends NBTBase {
+	public short[] shortArray;
+
+	public NBTTagShortArray() {
+	}
+
+	public NBTTagShortArray(short[] var1) {
+		this.shortArray = var1;
+	}
+
+	protected void writeTagContents(DataOutput var1) throws IOException {
+		var1.writeInt(this.shortArray.length);
+		ByteBuffer buffer = ByteBuffer.allocate(this.shortArray.length * 2);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asShortBuffer().put(this.shortArray);
+		byte[] bytes = buffer.array();
+		var1.write(bytes);
+	}
+
+	protected void readTagContents(DataInput var1) throws IOException {
+		int var2 = var1.readInt();
+		this.shortArray = new short[var2];
+		byte[] byteArray = new byte[var2 * 2];
+		var1.readFully(byteArray);
+		ByteBuffer buffer = ByteBuffer.wrap(byteArray);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asShortBuffer().get(this.shortArray);
+	}
+
+	public byte getType() {
+		return (byte)12;
+	}
+
+	public String toString() {
+		return "[" + this.shortArray.length + " shorts]";
+	}
+
+	public NBTBase copy() {
+		return new NBTTagShortArray(Arrays.copyOf(this.shortArray, this.shortArray.length)).setKey(this.getKey());
+	}
+}
--- net/minecraft/src/PlayerControllerSP.java
+++ net/minecraft/src/PlayerControllerSP.java
@@ -1,7 +1,6 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
-
 public class PlayerControllerSP extends PlayerController {
 	private int curBlockX = -1;
 	private int curBlockY = -1;
@@ -10,8 +9,7 @@
 	private float prevBlockDamage = 0.0F;
 	private float blockDestroySoundCounter = 0.0F;
 	private int blockHitWait = 0;
-	private SpawnerAnimals monsterSpawner = new SpawnerClient(this, 200, IMobs.class, new Class[]{EntityZombie.class, EntitySkeleton.class, EntityCreeper.class, EntitySpider.class, EntitySlime.class});
-	private SpawnerAnimals animalSpawner = new SpawnerAnimals(15, EntityAnimal.class, new Class[]{EntitySheep.class, EntityPig.class, EntityCow.class, EntityChicken.class});
+	private float prevStrength = 0.0F;
 
 	public PlayerControllerSP(Minecraft var1) {
 		super(var1);
@@ -25,9 +23,11 @@
 		int var5 = this.mc.theWorld.getBlockId(var1, var2, var3);
 		int var6 = this.mc.theWorld.getBlockMetadata(var1, var2, var3);
 		boolean var7 = super.sendBlockRemoved(var1, var2, var3, var4);
+		boolean silk = false;
 		ItemStack var8 = this.mc.thePlayer.getCurrentEquippedItem();
 		boolean var9 = this.mc.thePlayer.canHarvestBlock(Block.blocksList[var5]);
 		if(var8 != null) {
+			silk = var8.isSilk();
 			var8.onDestroyBlock(var5, var1, var2, var3);
 			if(var8.stackSize == 0) {
 				var8.onItemDestroyedByUse(this.mc.thePlayer);
@@ -36,7 +36,11 @@
 		}
 
 		if(var7 && var9) {
-			Block.blocksList[var5].harvestBlock(this.mc.theWorld, var1, var2, var3, var6);
+			if (silk) {
+				Block.blocksList[var5].harvestBlockSilk(this.mc.theWorld, var1, var2, var3, var6);
+			} else {
+				Block.blocksList[var5].harvestBlock(this.mc.theWorld, var1, var2, var3, var6);
+			}
 		}
 
 		return var7;
@@ -48,14 +52,22 @@
 			Block.blocksList[var5].onBlockClicked(this.mc.theWorld, var1, var2, var3, this.mc.thePlayer);
 		}
 
-		if(var5 > 0 && Block.blocksList[var5].blockStrength(this.mc.thePlayer) >= 1.0F) {
+		if(var5 > 0 && Block.blocksList[var5].blockStrength(this.mc.thePlayer) >= 1.0F
+				|| this.mc.thePlayer.creative && this.blockHitWait == 0) {
 			this.sendBlockRemoved(var1, var2, var3, var4);
 		}
 
+		if (this.mc.thePlayer.creative) {
+			this.blockHitWait = 10;
+		}
+
 	}
 
 	public void resetBlockRemoving() {
 		this.curBlockDamage = 0.0F;
+	}
+
+	public void stopBlockRemoving() {
 		this.blockHitWait = 0;
 	}
 
@@ -70,9 +82,17 @@
 				}
 
 				Block var6 = Block.blocksList[var5];
+				float strength = this.mc.thePlayer.inventory.getStrVsBlock(var6);
+				if (prevStrength != strength) {
+					this.curBlockDamage = 0;
+				}
+
 				this.curBlockDamage += var6.blockStrength(this.mc.thePlayer);
+				this.prevStrength = strength;
+
 				if(this.blockDestroySoundCounter % 4.0F == 0.0F && var6 != null) {
-					this.mc.sndManager.playSound(var6.stepSound.getStepSound(), (float)var1 + 0.5F, (float)var2 + 0.5F, (float)var3 + 0.5F, (var6.stepSound.getVolume() + 1.0F) / 8.0F, var6.stepSound.getPitch() * 0.5F);
+					this.mc.sndManager.playSound(var6.stepSound.getStepSound(), (float)var1 + 0.5F, (float)var2 + 0.5F, (float)var3 + 0.5F,
+							(var6.stepSound.getVolume() + 1.0F) / 8.0F, var6.stepSound.getPitch() * 0.5F);
 				}
 
 				++this.blockDestroySoundCounter;
@@ -81,7 +101,6 @@
 					this.curBlockDamage = 0.0F;
 					this.prevBlockDamage = 0.0F;
 					this.blockDestroySoundCounter = 0.0F;
-					this.blockHitWait = 5;
 				}
 			} else {
 				this.curBlockDamage = 0.0F;
@@ -107,18 +126,12 @@
 
 	}
 
-	public float getBlockReachDistance() {
-		return 4.0F;
-	}
-
 	public void onWorldChange(World var1) {
 		super.onWorldChange(var1);
 	}
 
 	public void onUpdate() {
 		this.prevBlockDamage = this.curBlockDamage;
-		this.monsterSpawner.onUpdate(this.mc.theWorld);
-		this.animalSpawner.onUpdate(this.mc.theWorld);
-		this.mc.sndManager.playRandomMusicIfReady();
+		super.onUpdate();
 	}
 }
--- /dev/null
+++ net/minecraft/src/InventoryReadonly.java
@@ -1,0 +1,152 @@
+package net.minecraft.src;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.*;
+
+public class InventoryReadonly implements IInventory {
+	private final ItemStack[] items;
+	private final boolean pickable;
+	public final Map<Integer, String> labels;
+	public boolean pickOne;
+
+	public InventoryReadonly(ItemStack[] items, boolean pickable, Map<Integer, String> labels) {
+		this.items = items;
+		this.pickable = pickable;
+		this.labels = labels;
+	}
+
+	public String getLabel(int row) {
+		return labels != null ? labels.get(row) : null;
+	}
+
+	public static InventoryReadonly generateCreativeInventory(boolean debug) {
+		List<ItemStack> items = new ArrayList<>();
+		for (int i = 0; i < Item.itemsList.length - 1; i++) {
+			Item item = Item.itemsList[i];
+			if (i < 10000 && Item.itemsList[i] instanceof ItemBlock) {
+				Block block = Block.blocksList[i];
+				if (block == null) {
+					continue;
+				}
+				for (int m : block.availableMetadata()) {
+					ItemStack stack = new ItemStack(i, 1, -1, m);
+					if (stack.getItem() != null && (debug || !stack.getTooltip().gradient.equals(ItemTooltip.INVALID_GRAD))) {
+						items.add(stack);
+					}
+				}
+			} else {
+				if (item == null) {
+					continue;
+				}
+				for (int m : item.availableMetadata()) {
+					ItemStack stack = new ItemStack(i, 1, -1, m);
+					if (stack.getItem() != null && (debug || !stack.getTooltip().gradient.equals(ItemTooltip.INVALID_GRAD))) {
+						items.add(stack);
+					}
+				}
+			}
+		}
+		ItemStack[] itemArray = new ItemStack[items.size()];
+		items.toArray(itemArray);
+		return new InventoryReadonly(itemArray, true, null);
+	}
+
+	public static InventoryReadonly getCreativeInventory() {
+		try {
+			List<String> ids = new ArrayList<>();
+			BufferedReader reader = new BufferedReader(
+					new InputStreamReader(
+							Objects.requireNonNull(InventoryReadonly.class.getResourceAsStream("/gui/creative_items.txt"))));
+
+			String line;
+			while ((line = reader.readLine()) != null) {
+				if (!line.matches("\\s*#.*") && !line.isEmpty()) {
+					if (line.startsWith(": ")) {
+						ids.add(line);
+					} else {
+						ids.addAll(Arrays.asList(line.trim().split("#")[0].split("\\s+")));
+					}
+				}
+			}
+
+			CreativeInventoryBuilder inv = new CreativeInventoryBuilder();
+			for (String id : ids) {
+				if (id.startsWith(": ")) {
+					inv.addLabel(id.substring(2));
+					continue;
+				}
+
+				if (id.equals("/br")) {
+					inv.lineBreak();
+					continue;
+				}
+
+				if (id.equals("/n")) {
+					inv.newLine();
+					continue;
+				}
+
+				String[] idSplit = id.split("-");
+				boolean isItem = idSplit[0].startsWith("i");
+				if (isItem) {
+					idSplit[0] = idSplit[0].substring(1);
+				}
+
+				int itemID = Integer.parseInt(idSplit[0]);
+				int itemMetadata = idSplit.length >= 2 ? Integer.parseInt(idSplit[1]) : 0;
+				if (isItem) {
+					itemID += 10000;
+				}
+
+				inv.addItem(itemID, itemMetadata);
+			}
+
+			ModLoader.callHook(BaseMod::setupCreativeInventory, inv);
+			return inv.toInventory();
+		} catch (Exception e) {
+			System.out.println("Could not get creative inventory!");
+			e.printStackTrace();
+			System.out.println("Generating creative inventory instead...");
+			return generateCreativeInventory(false);
+		}
+	}
+
+	public int getInventorySize() {
+		return items.length;
+	}
+
+	public ItemStack getStack(int var1) {
+		return var1 < items.length
+			? items[var1] == null
+				? null
+				: items[var1].copy()
+			: null;
+	}
+
+	public ItemStack decrStack(int var1, int var2) {
+		return this.pickable
+				? new ItemStack(items[var1].itemID,
+						this.pickOne ? 1 : items[var1].getMaxStackSize(),
+						items[var1].itemDmg, items[var1].itemMetadata)
+				: null;
+	}
+
+	public void setInventorySlotItem(int var1, ItemStack var2) {
+	}
+
+	public String getInventoryName() {
+		return "Readonly Inventory";
+	}
+
+	public int getStackLimit() {
+		return 64;
+	}
+
+	public void onInventoryChange() {
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return true;
+	}
+}
--- net/minecraft/src/EntityRainFX.java
+++ net/minecraft/src/EntityRainFX.java
@@ -15,10 +15,6 @@
 		this.particleMaxAge = (int)(8.0D / (Math.random() * 0.8D + 0.2D));
 	}
 
-	public void renderParticle(Tessellator var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-		super.renderParticle(var1, var2, var3, var4, var5, var6, var7);
-	}
-
 	public void onUpdate() {
 		this.prevPosX = this.posX;
 		this.prevPosY = this.posY;
--- net/minecraft/src/BlockStairs.java
+++ net/minecraft/src/BlockStairs.java
@@ -1,17 +1,31 @@
 package net.minecraft.src;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Random;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 
 public class BlockStairs extends Block {
-	private Block modelBlock;
-
-	protected BlockStairs(int var1, Block var2) {
-		super(var1, var2.blockIndexInTexture, var2.material);
-		this.modelBlock = var2;
-		this.setHardness(var2.hardness);
-		this.setResistance(var2.resistance / 3.0F);
-		this.setStepSound(var2.stepSound);
+	public final EnumBitField<Direction> fieldFacing;
+	public final BitField fieldType;
+	public final BitFlag fieldHalf;
+
+	private final ModelBlock[] modelBlocks;
+
+	public BlockStairs(int var1, Material var2, ModelBlock[] var3) {
+		super(var1, 1, var2);
+		if (var3.length > 32) {
+			throw new IllegalArgumentException("Too many stair types! 32 maximum!");
+		}
+		this.modelBlocks = var3;
+
+		this.fieldFacing = this.fields.addBitField("facing", Direction.class, 2);
+		this.fieldType = this.fields.addBitField("type", 5, Arrays.stream(var3)
+				.map(t -> t.name)
+				.collect(Collectors.toList()));
+		this.fieldHalf = this.fields.addBitFlag("half", "bottom", "top");
+
 	}
 
 	public boolean isOpaqueCube() {
@@ -30,222 +44,136 @@
 		return super.shouldSideBeRendered(var1, var2, var3, var4, var5);
 	}
 
-	public void getCollidingBoundingBoxes(World var1, int var2, int var3, int var4, AxisAlignedBB var5, ArrayList var6) {
-		int var7 = var1.getBlockMetadata(var2, var3, var4);
-		if(var7 == 0) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 0.5F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		} else if(var7 == 1) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 1.0F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		} else if(var7 == 2) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 0.5F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 1.0F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		} else if(var7 == 3) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 0.5F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-			this.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 0.5F, 1.0F);
-			super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
-		}
-
+	public void doShape(IBlockAccess blockAccess, int x, int y, int z, Runnable action) {
+		boolean finishedTop = false;
+
+		int meta = blockAccess.getBlockMetadata(x, y, z);
+		Direction dir = this.fieldFacing.get(meta);
+		boolean half = this.fieldHalf.get(meta);
+
+		float yOffBot = half ? 0.5F : 0.0F;
+		float yOffTop = half ? 0.0F : 0.5F;
+
+		// Inner corner checks
+		if (!finishedTop) {
+			int frontX = x + dir.getFrontX();
+			int frontZ = z + dir.getFrontZ();
+			Block frontBlock = blockAccess.getBlock(frontX, y, frontZ);
+			int frontMeta = blockAccess.getBlockMetadata(frontX, y, frontZ);
+
+			if (frontBlock instanceof BlockStairs
+					&& this.fieldHalf.get(frontMeta) == half) {
+				Direction frontDir = this.fieldFacing.get(frontMeta);
+				if (frontDir.getPerpLeft() == dir || frontDir.getPerpRight() == dir) {
+					Direction drawDir = frontDir == dir.getPerpRight() ? dir.getBehind() : dir.getPerpLeft();
+
+					this.setBlockBounds(
+							dir.getStairMinX(), yOffTop, dir.getStairMinZ(),
+							dir.getStairMaxX(), yOffTop + 0.5F, dir.getStairMaxZ()
+					);
+					action.run();
+
+					this.setBlockBounds(
+							drawDir.getInnerStairMinX(), yOffTop, drawDir.getInnerStairMinZ(),
+							drawDir.getInnerStairMaxX(), yOffTop + 0.5F, drawDir.getInnerStairMaxZ()
+					);
+					action.run();
+					finishedTop = true;
+				}
+			}
+		}
+
+		// Outer corner checks
+		if (!finishedTop) {
+			int backX = x + dir.getBackX();
+			int backZ = z + dir.getBackZ();
+			Block backBlock = blockAccess.getBlock(backX, y, backZ);
+			int backMeta = blockAccess.getBlockMetadata(backX, y, backZ);
+
+			if (backBlock instanceof BlockStairs
+					&& this.fieldHalf.get(backMeta) == half) {
+				Direction backDir = this.fieldFacing.get(backMeta);
+				Direction drawDir = null;
+
+				if (backDir == dir.getPerpLeft()) {
+					drawDir = dir;
+					finishedTop = true;
+				} else if (backDir == dir.getPerpRight()) {
+					drawDir = dir.getPerpRight();
+					finishedTop = true;
+				}
+
+				if (finishedTop) {
+					this.setBlockBounds(
+							drawDir.getInnerStairMinX(), yOffTop, drawDir.getInnerStairMinZ(),
+							drawDir.getInnerStairMaxX(), yOffTop + 0.5F, drawDir.getInnerStairMaxZ()
+					);
+					action.run();
+				}
+			}
+		}
+
+		// Default drawing
+		if (!finishedTop) {
+			this.setBlockBounds(
+					dir.getStairMinX(), yOffTop, dir.getStairMinZ(),
+					dir.getStairMaxX(), yOffTop + 0.5F, dir.getStairMaxZ()
+			);
+			action.run();
+			finishedTop = true;
+		}
+
+		this.setBlockBounds(0.0F, yOffBot, 0.0F, 1.0F, yOffBot + 0.5F, 1.0F);
+		action.run();
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
 	}
 
-	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		if(!var1.multiplayerWorld) {
-			if(var1.getBlockMaterial(var2, var3 + 1, var4).isSolid()) {
-				var1.setBlockWithNotify(var2, var3, var4, this.modelBlock.blockID);
-			} else {
-				this.updateState(var1, var2, var3, var4);
-				this.updateState(var1, var2 + 1, var3 - 1, var4);
-				this.updateState(var1, var2 - 1, var3 - 1, var4);
-				this.updateState(var1, var2, var3 - 1, var4 - 1);
-				this.updateState(var1, var2, var3 - 1, var4 + 1);
-				this.updateState(var1, var2 + 1, var3 + 1, var4);
-				this.updateState(var1, var2 - 1, var3 + 1, var4);
-				this.updateState(var1, var2, var3 + 1, var4 - 1);
-				this.updateState(var1, var2, var3 + 1, var4 + 1);
-			}
-
-			this.modelBlock.onNeighborBlockChange(var1, var2, var3, var4, var5);
-		}
-	}
-
-	private void updateState(World var1, int var2, int var3, int var4) {
-		if(this.isBlockStair(var1, var2, var3, var4)) {
-			byte var5 = -1;
-			if(this.isBlockStair(var1, var2 + 1, var3 + 1, var4)) {
-				var5 = 0;
-			}
-
-			if(this.isBlockStair(var1, var2 - 1, var3 + 1, var4)) {
-				var5 = 1;
-			}
-
-			if(this.isBlockStair(var1, var2, var3 + 1, var4 + 1)) {
-				var5 = 2;
-			}
-
-			if(this.isBlockStair(var1, var2, var3 + 1, var4 - 1)) {
-				var5 = 3;
-			}
-
-			if(var5 < 0) {
-				if(this.isBlockSolid(var1, var2 + 1, var3, var4) && !this.isBlockSolid(var1, var2 - 1, var3, var4)) {
-					var5 = 0;
-				}
-
-				if(this.isBlockSolid(var1, var2 - 1, var3, var4) && !this.isBlockSolid(var1, var2 + 1, var3, var4)) {
-					var5 = 1;
-				}
-
-				if(this.isBlockSolid(var1, var2, var3, var4 + 1) && !this.isBlockSolid(var1, var2, var3, var4 - 1)) {
-					var5 = 2;
-				}
-
-				if(this.isBlockSolid(var1, var2, var3, var4 - 1) && !this.isBlockSolid(var1, var2, var3, var4 + 1)) {
-					var5 = 3;
-				}
-			}
-
-			if(var5 < 0) {
-				if(this.isBlockStair(var1, var2 - 1, var3 - 1, var4)) {
-					var5 = 0;
-				}
-
-				if(this.isBlockStair(var1, var2 + 1, var3 - 1, var4)) {
-					var5 = 1;
-				}
-
-				if(this.isBlockStair(var1, var2, var3 - 1, var4 - 1)) {
-					var5 = 2;
-				}
-
-				if(this.isBlockStair(var1, var2, var3 - 1, var4 + 1)) {
-					var5 = 3;
-				}
-			}
-
-			if(var5 >= 0) {
-				var1.setBlockMetadataWithNotify(var2, var3, var4, var5);
-			}
-
-		}
-	}
-
-	private boolean isBlockSolid(World var1, int var2, int var3, int var4) {
-		return var1.getBlockMaterial(var2, var3, var4).isSolid();
-	}
-
-	private boolean isBlockStair(World var1, int var2, int var3, int var4) {
-		int var5 = var1.getBlockId(var2, var3, var4);
-		return var5 == 0 ? false : Block.blocksList[var5].getRenderType() == 10;
-	}
-
-	public void randomDisplayTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.modelBlock.randomDisplayTick(var1, var2, var3, var4, var5);
-	}
-
-	public void onBlockClicked(World var1, int var2, int var3, int var4, EntityPlayer var5) {
-		this.modelBlock.onBlockClicked(var1, var2, var3, var4, var5);
-	}
-
-	public void onBlockDestroyedByPlayer(World var1, int var2, int var3, int var4, int var5) {
-		this.modelBlock.onBlockDestroyedByPlayer(var1, var2, var3, var4, var5);
-	}
-
-	public float getBlockBrightness(IBlockAccess var1, int var2, int var3, int var4) {
-		return this.modelBlock.getBlockBrightness(var1, var2, var3, var4);
-	}
-
-	public float getExplosionResistance(Entity var1) {
-		return this.modelBlock.getExplosionResistance(var1);
-	}
-
-	public int getRenderBlockPass() {
-		return this.modelBlock.getRenderBlockPass();
-	}
-
-	public int idDropped(int var1, Random var2) {
-		return this.modelBlock.idDropped(var1, var2);
-	}
-
-	public int quantityDropped(Random var1) {
-		return this.modelBlock.quantityDropped(var1);
+	public void getCollidingBoundingBoxes(World var1, int var2, int var3, int var4, AxisAlignedBB var5, ArrayList var6) {
+		this.doShape(var1, var2, var3, var4,
+				() -> super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6));
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return this.fieldType.get(var1) * 4;
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, modelBlocks.length).map(i -> i * 4).toArray();
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return this.modelBlock.getBlockTextureFromSideAndMetadata(var1, var2);
-	}
-
-	public int getBlockTextureFromSide(int var1) {
-		return this.modelBlock.getBlockTextureFromSide(var1);
-	}
-
-	public int getBlockTexture(IBlockAccess var1, int var2, int var3, int var4, int var5) {
-		return this.modelBlock.getBlockTexture(var1, var2, var3, var4, var5);
-	}
-
-	public int tickRate() {
-		return this.modelBlock.tickRate();
-	}
-
-	public AxisAlignedBB getSelectedBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
-		return this.modelBlock.getSelectedBoundingBoxFromPool(var1, var2, var3, var4);
-	}
-
-	public void velocityToAddToEntity(World var1, int var2, int var3, int var4, Entity var5, Vec3D var6) {
-		this.modelBlock.velocityToAddToEntity(var1, var2, var3, var4, var5, var6);
-	}
-
-	public boolean isCollidable() {
-		return this.modelBlock.isCollidable();
-	}
-
-	public boolean canCollideCheck(int var1, boolean var2) {
-		return this.modelBlock.canCollideCheck(var1, var2);
-	}
-
-	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
-		return this.modelBlock.canPlaceBlockAt(var1, var2, var3, var4);
+		return this.modelBlocks[this.fieldType.get(var2)].texture;
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
 		this.onNeighborBlockChange(var1, var2, var3, var4, 0);
-		this.modelBlock.onBlockAdded(var1, var2, var3, var4);
-	}
-
-	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
-		this.modelBlock.onBlockRemoval(var1, var2, var3, var4);
-	}
-
-	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
-		this.modelBlock.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
-	}
-
-	public void dropBlockAsItem(World var1, int var2, int var3, int var4, int var5) {
-		this.modelBlock.dropBlockAsItem(var1, var2, var3, var4, var5);
-	}
-
-	public void onEntityWalking(World var1, int var2, int var3, int var4, Entity var5) {
-		this.modelBlock.onEntityWalking(var1, var2, var3, var4, var5);
-	}
-
-	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-		this.modelBlock.updateTick(var1, var2, var3, var4, var5);
-	}
-
-	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
-		return this.modelBlock.blockActivated(var1, var2, var3, var4, var5);
-	}
-
-	public void onBlockDestroyedByExplosion(World var1, int var2, int var3, int var4) {
-		this.modelBlock.onBlockDestroyedByExplosion(var1, var2, var3, var4);
+	}
+
+	public AxisAlignedBB getSelectedBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
+		return AxisAlignedBB.getBoundingBoxFromPool(var2 + 0.0F, var3 + 0.0F, var4 + 0.0F, var2 + 1.0F, var3 + 1.0F, var4 + 1.0F);
+	}
+
+	public int onBlockPlaced(World var1, int var2, int var3, int var4, int var5, float hitx, float hity, float hitz, int meta) {
+		if (var5 != 1 && (var5 == 0 || hity >= 0.5F)) {
+			meta = this.fieldHalf.set(meta, true);
+		}
+		return meta;
+	}
+
+	public void onBlockPlacedBy(World var1, int var2, int var3, int var4, EntityPlayer var5, ItemStack var6) {
+		int meta = var1.getBlockMetadata(var2, var3, var4);
+		int var7 = MathHelper.floor_double((double)(var5.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3;
+
+		if(var7 == 0) {
+			meta = this.fieldFacing.set(meta, Direction.SOUTH);
+		} else if(var7 == 1) {
+			meta = this.fieldFacing.set(meta, Direction.WEST);
+		} else if(var7 == 2) {
+			meta = this.fieldFacing.set(meta, Direction.NORTH);
+		} else {
+			meta = this.fieldFacing.set(meta, Direction.EAST);
+		}
+
+		var1.setBlockMetadataWithNotify(var2, var3, var4, meta);
 	}
 }
--- net/minecraft/src/RecipesArmor.java
+++ net/minecraft/src/RecipesArmor.java
@@ -1,18 +1,19 @@
 package net.minecraft.src;
 
+import java.util.Arrays;
+
 public class RecipesArmor {
 	private String[][] recipePatterns = new String[][]{{"XXX", "X X"}, {"X X", "XXX", "XXX"}, {"XXX", "X X", "X X"}, {"X X", "X X"}};
-	private Object[][] recipeItems = new Object[][]{{Item.leather, Block.fire, Item.ingotIron, Item.diamond, Item.ingotGold}, {Item.helmetLeather, Item.helmetChain, Item.helmetSteel, Item.helmetDiamond, Item.helmetGold}, {Item.plateLeather, Item.plateChain, Item.plateSteel, Item.plateDiamond, Item.plateGold}, {Item.legsLeather, Item.legsChain, Item.legsSteel, Item.legsDiamond, Item.legsGold}, {Item.bootsLeather, Item.bootsChain, Item.bootsSteel, Item.bootsDiamond, Item.bootsGold}};
+	private Object[][] recipeItems = new Object[][]{{Item.leather, Block.fire, Item.ingotIron, Item.diamond, Item.ingotGold, Item.paper}, {Item.helmetLeather, Item.helmetChain, Item.helmetSteel, Item.helmetDiamond, Item.helmetGold, Item.helmetCardboard}, {Item.plateLeather, Item.plateChain, Item.plateSteel, Item.plateDiamond, Item.plateGold, Item.plateCardboard}, {Item.legsLeather, Item.legsChain, Item.legsSteel, Item.legsDiamond, Item.legsGold, Item.legsCardboard}, {Item.bootsLeather, Item.bootsChain, Item.bootsSteel, Item.bootsDiamond, Item.bootsGold, Item.bootsCardboard}};
 
-	public void addRecipes(CraftingManager var1) {
+	public void addRecipes(CraftingManager craftingManager) {
 		for(int var2 = 0; var2 < this.recipeItems[0].length; ++var2) {
 			Object var3 = this.recipeItems[0][var2];
 
 			for(int var4 = 0; var4 < this.recipeItems.length - 1; ++var4) {
 				Item var5 = (Item)this.recipeItems[var4 + 1][var2];
-				var1.addRecipe(new ItemStack(var5), new Object[]{this.recipePatterns[var4], Character.valueOf('X'), var3});
+				craftingManager.addRecipe(new ItemStack(var5), this.recipePatterns[var4], 'X', var3);
 			}
 		}
-
 	}
 }
--- net/minecraft/src/WorldIso.java
+++ net/minecraft/src/WorldIso.java
@@ -2,15 +2,15 @@
 
 import java.io.File;
 
-class WorldIso extends World {
-	final CanvasIsomPreview isomPreview;
+public class WorldIso extends World {
+	public final CanvasIsomPreview isomPreview;
 
-	WorldIso(CanvasIsomPreview var1, File var2, String var3) {
+	public WorldIso(CanvasIsomPreview var1, File var2, String var3) {
 		super(var2, var3);
 		this.isomPreview = var1;
 	}
 
-	protected IChunkProvider getChunkProvider(File var1) {
+	public IChunkProvider getChunkProvider(File var1) {
 		return new ChunkProviderIso(this, new ChunkLoader(var1, false));
 	}
 }
--- /dev/null
+++ net/minecraft/src/BlockWood.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import java.util.stream.IntStream;
+
+public class BlockWood extends Block {
+	public static final List<String> woodTypeNames = Arrays.asList(
+			"oak",
+			"spruce",
+			"maple",
+			"mahogany"
+	);
+	public final BitField fieldType = this.fields.addBitField("type", 8, woodTypeNames);
+
+	public BlockWood(int id, int tex, Material material) {
+		super(id, tex, material);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int side, int metadata) {
+		return this.blockIndexInTexture + metadata * 32;
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var1;
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, woodTypeNames.size()).toArray();
+	}
+}
--- /dev/null
+++ net/minecraft/src/MapGenUnderworldCaves.java
@@ -1,0 +1,182 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
+import java.util.Random;
+
+public class MapGenUnderworldCaves extends MapGenBase {
+protected void generateLargeCaveNode(int var1, int var2, short[] var3, double var4, double var6, double var8) {
+		this.generateCaveNode(var1, var2, var3, var4, var6, var8, 1.0F + this.rand.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5D);
+	}
+
+	protected void generateCaveNode(int var1, int var2, short[] var3, double var4, double var6, double var8, float var10, float var11, float var12, int var13, int var14, double var15) {
+		double var17 = (double)(var1 * 16 + 8);
+		double var19 = (double)(var2 * 16 + 8);
+		float var21 = 0.0F;
+		float var22 = 0.0F;
+		Random var23 = new Random(this.rand.nextLong());
+		if(var14 <= 0) {
+			int var24 = this.range * 16 - 16;
+			var14 = var24 - var23.nextInt(var24 / 4);
+		}
+
+		boolean var52 = false;
+		if(var13 == -1) {
+			var13 = var14 / 2;
+			var52 = true;
+		}
+
+		int var25 = var23.nextInt(var14 / 2) + var14 / 4;
+
+		for(boolean var26 = var23.nextInt(6) == 0; var13 < var14; ++var13) {
+			double var27 = 1.5D + (double)(MathHelper.sin((float)var13 * (float)Math.PI / (float)var14) * var10 * 1.0F);
+			double var29 = var27 * var15;
+			float var31 = MathHelper.cos(var12);
+			float var32 = MathHelper.sin(var12);
+			var4 += (double)(MathHelper.cos(var11) * var31);
+			var6 += (double)var32;
+			var8 += (double)(MathHelper.sin(var11) * var31);
+			if(var26) {
+				var12 *= 0.92F;
+			} else {
+				var12 *= 0.7F;
+			}
+
+			var12 += var22 * 0.1F;
+			var11 += var21 * 0.1F;
+			var22 *= 0.9F;
+			var21 *= 12.0F / 16.0F;
+			var22 += (var23.nextFloat() - var23.nextFloat()) * var23.nextFloat() * 2.0F;
+			var21 += (var23.nextFloat() - var23.nextFloat()) * var23.nextFloat() * 4.0F;
+			if(!var52 && var13 == var25 && var10 > 1.0F) {
+				this.generateCaveNode(var1, var2, var3, var4, var6, var8, var23.nextFloat() * 0.5F + 0.5F, var11 - (float)Math.PI * 0.5F, var12 / 3.0F, var13, var14, 1.0D);
+				this.generateCaveNode(var1, var2, var3, var4, var6, var8, var23.nextFloat() * 0.5F + 0.5F, var11 + (float)Math.PI * 0.5F, var12 / 3.0F, var13, var14, 1.0D);
+				return;
+			}
+
+			if(var52 || var23.nextInt(4) != 0) {
+				double var33 = var4 - var17;
+				double var35 = var8 - var19;
+				double var37 = (double)(var14 - var13);
+				double var39 = (double)(var10 + 2.0F + 16.0F);
+				if(var33 * var33 + var35 * var35 - var37 * var37 > var39 * var39) {
+					return;
+				}
+
+				if(var4 >= var17 - 16.0D - var27 * 2.0D && var8 >= var19 - 16.0D - var27 * 2.0D && var4 <= var17 + 16.0D + var27 * 2.0D && var8 <= var19 + 16.0D + var27 * 2.0D) {
+					int var53 = MathHelper.floor_double(var4 - var27) - var1 * 16 - 1;
+					int var34 = MathHelper.floor_double(var4 + var27) - var1 * 16 + 1;
+					int var54 = MathHelper.floor_double(var6 - var29) - 1;
+					int var36 = MathHelper.floor_double(var6 + var29) + 1;
+					int var55 = MathHelper.floor_double(var8 - var27) - var2 * 16 - 1;
+					int var38 = MathHelper.floor_double(var8 + var27) - var2 * 16 + 1;
+					if(var53 < 0) {
+						var53 = 0;
+					}
+
+					if(var34 > 16) {
+						var34 = 16;
+					}
+
+					if(var54 < 1) {
+						var54 = 1;
+					}
+
+					if(var36 > 72) {
+						var36 = 72;
+					}
+
+					if(var55 < 0) {
+						var55 = 0;
+					}
+
+					if(var38 > 16) {
+						var38 = 16;
+					}
+
+					boolean var56 = false;
+
+					int var40;
+					int var43;
+					for(var40 = var53; !var56 && var40 < var34; ++var40) {
+						for(int var41 = var55; !var56 && var41 < var38; ++var41) {
+							for(int var42 = var36 + 1; !var56 && var42 >= var54 - 1; --var42) {
+								var43 = (var40 * 16 + var41) * CHUNK_HEIGHT + var42;
+								if(var42 >= 0 && var42 < CHUNK_HEIGHT) {
+									if(var3[var43] == Block.waterMoving.blockID || var3[var43] == Block.waterStill.blockID) {
+										var56 = true;
+									}
+
+									if(var42 != var54 - 1 && var40 != var53 && var40 != var34 - 1 && var41 != var55 && var41 != var38 - 1) {
+										var42 = var54;
+									}
+								}
+							}
+						}
+					}
+
+					if(!var56) {
+						for(var40 = var53; var40 < var34; ++var40) {
+							double var57 = ((double)(var40 + var1 * 16) + 0.5D - var4) / var27;
+
+							for(var43 = var55; var43 < var38; ++var43) {
+								double var44 = ((double)(var43 + var2 * 16) + 0.5D - var8) / var27;
+								int var46 = (var40 * 16 + var43) * CHUNK_HEIGHT + var36;
+								boolean var47 = false;
+
+								for(int var48 = var36 - 1; var48 >= var54; --var48) {
+									double var49 = ((double)var48 + 0.5D - var6) / var29;
+									if(var49 > -0.7D && var57 * var57 + var49 * var49 + var44 * var44 < 1.0D) {
+										short var51 = var3[var46];
+										if(var51 == Block.grass.blockID) {
+											var47 = true;
+										}
+
+										if(var51 == Block.stone.blockID) {
+											var3[var46] = 0;
+											if(var47 && var3[var46 - 1] == Block.dirt.blockID) {
+												var3[var46 - 1] = (short)Block.grass.blockID;
+											}
+										}
+									}
+
+									--var46;
+								}
+							}
+						}
+
+						if(var52) {
+							break;
+						}
+					}
+				}
+			}
+		}
+
+	}
+
+	protected void recursiveGenerate(World var1, int var2, int var3, int var4, int var5, short[] var6) {
+		int var7 = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(20) + 1) + 1);
+		if(this.rand.nextInt(5) != 0) {
+			var7 = 0;
+		}
+
+		for(int var8 = 0; var8 < var7; ++var8) {
+			double var9 = (double)(var2 * 16 + this.rand.nextInt(16));
+			double var11 = (double)this.rand.nextInt(64);
+			double var13 = (double)(var3 * 16 + this.rand.nextInt(16));
+			int var15 = 1;
+			if(this.rand.nextInt(4) == 0) {
+				this.generateLargeCaveNode(var4, var5, var6, var9, var11, var13);
+				var15 += this.rand.nextInt(4);
+			}
+
+			for(int var16 = 0; var16 < var15; ++var16) {
+				float var17 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
+				float var18 = (this.rand.nextFloat() - 0.5F) / 4.0F;
+				float var19 = this.rand.nextFloat() * 6.0F;
+				this.generateCaveNode(var4, var5, var6, var9, var11, var13, var19, var17, var18, 0, 0, 1.0D);
+			}
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/ContainerWorkbench.java
@@ -1,0 +1,76 @@
+package net.minecraft.src;
+
+public class ContainerWorkbench extends Container {
+	public InventoryCrafting a = new InventoryCrafting(this, 3, 3);
+	public IInventory b = new InventoryCraftResult();
+	private World field_20133_c;
+	private int field_20132_h;
+	private int field_20131_i;
+	private int field_20130_j;
+
+	public ContainerWorkbench(InventoryPlayer var1, World var2, int var3, int var4, int var5) {
+		this.field_20133_c = var2;
+		this.field_20132_h = var3;
+		this.field_20131_i = var4;
+		this.field_20130_j = var5;
+		this.addSlot(new SlotCrafting(this.a, this.b, 0, 124, 35));
+
+		int var6;
+		int var7;
+		for(var6 = 0; var6 < 3; ++var6) {
+			for(var7 = 0; var7 < 3; ++var7) {
+				this.addSlot(new Slot(this.a, var7 + var6 * 3, 30 + var7 * 18, 17 + var6 * 18));
+			}
+		}
+
+		for(var6 = 0; var6 < 3; ++var6) {
+			for(var7 = 0; var7 < 9; ++var7) {
+				this.addSlot(new Slot(var1, var7 + var6 * 9 + 9, 8 + var7 * 18, 84 + var6 * 18));
+			}
+		}
+
+		for(var6 = 0; var6 < 9; ++var6) {
+			this.addSlot(new Slot(var1, var6, 8 + var6 * 18, 142));
+		}
+
+		this.onCraftMatrixChanged(this.a);
+	}
+
+	public void onCraftMatrixChanged(IInventory var1) {
+		int[] var2 = new int[9];
+		int[] meta = new int[9];
+
+		for(int var3 = 0; var3 < 3; ++var3) {
+			for(int var4 = 0; var4 < 3; ++var4) {
+				int var5 = var3 + var4 * 3;
+				ItemStack var6 = this.a.getStack(var5);
+				if(var6 == null) {
+					var2[var5] = -1;
+					meta[var5] = 0;
+				} else {
+					var2[var5] = var6.itemID;
+					meta[var5] = var6.itemMetadata;
+				}
+			}
+		}
+
+		this.b.setInventorySlotItem(0, CraftingManager.getInstance().craft(var2, meta));
+	}
+
+	public void onCraftGuiClosed(EntityPlayer var1) {
+		super.onCraftGuiClosed(var1);
+
+		if (var1.worldObj.canDoClientAction()) {
+			for(int var2 = 0; var2 < 9; ++var2) {
+				ItemStack var3 = this.a.getStack(var2);
+				if(var3 != null) {
+					var1.dropPlayerItem(var3);
+				}
+			}
+		}
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return this.field_20133_c.getBlockId(this.field_20132_h, this.field_20131_i, this.field_20130_j) == Block.workbench.blockID && var1.getDistanceSq((double) this.field_20132_h + 0.5D, (double) this.field_20131_i + 0.5D, (double) this.field_20130_j + 0.5D) <= 64.0D;
+	}
+}
--- /dev/null
+++ net/minecraft/src/ContainerPlayer.java
@@ -1,0 +1,83 @@
+package net.minecraft.src;
+
+public class ContainerPlayer extends Container {
+	public InventoryCrafting craftMatrix;
+	public IInventory craftResult;
+	public boolean unused;
+
+	public ContainerPlayer(InventoryPlayer var1, boolean var2) {
+		this.craftMatrix = new InventoryCrafting(this, 2, 2);
+		this.craftResult = new InventoryCraftResult();
+		this.unused = var2;
+		this.addSlot(new SlotCrafting(this.craftMatrix, this.craftResult, 0, 152, 27));
+
+		int var3;
+		int var4;
+		for(var3 = 0; var3 < 2; ++var3) {
+			for(var4 = 0; var4 < 2; ++var4) {
+				this.addSlot(new Slot(this.craftMatrix, var4 + var3 * 2, 107 + var4 * 18, 17 + var3 * 18));
+			}
+		}
+
+		for(var3 = 0; var3 < 4; ++var3) {
+			this.addSlot(new SlotArmor(var1, var1.getInventorySize() - 8 - var3, 8, 8 + var3 * 18, var3));
+			this.addSlot(new SlotArmor(var1, var1.getInventorySize() - 4 - var3, 80, 8 + var3 * 18, var3 + 4));
+		}
+		for(var3 = 0; var3 < 3; ++var3) {
+			this.addSlot(new SlotArmor(var1, var1.getInventorySize() - 1 - var3, 116 + var3 * 18, 62, var3 + 8));
+		}
+
+		for(var3 = 0; var3 < 3; ++var3) {
+			for(var4 = 0; var4 < 9; ++var4) {
+				this.addSlot(new Slot(var1, var4 + (var3 + 1) * 9, 8 + var4 * 18, 84 + var3 * 18));
+			}
+		}
+
+		for(var3 = 0; var3 < 9; ++var3) {
+			this.addSlot(new Slot(var1, var3, 8 + var3 * 18, 142));
+		}
+
+		this.onCraftMatrixChanged(this.craftMatrix);
+	}
+
+	public void onCraftMatrixChanged(IInventory var1) {
+		int[] var2 = new int[9];
+		int[] meta = new int[9];
+
+		for(int var3 = 0; var3 < 3; ++var3) {
+			for(int var4 = 0; var4 < 3; ++var4) {
+				int var5 = -1;
+				int var5m = 0;
+				if(var3 < 2 && var4 < 2) {
+					ItemStack var6 = this.craftMatrix.getStack(var3 + var4 * 2);
+					if(var6 != null) {
+						var5 = var6.itemID;
+						var5m = var6.itemMetadata;
+					}
+				}
+
+				var2[var3 + var4 * 3] = var5;
+				meta[var3 + var4 * 3] = var5m;
+			}
+		}
+
+		this.craftResult.setInventorySlotItem(0, CraftingManager.getInstance().craft(var2, meta));
+	}
+
+	public void onCraftGuiClosed(EntityPlayer var1) {
+		super.onCraftGuiClosed(var1);
+
+		for(int var2 = 0; var2 < 4; ++var2) {
+			ItemStack var3 = this.craftMatrix.getStack(var2);
+			if(var3 != null) {
+				var1.dropPlayerItem(var3);
+				this.craftMatrix.setInventorySlotItem(var2, (ItemStack)null);
+			}
+		}
+
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return true;
+	}
+}
--- net/minecraft/src/GuiButton.java
+++ net/minecraft/src/GuiButton.java
@@ -4,8 +4,8 @@
 import org.lwjgl.opengl.GL11;
 
 public class GuiButton extends Gui {
-	protected int width;
-	protected int height;
+	public int width;
+	public int height;
 	public int xPosition;
 	public int yPosition;
 	public String displayString;
@@ -17,16 +17,14 @@
 		this(var1, var2, var3, 200, 20, var4);
 	}
 
-	protected GuiButton(int var1, int var2, int var3, int var4, int var5, String var6) {
-		this.width = 200;
-		this.height = 20;
+	public GuiButton(int var1, int var2, int var3, int var4, int var5, String var6) {
+		this.width = var4;
+		this.height = var5;
 		this.enabled = true;
 		this.visible = true;
 		this.id = var1;
 		this.xPosition = var2;
 		this.yPosition = var3;
-		this.width = var4;
-		this.height = var5;
 		this.displayString = var6;
 	}
 
@@ -44,7 +42,7 @@
 	public void drawButton(Minecraft var1, int var2, int var3) {
 		if(this.visible) {
 			FontRenderer var4 = var1.fontRenderer;
-			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("/gui/gui.png"));
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("@@/gui/gui.png"));
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 			boolean var5 = var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
 			int var6 = this.getHoverState(var5);
@@ -70,5 +68,9 @@
 
 	public boolean mousePressed(Minecraft var1, int var2, int var3) {
 		return this.enabled && var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
+	}
+
+	public boolean mouseHover(int var1, int var2) {
+		return var1 >= this.xPosition && var2 >= this.yPosition && var1 < this.xPosition + this.width && var2 < this.yPosition + this.height;
 	}
 }
--- net/minecraft/src/RenderEngine.java
+++ net/minecraft/src/RenderEngine.java
@@ -19,17 +19,28 @@
 	private HashMap textureMap = new HashMap();
 	private HashMap textureContentsMap = new HashMap();
 	private IntBuffer singleIntBuffer = GLAllocation.createDirectIntBuffer(1);
-	private ByteBuffer imageData = GLAllocation.createDirectByteBuffer(1048576);
+	private ByteBuffer imageData = GLAllocation.createDirectByteBuffer(4194304);
 	private List textureList = new ArrayList();
 	private Map urlToImageDataMap = new HashMap();
 	private GameSettings options;
 	private boolean clampTexture = false;
+	private boolean blurTexture = false;
 
 	public RenderEngine(GameSettings var1) {
 		this.options = var1;
+		RenderGlobal.globalBrightness = this.options.brightness * 0.2F;
 	}
 
 	public int getTexture(String var1) {
+		if (var1.startsWith("@@")) {
+			if (this.options.darkMode) {
+				int dotPos = var1.indexOf(".");
+				var1 = var1.substring(2, dotPos) + "_dark.png";
+			} else {
+				var1 = var1.substring(2);
+			}
+		}
+
 		Integer var2 = (Integer)this.textureMap.get(var1);
 		if(var2 != null) {
 			return var2.intValue();
@@ -44,14 +55,21 @@
 					this.clampTexture = true;
 					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1.substring(2))), var4);
 					this.clampTexture = false;
+				} else if (var1.startsWith("~~")) {
+					this.blurTexture = true;
+					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1.substring(2))), var4);
+					this.blurTexture = false;
 				} else {
 					this.setupTexture(ImageIO.read(RenderEngine.class.getResourceAsStream(var1)), var4);
 				}
 
 				this.textureMap.put(var1, Integer.valueOf(var4));
 				return var4;
-			} catch (IOException var3) {
-				throw new RuntimeException("!!");
+			} catch (Exception var3) {
+				if (var1.equals("/missing.png")) {
+					throw new RuntimeException("!!");
+				}
+				return this.getTexture("/missing.png");
 			}
 		}
 	}
@@ -83,6 +101,9 @@
 		if(useMipmaps) {
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+		} else if (blurTexture) {
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
+			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
 		} else {
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
 			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
@@ -235,7 +256,7 @@
 
 			for(var3 = 0; var3 < var2.tileSize; ++var3) {
 				for(var4 = 0; var4 < var2.tileSize; ++var4) {
-					GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, 0, var2.iconIndex % 16 * 16 + var3 * 16, var2.iconIndex / 16 * 16 + var4 * 16, 16, 16, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
+					GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, 0, var2.iconIndex % 32 * 16 + var3 * 16, var2.iconIndex / 32 * 16 + var4 * 16, 16, 16, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
 					if(useMipmaps) {
 						for(var5 = 1; var5 <= 4; ++var5) {
 							var6 = 16 >> var5 - 1;
@@ -252,7 +273,7 @@
 								}
 							}
 
-							GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, var5, var2.iconIndex % 16 * var7, var2.iconIndex / 16 * var7, var7, var7, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, this.imageData);
+							GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, var5, (var2.iconIndex % 32 + var3) * var7, (var2.iconIndex / 32 + var4) * var7, var7, var7, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, this.imageData);
 						}
 					}
 				}
--- net/minecraft/src/ThreadDownloadImage.java
+++ net/minecraft/src/ThreadDownloadImage.java
@@ -1,15 +1,18 @@
 package net.minecraft.src;
 
 import java.net.HttpURLConnection;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
 import java.net.URL;
 import javax.imageio.ImageIO;
 
-class ThreadDownloadImage extends Thread {
-	final String location;
-	final ImageBuffer buffer;
-	final ThreadDownloadImageData imageData;
+import net.minecraft.client.Minecraft;
+public class ThreadDownloadImage extends Thread {
+	public final String location;
+	public final ImageBuffer buffer;
+	public final ThreadDownloadImageData imageData;
 
-	ThreadDownloadImage(ThreadDownloadImageData var1, String var2, ImageBuffer var3) {
+	public ThreadDownloadImage(ThreadDownloadImageData var1, String var2, ImageBuffer var3) {
 		this.imageData = var1;
 		this.location = var2;
 		this.buffer = var3;
@@ -20,7 +23,7 @@
 
 		try {
 			URL var2 = new URL(this.location);
-			var1 = (HttpURLConnection)var2.openConnection();
+			var1 = (HttpURLConnection)var2.openConnection(Minecraft.betacraftProxy);
 			var1.setDoInput(true);
 			var1.setDoOutput(false);
 			var1.connect();
@@ -30,12 +33,9 @@
 				} else {
 					this.imageData.image = this.buffer.parseUserSkin(ImageIO.read(var1.getInputStream()));
 				}
-
-				return;
 			}
 		} catch (Exception var6) {
 			var6.printStackTrace();
-			return;
 		} finally {
 			var1.disconnect();
 		}
--- /dev/null
+++ net/minecraft/src/Constants.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+public class Constants {
+    public static final int CHUNK_HEIGHT = 256;
+    public static final int CHUNK_BIT_OFFSET = (int)Math.ceil(Math.log(CHUNK_HEIGHT) / Math.log(2.0));
+    public static final String ALLOWED_CHARACTERS = " !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\'abcdefghijklmnopqrstuvwxyz{|}~\u2302\u00c7\u00fc\u00e9\u00e2\u00e4\u00e0\u00e5\u00e7\u00ea\u00eb\u00e8\u00ef\u00ee\u00ec\u00c4\u00c5\u00c9\u00e6\u00c6\u00f4\u00f6\u00f2\u00fb\u00f9\u00ff\u00d6\u00dc\u00f8\u00a3\u00d8\u00d7\u0192\u00e1\u00ed\u00f3\u00fa\u00f1\u00d1\u00aa\u00ba\u00bf\u00ae\u00ac\u00bd\u00bc\u00a1\u00ab\u00bb";
+    public static final String ILLEGAL_FOLDER_CHARACTERS = "/\n\r\t\u0000\f`?*\\<>|\":";
+
+    private Constants() {
+    }
+}
--- net/minecraft/src/CraftingInventoryWorkbenchCB.java
+++ /dev/null
@@ -1,36 +1,0 @@
-package net.minecraft.src;
-
-public class CraftingInventoryWorkbenchCB extends CraftingInventoryCB {
-	public InventoryCrafting craftMatrix = new InventoryCrafting(this, 3, 3);
-	public IInventory craftResult = new InventoryCraftResult();
-
-	public void onCraftMatrixChanged(IInventory var1) {
-		int[] var2 = new int[9];
-
-		for(int var3 = 0; var3 < 3; ++var3) {
-			for(int var4 = 0; var4 < 3; ++var4) {
-				int var5 = var3 + var4 * 3;
-				ItemStack var6 = this.craftMatrix.getStackInSlot(var5);
-				if(var6 == null) {
-					var2[var5] = -1;
-				} else {
-					var2[var5] = var6.itemID;
-				}
-			}
-		}
-
-		this.craftResult.setInventorySlotContents(0, CraftingManager.getInstance().findMatchingRecipe(var2));
-	}
-
-	public void onCraftGuiClosed(EntityPlayer var1) {
-		super.onCraftGuiClosed(var1);
-
-		for(int var2 = 0; var2 < 9; ++var2) {
-			ItemStack var3 = this.craftMatrix.getStackInSlot(var2);
-			if(var3 != null) {
-				var1.dropPlayerItem(var3);
-			}
-		}
-
-	}
-}
--- net/minecraft/src/CanvasCrashReport.java
+++ net/minecraft/src/CanvasCrashReport.java
@@ -3,7 +3,7 @@
 import java.awt.Canvas;
 import java.awt.Dimension;
 
-class CanvasCrashReport extends Canvas {
+public class CanvasCrashReport extends Canvas {
 	public CanvasCrashReport(int var1) {
 		this.setPreferredSize(new Dimension(var1, var1));
 		this.setMinimumSize(new Dimension(var1, var1));
--- /dev/null
+++ net/minecraft/src/Packet100OpenWindow.java
@@ -1,0 +1,59 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet100OpenWindow extends Packet {
+	public static final int
+			WINDOW_CHEST = 0,
+			WINDOW_WORKBENCH = 1,
+			WINDOW_FURNACE = 2,
+			WINDOW_REFABRICATOR = 3,
+			WINDOW_CREATIVE = 4,
+			WINDOW_CRATE = 5;
+
+	public int windowId;
+	public int inventoryType;
+	public String windowTitle;
+	public int slotsCount;
+
+	public Packet100OpenWindow() {
+	}
+
+	public Packet100OpenWindow(int var1) {
+		this.windowId = -1;
+		this.inventoryType = var1;
+		this.windowTitle = "Inventory";
+		this.slotsCount = 0;
+	}
+
+	public Packet100OpenWindow(int var1, int var2, String var3, int var4) {
+		this.windowId = var1;
+		this.inventoryType = var2;
+		this.windowTitle = var3;
+		this.slotsCount = var4;
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleOpenWindow(this);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.windowId = var1.readByte();
+		this.inventoryType = var1.readByte();
+		this.windowTitle = var1.readUTF();
+		this.slotsCount = var1.readByte();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeByte(this.windowId);
+		var1.writeByte(this.inventoryType);
+		var1.writeUTF(this.windowTitle);
+		var1.writeByte(this.slotsCount);
+	}
+
+	public int getPacketSize() {
+		return 3 + this.windowTitle.length();
+	}
+}
--- net/minecraft/src/ServerGuiCommandListener.java
+++ net/minecraft/src/ServerGuiCommandListener.java
@@ -4,11 +4,11 @@
 import java.awt.event.ActionListener;
 import javax.swing.JTextField;
 
-class ServerGuiCommandListener implements ActionListener {
-	final JTextField textField;
-	final ServerGUI mcServerGui;
+public class ServerGuiCommandListener implements ActionListener {
+	public final JTextField textField;
+	public final ServerGUI mcServerGui;
 
-	ServerGuiCommandListener(ServerGUI var1, JTextField var2) {
+	public ServerGuiCommandListener(ServerGUI var1, JTextField var2) {
 		this.mcServerGui = var1;
 		this.textField = var2;
 	}
--- net/minecraft/src/GuiOptions.java
+++ net/minecraft/src/GuiOptions.java
@@ -1,34 +1,84 @@
 package net.minecraft.src;
 
+import java.util.List;
+
 public class GuiOptions extends GuiScreen {
 	private GuiScreen parentScreen;
 	protected String screenTitle = "Options";
 	private GameSettings options;
+	private int maxPages = 1;
+	private int currentPage;
+	private int prevPage;
+	private OptionCategory category;
+	private List<EnumOption> categoryOptions;
 
 	public GuiOptions(GuiScreen var1, GameSettings var2) {
+		this(var1, var2, null);
+	}
+
+	public GuiOptions(GuiScreen var1, GameSettings var2, OptionCategory var3) {
 		this.parentScreen = var1;
 		this.options = var2;
+		if (var3 != null) {
+			this.category = var3;
+			this.categoryOptions = EnumOption.inCategory(this.category);
+			this.maxPages = Math.floorDiv(this.categoryOptions.size() - 1, 10) + 1;
+		}
 	}
 
 	public void initGui() {
-		for(int var1 = 0; var1 < this.options.numberOfOptions; ++var1) {
-			int var2 = this.options.isSlider(var1);
-			if(var2 == 0) {
-				this.controlList.add(new GuiSmallButton(var1, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), this.options.getOptionDisplayString(var1)));
+		this.controlList.clear();
+		this.controlList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 132, this.category == null ? "Done" : "Back"));
+
+		if (this.category == null) {
+			initCategories();
+		} else {
+			initPage();
+		}
+
+		if (this.maxPages > 1) {
+			this.controlList.add(new GuiButton(300 + this.currentPage * 2, this.width / 2 - 140, this.height / 6 + 132, 20, 20, "<"));
+			this.controlList.add(new GuiButton(301 + this.currentPage * 2, this.width / 2 + 120, this.height / 6 + 132, 20, 20, ">"));
+		}
+	}
+
+	private void initCategories() {
+		for (int i = 0; i < Math.min(OptionCategory.values().length - this.currentPage * 10, 10); i++) {
+			this.controlList.add(new GuiSmallButton(i + this.currentPage * 10, this.width / 2 - 155 + i % 2 * 160, this.height / 6 + 24 * (i >> 1), OptionCategory.values()[i + this.currentPage * 10].toString()));
+		}
+	}
+
+	private void initPage() {
+		this.categoryOptions = EnumOption.inCategory(this.category);
+		this.maxPages = Math.floorDiv(this.categoryOptions.size() - 1, 10) + 1;
+
+		for(int var1 = 0; var1 < Math.min(this.categoryOptions.size() - this.currentPage * 10, 10); ++var1) {
+			EnumOption var11 = this.categoryOptions.get(var1 + this.currentPage * 10);
+			int var11i = var11.ordinal();
+			if (var11 == EnumOption.KEYBINDS) {
+				this.controlList.add(new GuiSmallButton(100, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), "Keybinds"));
+			} else if (this.options.isSlider(var11i) == 0) {
+				this.controlList.add(new GuiSmallButton(var11i, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), this.options.getOptionDisplayString(var11i)));
 			} else {
-				this.controlList.add(new GuiSlider(var1, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), var1, this.options.getOptionDisplayString(var1), this.options.getOptionFloatValue(var1)));
+				this.controlList.add(new GuiSlider(var11i, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), var11i, this.options.getOptionDisplayString(var11i), this.options.getOptionFloatValue(var11i)));
 			}
 		}
-
-		this.controlList.add(new GuiButton(100, this.width / 2 - 100, this.height / 6 + 120 + 12, "Controls..."));
-		this.controlList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 168, "Done"));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
 		if(var1.enabled) {
 			if(var1.id < 100) {
-				this.options.setOptionValue(var1.id, 1);
-				var1.displayString = this.options.getOptionDisplayString(var1.id);
+				if (this.category == null) {
+					OptionCategory category = OptionCategory.values()[var1.id];
+					GuiScreen nextScreen = category.getNextScreen(this);
+					if (nextScreen == null) {
+						nextScreen = new GuiOptions(this, this.options, category);
+					}
+					this.mc.displayGuiScreen(nextScreen);
+				} else {
+					this.options.setOptionValue(var1.id, 1);
+					var1.displayString = this.options.getOptionDisplayString(var1.id);
+				}
 			}
 
 			if(var1.id == 100) {
@@ -39,12 +89,28 @@
 				this.mc.displayGuiScreen(this.parentScreen);
 			}
 
+			if(var1.id == 300 + this.prevPage * 2) {
+				this.currentPage--;
+				if (this.currentPage < 0) {
+					this.currentPage = this.maxPages - 1;
+				}
+				this.initGui();
+			}
+
+			if(var1.id == 301 + this.prevPage * 2) {
+				this.currentPage++;
+				if (this.currentPage >= this.maxPages) {
+					this.currentPage = 0;
+				}
+				this.initGui();
+			}
 		}
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 20, 16777215);
 		super.drawScreen(var1, var2, var3);
+		this.prevPage = this.currentPage;
 	}
 }
--- net/minecraft/src/EntityPlayerSP.java
+++ net/minecraft/src/EntityPlayerSP.java
@@ -1,31 +1,49 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
-
 public class EntityPlayerSP extends EntityPlayer {
 	public MovementInput movementInput;
 	private Minecraft mc;
+	private boolean wasJumping;
 
 	public EntityPlayerSP(Minecraft var1, World var2, Session var3) {
 		super(var2);
 		this.mc = var1;
-		if(var3 != null && var3.username != null && var3.username.length() > 0) {
-			this.skinUrl = "http://www.minecraft.net/skin/" + var3.username + ".png";
-			System.out.println("Loading texture " + this.skinUrl);
+		if (var3 != null && var3.username != null && var3.username.length() > 0) {
+			this.username = var3.username;
+			this.blueStaggo = this.username.equals("BlueStag256");
+			if (this.blueStaggo) {
+				this.texture = "/mob/staggo.png";
+				var1.achievements.updateProgress(Achievement.MEET_THE_STAGGO, 1);
+			} else {
+				this.skinUrl = "http://www.minecraft.net/skin/" + var3.username + ".png";
+			}
 		}
-
-		this.username = var3.username;
 	}
 
 	public void updateEntityActionState() {
 		super.updateEntityActionState();
 		this.moveStrafing = this.movementInput.moveStrafe;
 		this.moveForward = this.movementInput.moveForward;
+		this.wasJumping = this.isJumping;
 		this.isJumping = this.movementInput.jump;
+		this.justJumped = this.movementInput.jump && !this.wasJumping;
 	}
 
 	public void onLivingUpdate() {
+		boolean prevJump = this.movementInput.jump;
+
 		this.movementInput.updatePlayerMoveState(this);
+
+		if(this.creative && this.movementInput.jump && !prevJump) {
+			if(this.flyToggleTimer == 0) {
+				this.flyToggleTimer = 7;
+			} else {
+				this.flying = !this.flying;
+				this.flyToggleTimer = 0;
+			}
+		}
+
 		if(this.movementInput.sneak && this.ySize < 0.2F) {
 			this.ySize = 0.2F;
 		}
@@ -55,32 +73,35 @@
 		this.mc.displayGuiScreen(new GuiChest(this.inventory, var1));
 	}
 
+	public void displayGUICrate(IInventory var1) {
+		this.mc.displayGuiScreen(new GuiCrate(this.inventory, var1));
+	}
+
 	public void displayGUIEditSign(TileEntitySign var1) {
 		this.mc.displayGuiScreen(new GuiEditSign(var1));
 	}
 
-	public void displayWorkbenchGUI() {
-		this.mc.displayGuiScreen(new GuiCrafting(this.inventory));
+	public void displayWorkbenchGUI(int var1, int var2, int var3) {
+		this.mc.displayGuiScreen(new GuiCrafting(this.inventory, this.worldObj, var1, var2, var3));
 	}
 
 	public void displayGUIFurnace(TileEntityFurnace var1) {
 		this.mc.displayGuiScreen(new GuiFurnace(this.inventory, var1));
 	}
 
-	public void attackEntity(Entity var1) {
-		int var2 = this.inventory.getDamageVsEntity(var1);
-		if(var2 > 0) {
-			var1.attackEntityFrom(this, var2);
-			ItemStack var3 = this.getCurrentEquippedItem();
-			if(var3 != null && var1 instanceof EntityLiving) {
-				var3.hitEntity((EntityLiving)var1);
-				if(var3.stackSize <= 0) {
-					var3.onItemDestroyedByUse(this);
-					this.destroyCurrentEquippedItem();
-				}
-			}
+	public void displayGUIRefabricator(TileEntityRefabricator var1) {
+		this.mc.displayGuiScreen(new GuiRefabricator(this.inventory, var1));
+	}
+
+	public void displayGUIRecipeGuide(ItemStack var1) {
+		if (var1 != null)
+			this.mc.displayGuiScreen(new GuiRecipeGuide(var1));
+	}
+
+	public void displayGUICreative() {
+		if (this.creative || this.mc.options.creativeDebug) {
+			this.mc.displayGuiScreen(new GuiCreative(this.inventory, this.mc));
 		}
-
 	}
 
 	public void onItemPickup(Entity var1, int var2) {
@@ -91,27 +112,46 @@
 		return this.inventory.getTotalArmorValue();
 	}
 
-	public void interactWithEntity(Entity var1) {
-		if(!var1.interact(this)) {
-			ItemStack var2 = this.getCurrentEquippedItem();
-			if(var2 != null && var1 instanceof EntityLiving) {
-				var2.useItemOnEntity((EntityLiving)var1);
-				if(var2.stackSize <= 0) {
-					var2.onItemDestroyedByUse(this);
-					this.destroyCurrentEquippedItem();
-				}
-			}
-
-		}
-	}
-
 	public void sendChatMessage(String var1) {
 	}
 
-	public void onPlayerUpdate() {
-	}
-
 	public boolean isSneaking() {
 		return this.movementInput.sneak;
+	}
+
+	public boolean isRunning() {
+		return this.movementInput.run
+				&& !this.energyRegen
+				&& (this.flying || this.movementInput.moveForward > 0.0F);
+	}
+
+	public void setHealth(int var1) {
+		int var2 = this.health - var1;
+		if(var2 <= 0) {
+			this.health = var1;
+			if(var2 < 0) {
+				this.heartsLife = this.heartsHalvesLife / 2;
+			}
+		} else {
+			this.prevDamage = var2;
+			this.prevHealth = this.health;
+			this.heartsLife = this.heartsHalvesLife;
+			this.damageEntity(var2);
+			this.hurtTime = this.maxHurtTime = 10;
+			this.worldObj.playSoundAtEntity(this, this.getHurtSound(), this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
+		}
+	}
+
+	public void respawnPlayer() {
+		this.mc.respawn();
+	}
+
+	public void closeCurrentInventory() {
+		super.closeCurrentInventory();
+		this.mc.displayGuiScreen((GuiScreen)null);
+	}
+
+	public boolean moveInMultiplayer() {
+		return true;
 	}
 }
--- net/minecraft/src/EnumSkyBlock.java
+++ net/minecraft/src/EnumSkyBlock.java
@@ -6,7 +6,7 @@
 
 	public final int defaultLightValue;
 
-	private EnumSkyBlock(int var3) {
+	EnumSkyBlock(int var3) {
 		this.defaultLightValue = var3;
 	}
 }
--- /dev/null
+++ net/minecraft/src/GuiCrate.java
@@ -1,0 +1,31 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+public class GuiCrate extends GuiContainer {
+	private IInventory upperChestInventory;
+	private IInventory lowerChestInventory;
+
+	public GuiCrate(IInventory var1, IInventory var2) {
+		super(new ContainerCrate(var1, var2));
+		this.upperChestInventory = var1;
+		this.lowerChestInventory = var2;
+		this.allowUserInput = false;
+		this.xSize = 176;
+		this.ySize = 132;
+	}
+
+	protected void drawGuiContainerForegroundLayer() {
+		this.fontRenderer.drawString(this.lowerChestInventory.getInventoryName(), 8, 6, this.mc.options.getTextColor());
+		this.fontRenderer.drawString(this.upperChestInventory.getInventoryName(), 8, 38, this.mc.options.getTextColor());
+	}
+
+	protected void drawGuiContainerBackgroundLayer(float var1) {
+		int var2 = this.mc.renderEngine.getTexture("@@/gui/crate.png");
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		this.mc.renderEngine.bindTexture(var2);
+		int var3 = (this.width - this.xSize) / 2;
+		int var4 = (this.height - this.ySize) / 2;
+		this.drawTexturedModalRect(var3, var4, 0, 0, this.xSize, this.ySize);
+	}
+}
--- net/minecraft/src/GuiConflictWarning.java
+++ net/minecraft/src/GuiConflictWarning.java
@@ -22,7 +22,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, "Level save conflict", this.width / 2, this.height / 4 - 60 + 20, 16777215);
 		this.drawString(this.fontRenderer, "Minecraft detected a conflict in the level save data.", this.width / 2 - 140, this.height / 4 - 60 + 60 + 0, 10526880);
 		this.drawString(this.fontRenderer, "This could be caused by two copies of the game", this.width / 2 - 140, this.height / 4 - 60 + 60 + 18, 10526880);
--- net/minecraft/src/BlockSand.java
+++ net/minecraft/src/BlockSand.java
@@ -23,7 +23,7 @@
 
 	private void tryToFall(World var1, int var2, int var3, int var4) {
 		if(canFallBelow(var1, var2, var3 - 1, var4) && var3 >= 0) {
-			EntityFallingSand var8 = new EntityFallingSand(var1, (float)var2 + 0.5F, (float)var3 + 0.5F, (float)var4 + 0.5F, this.blockID);
+			EntityFallingSand var8 = new EntityFallingSand(var1, var2 + 0.5D, var3 + 0.5D, var4 + 0.5D, this.blockID);
 			if(fallInstantly) {
 				while(!var8.isDead) {
 					var8.onUpdate();
--- /dev/null
+++ net/minecraft/src/Packet61DoorChange.java
@@ -1,0 +1,48 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet61DoorChange extends Packet {
+	public int type;
+	public int direction;
+	public int x;
+	public int y;
+	public int z;
+
+	public Packet61DoorChange() {
+	}
+
+	public Packet61DoorChange(int var1, int var2, int var3, int var4, int var5) {
+		this.type = var1;
+		this.x = var2;
+		this.y = var3;
+		this.z = var4;
+		this.direction = var5;
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.type = var1.readInt();
+		this.x = var1.readInt();
+		this.y = var1.readByte();
+		this.z = var1.readInt();
+		this.direction = var1.readInt();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeInt(this.type);
+		var1.writeInt(this.x);
+		var1.writeByte(this.y);
+		var1.writeInt(this.z);
+		var1.writeInt(this.direction);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleDoorChange(this);
+	}
+
+	public int getPacketSize() {
+		return 20;
+	}
+}
--- /dev/null
+++ net/minecraft/src/BiomeForest.java
@@ -1,0 +1,22 @@
+package net.minecraft.src;
+
+public class BiomeForest extends Biome {
+	private static final TreePopulator trees = new TreePopulator()
+			.withTree(new WorldGenTrees())
+			.withBigTree(new WorldGenBigTree(), 10, 2)
+			.withHighTree(new WorldGenSpruceTrees(), 160, 180)
+			.withDensity(1.0D, 0.5D, 0.3D, 0.0D, 250.0D);
+
+	protected BiomeForest(int id, String name, float priority, ClimateZone... climateZones) {
+		super(id, name, priority, climateZones);
+	}
+
+	public void populate(PopulatorHost host) {
+		trees.populate(host);
+		host.generateFlowers(2);
+	}
+
+	public int[] getMapColor() {
+		return new int[] { 0, 220, 0 };
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiTextField.java
@@ -1,0 +1,104 @@
+package net.minecraft.src;
+
+public class GuiTextField extends Gui {
+	private final FontRenderer fontRenderer;
+	private final int xPos;
+	private final int yPos;
+	private final int width;
+	private final int height;
+	private String text;
+	private int maxStringLength;
+	private int cursorCounter;
+	public boolean isFocused = false;
+	public boolean isEnabled = true;
+	private GuiScreen parentGuiScreen;
+
+	public GuiTextField(GuiScreen guiScreen1, FontRenderer var2, int var3, int var4, int var5, int var6, String var7) {
+		this.parentGuiScreen = guiScreen1;
+		this.fontRenderer = var2;
+		this.xPos = var3;
+		this.yPos = var4;
+		this.width = var5;
+		this.height = var6;
+		this.setText(var7);
+	}
+
+	public void setText(String var1) {
+		this.text = var1;
+	}
+
+	public String getText() {
+		return this.text;
+	}
+
+	public void updateCursorCounter() {
+		++this.cursorCounter;
+	}
+
+	public void textboxKeyTyped(char c1, int var2) {
+		if(this.isEnabled && this.isFocused) {
+//			if(c1 == 9) {
+//				this.parentGuiScreen.selectNextField();
+//			}
+
+			if(c1 == 22) {
+				String var3 = GuiScreen.getClipboardString();
+				if(var3 == null) {
+					var3 = "";
+				}
+
+				int var4 = 32 - this.text.length();
+				if(var4 > var3.length()) {
+					var4 = var3.length();
+				}
+
+				if(var4 > 0) {
+					this.text = this.text + var3.substring(0, var4);
+				}
+			}
+
+			if(var2 == 14 && this.text.length() > 0) {
+				this.text = this.text.substring(0, this.text.length() - 1);
+			}
+
+			if(" !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\'abcdefghijklmnopqrstuvwxyz{|}~\u2302\u00c7\u00fc\u00e9\u00e2\u00e4\u00e0\u00e5\u00e7\u00ea\u00eb\u00e8\u00ef\u00ee\u00ec\u00c4\u00c5\u00c9\u00e6\u00c6\u00f4\u00f6\u00f2\u00fb\u00f9\u00ff\u00d6\u00dc\u00f8\u00a3\u00d8\u00d7\u0192\u00e1\u00ed\u00f3\u00fa\u00f1\u00d1\u00aa\u00ba\u00bf\u00ae\u00ac\u00bd\u00bc\u00a1\u00ab\u00bb"
+					.indexOf(c1) >= 0 && (this.text.length() < this.maxStringLength || this.maxStringLength == 0)) {
+				this.text = this.text + c1;
+			}
+
+		}
+	}
+
+	public void mouseClicked(int var1, int var2, int var3) {
+		boolean var4 = this.isEnabled && var1 >= this.xPos && var1 < this.xPos + this.width && var2 >= this.yPos && var2 < this.yPos + this.height;
+		this.setFocused(var4);
+	}
+
+	public void setFocused(boolean var1) {
+		if(var1 && !this.isFocused) {
+			this.cursorCounter = 0;
+		}
+
+		this.isFocused = var1;
+	}
+
+	public void drawTextBox() {
+		this.drawRect(this.xPos - 1, this.yPos - 1, this.xPos + this.width + 1, this.yPos + this.height + 1, -6250336);
+		this.drawRect(this.xPos, this.yPos, this.xPos + this.width, this.yPos + this.height, -16777216);
+		if(this.isEnabled) {
+			boolean var1 = this.isFocused && this.cursorCounter / 6 % 2 == 0;
+			this.drawString(this.fontRenderer, this.text + (var1 ? "_" : ""), this.xPos + 4, this.yPos + (this.height - 8) / 2, 14737632);
+		} else {
+			this.drawString(this.fontRenderer, this.text, this.xPos + 4, this.yPos + (this.height - 8) / 2, 7368816);
+		}
+
+	}
+
+	public void setMaxStringLength(int var1) {
+		this.maxStringLength = var1;
+	}
+
+	public boolean mouseHover(int var1, int var2) {
+		return var1 >= this.xPos && var1 < this.xPos + this.width && var2 >= this.yPos && var2 < this.yPos + this.height;
+	}
+}
--- net/minecraft/src/CodecMus.java
+++ net/minecraft/src/CodecMus.java
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+
 import paulscode.sound.codecs.CodecJOrbis;
 
 public class CodecMus extends CodecJOrbis {
--- net/minecraft/src/ThreadDownloadResources.java
+++ net/minecraft/src/ThreadDownloadResources.java
@@ -1,11 +1,12 @@
 package net.minecraft.src;
 
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
+import java.io.*;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
 import java.net.URL;
+import java.net.URLConnection;
+import java.nio.file.*;
+import java.util.Scanner;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import net.minecraft.client.Minecraft;
@@ -20,10 +21,17 @@
 	private boolean closing = false;
 
 	public ThreadDownloadResources(File var1, Minecraft var2) {
+		String proxyHost = System.getProperty("http.proxyHost");
+		if (proxyHost != null && proxyHost.equals("betacraft.uk")) {
+			// Minecraft Diverge already uses Betacraft's proxy
+			System.setProperty("http.proxyHost", "");
+			System.setProperty("http.proxyPort", "");
+		}
+
 		this.mc = var2;
 		this.setName("Resource download thread");
 		this.setDaemon(true);
-		this.resourcesFolder = new File(var1, "resources/");
+		this.resourcesFolder = new File(var1, "resources-dvge/");
 		if(!this.resourcesFolder.exists() && !this.resourcesFolder.mkdirs()) {
 			throw new RuntimeException("The working directory could not be created: " + this.resourcesFolder);
 		}
@@ -31,33 +39,57 @@
 
 	public void run() {
 		try {
-			URL var1 = new URL("http://s3.amazonaws.com/MinecraftResources/");
-			DocumentBuilderFactory var2 = DocumentBuilderFactory.newInstance();
-			DocumentBuilder var3 = var2.newDocumentBuilder();
-			Document var4 = var3.parse(var1.openStream());
-			NodeList var5 = var4.getElementsByTagName("Contents");
+			this.downloadAllResources(new URL("http://s3.amazonaws.com/MinecraftResources/"), true);
+			this.downloadAllResources(new URL("https://github.com/BlueStaggo/DivergeResources/raw/main/resources.xml"), false);
 
-			for(int var6 = 0; var6 < 2; ++var6) {
-				for(int var7 = 0; var7 < var5.getLength(); ++var7) {
-					Node var8 = var5.item(var7);
-					if(var8.getNodeType() == 1) {
-						Element var9 = (Element)var8;
-						String var10 = ((Element)var9.getElementsByTagName("Key").item(0)).getChildNodes().item(0).getNodeValue();
-						long var11 = Long.parseLong(((Element)var9.getElementsByTagName("Size").item(0)).getChildNodes().item(0).getNodeValue());
-						if(var11 > 0L) {
-							this.downloadAndInstallResource(var1, var10, var11, var6);
-							if(this.closing) {
-								return;
-							}
-						}
-					}
-				}
-			}
+			this.loadResource(this.resourcesFolder, "");
 		} catch (Exception var13) {
 			this.loadResource(this.resourcesFolder, "");
 			var13.printStackTrace();
 		}
-
+	}
+
+	private void downloadAllResources(URL var1, boolean useProxy) throws Exception {
+		URLConnection connection;
+		if (useProxy) {
+			connection = var1.openConnection(Minecraft.betacraftProxy);
+		} else {
+			connection = var1.openConnection();
+		}
+
+		DocumentBuilderFactory var2 = DocumentBuilderFactory.newInstance();
+		DocumentBuilder var3 = var2.newDocumentBuilder();
+		Document var4 = var3.parse(connection.getInputStream());
+		NodeList var5 = var4.getElementsByTagName("Contents");
+
+		for(int var6 = 0; var6 < 2; ++var6) {
+			for(int var7 = 0; var7 < var5.getLength(); ++var7) {
+				Node var8 = var5.item(var7);
+				if(var8.getNodeType() == 1) {
+					Element var9 = (Element)var8;
+					String var10 = ((Element)var9.getElementsByTagName("Key").item(0)).getChildNodes().item(0).getNodeValue();
+					long var11 = Long.parseLong(((Element)var9.getElementsByTagName("Size").item(0)).getChildNodes().item(0).getNodeValue());
+					if(var11 > 0L) {
+						this.downloadAndInstallResource(var1, var10, var11, var6, useProxy);
+						if(this.closing) {
+							return;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	private void unpackCustomResource(String path) throws IOException {
+		if (!path.equals("")) {
+			InputStream resStream = this.getClass().getResourceAsStream(path);
+			if (resStream == null) {
+				throw new IOException("Resource " + path + " is invalid.");
+			}
+			File res = new File(this.resourcesFolder, path.replaceFirst("/resources/", "/"));
+			res.mkdirs();
+			Files.copy(resStream, res.toPath(), StandardCopyOption.REPLACE_EXISTING);
+		}
 	}
 
 	public void reloadResources() {
@@ -81,7 +113,7 @@
 
 	}
 
-	private void downloadAndInstallResource(URL var1, String var2, long var3, int var5) {
+	private void downloadAndInstallResource(URL var1, String var2, long var3, int var5, boolean useProxy) {
 		try {
 			int var6 = var2.indexOf("/");
 			String var7 = var2.substring(0, var6);
@@ -97,7 +129,7 @@
 			if(!var8.exists() || var8.length() != var3) {
 				var8.getParentFile().mkdirs();
 				String var9 = var2.replaceAll(" ", "%20");
-				this.downloadResource(new URL(var1, var9), var8, var3);
+				this.downloadResource(new URL(var1, var9), var8, var3, useProxy);
 				if(this.closing) {
 					return;
 				}
@@ -110,9 +142,16 @@
 
 	}
 
-	private void downloadResource(URL var1, File var2, long var3) throws IOException {
+	private void downloadResource(URL var1, File var2, long var3, boolean useProxy) throws IOException {
+		URLConnection connection;
+		if (useProxy) {
+			connection = var1.openConnection(Minecraft.betacraftProxy);
+		} else {
+			connection = var1.openConnection();
+		}
+
 		byte[] var5 = new byte[4096];
-		DataInputStream var6 = new DataInputStream(var1.openStream());
+		DataInputStream var6 = new DataInputStream(connection.getInputStream());
 		DataOutputStream var7 = new DataOutputStream(new FileOutputStream(var2));
 		boolean var8 = false;
 
--- net/minecraft/src/BlockFluid.java
+++ net/minecraft/src/BlockFluid.java
@@ -5,8 +5,9 @@
 public abstract class BlockFluid extends Block {
 	protected int fluidType = 1;
 
-	protected BlockFluid(int var1, Material var2) {
-		super(var1, (var2 == Material.lava ? 14 : 12) * 16 + 13, var2);
+	public BlockFluid(int var1, Material var2) {
+		super(var1, textureXY(29, var2 == Material.lava ? 30 : 28), var2);
+		canBlockGrass[var1] = true;
 		float var3 = 0.0F;
 		float var4 = 0.0F;
 		if(var2 == Material.lava) {
--- net/minecraft/src/ChunkLoader.java
+++ net/minecraft/src/ChunkLoader.java
@@ -1,9 +1,12 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.util.Iterator;
+import java.util.List;
 
 public class ChunkLoader implements IChunkLoader {
 	private File saveDir;
@@ -101,17 +104,20 @@
 
 	}
 
-	public void storeChunkInCompound(Chunk var1, World var2, NBTTagCompound var3) {
+	public static void storeChunkInCompound(Chunk var1, World var2, NBTTagCompound var3) {
 		var2.checkSessionLock();
 		var3.setInteger("xPos", var1.xPosition);
 		var3.setInteger("zPos", var1.zPosition);
 		var3.setLong("LastUpdate", var2.worldTime);
-		var3.setByteArray("Blocks", var1.blocks);
-		var3.setByteArray("Data", var1.data.data);
+		var3.setShortArray("Blocks", var1.blocks);
+		var3.setByteArray("Data", var1.data);
 		var3.setByteArray("SkyLight", var1.skylightMap.data);
 		var3.setByteArray("BlockLight", var1.blocklightMap.data);
-		var3.setByteArray("HeightMap", var1.heightMap);
+		var3.setIntArray("HeightMap", var1.heightMap);
+		var3.setByteArray("Biomes", var1.biomes);
 		var3.setBoolean("TerrainPopulated", var1.isTerrainPopulated);
+		var3.setBoolean("UnderworldPopulated", var1.isUnderworldPopulated);
+		var3.setInteger("ChunkVersion", Chunk.CHUNK_VERSION_CURRENT);
 		var1.hasEntities = false;
 		NBTTagList var4 = new NBTTagList();
 
@@ -148,25 +154,26 @@
 		int var2 = var1.getInteger("xPos");
 		int var3 = var1.getInteger("zPos");
 		Chunk var4 = new Chunk(var0, var2, var3);
-		var4.blocks = var1.getByteArray("Blocks");
-		var4.data = new NibbleArray(var1.getByteArray("Data"));
+		var4.blocks = var1.getShortArray("Blocks");
+		var4.data = var1.getByteArray("Data");
+		var4.biomes = var1.getByteArray("Biomes");
 		var4.skylightMap = new NibbleArray(var1.getByteArray("SkyLight"));
 		var4.blocklightMap = new NibbleArray(var1.getByteArray("BlockLight"));
-		var4.heightMap = var1.getByteArray("HeightMap");
 		var4.isTerrainPopulated = var1.getBoolean("TerrainPopulated");
-		if(!var4.data.isValid()) {
-			var4.data = new NibbleArray(var4.blocks.length);
-		}
-
-		if(var4.heightMap == null || !var4.skylightMap.isValid()) {
-			var4.heightMap = new byte[256];
-			var4.skylightMap = new NibbleArray(var4.blocks.length);
-			var4.generateSkylightMap();
-		}
-
-		if(!var4.blocklightMap.isValid()) {
-			var4.blocklightMap = new NibbleArray(var4.blocks.length);
-			var4.doNothing();
+		var4.isUnderworldPopulated = var1.getBoolean("UnderworldPopulated");
+
+		if (var4.biomes.length == 0) {
+			var4.biomes = new byte[256];
+			var4.generateBiomes(var0);
+		}
+
+		if (var1.hasKey("HeightMap")) {
+			if (var1.getType("HeightMap") == 7) {
+				var4.heightMap = new int[256];
+				var4.generateHeightMap();
+			} else {
+				var4.heightMap = var1.getIntArray("HeightMap");
+			}
 		}
 
 		NBTTagList var5 = var1.getTagList("Entities");
@@ -191,6 +198,39 @@
 				}
 			}
 		}
+
+		int chunkVersion = var1.getInteger("ChunkVersion");
+
+		if (chunkVersion < Chunk.CHUNK_VERSION_CURRENT) {
+			for (int x = 0; x < 16; x++)
+				for (int z = 0; z < 16; z++)
+					for (int y = 0; y < CHUNK_HEIGHT; y++) {
+						int blockId = var4.getBlockID(x, y, z);
+						int meta = var4.getBlockMetadata(x, y, z);
+						Block.onChunkUpdate(var4, chunkVersion, x, y, z, blockId, meta);
+					}
+
+			for (Object tileEntity : var4.chunkTileEntityMap.values()) {
+				if (!((TileEntity)tileEntity).hadChunkUpdate && tileEntity instanceof IInventory) {
+					((TileEntity)tileEntity).hadChunkUpdate = true;
+					((IInventory)tileEntity).onChunkUpdate(chunkVersion);
+				}
+			}
+
+			for (List entityList : var4.entities) {
+				for (Object entity : entityList) {
+					if (!((Entity)entity).hadChunkUpdate) {
+						((Entity)entity).hadChunkUpdate = true;
+						((Entity)entity).onChunkUpdate(chunkVersion);
+					}
+				}
+			}
+
+			if(chunkVersion < Chunk.CHUNK_VERSION_0_3) {
+				var0.upgradeChunkHeight(var4);
+			}
+		}
+		var1.setInteger("ChunkVersion", Chunk.CHUNK_VERSION_CURRENT);
 
 		return var4;
 	}
--- /dev/null
+++ net/minecraft/src/BlockSpeleothem.java
@@ -1,0 +1,103 @@
+package net.minecraft.src;
+
+public class BlockSpeleothem extends Block {
+	public final EnumBitField<SpeleothemShape> fieldShape = this.fields.addBitField("shape", SpeleothemShape.class, 2);
+	public final BitField fieldType = this.fields.addBitField("type", 6, BlockStone.stoneTypeNames);
+
+	public BlockSpeleothem(int var1, int var2) {
+		super(var1, var2, Material.rock);
+		this.minX = 0.25D;
+		this.minZ = 0.25D;
+		this.maxX = 0.75D;
+		this.maxZ = 0.75D;
+	}
+
+	private int getStoneMetadata(Chunk chunk, int var2, int var3, int var4) {
+		int id = chunk.getBlockID(var2, var3, var4);
+		Block block = Block.blocksList[id];
+		return block instanceof BlockStone
+				? chunk.getBlockMetadata(var2, var3, var4)
+				: id ==  Block.obsidian.blockID ? 4 : 0;
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if (!canPlaceBlockAt(var1, var2, var3, var4)) {
+			this.dropBlockAsItem(var1, var2, var3, var4, var5);
+			var1.setBlockWithNotify(var2, var3, var4, 0);
+		} else {
+			updateMetadata(var1.getChunkFromBlockCoords(var2, var4), var2 & 15, var3, var4 & 15);
+		}
+	}
+
+	public int getMetadataAt(World var1, int var2, int var3, int var4) {
+		return this.getMetadataAt(var1.getChunkFromBlockCoords(var2, var4), var2 & 15, var3, var4 & 15);
+	}
+
+	public int getMetadataAt(Chunk var1, int var2, int var3, int var4) {
+		int metadata = 0;
+		if (isChunkBlockNormalCube(var1, var2, var3 - 1, var4)) {
+			if (var1.getBlockID(var2, var3 + 1, var4) == this.blockID) {
+				metadata = this.fieldShape.set(metadata, SpeleothemShape.STALAGMITE_ANCHOR);
+			} else {
+				metadata = this.fieldShape.set(metadata, SpeleothemShape.STALAGMITE_TIP);
+			}
+			var3 -= 1;
+		} else if (isChunkBlockNormalCube(var1, var2, var3 + 1, var4)) {
+			if (var1.getBlockID(var2, var3 - 1, var4) == this.blockID) {
+				metadata = this.fieldShape.set(metadata, SpeleothemShape.STALACTITE_ANCHOR);
+			} else {
+				metadata = this.fieldShape.set(metadata, SpeleothemShape.STALACTITE_TIP);
+			}
+			var3 += 1;
+		} else if (isChunkBlockNormalCube(var1, var2, var3 + 2, var4)
+				&& var1.getBlockID(var2, var3 + 1, var4) == this.blockID) {
+			metadata = this.fieldShape.set(metadata, SpeleothemShape.STALACTITE_TIP);
+			var3 += 2;
+		} else {
+			metadata = this.fieldShape.set(metadata, SpeleothemShape.STALAGMITE_TIP);
+			var3 -= 2;
+		}
+		metadata = this.fieldType.set(metadata, this.getStoneMetadata(var1, var2, var3, var4));
+		return metadata;
+	}
+
+	private static boolean isChunkBlockNormalCube(Chunk chunk, int var2, int var3, int var4) {
+		Block var5 = Block.blocksList[chunk.getBlockID(var2, var3, var4)];
+		return var5 != null && var5.isOpaqueCube();
+	}
+
+	public void updateMetadata(Chunk var1, int var2, int var3, int var4) {
+		var1.setBlockMetadata(var2, var3, var4, this.getMetadataAt(var1, var2, var3, var4));
+	}
+
+	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
+		return var1.isBlockNormalCube(var2, var3 - 1, var4)
+				|| (var1.isBlockNormalCube(var2, var3 - 2, var4) && var1.getBlockId(var2, var3 - 1, var4) == this.blockID)
+				|| var1.isBlockNormalCube(var2, var3 + 1, var4)
+				|| (var1.isBlockNormalCube(var2, var3 + 2, var4) && var1.getBlockId(var2, var3 + 1, var4) == this.blockID);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return this.blockIndexInTexture + this.fieldShape.geti(var2) + this.fieldType.get(var2) * 32;
+	}
+
+	public void onBlockAdded(World var1, int var2, int var3, int var4) {
+		this.updateMetadata(var1.getChunkFromBlockCoords(var2, var4), var2 & 15, var3, var4 & 15);
+	}
+
+	public boolean isOpaqueCube() {
+		return false;
+	}
+
+	public boolean renderAsNormalBlock() {
+		return false;
+	}
+
+	public int getRenderType() {
+		return 1;
+	}
+
+	public float getBlockBrightness(IBlockAccess var1, int var2, int var3, int var4) {
+		return super.getBlockBrightness(var1, var2, var3, var4) * 0.8F;
+	}
+}
--- net/minecraft/src/EntitySkeleton.java
+++ net/minecraft/src/EntitySkeleton.java
@@ -1,9 +1,8 @@
 package net.minecraft.src;
 
-public class EntitySkeleton extends EntityMob {
+public class EntitySkeleton extends EntityLeveledMob {
 	public EntitySkeleton(World var1) {
-		super(var1);
-		this.texture = "/mob/skeleton.png";
+		super(var1, "/mob/skeleton");
 	}
 
 	protected String getLivingSound() {
@@ -18,6 +17,15 @@
 		return "mob.skeletonhurt";
 	}
 
+	protected float getSoundPitch() {
+		return 1.0F - this.getLevel() * 0.3F;
+	}
+
+	public void setLevel(int level) {
+		super.setLevel(level);
+		this.heartsHalvesLife = 20 + level * 5;
+	}
+
 	public void onLivingUpdate() {
 		if(this.worldObj.isDaytime()) {
 			float var1 = this.getBrightness(1.0F);
@@ -30,6 +38,10 @@
 	}
 
 	protected void attackEntity(Entity var1, float var2) {
+		if (this.getLevel() > 0) {
+			super.attackEntity(var1, var2);
+		}
+
 		if(var2 < 10.0F) {
 			double var3 = var1.posX - this.posX;
 			double var5 = var1.posZ - this.posZ;
@@ -47,7 +59,14 @@
 			this.rotationYaw = (float)(Math.atan2(var5, var3) * 180.0D / (double)((float)Math.PI)) - 90.0F;
 			this.hasAttacked = true;
 		}
-
+	}
+
+	public void onDeath(Entity var1) {
+		super.onDeath(var1);
+
+		if (this.rand.nextInt(250) == 0) {
+			this.dropItem(Item.skeletonSpirit.shiftedIndex, 1);
+		}
 	}
 
 	public void writeEntityToNBT(NBTTagCompound var1) {
--- /dev/null
+++ net/minecraft/src/Packet9Respawn.java
@@ -1,0 +1,21 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet9Respawn extends Packet {
+	public void processPacket(NetHandler var1) {
+		var1.handleRespawnPacket(this);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+	}
+
+	public int getPacketSize() {
+		return 0;
+	}
+}
--- net/minecraft/src/InventoryCrafting.java
+++ net/minecraft/src/InventoryCrafting.java
@@ -3,33 +3,27 @@
 public class InventoryCrafting implements IInventory {
 	private ItemStack[] stackList;
 	private int gridSize;
-	private CraftingInventoryCB craftingInventory;
+	private Container craftingInventory;
 
-	public InventoryCrafting(CraftingInventoryCB var1, int var2, int var3) {
+	public InventoryCrafting(Container var1, int var2, int var3) {
 		this.gridSize = var2 * var3;
 		this.stackList = new ItemStack[this.gridSize];
 		this.craftingInventory = var1;
 	}
 
-	public InventoryCrafting(CraftingInventoryCB var1, ItemStack[] var2) {
-		this.gridSize = var2.length;
-		this.stackList = var2;
-		this.craftingInventory = var1;
-	}
-
-	public int getSizeInventory() {
+	public int getInventorySize() {
 		return this.gridSize;
 	}
 
-	public ItemStack getStackInSlot(int var1) {
+	public ItemStack getStack(int var1) {
 		return this.stackList[var1];
 	}
 
-	public String getInvName() {
+	public String getInventoryName() {
 		return "Crafting";
 	}
 
-	public ItemStack decrStackSize(int var1, int var2) {
+	public ItemStack decrStack(int var1, int var2) {
 		if(this.stackList[var1] != null) {
 			ItemStack var3;
 			if(this.stackList[var1].stackSize <= var2) {
@@ -51,15 +45,19 @@
 		}
 	}
 
-	public void setInventorySlotContents(int var1, ItemStack var2) {
+	public void setInventorySlotItem(int var1, ItemStack var2) {
 		this.stackList[var1] = var2;
 		this.craftingInventory.onCraftMatrixChanged(this);
 	}
 
-	public int getInventoryStackLimit() {
+	public int getStackLimit() {
 		return 64;
 	}
 
-	public void onInventoryChanged() {
+	public void onInventoryChange() {
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return true;
 	}
 }
--- net/minecraft/src/WorldGenMinable.java
+++ net/minecraft/src/WorldGenMinable.java
@@ -3,22 +3,34 @@
 import java.util.Random;
 
 public class WorldGenMinable extends WorldGenerator {
-	private int minableBlockId;
-	private int numberOfBlocks;
+	private final int minableBlockId;
+	private final int numberOfBlocks;
+	private final int metadata;
+	private boolean mergeWithStone;
 
 	public WorldGenMinable(int var1, int var2) {
+		this(var1, var2, 0);
+	}
+
+	public WorldGenMinable(int var1, int var2, int var3) {
 		this.minableBlockId = var1;
 		this.numberOfBlocks = var2;
+		this.metadata = var3;
+	}
+
+	public WorldGenMinable mergeWithStone() {
+		this.mergeWithStone = true;
+		return this;
 	}
 
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
 		float var6 = var2.nextFloat() * (float)Math.PI;
-		double var7 = (double)((float)(var3 + 8) + MathHelper.sin(var6) * (float)this.numberOfBlocks / 8.0F);
-		double var9 = (double)((float)(var3 + 8) - MathHelper.sin(var6) * (float)this.numberOfBlocks / 8.0F);
-		double var11 = (double)((float)(var5 + 8) + MathHelper.cos(var6) * (float)this.numberOfBlocks / 8.0F);
-		double var13 = (double)((float)(var5 + 8) - MathHelper.cos(var6) * (float)this.numberOfBlocks / 8.0F);
-		double var15 = (double)(var4 + var2.nextInt(3) + 2);
-		double var17 = (double)(var4 + var2.nextInt(3) + 2);
+		double var7 = ((float)(var3 + 8) + MathHelper.sin(var6) * (float)this.numberOfBlocks / 8.0F);
+		double var9 = ((float)(var3 + 8) - MathHelper.sin(var6) * (float)this.numberOfBlocks / 8.0F);
+		double var11 = ((float)(var5 + 8) + MathHelper.cos(var6) * (float)this.numberOfBlocks / 8.0F);
+		double var13 = ((float)(var5 + 8) - MathHelper.cos(var6) * (float)this.numberOfBlocks / 8.0F);
+		double var15 = (var4 + var2.nextInt(3) + 2);
+		double var17 = (var4 + var2.nextInt(3) + 2);
 
 		for(int var19 = 0; var19 <= this.numberOfBlocks; ++var19) {
 			double var20 = var7 + (var9 - var7) * (double)var19 / (double)this.numberOfBlocks;
@@ -35,7 +47,9 @@
 						double var37 = ((double)var33 + 0.5D - var22) / (var30 / 2.0D);
 						double var39 = ((double)var34 + 0.5D - var24) / (var28 / 2.0D);
 						if(var35 * var35 + var37 * var37 + var39 * var39 < 1.0D && var1.getBlockId(var32, var33, var34) == Block.stone.blockID) {
+							int metadata = this.mergeWithStone ? var1.getBlockMetadata(var32, var33, var34) : this.metadata;
 							var1.setBlock(var32, var33, var34, this.minableBlockId);
+							var1.setBlockMetadata(var32, var33, var34, metadata);
 						}
 					}
 				}
--- net/minecraft/client/MinecraftApplet.java
+++ net/minecraft/client/MinecraftApplet.java
@@ -3,9 +3,10 @@
 import java.applet.Applet;
 import java.awt.BorderLayout;
 import java.awt.Canvas;
-import net.minecraft.src.CanvasMinecraftApplet;
+
 import net.minecraft.src.MinecraftAppletImpl;
 import net.minecraft.src.Session;
+import net.minecraft.src.CanvasMinecraftApplet;
 
 public class MinecraftApplet extends Applet {
 	private Canvas mcCanvas;
@@ -80,11 +81,11 @@
 
 			try {
 				this.mcThread.join(10000L);
-			} catch (InterruptedException var4) {
+			} catch (InterruptedException interruptedException4) {
 				try {
 					this.mc.shutdownMinecraftApplet();
-				} catch (Exception var3) {
-					var3.printStackTrace();
+				} catch (Exception exception3) {
+					exception3.printStackTrace();
 				}
 			}
 
@@ -100,7 +101,7 @@
 		try {
 			this.removeAll();
 			this.validate();
-		} catch (Exception var2) {
+		} catch (Exception exception2) {
 		}
 
 	}
--- /dev/null
+++ net/minecraft/src/NamedBitFlag.java
@@ -1,0 +1,15 @@
+package net.minecraft.src;
+
+public class NamedBitFlag extends BitFlag {
+	public final String nameFalse, nameTrue;
+
+	public NamedBitFlag(String name, int offset, String nameFalse, String nameTrue) {
+		super(name, offset);
+		this.nameFalse = nameFalse;
+		this.nameTrue = nameTrue;
+	}
+
+	public String getString(int number) {
+		return this.get(number) ? this.nameTrue : this.nameFalse;
+	}
+}
--- net/minecraft/src/ItemRedstone.java
+++ net/minecraft/src/ItemRedstone.java
@@ -5,7 +5,7 @@
 		super(var1);
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var7 == 0) {
 			--var5;
 		}
--- /dev/null
+++ net/minecraft/src/BlockUmbrashardCrystal.java
@@ -1,0 +1,29 @@
+package net.minecraft.src;
+
+import java.util.Random;
+
+public class BlockUmbrashardCrystal extends BlockBreakable {
+	public BlockUmbrashardCrystal(int var1, int var2) {
+		super(var1, var2, Material.iron, false);
+	}
+
+	public int getRenderBlockPass() {
+		return 1;
+	}
+
+	public int quantityDropped(Random var1) {
+		return var1.nextInt(3) == 0 ? 1 : 0;
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.umbrashard.shiftedIndex;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return 1;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
+	}
+}
--- net/minecraft/src/ItemStack.java
+++ net/minecraft/src/ItemStack.java
@@ -1,21 +1,33 @@
 package net.minecraft.src;
 
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.stream.Collectors;
+
 public final class ItemStack {
 	public int stackSize;
 	public int animationsToGo;
 	public int itemID;
 	public int itemDmg;
+	public int itemMetadata;
+	public NBTTagCompound storage = null;
 
 	public ItemStack(Block var1) {
-		this((Block)var1, 1);
+		this(var1, 1);
 	}
 
 	public ItemStack(Block var1, int var2) {
+		this(var1, var2, 0);
+	}
+
+	public ItemStack(Block var1, int var2, int metadata) {
 		this(var1.blockID, var2);
+		this.itemMetadata = metadata;
 	}
 
 	public ItemStack(Item var1) {
-		this((Item)var1, 1);
+		this(var1, 1);
 	}
 
 	public ItemStack(Item var1, int var2) {
@@ -27,42 +39,100 @@
 	}
 
 	public ItemStack(int var1, int var2) {
-		this.stackSize = 0;
 		this.itemID = var1;
 		this.stackSize = var2;
+		if (Item.itemsList[var1] != null) {
+			this.itemDmg = Item.itemsList[var1].startingDamage;
+		}
 	}
 
 	public ItemStack(int var1, int var2, int var3) {
-		this.stackSize = 0;
 		this.itemID = var1;
 		this.stackSize = var2;
 		this.itemDmg = var3;
+
+		if (this.itemDmg < 0 && Item.itemsList[var1] != null) {
+			this.itemDmg = Item.itemsList[var1].startingDamage;
+		}
+	}
+
+	public ItemStack(int var1, int var2, int var3, int var4) {
+		this(var1, var2, var3);
+		this.itemMetadata = var4;
 	}
 
 	public ItemStack(NBTTagCompound var1) {
-		this.stackSize = 0;
 		this.readFromNBT(var1);
 	}
 
+	public int getMissingItemID() {
+		return this.storage != null ? this.storage.getShort("MissingItem") & 0xFFFF : 0;
+	}
+
+	public void checkMissing() {
+		if (this.itemID != 0 && (this.itemID < 0 || this.itemID > 65535 || Item.itemsList[this.itemID] == null)) {
+			if (this.storage == null) {
+				this.storage = new NBTTagCompound();
+			}
+			this.storage.setShort("MissingItem", (short)this.itemID);
+			this.itemID = 65535;
+		} else if (this.itemID == 65535 && Item.itemsList[this.getMissingItemID()] != null) {
+			this.itemID = this.getMissingItemID();
+			this.storage.setTag("MissingItem", null);
+			if (this.storage.isEmpty()) {
+				this.storage = null;
+			}
+		}
+	}
+
+	public ItemStack withMetadata(int metadata) {
+		this.itemMetadata = metadata;
+		return this;
+	}
+
+	public ItemStack withStorage(NBTTagCompound storage) {
+		int missingID = this.getMissingItemID();
+		this.storage = storage;
+		if (missingID > 0) {
+			this.storage.setShort("MissingItem", (short)missingID);
+		}
+		return this;
+	}
+
 	public ItemStack splitStack(int var1) {
 		this.stackSize -= var1;
-		return new ItemStack(this.itemID, var1, this.itemDmg);
+		ItemStack itemStack = new ItemStack(this.itemID, var1, this.itemDmg, this.itemMetadata);
+		if (this.storage != null) {
+			itemStack.storage = this.storage.copy();
+		}
+		return itemStack;
 	}
 
 	public Item getItem() {
-		return Item.itemsList[this.itemID];
+		if (this.itemID == 0) return null;
+
+		Item item;
+		if (this.itemID > 65535 || (item = Item.itemsList[this.itemID]) == null) {
+			this.checkMissing();
+			return Item.missingItem;
+		}
+		return item;
 	}
 
 	public int getIconIndex() {
 		return this.getItem().getIconIndex(this);
 	}
 
-	public boolean useItem(EntityPlayer var1, World var2, int var3, int var4, int var5, int var6) {
-		return this.getItem().onItemUse(this, var1, var2, var3, var4, var5, var6);
+	public boolean useItem(EntityPlayer var1, World var2, int var3, int var4, int var5, int var6, float var7, float var8, float var9) {
+		return this.getItem().onItemUse(this, var1, var2, var3, var4, var5, var6, var7, var8, var9);
 	}
 
 	public float getStrVsBlock(Block var1) {
-		return this.getItem().getStrVsBlock(this, var1);
+		float strength = Item.itemsList[this.itemID].getStrVsBlock(this, var1);
+		if (this.getTrinket() != null) {
+			strength = this.getTrinket().modifyToolStrength(strength);
+		}
+		return strength;
 	}
 
 	public ItemStack useItemRightClick(World var1, EntityPlayer var2) {
@@ -73,13 +143,22 @@
 		var1.setShort("id", (short)this.itemID);
 		var1.setByte("Count", (byte)this.stackSize);
 		var1.setShort("Damage", (short)this.itemDmg);
+		var1.setShort("Metadata", (short)this.itemMetadata);
+		if (this.storage != null) {
+			var1.setCompoundTag("Storage", this.storage);
+		}
 		return var1;
 	}
 
 	public void readFromNBT(NBTTagCompound var1) {
-		this.itemID = var1.getShort("id");
+		this.itemID = var1.getShort("id") & 0xFFFF;
 		this.stackSize = var1.getByte("Count");
 		this.itemDmg = var1.getShort("Damage");
+		this.itemMetadata = var1.getShort("Metadata") & 0xFF;
+		this.storage = var1.getCompoundTag("Storage");
+		if (this.storage.isEmpty()) {
+			this.storage = null;
+		}
 	}
 
 	public int getMaxStackSize() {
@@ -92,7 +171,7 @@
 
 	public void damageItem(int var1) {
 		this.itemDmg += var1;
-		if(this.itemDmg > this.getMaxDamage()) {
+		if(this.itemDmg >= this.getMaxDamage()) {
 			--this.stackSize;
 			if(this.stackSize < 0) {
 				this.stackSize = 0;
@@ -112,7 +191,11 @@
 	}
 
 	public int getDamageVsEntity(Entity var1) {
-		return Item.itemsList[this.itemID].getDamageVsEntity(var1);
+		int damage = Item.itemsList[this.itemID].getDamageVsEntity(var1);
+		if (this.getTrinket() != null) {
+			damage = this.getTrinket().modifyAttackDamage(damage);
+		}
+		return damage;
 	}
 
 	public boolean canHarvestBlock(Block var1) {
@@ -127,6 +210,89 @@
 	}
 
 	public ItemStack copy() {
-		return new ItemStack(this.itemID, this.stackSize, this.itemDmg);
+		ItemStack itemStack = new ItemStack(this.itemID, this.stackSize, this.itemDmg, this.itemMetadata);
+		if (this.storage != null) {
+			itemStack.storage = this.storage.copy();
+		}
+		return itemStack;
+	}
+
+	public ItemTooltip getTooltip() {
+		return Item.itemsList[this.itemID].getTooltip(this);
+	}
+
+	public void onChunkUpdate(int version) {
+		if (version < Chunk.CHUNK_VERSION_0_2) {
+			if (this.itemID < 256) {
+				if (this.itemID == Block.stairDouble.blockID && this.itemMetadata == 9) {
+					this.itemID = Block.brickStairDouble.blockID;
+					this.itemMetadata = 0;
+				}
+
+				if (this.itemID == Block.stairSingle.blockID && this.itemMetadata == 9) {
+					this.itemID = Block.brickStairSingle.blockID;
+					this.itemMetadata = 0;
+				}
+
+				Block block = Block.blocksList[this.itemID];
+				if (block != null) {
+					if (block instanceof BlockOre && this.itemMetadata == 1) {
+						this.itemMetadata = 2;
+					}
+				}
+			}
+		}
+
+		if (version < Chunk.CHUNK_VERSION_0_3) {
+			if (this.itemID >= 256) {
+				this.itemID += 9744;
+			}
+
+			if (this.itemID == 24) {
+				this.itemID = Block.stairDouble.blockID;
+				this.itemMetadata = 16;
+			}
+
+			if (this.itemID == 25) {
+				this.itemID = Block.stairSingle.blockID;
+				this.itemMetadata = 16;
+			}
+		}
+	}
+
+	public boolean isSilk() {
+		return Item.itemsList[this.itemID] != null && Item.itemsList[this.itemID].isSilk();
+	}
+
+	public static boolean areItemStacksEqual(ItemStack var0, ItemStack var1) {
+		return var0 == null && var1 == null
+				|| var0 != null && var1 != null
+						&& var0.storage == null && var1.storage == null
+						&& var0.stackEqual(var1);
+	}
+
+	private boolean stackEqual(ItemStack var1) {
+		return this.stackSize == var1.stackSize
+				&& this.itemID == var1.itemID
+				&& this.itemDmg == var1.itemDmg
+				&& this.itemMetadata == var1.itemMetadata;
+	}
+
+	public static ItemStack safeCopy(ItemStack var0) {
+		return var0 == null ? null : var0.copy();
+	}
+
+	public ItemTrinket getTrinket() {
+		if (this.storage == null) return null;
+		int id = this.storage.getInteger("Trinket");
+		Item item = Item.itemsList[id];
+
+		if (item instanceof ItemTrinket) return (ItemTrinket)item;
+		return null;
+	}
+
+	public void applyTrinket(ItemTrinket var1) {
+		if (this.storage == null) this.storage = new NBTTagCompound();
+		this.storage.setInteger("Trinket", var1.shiftedIndex);
 	}
 }
--- net/minecraft/src/EntityChicken.java
+++ net/minecraft/src/EntityChicken.java
@@ -40,7 +40,7 @@
 		}
 
 		this.wingRotation += this.moveWings * 2.0F;
-		if(!this.worldObj.multiplayerWorld && --this.timeUntilNextEgg <= 0) {
+		if(this.worldObj.canDoClientAction() && --this.timeUntilNextEgg <= 0) {
 			this.worldObj.playSoundAtEntity(this, "mob.chickenplop", 1.0F, (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
 			this.dropItem(Item.egg.shiftedIndex, 1);
 			this.timeUntilNextEgg = this.rand.nextInt(6000) + 6000;
@@ -71,7 +71,7 @@
 		return "mob.chickenhurt";
 	}
 
-	protected int getDropItemId() {
-		return Item.feather.shiftedIndex;
+	protected int[] getDropItems() {
+		return new int[] { Item.feather.shiftedIndex, Item.chickenRaw.shiftedIndex };
 	}
 }
--- net/minecraft/src/Entity.java
+++ net/minecraft/src/Entity.java
@@ -1,16 +1,18 @@
 package net.minecraft.src;
 
+import net.minecraft.server.MinecraftServer;
 import java.util.List;
 import java.util.Random;
 
 public abstract class Entity {
 	private static int nextEntityID = 0;
+	public boolean hadChunkUpdate = false;
 	public int entityID = nextEntityID++;
 	public double renderDistanceWeight = 1.0D;
 	public boolean preventEntitySpawning = false;
 	public Entity riddenByEntity;
 	public Entity ridingEntity;
-	protected World worldObj;
+	public World worldObj;
 	public double prevPosX;
 	public double prevPosY;
 	public double prevPosZ;
@@ -29,6 +31,7 @@
 	public boolean isCollidedHorizontally;
 	public boolean isCollidedVertically;
 	public boolean isCollided = false;
+	public boolean updateVelocity = false;
 	public boolean surfaceCollision = true;
 	public boolean isDead = false;
 	public float yOffset = 0.0F;
@@ -45,6 +48,7 @@
 	public float ySize = 0.0F;
 	public float stepHeight = 0.0F;
 	public boolean noClip = false;
+	public boolean flying;
 	public float entityCollisionReduction = 0.0F;
 	public boolean unusedBool = false;
 	protected Random rand = new Random();
@@ -66,10 +70,17 @@
 	public int serverPosX;
 	public int serverPosY;
 	public int serverPosZ;
+	private List<Effect> effects;
+	protected DataWatcher dataWatcher = new DataWatcher();
 
 	public Entity(World var1) {
 		this.worldObj = var1;
 		this.setPosition(0.0D, 0.0D, 0.0D);
+		this.dataWatcher.addObject(0, (byte)0);
+	}
+
+	public DataWatcher getDataWatcher() {
+		return this.dataWatcher;
 	}
 
 	public boolean equals(Object var1) {
@@ -141,6 +152,7 @@
 	}
 
 	public void onEntityUpdate() {
+		Profiler.startSection("entityBaseTick");
 		if(this.ridingEntity != null && this.ridingEntity.isDead) {
 			this.ridingEntity = null;
 		}
@@ -203,6 +215,7 @@
 		}
 
 		this.firstUpdate = false;
+		Profiler.endSection();
 	}
 
 	protected void kill() {
@@ -216,12 +229,17 @@
 	}
 
 	public void moveEntity(double var1, double var3, double var5) {
+		if (!this.worldObj.canDoClientAction() && !this.moveInMultiplayer()) {
+			return;
+		}
+
 		if(this.noClip) {
 			this.boundingBox.offset(var1, var3, var5);
 			this.posX = (this.boundingBox.minX + this.boundingBox.maxX) / 2.0D;
 			this.posY = this.boundingBox.minY + (double)this.yOffset - (double)this.ySize;
 			this.posZ = (this.boundingBox.minZ + this.boundingBox.maxZ) / 2.0D;
 		} else {
+			Profiler.startSection("move");
 			double var7 = this.posX;
 			double var9 = this.posZ;
 			double var11 = var1;
@@ -347,6 +365,8 @@
 				}
 			}
 
+			Profiler.endStartSection("rest");
+			
 			this.posX = (this.boundingBox.minX + this.boundingBox.maxX) / 2.0D;
 			this.posY = this.boundingBox.minY + (double)this.yOffset - (double)this.ySize;
 			this.posZ = (this.boundingBox.minZ + this.boundingBox.maxZ) / 2.0D;
@@ -354,14 +374,7 @@
 			this.isCollidedVertically = var13 != var3;
 			this.onGround = var13 != var3 && var13 < 0.0D;
 			this.isCollided = this.isCollidedHorizontally || this.isCollidedVertically;
-			if(this.onGround) {
-				if(this.fallDistance > 0.0F) {
-					this.fall(this.fallDistance);
-					this.fallDistance = 0.0F;
-				}
-			} else if(var3 < 0.0D) {
-				this.fallDistance = (float)((double)this.fallDistance - var3);
-			}
+			this.updateFallState(var3, this.onGround);
 
 			if(var11 != var1) {
 				this.motionX = 0.0D;
@@ -378,22 +391,24 @@
 			var37 = this.posX - var7;
 			var23 = this.posZ - var9;
 			this.distanceWalkedModified = (float)((double)this.distanceWalkedModified + (double)MathHelper.sqrt_double(var37 * var37 + var23 * var23) * 0.6D);
-			int var26;
-			int var38;
-			int var40;
+			int var26 = MathHelper.floor_double(this.posY - (double)0.2F - (double)this.yOffset);
+			int var38 = MathHelper.floor_double(this.posX);
+			int var40 = MathHelper.floor_double(this.posZ);
+			var28 = this.worldObj.getBlockId(var38, var26, var40);
+
+			if (var28 == 0) {
+				this.nextStepDistance = (int)this.distanceWalkedModified;
+			}
+
 			if(this.canTriggerWalking && !var18) {
-				var38 = MathHelper.floor_double(this.posX);
-				var26 = MathHelper.floor_double(this.posY - (double)0.2F - (double)this.yOffset);
-				var40 = MathHelper.floor_double(this.posZ);
-				var28 = this.worldObj.getBlockId(var38, var26, var40);
 				if(this.distanceWalkedModified > (float)this.nextStepDistance && var28 > 0) {
 					++this.nextStepDistance;
-					StepSound var29 = Block.blocksList[var28].stepSound;
+					StepSound stepSound29 = Block.blocksList[var28].stepSound;
 					if(this.worldObj.getBlockId(var38, var26 + 1, var40) == Block.snow.blockID) {
-						var29 = Block.snow.stepSound;
-						this.worldObj.playSoundAtEntity(this, var29.getStepSound(), var29.getVolume() * 0.15F, var29.getPitch());
+						stepSound29 = Block.snow.stepSound;
+						this.worldObj.playSoundAtEntity(this, stepSound29.getStepSound(), stepSound29.getVolume() * 0.15F, stepSound29.getPitch());
 					} else if(!Block.blocksList[var28].material.getIsLiquid()) {
-						this.worldObj.playSoundAtEntity(this, var29.getStepSound(), var29.getVolume() * 0.15F, var29.getPitch());
+						this.worldObj.playSoundAtEntity(this, stepSound29.getStepSound(), stepSound29.getVolume() * 0.15F, stepSound29.getPitch());
 					}
 
 					Block.blocksList[var28].onEntityWalking(this.worldObj, var38, var26, var40, this);
@@ -437,11 +452,45 @@
 				this.fire = -this.fireResistance;
 			}
 
+			Profiler.endSection();
+		}
+	}
+
+	protected void updateFallState(double moveY, boolean onGround) {
+		if(onGround) {
+			if(this.fallDistance > 0.0F) {
+				this.fall(this.fallDistance);
+				this.fallDistance = 0.0F;
+			}
+		} else if(moveY < 0.0D) {
+			this.fallDistance = (float)((double)this.fallDistance - moveY);
 		}
 	}
 
 	public boolean isSneaking() {
+		return this.getEntityFlag(1);
+	}
+
+	public boolean isRunning() {
 		return false;
+	}
+
+	public void setSneaking(boolean var1) {
+        this.setEntityFlag(1, var1);
+    }
+
+	protected boolean getEntityFlag(int var1) {
+		return (this.dataWatcher.getWatchableObjectByte(0) & 1 << var1) != 0;
+	}
+
+	protected void setEntityFlag(int var1, boolean var2) {
+		byte var3 = this.dataWatcher.getWatchableObjectByte(0);
+		if(var2) {
+			this.dataWatcher.updateObject(0, (byte)(var3 | 1 << var1));
+		} else {
+			this.dataWatcher.updateObject(0, (byte)(var3 & ~(1 << var1)));
+		}
+
 	}
 
 	public AxisAlignedBB getBoundingBox() {
@@ -504,7 +553,11 @@
 		double var3 = (this.boundingBox.maxY - this.boundingBox.minY) * 0.66D;
 		int var5 = MathHelper.floor_double(this.posY - (double)this.yOffset + var3);
 		int var6 = MathHelper.floor_double(this.posZ);
-		return this.worldObj.getBrightness(var2, var5, var6);
+		float var7 = this.worldObj.getBrightness(var2, var5, var6);
+		if (MinecraftServer.getInstance() == null) {
+			var7 = var7 * (1 - RenderGlobal.globalBrightness) + RenderGlobal.globalBrightness;
+		}
+		return var7;
 	}
 
 	public void setWorld(World var1) {
@@ -531,9 +584,9 @@
 	}
 
 	public void setLocationAndAngles(double var1, double var3, double var5, float var7, float var8) {
-		this.prevPosX = this.posX = var1;
-		this.prevPosY = this.posY = var3 + (double)this.yOffset;
-		this.prevPosZ = this.posZ = var5;
+		this.lastTickPosX = this.prevPosX = this.posX = var1;
+		this.lastTickPosY = this.prevPosY = this.posY = var3 + (double)this.yOffset;
+		this.lastTickPosZ = this.prevPosZ = this.posZ = var5;
 		this.rotationYaw = var7;
 		this.rotationPitch = var8;
 		this.setPosition(this.posX, this.posY, this.posZ);
@@ -604,6 +657,7 @@
 	}
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
+		this.setUpdateVelocity();
 		return false;
 	}
 
@@ -628,7 +682,7 @@
 
 	public boolean isInRangeToRenderDist(double var1) {
 		double var3 = this.boundingBox.getAverageEdgeLength();
-		var3 *= 64.0D * this.renderDistanceWeight;
+		var3 *= 256.0D * this.renderDistanceWeight;
 		return var1 < var3 * var3;
 	}
 
@@ -736,7 +790,7 @@
 		int var1 = MathHelper.floor_double(this.posX);
 		int var2 = MathHelper.floor_double(this.posY + (double)this.getEyeHeight());
 		int var3 = MathHelper.floor_double(this.posZ);
-		return this.worldObj.isBlockNormalCube(var1, var2, var3);
+		return this.worldObj.isBlockNormalCube(var1, var2, var3) && !this.noClip;
 	}
 
 	public boolean interact(EntityPlayer var1) {
@@ -755,51 +809,53 @@
 			this.motionY = 0.0D;
 			this.motionZ = 0.0D;
 			this.onUpdate();
-			this.ridingEntity.updateRiderPosition();
-			this.entityRiderYawDelta += (double)(this.ridingEntity.rotationYaw - this.ridingEntity.prevRotationYaw);
-
-			for(this.entityRiderPitchDelta += (double)(this.ridingEntity.rotationPitch - this.ridingEntity.prevRotationPitch); this.entityRiderYawDelta >= 180.0D; this.entityRiderYawDelta -= 360.0D) {
-			}
-
-			while(this.entityRiderYawDelta < -180.0D) {
-				this.entityRiderYawDelta += 360.0D;
-			}
-
-			while(this.entityRiderPitchDelta >= 180.0D) {
-				this.entityRiderPitchDelta -= 360.0D;
-			}
-
-			while(this.entityRiderPitchDelta < -180.0D) {
-				this.entityRiderPitchDelta += 360.0D;
-			}
-
-			double var1 = this.entityRiderYawDelta * 0.5D;
-			double var3 = this.entityRiderPitchDelta * 0.5D;
-			float var5 = 10.0F;
-			if(var1 > (double)var5) {
-				var1 = (double)var5;
-			}
-
-			if(var1 < (double)(-var5)) {
-				var1 = (double)(-var5);
-			}
-
-			if(var3 > (double)var5) {
-				var3 = (double)var5;
-			}
-
-			if(var3 < (double)(-var5)) {
-				var3 = (double)(-var5);
-			}
-
-			this.entityRiderYawDelta -= var1;
-			this.entityRiderPitchDelta -= var3;
-			this.rotationYaw = (float)((double)this.rotationYaw + var1);
-			this.rotationPitch = (float)((double)this.rotationPitch + var3);
+			if (this.ridingEntity != null) {
+				this.ridingEntity.updateRiderPosition();
+				this.entityRiderYawDelta += (double)(this.ridingEntity.rotationYaw - this.ridingEntity.prevRotationYaw);
+
+				for(this.entityRiderPitchDelta += (double)(this.ridingEntity.rotationPitch - this.ridingEntity.prevRotationPitch); this.entityRiderYawDelta >= 180.0D; this.entityRiderYawDelta -= 360.0D) {
+				}
+
+				while(this.entityRiderYawDelta < -180.0D) {
+					this.entityRiderYawDelta += 360.0D;
+				}
+
+				while(this.entityRiderPitchDelta >= 180.0D) {
+					this.entityRiderPitchDelta -= 360.0D;
+				}
+
+				while(this.entityRiderPitchDelta < -180.0D) {
+					this.entityRiderPitchDelta += 360.0D;
+				}
+
+				double var1 = this.entityRiderYawDelta * 0.5D;
+				double var3 = this.entityRiderPitchDelta * 0.5D;
+				float var5 = 10.0F;
+				if(var1 > (double)var5) {
+					var1 = (double)var5;
+				}
+
+				if(var1 < (double)(-var5)) {
+					var1 = (double)(-var5);
+				}
+
+				if(var3 > (double)var5) {
+					var3 = (double)var5;
+				}
+
+				if(var3 < (double)(-var5)) {
+					var3 = (double)(-var5);
+				}
+
+				this.entityRiderYawDelta -= var1;
+				this.entityRiderPitchDelta -= var3;
+				this.rotationYaw = (float)((double)this.rotationYaw + var1);
+				this.rotationPitch = (float)((double)this.rotationPitch + var3);
+			}
 		}
 	}
 
-	protected void updateRiderPosition() {
+	public void updateRiderPosition() {
 		this.riddenByEntity.setPosition(this.posX, this.posY + this.getMountedYOffset() + this.riddenByEntity.getYOffset(), this.posZ);
 	}
 
@@ -814,7 +870,14 @@
 	public void mountEntity(Entity var1) {
 		this.entityRiderPitchDelta = 0.0D;
 		this.entityRiderYawDelta = 0.0D;
-		if(this.ridingEntity == var1) {
+		if(var1 == null) {
+			if(this.ridingEntity != null) {
+				this.setLocationAndAngles(this.ridingEntity.posX, this.ridingEntity.boundingBox.minY + (double)this.ridingEntity.height, this.ridingEntity.posZ, this.rotationYaw, this.rotationPitch);
+				this.ridingEntity.riddenByEntity = null;
+			}
+
+			this.ridingEntity = null;
+		} else if(this.ridingEntity == var1) {
 			this.ridingEntity.riddenByEntity = null;
 			this.ridingEntity = null;
 			this.setLocationAndAngles(var1.posX, var1.boundingBox.minY + (double)var1.height, var1.posZ, this.rotationYaw, this.rotationPitch);
@@ -835,5 +898,53 @@
 	public void setPositionAndRotation(double var1, double var3, double var5, float var7, float var8, int var9) {
 		this.setPosition(var1, var3, var5);
 		this.setRotation(var7, var8);
+		List var10 = this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox.getOffsetBoundingBox(1.0D / 32.0D, 0.0D, 1.0D / 32.0D));
+		if(var10.size() > 0) {
+			double var11 = 0.0D;
+
+			for(int var13 = 0; var13 < var10.size(); ++var13) {
+				AxisAlignedBB var14 = (AxisAlignedBB)var10.get(var13);
+				if(var14.maxY > var11) {
+					var11 = var14.maxY;
+				}
+			}
+
+			var3 += var11 - this.boundingBox.minY;
+			this.setPosition(var1, var3, var5);
+		}
+	}
+
+	public void playSound(String sound, float volume, float pitch) {
+		this.worldObj.playSoundAtEntity(this, sound, volume, pitch);
+	}
+
+	public void handleHealthUpdate(byte entityStatus) {
+	}
+
+	public void onChunkUpdate(int chunkVersion) {
+	}
+
+	public void outfitWithItem(int var1, int var2, int var3, int var4) {
+	}
+
+	public void setVelocity(double var1, double var3, double var5) {
+		this.motionX = var1;
+		this.motionY = var3;
+		this.motionZ = var5;
+	}
+
+	public void setUpdateVelocity() {
+		this.updateVelocity = true;
+	}
+
+	public void performHurtAnimation() {
+	}
+
+	public ItemStack[] getInventory() {
+		return null;
+	}
+
+	public boolean moveInMultiplayer() {
+		return true;
 	}
 }
--- net/minecraft/src/IInventory.java
+++ net/minecraft/src/IInventory.java
@@ -1,17 +1,29 @@
 package net.minecraft.src;
 
 public interface IInventory {
-	int getSizeInventory();
-
-	ItemStack getStackInSlot(int var1);
-
-	ItemStack decrStackSize(int var1, int var2);
-
-	void setInventorySlotContents(int var1, ItemStack var2);
-
-	String getInvName();
-
-	int getInventoryStackLimit();
-
-	void onInventoryChanged();
+	int getInventorySize();
+
+	ItemStack getStack(int var1);
+
+	ItemStack decrStack(int var1, int var2);
+
+	void setInventorySlotItem(int var1, ItemStack var2);
+
+	String getInventoryName();
+
+	int getStackLimit();
+
+	void onInventoryChange();
+
+	boolean isNearPlayer(EntityPlayer var1);
+
+	default void onChunkUpdate(int version) {
+		for (int i = 0; i < getInventorySize(); i++) {
+			ItemStack item = this.getStack(i);
+			if (item != null) {
+				item.onChunkUpdate(version);
+				item.checkMissing();
+			}
+		}
+	}
 }
--- net/minecraft/src/BlockSponge.java
+++ net/minecraft/src/BlockSponge.java
@@ -1,9 +1,9 @@
 package net.minecraft.src;
 
 public class BlockSponge extends Block {
-	protected BlockSponge(int var1) {
+	public BlockSponge(int var1) {
 		super(var1, Material.sponge);
-		this.blockIndexInTexture = 48;
+		this.blockIndexInTexture = textureXY(2, 1);
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
@@ -13,6 +13,7 @@
 			for(int var7 = var3 - var5; var7 <= var3 + var5; ++var7) {
 				for(int var8 = var4 - var5; var8 <= var4 + var5; ++var8) {
 					if(var1.getBlockMaterial(var6, var7, var8) == Material.water) {
+						var1.setBlock(var6, var7, var8, 0);
 					}
 				}
 			}
--- net/minecraft/src/NBTTagByteArray.java
+++ net/minecraft/src/NBTTagByteArray.java
@@ -3,6 +3,7 @@
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.util.Arrays;
 
 public class NBTTagByteArray extends NBTBase {
 	public byte[] byteArray;
@@ -14,12 +15,12 @@
 		this.byteArray = var1;
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeInt(this.byteArray.length);
 		var1.write(this.byteArray);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		int var2 = var1.readInt();
 		this.byteArray = new byte[var2];
 		var1.readFully(this.byteArray);
@@ -31,5 +32,9 @@
 
 	public String toString() {
 		return "[" + this.byteArray.length + " bytes]";
+	}
+
+	public NBTBase copy() {
+		return new NBTTagByteArray(Arrays.copyOf(this.byteArray, this.byteArray.length)).setKey(this.getKey());
 	}
 }
--- net/minecraft/src/NetClientHandler.java
+++ net/minecraft/src/NetClientHandler.java
@@ -6,9 +6,10 @@
 import java.net.InetAddress;
 import java.net.Socket;
 import java.net.URL;
+import java.util.List;
 import java.util.Random;
+
 import net.minecraft.client.Minecraft;
-
 public class NetClientHandler extends NetHandler {
 	private boolean disconnected = false;
 	private NetworkManager netManager;
@@ -32,17 +33,18 @@
 
 	public void handleLogin(Packet1Login var1) {
 		this.mc.playerController = new PlayerControllerMP(this.mc, this);
-		this.worldClient = new WorldClient(this);
+		this.worldClient = new WorldClient(this, this.mc.achievements);
 		this.worldClient.multiplayerWorld = true;
 		this.mc.changeWorld1(this.worldClient);
 		this.mc.displayGuiScreen(new GuiDownloadTerrain(this));
+		this.mc.thePlayer.entityID = var1.protocolVersion;
 	}
 
 	public void handlePickupSpawn(Packet21PickupSpawn var1) {
 		double var2 = (double)var1.xPosition / 32.0D;
 		double var4 = (double)var1.yPosition / 32.0D;
 		double var6 = (double)var1.zPosition / 32.0D;
-		EntityItem var8 = new EntityItem(this.worldClient, var2, var4, var6, new ItemStack(var1.itemID, var1.count));
+		EntityItem var8 = new EntityItem(this.worldClient, var2, var4, var6, new ItemStack(var1.itemID, var1.count, var1.itemDamage, var1.itemMetadata).withStorage(var1.storage));
 		var8.motionX = (double)var1.rotation / 128.0D;
 		var8.motionY = (double)var1.pitch / 128.0D;
 		var8.motionZ = (double)var1.roll / 128.0D;
@@ -56,7 +58,7 @@
 		double var2 = (double)var1.xPosition / 32.0D;
 		double var4 = (double)var1.yPosition / 32.0D;
 		double var6 = (double)var1.zPosition / 32.0D;
-		Object var8 = null;
+		Entity var8 = null;
 		if(var1.type == 10) {
 			var8 = new EntityMinecart(this.worldClient, var2, var4, var6, 0);
 		}
@@ -73,14 +75,30 @@
 			var8 = new EntityBoat(this.worldClient, var2, var4, var6);
 		}
 
+		if(var1.type == 60) {
+			var8 = new EntityArrow(this.worldClient, var2, var4, var6);
+		}
+
+		if(var1.type == 61) {
+			var8 = new EntitySnowball(this.worldClient, var2, var4, var6, EntitySnowballType.snowball);
+		}
+
+		if(var1.type == 70) {
+			var8 = new EntityFallingSand(this.worldClient, var2, var4, var6, Block.sand.blockID);
+		}
+
 		if(var8 != null) {
-			((Entity)var8).serverPosX = var1.xPosition;
-			((Entity)var8).serverPosY = var1.yPosition;
-			((Entity)var8).serverPosZ = var1.zPosition;
-			((Entity)var8).rotationYaw = 0.0F;
-			((Entity)var8).rotationPitch = 0.0F;
-			((Entity)var8).entityID = var1.entityId;
-			this.worldClient.addEntityToWorld(var1.entityId, (Entity)var8);
+			var8.serverPosX = var1.xPosition;
+			var8.serverPosY = var1.yPosition;
+			var8.serverPosZ = var1.zPosition;
+			var8.rotationYaw = 0.0F;
+			var8.rotationPitch = 0.0F;
+			var8.entityID = var1.entityId;
+			this.worldClient.addEntityToWorld(var1.entityId, var8);
+			List var9 = var1.getMetadata();
+	        if (var9 != null) {
+	            var8.getDataWatcher().updateWatchedObjectsFromList(var9);
+	        }
 		}
 
 	}
@@ -128,7 +146,7 @@
 			var2.serverPosY += var1.yPosition;
 			var2.serverPosZ += var1.zPosition;
 			double var3 = (double)var2.serverPosX / 32.0D;
-			double var5 = (double)var2.serverPosY / 32.0D;
+			double var5 = (double)var2.serverPosY / 32.0D + 1.0D / 64.0D;
 			double var7 = (double)var2.serverPosZ / 32.0D;
 			float var9 = var1.rotating ? (float)(var1.yaw * 360) / 256.0F : var2.rotationYaw;
 			float var10 = var1.rotating ? (float)(var1.pitch * 360) / 256.0F : var2.rotationPitch;
@@ -201,7 +219,9 @@
 
 	public void handleMapChunk(Packet51MapChunk var1) {
 		this.worldClient.invalidateBlockReceiveRegion(var1.xPosition, var1.yPosition, var1.zPosition, var1.xPosition + var1.xSize - 1, var1.yPosition + var1.ySize - 1, var1.zPosition + var1.zSize - 1);
-		this.worldClient.setChunkData(var1.xPosition, var1.yPosition, var1.zPosition, var1.xSize, var1.ySize, var1.zSize, var1.chunkData);
+		if (var1.includeInitialize)
+			this.worldClient.doPreChunk(var1.xPosition >> 4, var1.zPosition >> 4, true);
+		this.worldClient.setChunkData(var1.xPosition, var1.yPosition, var1.zPosition, var1.xSize, var1.ySize, var1.zSize, var1.chunkData, !var1.includeInitialize);
 	}
 
 	public void handleBlockChange(Packet53BlockChange var1) {
@@ -230,53 +250,39 @@
 	}
 
 	public void handleCollect(Packet22Collect var1) {
-		EntityItem var2 = (EntityItem)this.worldClient.getEntityByID(var1.collectedEntityId);
-		Object var3 = (EntityLiving)this.worldClient.getEntityByID(var1.collectorEntityId);
+		Entity var2 = this.worldClient.getEntityByID(var1.collectedEntityId);
+		Entity var3 = this.worldClient.getEntityByID(var1.collectorEntityId);
 		if(var3 == null) {
 			var3 = this.mc.thePlayer;
 		}
 
 		if(var2 != null) {
 			this.worldClient.playSoundAtEntity(var2, "random.pop", 0.2F, ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.7F + 1.0F) * 2.0F);
-			this.mc.effectRenderer.addEffect(new EntityPickupFX(this.mc.theWorld, var2, (Entity)var3, -0.5F));
+			this.mc.effectRenderer.addEffect(new EntityPickupFX(this.mc.theWorld, var2, var3, -0.5F));
 			this.worldClient.removeEntityFromWorld(var1.collectedEntityId);
 		}
 
 	}
 
-	public void handleBlockItemSwitch(Packet16BlockItemSwitch var1) {
-		Entity var2 = this.worldClient.getEntityByID(var1.entityId);
-		if(var2 != null) {
-			EntityPlayer var3 = (EntityPlayer)var2;
-			int var4 = var1.id;
-			if(var4 == 0) {
-				var3.inventory.mainInventory[var3.inventory.currentItem] = null;
-			} else {
-				var3.inventory.mainInventory[var3.inventory.currentItem] = new ItemStack(var4);
-			}
-
-		}
-	}
-
 	public void handleChat(Packet3Chat var1) {
 		this.mc.ingameGUI.addChatMessage(var1.message);
 	}
 
 	public void handleArmAnimation(Packet18ArmAnimation var1) {
-		Entity var2 = this.worldClient.getEntityByID(var1.entityId);
-		if(var2 != null) {
-			EntityPlayer var3 = (EntityPlayer)var2;
-			var3.swingItem();
-		}
-	}
-
-	public void handleAddToInventory(Packet17AddToInventory var1) {
-		this.mc.thePlayer.inventory.addItemStackToInventory(new ItemStack(var1.itemID, var1.count, var1.itemDamage));
+        Entity var2 = this.getEntityByID(var1.entityId);
+        if(var2 != null) {
+            if(var1.animate == 1) {
+                EntityPlayer var3 = (EntityPlayer)var2;
+                var3.swingItem();
+            } else if(var1.animate == 2) {
+                var2.performHurtAnimation();
+            }
+        }
 	}
 
 	public void handleHandshake(Packet2Handshake var1) {
 		if(var1.username.equals("-")) {
-			this.addToSendQueue(new Packet1Login(this.mc.session.username, "Password", 2));
+			this.addToSendQueue(new Packet1Login(this.mc.session.username, "Password", NetHandler.PROTOCOL_VERSION));
 		} else {
 			try {
 				URL var2 = new URL("http://www.minecraft.net/game/joinserver.jsp?user=" + this.mc.session.username + "&sessionId=" + this.mc.session.sessionId + "&serverId=" + var1.username);
@@ -284,7 +290,7 @@
 				String var4 = var3.readLine();
 				var3.close();
 				if(var4.equalsIgnoreCase("ok")) {
-					this.addToSendQueue(new Packet1Login(this.mc.session.username, "Password", 2));
+					this.addToSendQueue(new Packet1Login(this.mc.session.username, "Password", NetHandler.PROTOCOL_VERSION));
 				} else {
 					this.netManager.networkShutdown("Failed to login: " + var4);
 				}
@@ -302,6 +308,10 @@
 	}
 
 	public void handleMobSpawn(Packet24MobSpawn var1) {
+		if (var1.type > 40 && var1.type < 60) {
+			System.out.println("Spawning mob: " + var1.type);
+		}
+
 		double var2 = (double)var1.xPosition / 32.0D;
 		double var4 = (double)var1.yPosition / 32.0D;
 		double var6 = (double)var1.zPosition / 32.0D;
@@ -311,43 +321,195 @@
 		var10.serverPosX = var1.xPosition;
 		var10.serverPosY = var1.yPosition;
 		var10.serverPosZ = var1.zPosition;
+		var10.entityID = var1.entityId;
 		var10.setPositionAndRotation(var2, var4, var6, var8, var9);
 		var10.isAIEnabled = true;
 		this.worldClient.addEntityToWorld(var1.entityId, var10);
+		List var11 = var1.getMetadata();
+        if (var11 != null) {
+            var10.getDataWatcher().updateWatchedObjectsFromList(var11);
+        }
 	}
 
 	public void handleUpdateTime(Packet4UpdateTime var1) {
 		this.mc.theWorld.setWorldTime(var1.time);
 	}
 
-	public void handlePlayerInventory(Packet5PlayerInventory var1) {
-		EntityPlayerSP var2 = this.mc.thePlayer;
-		if(var1.inventoryType == -1) {
-			var2.inventory.mainInventory = var1.inventory;
-		}
-
-		if(var1.inventoryType == -2) {
-			var2.inventory.craftingInventory = var1.inventory;
-		}
-
-		if(var1.inventoryType == -3) {
-			var2.inventory.armorInventory = var1.inventory;
-		}
-
-	}
-
-	public void handleComplexEntity(Packet59ComplexEntity var1) {
-		TileEntity var2 = this.worldClient.getBlockTileEntity(var1.xCoord, var1.yCoord, var1.zCoord);
-		if(var2 != null) {
-			var2.readFromNBT(var1.tileEntityNBT);
-			this.worldClient.markBlocksDirty(var1.xCoord, var1.yCoord, var1.zCoord, var1.xCoord, var1.yCoord, var1.zCoord);
-		}
-
-	}
+    public void handlePlayerInventory(Packet5PlayerInventory var1) {
+        Entity var2 = this.getEntityByID(var1.entityID);
+        if (var2 != null) {
+            var2.outfitWithItem(var1.slot, var1.itemID, var1.itemDamage, var1.itemMetadata);
+        }
+    }
 
 	public void handleSpawnPosition(Packet6SpawnPosition var1) {
 		this.worldClient.spawnX = var1.xPosition;
 		this.worldClient.spawnY = var1.yPosition;
 		this.worldClient.spawnZ = var1.zPosition;
+	}
+
+	public void handleWorldType(Packet70WorldType var1) {
+		this.worldClient.randomSeed = var1.info.seed;
+		this.worldClient.setWorldType(var1.info.worldType);
+		this.worldClient.creative = var1.info.creative;
+		this.mc.thePlayer.creative = var1.info.creative;
+	}
+
+	public void handleEntityStatus(Packet38EntityStatus var1) {
+		Entity entity = this.getEntityByID(var1.entityId);
+		if (entity != null) {
+			entity.handleHealthUpdate(var1.entityStatus);
+		}
+	}
+
+	public void handleHealth(Packet8UpdateHealth var1) {
+		this.mc.thePlayer.setHealth(var1.healthMP);
+	}
+
+	public Entity getEntityByID(int var1) {
+		return (Entity)(var1 == this.mc.thePlayer.entityID ? this.mc.thePlayer : this.worldClient.getEntityByID(var1));
+	}
+
+	public void handleRespawnPacket(Packet9Respawn var1) {
+		this.mc.respawn();
+	}
+
+	public void handleCloseWindow(Packet101CloseWindow var1) {
+        this.mc.thePlayer.closeCurrentInventory();
+    }
+
+	public void handleProgressBar(Packet105UpgradeProgressbar var1) {
+        this.registerPacket(var1);
+        if (this.mc.thePlayer.craftingInventory != null
+                && this.mc.thePlayer.craftingInventory.windowId == var1.windowId) {
+            this.mc.thePlayer.craftingInventory.func_20112_a(var1.progressBar, var1.progressBarValue);
+        }
+    }
+
+	public void handleWindowItems(Packet104WindowItems var1) {
+        if (var1.windowId == 0) {
+            this.mc.thePlayer.inventorySlots.func_20115_a(var1.itemStack);
+        } else if (var1.windowId == this.mc.thePlayer.craftingInventory.windowId) {
+            this.mc.thePlayer.craftingInventory.func_20115_a(var1.itemStack);
+        }
+
+    }
+
+    public void handleUpdateSign(Packet130UpdateSign var1) {
+        if (this.mc.theWorld.blockExists(var1.xPosition, var1.yPosition, var1.zPosition)) {
+            TileEntity var2 = this.mc.theWorld.getBlockTileEntity(var1.xPosition, var1.yPosition, var1.zPosition);
+            if (var2 instanceof TileEntitySign) {
+                TileEntitySign var3 = (TileEntitySign)var2;
+
+                for (int var4 = 0; var4 < 4; ++var4) {
+                    var3.signText[var4] = var1.signLines[var4];
+                }
+
+                var3.onInventoryChange();
+            }
+        }
+    }
+
+	public void handleTransaction(Packet106Transaction var1) {
+		Container var2 = null;
+		if(var1.windowId == 0) {
+			var2 = this.mc.thePlayer.inventorySlots;
+		} else if(var1.windowId == this.mc.thePlayer.craftingInventory.windowId) {
+			var2 = this.mc.thePlayer.craftingInventory;
+		}
+
+		if(var2 != null) {
+			if(var1.mysteryBoolean) {
+				var2.func_20113_a(var1.mysteryShort);
+			} else {
+				var2.func_20110_b(var1.mysteryShort);
+				this.addToSendQueue(new Packet106Transaction(var1.windowId, var1.mysteryShort, true));
+			}
+		}
+	}
+
+	public void handleSetSlot(Packet103SetSlot var1) {
+        if (var1.windowId == -1) {
+            this.mc.thePlayer.inventory.setDraggedItemStack(var1.myItemStack);
+        } else if (var1.windowId == 0) {
+            this.mc.thePlayer.inventorySlots.setSlot(var1.itemSlot, var1.myItemStack);
+        } else if (var1.windowId == this.mc.thePlayer.craftingInventory.windowId) {
+            this.mc.thePlayer.craftingInventory.setSlot(var1.itemSlot, var1.myItemStack);
+        }
+    }
+
+    public void handleOpenWindow(Packet100OpenWindow var1) {
+        if (var1.inventoryType == Packet100OpenWindow.WINDOW_CHEST) {
+            InventoryBasic var2 = new InventoryBasic(var1.windowTitle, var1.slotsCount);
+            this.mc.thePlayer.displayGUIChest(var2);
+            this.mc.thePlayer.craftingInventory.windowId = var1.windowId;
+        } else if (var1.inventoryType == Packet100OpenWindow.WINDOW_FURNACE) {
+            TileEntityFurnace var3 = new TileEntityFurnace();
+            this.mc.thePlayer.displayGUIFurnace(var3);
+            this.mc.thePlayer.craftingInventory.windowId = var1.windowId;
+        } else if (var1.inventoryType == Packet100OpenWindow.WINDOW_WORKBENCH) {
+            EntityPlayerSP var4 = this.mc.thePlayer;
+            this.mc.thePlayer.displayWorkbenchGUI(MathHelper.floor_double(var4.posX),
+                    MathHelper.floor_double(var4.posY), MathHelper.floor_double(var4.posZ));
+            this.mc.thePlayer.craftingInventory.windowId = var1.windowId;
+        } else if (var1.inventoryType == Packet100OpenWindow.WINDOW_REFABRICATOR) {
+            TileEntityRefabricator var3 = new TileEntityRefabricator();
+            this.mc.thePlayer.displayGUIRefabricator(var3);
+            this.mc.thePlayer.craftingInventory.windowId = var1.windowId;
+        } else if (var1.inventoryType == Packet100OpenWindow.WINDOW_CREATIVE) {
+            this.mc.thePlayer.displayGUICreative();
+            this.mc.thePlayer.craftingInventory.windowId = var1.windowId;
+	        ((ContainerCreative)this.mc.thePlayer.craftingInventory).inventory.pickOne = true;
+        } else if (var1.inventoryType == Packet100OpenWindow.WINDOW_CRATE) {
+            InventoryBasic var2 = new InventoryBasic(var1.windowTitle, 9);
+            this.mc.thePlayer.displayGUICrate(var2);
+            this.mc.thePlayer.craftingInventory.windowId = var1.windowId;
+        }
+    }
+
+	public void handleAttachEntity(Packet39AttachEntity var1) {
+        Object var2 = this.getEntityByID(var1.passenger);
+        Entity var3 = this.getEntityByID(var1.vehicle);
+        if(var1.passenger == this.mc.thePlayer.entityID) {
+            var2 = this.mc.thePlayer;
+        }
+
+        if(var2 != null) {
+            ((Entity)var2).mountEntity(var3);
+        }
+    }
+
+	public void handleEntityVelocity(Packet28EntityVelocity var1) {
+        Entity var2 = this.getEntityByID(var1.entityId);
+        if(var2 != null) {
+            var2.setVelocity((double)var1.motionX / 8000.0D, (double)var1.motionY / 8000.0D,
+                    (double)var1.motionZ / 8000.0D);
+        }
+	}
+
+	public void handleEntityMetadata(Packet40EntityMetadata var1) {
+        Entity var2 = this.getEntityByID(var1.entityId);
+        if (var2 != null && var1.changedObjects != null) {
+            var2.getDataWatcher().updateWatchedObjectsFromList(var1.changedObjects);
+        }
+    }
+
+	public void handleEntityPainting(Packet25EntityPainting var1) {
+        EntityPainting var2 = new EntityPainting(this.worldClient, var1.xPosition, var1.yPosition, var1.zPosition,
+                var1.direction, var1.title);
+        this.worldClient.addEntityToWorld(var1.entityId, var2);
+    }
+
+	public void handleDoorChange(Packet61DoorChange var1) {
+		this.worldClient.performActionGeneric(var1.type, var1.x, var1.y, var1.z, var1.direction);
+	}
+
+	public void handleAddEffect(Packet41AddEffect var1) {
+		Effect effect = this.mc.thePlayer.addEffect(EffectType.effectsList[var1.type], var1.duration, var1.metadata);
+		effect.maxDuration = var1.maxDuration;
+	}
+
+	public void handleRemoveEffect(Packet42RemoveEffect var1) {
+		this.mc.thePlayer.removeEffect(EffectType.effectsList[var1.type]);
 	}
 }
--- /dev/null
+++ net/minecraft/src/MCHashEntryLong.java
@@ -1,0 +1,50 @@
+package net.minecraft.src;
+
+public class MCHashEntryLong {
+	public final long hashEntry;
+	public Object valueEntry;
+	public MCHashEntryLong nextEntry;
+	public final int slotHash;
+
+	MCHashEntryLong(int var1, long var2, Object var4, MCHashEntryLong var5) {
+		this.valueEntry = var4;
+		this.nextEntry = var5;
+		this.hashEntry = var2;
+		this.slotHash = var1;
+	}
+
+	public final long getHash() {
+		return this.hashEntry;
+	}
+
+	public final Object getValue() {
+		return this.valueEntry;
+	}
+
+	public final boolean equals(Object var1) {
+		if(!(var1 instanceof MCHashEntryLong)) {
+			return false;
+		} else {
+			MCHashEntryLong var2 = (MCHashEntryLong)var1;
+			Long var3 = Long.valueOf(this.getHash());
+			Long var4 = Long.valueOf(var2.getHash());
+			if(var3 == var4 || var3 != null && var3.equals(var4)) {
+				Object var5 = this.getValue();
+				Object var6 = var2.getValue();
+				if(var5 == var6 || var5 != null && var5.equals(var6)) {
+					return true;
+				}
+			}
+
+			return false;
+		}
+	}
+
+	public final int hashCode() {
+		return MCHashTableLong.getHash(this.hashEntry);
+	}
+
+	public final String toString() {
+		return this.getHash() + "=" + this.getValue();
+	}
+}
--- net/minecraft/src/SpawnerAnimals.java
+++ net/minecraft/src/SpawnerAnimals.java
@@ -5,35 +5,23 @@
 import java.util.Set;
 
 public class SpawnerAnimals {
-	private int maxSpawns;
-	private Class entityType;
-	private Class[] entities;
-	private Set eligibleChunksForSpawning = new HashSet();
+	private final int maxSpawns;
+	private final Class entityType;
+	private final Set eligibleChunksForSpawning = new HashSet();
 
-	public SpawnerAnimals(int var1, Class var2, Class[] var3) {
+	public SpawnerAnimals(int var1, Class var2) {
 		this.maxSpawns = var1;
 		this.entityType = var2;
-		this.entities = var3;
-	}
-
-	public void onUpdate(World var1) {
-		int var2 = var1.countEntities(this.entityType);
-		if(var2 < this.maxSpawns) {
-			for(int var3 = 0; var3 < 3; ++var3) {
-				this.performSpawning(var1, 1, (IProgressUpdate)null);
-			}
-		}
-
 	}
 
 	protected ChunkPosition getRandomSpawningPointInChunk(World var1, int var2, int var3) {
 		int var4 = var2 + var1.rand.nextInt(16);
-		int var5 = var1.rand.nextInt(128);
+		int var5 = var1.rand.nextInt(208) + 48;
 		int var6 = var3 + var1.rand.nextInt(16);
 		return new ChunkPosition(var4, var5, var6);
 	}
 
-	private int performSpawning(World var1, int var2, IProgressUpdate var3) {
+	public int performSpawning(World var1) {
 		this.eligibleChunksForSpawning.clear();
 
 		int var4;
@@ -44,54 +32,65 @@
 			EntityPlayer var5 = (EntityPlayer)var1.playerEntities.get(var4);
 			int var6 = MathHelper.floor_double(var5.posX / 16.0D);
 			var7 = MathHelper.floor_double(var5.posZ / 16.0D);
-			byte var8 = 4;
+			byte var8 = (byte)var1.simulationDistance;
 
 			for(var9 = -var8; var9 <= var8; ++var9) {
 				for(var10 = -var8; var10 <= var8; ++var10) {
-					this.eligibleChunksForSpawning.add(new ChunkCoordIntPair(var9 + var6, var10 + var7));
+					if (var1.chunkExists(var9 + var6, var10 + var7)) {
+						this.eligibleChunksForSpawning.add(new ChunkCoordIntPair(var9 + var6, var10 + var7));
+					}
 				}
 			}
+		}
+
+		if (var1.countEntities(this.entityType) > this.maxSpawns * this.eligibleChunksForSpawning.size() / 256) {
+			return 0;
 		}
 
 		var4 = 0;
 		Iterator var26 = this.eligibleChunksForSpawning.iterator();
 
-		while(true) {
+		spawnLoop: while(true) {
 			ChunkCoordIntPair var27;
-			do {
-				if(!var26.hasNext()) {
-					return var4;
-				}
-
-				var27 = (ChunkCoordIntPair)var26.next();
-			} while(var1.rand.nextInt(10) != 0);
-
-			var7 = var1.rand.nextInt(this.entities.length);
+			if(!var26.hasNext()) {
+				return var4;
+			}
+
+			var27 = (ChunkCoordIntPair)var26.next();
+
 			ChunkPosition var28 = this.getRandomSpawningPointInChunk(var1, var27.chunkXPos * 16, var27.chunkZPos * 16);
 			var9 = var28.x;
 			var10 = var28.y;
 			int var11 = var28.z;
+			if (!var1.chunkExists(var9 >> 4, var11 >> 4)) {
+				continue;
+			}
+
 			if(var1.isBlockNormalCube(var9, var10, var11)) {
-				return 0;
+				continue;
 			}
 
 			if(var1.getBlockMaterial(var9, var10, var11) != Material.air) {
-				return 0;
-			}
-
-			for(int var12 = 0; var12 < 3; ++var12) {
+				continue;
+			}
+
+			Class<? extends EntityLiving> entity = this.getEntity(var1, var1.getBiome(var9, var11));
+			if (entity == null) {
+				continue;
+			}
+
+			int spawned = 0;
+			for(int var12 = 0; var12 < 6; ++var12) {
 				int var13 = var9;
-				int var14 = var10;
 				int var15 = var11;
 				byte var16 = 6;
 
-				for(int var17 = 0; var17 < 2; ++var17) {
+				for(int var17 = 0; var17 < 4; ++var17) {
 					var13 += var1.rand.nextInt(var16) - var1.rand.nextInt(var16);
-					var14 += var1.rand.nextInt(1) - var1.rand.nextInt(1);
 					var15 += var1.rand.nextInt(var16) - var1.rand.nextInt(var16);
-					if(var1.isBlockNormalCube(var13, var14 - 1, var15) && !var1.isBlockNormalCube(var13, var14, var15) && !var1.getBlockMaterial(var13, var14, var15).getIsLiquid() && !var1.isBlockNormalCube(var13, var14 + 1, var15)) {
+					if(var1.chunkExists(var13 >> 4, var15 >> 4) && var1.isBlockNormalCube(var13, var10 - 1, var15) && !var1.isBlockNormalCube(var13, var10, var15) && !var1.getBlockMaterial(var13, var10, var15).getIsLiquid() && !var1.isBlockNormalCube(var13, var10 + 1, var15)) {
 						float var18 = (float)var13 + 0.5F;
-						float var19 = (float)var14;
+						float var19 = (float)var10;
 						float var20 = (float)var15 + 0.5F;
 						if(var1.getClosestPlayer((double)var18, (double)var19, (double)var20, 24.0D) == null) {
 							float var21 = var18 - (float)var1.spawnX;
@@ -101,15 +100,25 @@
 							if(var24 >= 576.0F) {
 								EntityLiving var29;
 								try {
-									var29 = (EntityLiving)this.entities[var7].getConstructor(new Class[]{World.class}).newInstance(new Object[]{var1});
+									var29 = entity.getConstructor(World.class).newInstance(var1);
 								} catch (Exception var25) {
 									var25.printStackTrace();
 									return var4;
 								}
 
 								var29.setLocationAndAngles((double)var18, (double)var19, (double)var20, var1.rand.nextFloat() * 360.0F, 0.0F);
+								EntityPlayer var5 = (EntityPlayer)var1.playerEntities.get(0);
 								if(var29.getCanSpawnHere()) {
-									++var4;
+									if(var29 instanceof EntityFox
+											&& (var1.worldType == WorldType.WINTER
+											|| var1.getBiome((int)var18, (int)var20).isSnowy())) {
+										((EntityFox)var29).setArctic(true);
+									}
+									if(var29 instanceof EntityLeveledMob) {
+										if (var19 <= 88 || var1.mantleDisrupted) {
+											((EntityLeveledMob)var29).setLevel(1);
+										}
+									}
 									var1.spawnEntityInWorld(var29);
 									if(var29 instanceof EntitySpider && var1.rand.nextInt(100) == 0) {
 										EntitySkeleton var30 = new EntitySkeleton(var1);
@@ -117,12 +126,22 @@
 										var1.spawnEntityInWorld(var30);
 										var30.mountEntity(var29);
 									}
+
+									spawned++;
+									if (spawned >= var29.getMaxSpawnedInChunk()) {
+										continue spawnLoop;
+									}
 								}
+								var4 += spawned;
 							}
 						}
 					}
 				}
 			}
 		}
+	}
+
+	public Class<? extends EntityLiving> getEntity(World world, Biome biome) {
+		return biome.spawnableAnimals.isEmpty() ? null : biome.spawnableAnimals.get(world.rand.nextInt(biome.spawnableAnimals.size()));
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet105UpgradeProgressbar.java
@@ -1,0 +1,40 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet105UpgradeProgressbar extends Packet {
+	public int windowId;
+	public int progressBar;
+	public int progressBarValue;
+
+	public Packet105UpgradeProgressbar() {
+	}
+
+	public Packet105UpgradeProgressbar(int var1, int var2, int var3) {
+		this.windowId = var1;
+		this.progressBar = var2;
+		this.progressBarValue = var3;
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleProgressBar(this);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.windowId = var1.readByte();
+		this.progressBar = var1.readShort();
+		this.progressBarValue = var1.readShort();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeByte(this.windowId);
+		var1.writeShort(this.progressBar);
+		var1.writeShort(this.progressBarValue);
+	}
+
+	public int getPacketSize() {
+		return 5;
+	}
+}
--- /dev/null
+++ net/minecraft/src/ContainerRefabricator.java
@@ -1,0 +1,46 @@
+package net.minecraft.src;
+
+public class ContainerRefabricator extends Container {
+	private TileEntityRefabricator refabricatorTileEntity;
+	private int refabricationTime;
+
+	public ContainerRefabricator(IInventory var1, TileEntityRefabricator var2) {
+		this.refabricatorTileEntity = var2;
+		this.addSlot(new Slot(var2, 0, 80, 35));
+		this.addSlot(new Slot(var2, 1, 107, 58));
+
+		int var3;
+		for(var3 = 0; var3 < 3; ++var3) {
+			for(int var4 = 0; var4 < 9; ++var4) {
+				this.addSlot(new Slot(var1, var4 + var3 * 9 + 9, 8 + var4 * 18, 84 + var3 * 18));
+			}
+		}
+
+		for(var3 = 0; var3 < 9; ++var3) {
+			this.addSlot(new Slot(var1, var3, 8 + var3 * 18, 142));
+		}
+	}
+
+	public void updateCraftingMatrix() {
+		super.updateCraftingMatrix();
+
+		for (int var1 = 0; var1 < this.crafters.size(); var1++) {
+			ICrafting var2 = (ICrafting)this.crafters.get(var1);
+			if(this.refabricationTime != this.refabricatorTileEntity.refabricationTime) {
+				var2.setOtherSlot(this, 0, this.refabricatorTileEntity.refabricationTime);
+			}
+		}
+
+		this.refabricationTime = this.refabricatorTileEntity.refabricationTime;
+	}
+
+	public void func_20112_a(int var1, int var2) {
+		if (var1 == 0) {
+			this.refabricatorTileEntity.refabricationTime = var2;
+		}
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return this.refabricatorTileEntity.isNearPlayer(var1);
+	}
+}
--- net/minecraft/src/ThreadRunIsoClient.java
+++ net/minecraft/src/ThreadRunIsoClient.java
@@ -1,9 +1,9 @@
 package net.minecraft.src;
 
-class ThreadRunIsoClient extends Thread {
-	final CanvasIsomPreview isomPreview;
+public class ThreadRunIsoClient extends Thread {
+	public final CanvasIsomPreview isomPreview;
 
-	ThreadRunIsoClient(CanvasIsomPreview var1) {
+	public ThreadRunIsoClient(CanvasIsomPreview var1) {
 		this.isomPreview = var1;
 	}
 
--- net/minecraft/src/ItemBow.java
+++ net/minecraft/src/ItemBow.java
@@ -6,10 +6,24 @@
 		this.maxStackSize = 1;
 	}
 
+	private boolean canShootArrow(EntityPlayer var1) {
+		for (ItemStack item : var1.inventory.armorInventory) {
+			if (item != null
+					&& item.itemID == Item.quiver.shiftedIndex
+					&& item.itemDmg < item.getMaxDamage()) {
+				item.itemDmg += 1;
+				return true;
+			}
+		}
+		return var1.inventory.consumeInventoryItem(Item.arrow.shiftedIndex);
+	}
+
 	public ItemStack onItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
-		if(var3.inventory.consumeInventoryItem(Item.arrow.shiftedIndex)) {
+		if (this.canShootArrow(var3)) {
 			var2.playSoundAtEntity(var3, "random.bow", 1.0F, 1.0F / (rand.nextFloat() * 0.4F + 0.8F));
-			var2.spawnEntityInWorld(new EntityArrow(var2, var3));
+			if (var2.canDoClientAction()) {
+				var2.spawnEntityInWorld(new EntityArrow(var2, var3));
+			}
 		}
 
 		return var1;
--- net/minecraft/src/PlayerControllerMP.java
+++ net/minecraft/src/PlayerControllerMP.java
@@ -1,7 +1,6 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
-
 public class PlayerControllerMP extends PlayerController {
 	private int currentBlockX = -1;
 	private int currentBlockY = -1;
@@ -24,38 +23,48 @@
 	}
 
 	public boolean sendBlockRemoved(int var1, int var2, int var3, int var4) {
-		this.netClientHandler.addToSendQueue(new Packet14BlockDig(3, var1, var2, var3, var4));
-		int var5 = this.mc.theWorld.getBlockId(var1, var2, var3);
-		int var6 = this.mc.theWorld.getBlockMetadata(var1, var2, var3);
-		boolean var7 = super.sendBlockRemoved(var1, var2, var3, var4);
-		ItemStack var8 = this.mc.thePlayer.getCurrentEquippedItem();
-		if(var8 != null) {
-			var8.onDestroyBlock(var5, var1, var2, var3);
-			if(var8.stackSize == 0) {
-				var8.onItemDestroyedByUse(this.mc.thePlayer);
-				this.mc.thePlayer.destroyCurrentEquippedItem();
+		if (this.mc.thePlayer.creative) {
+			return super.sendBlockRemoved(var1, var2, var3, var4);
+		} else {
+			int var5 = this.mc.theWorld.getBlockId(var1, var2, var3);
+			boolean var6 = super.sendBlockRemoved(var1, var2, var3, var4);
+			ItemStack var7 = this.mc.thePlayer.getCurrentEquippedItem();
+			if(var7 != null) {
+				var7.onDestroyBlock(var5, var1, var2, var3);
+				if(var7.stackSize == 0) {
+					var7.onItemDestroyedByUse(this.mc.thePlayer);
+					this.mc.thePlayer.destroyCurrentEquippedItem();
+				}
 			}
-		}
-
-		if(var7 && this.mc.thePlayer.canHarvestBlock(Block.blocksList[var5])) {
-			Block.blocksList[var5].dropBlockAsItem(this.mc.theWorld, var1, var2, var3, var6);
-		}
-
-		return var7;
+
+			return var6;
+		}
 	}
 
 	public void clickBlock(int var1, int var2, int var3, int var4) {
-		this.isHittingBlock = true;
-		this.netClientHandler.addToSendQueue(new Packet14BlockDig(0, var1, var2, var3, var4));
-		int var5 = this.mc.theWorld.getBlockId(var1, var2, var3);
-		if(var5 > 0 && this.curBlockDamageMP == 0.0F) {
-			Block.blocksList[var5].onBlockClicked(this.mc.theWorld, var1, var2, var3, this.mc.thePlayer);
-		}
-
-		if(var5 > 0 && Block.blocksList[var5].blockStrength(this.mc.thePlayer) >= 1.0F) {
+		if(this.mc.thePlayer.creative) {
+			this.netClientHandler.addToSendQueue(new Packet14BlockDig(0, var1, var2, var3, var4));
 			this.sendBlockRemoved(var1, var2, var3, var4);
-		}
+			this.blockHitDelay = 10;
+		} else if(!this.isHittingBlock || var1 != this.currentBlockX || var2 != this.currentBlockY || var3 != this.currentBlockZ) {
+			this.netClientHandler.addToSendQueue(new Packet14BlockDig(0, var1, var2, var3, var4));
+			int var5 = this.mc.theWorld.getBlockId(var1, var2, var3);
+			if(var5 > 0 && this.curBlockDamageMP == 0.0F) {
+				Block.blocksList[var5].onBlockClicked(this.mc.theWorld, var1, var2, var3, this.mc.thePlayer);
+			}
 
+			if(var5 > 0 && Block.blocksList[var5].blockStrength(this.mc.thePlayer) >= 1.0F) {
+				this.sendBlockRemoved(var1, var2, var3, var4);
+			} else {
+				this.isHittingBlock = true;
+				this.currentBlockX = var1;
+				this.currentBlockY = var2;
+				this.currentBlockZ = var3;
+				this.curBlockDamageMP = 0.0F;
+				this.prevBlockDamageMP = 0.0F;
+				this.stepSoundTickCounter = 0.0F;
+			}
+		}
 	}
 
 	public void resetBlockRemoving() {
@@ -63,17 +72,22 @@
 			this.isHittingBlock = false;
 			this.netClientHandler.addToSendQueue(new Packet14BlockDig(2, 0, 0, 0, 0));
 			this.curBlockDamageMP = 0.0F;
-			this.blockHitDelay = 0;
 		}
+	}
+
+	public void stopBlockRemoving() {
+		this.blockHitDelay = 0;
 	}
 
 	public void sendBlockRemoving(int var1, int var2, int var3, int var4) {
 		this.isHittingBlock = true;
 		this.syncCurrentPlayItem();
-		this.netClientHandler.addToSendQueue(new Packet14BlockDig(1, var1, var2, var3, var4));
 		if(this.blockHitDelay > 0) {
 			--this.blockHitDelay;
-		} else {
+		} else if (this.mc.thePlayer.creative) {
+			this.netClientHandler.addToSendQueue(new Packet14BlockDig(0, var1, var2, var3, var4));
+			this.sendBlockRemoved(var1, var2, var3, var4);
+		} else{
 			if(var1 == this.currentBlockX && var2 == this.currentBlockY && var3 == this.currentBlockZ) {
 				int var5 = this.mc.theWorld.getBlockId(var1, var2, var3);
 				if(var5 == 0) {
@@ -88,19 +102,16 @@
 
 				++this.stepSoundTickCounter;
 				if(this.curBlockDamageMP >= 1.0F) {
+					this.isHittingBlock = false;
+					this.netClientHandler.addToSendQueue(new Packet14BlockDig(2, var1, var2, var3, var4));
 					this.sendBlockRemoved(var1, var2, var3, var4);
 					this.curBlockDamageMP = 0.0F;
 					this.prevBlockDamageMP = 0.0F;
 					this.stepSoundTickCounter = 0.0F;
-					this.blockHitDelay = 5;
+					this.blockHitDelay = this.mc.thePlayer.creative ? 10 : 0;
 				}
 			} else {
-				this.curBlockDamageMP = 0.0F;
-				this.prevBlockDamageMP = 0.0F;
-				this.stepSoundTickCounter = 0.0F;
-				this.currentBlockX = var1;
-				this.currentBlockY = var2;
-				this.currentBlockZ = var3;
+				this.clickBlock(var1, var2, var3, var4);
 			}
 
 		}
@@ -118,40 +129,71 @@
 
 	}
 
-	public float getBlockReachDistance() {
-		return 4.0F;
-	}
-
 	public void onWorldChange(World var1) {
 		super.onWorldChange(var1);
 	}
 
-	public void onUpdate() {
+ 	public void onUpdate() {
 		this.syncCurrentPlayItem();
 		this.prevBlockDamageMP = this.curBlockDamageMP;
-	}
+
+		super.onUpdate();
+ 	}
 
 	private void syncCurrentPlayItem() {
-		ItemStack var1 = this.mc.thePlayer.inventory.getCurrentItem();
-		int var2 = 0;
-		if(var1 != null) {
-			var2 = var1.itemID;
-		}
-
-		if(var2 != this.currentPlayerItem) {
-			this.currentPlayerItem = var2;
+		int var1 = this.mc.thePlayer.inventory.currentItem;
+		if(var1 != this.currentPlayerItem) {
+			this.currentPlayerItem = var1;
 			this.netClientHandler.addToSendQueue(new Packet16BlockItemSwitch(0, this.currentPlayerItem));
 		}
-
-	}
-
-	public boolean onPlayerRightClick(EntityPlayer var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7) {
-		this.syncCurrentPlayItem();
-		this.netClientHandler.addToSendQueue(new Packet15Place(var3 != null ? var3.itemID : -1, var4, var5, var6, var7));
-		return super.onPlayerRightClick(var1, var2, var3, var4, var5, var6, var7);
+	}
+
+	public void attackEntity(EntityPlayer var1, Entity var2) {
+		this.syncCurrentPlayItem();
+		this.netClientHandler.addToSendQueue(new Packet7UseEntity(var1.entityID, var2.entityID, 1));
+		var1.attackEntity(var2);
+	}
+
+	public void interactWithEntity(EntityPlayer var1, Entity var2) {
+		this.syncCurrentPlayItem();
+		this.netClientHandler.addToSendQueue(new Packet7UseEntity(var1.entityID, var2.entityID, 0));
+		var1.interactWithEntity(var2);
 	}
 
 	public EntityPlayer createPlayer(World var1) {
 		return new EntityClientPlayerMP(this.mc, var1, this.mc.session, this.netClientHandler);
+	}
+
+	public boolean sendPlaceBlock(EntityPlayer var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7, Vec3D hit) {
+		this.syncCurrentPlayItem();
+		boolean var8 = super.sendPlaceBlock(var1, var2, var3, var4, var5, var6, var7, hit);
+		this.netClientHandler.addToSendQueue(new Packet15Place(var4, var5, var6, var7, var1.inventory.getCurrentItem(),
+				(float)hit.xCoord - var4, (float)hit.yCoord - var5, (float)hit.zCoord - var6));
+		return var8;
+	}
+
+	public boolean sendUseItem(EntityPlayer var1, World var2, ItemStack var3) {
+		this.syncCurrentPlayItem();
+		boolean var4 = super.sendUseItem(var1, var2, var3);
+		this.netClientHandler.addToSendQueue(new Packet15Place(-1, -1, -1, 255, var1.inventory.getCurrentItem()));
+		return var4;
+	}
+
+	public ItemStack func_20085_a(int var1, int var2, int var3, EntityPlayer var4) {
+		short var5 = var4.craftingInventory.func_20111_a(var4.inventory);
+		ItemStack var6 = super.func_20085_a(var1, var2, var3, var4);
+		this.netClientHandler.addToSendQueue(new Packet102WindowClick(var1, var2, var3, var6, var5));
+		return var6;
+	}
+
+	public void func_20086_a(int var1, EntityPlayer var2) {
+	}
+
+	public void displayGuiCreative() {
+		this.netClientHandler.addToSendQueue(new Packet100OpenWindow(Packet100OpenWindow.WINDOW_CREATIVE));
+	}
+
+	public void setupCreativeItems(int windowId, int row) {
+		this.netClientHandler.addToSendQueue(new Packet102WindowClick(windowId, row, -1, new ItemStack(0), (short)-1));
 	}
 }
--- net/minecraft/src/RecipesIngots.java
+++ net/minecraft/src/RecipesIngots.java
@@ -1,15 +1,23 @@
 package net.minecraft.src;
 
 public class RecipesIngots {
-	private Object[][] recipeItems = new Object[][]{{Block.blockGold, Item.ingotGold}, {Block.blockSteel, Item.ingotIron}, {Block.blockDiamond, Item.diamond}};
+	private Object[][] recipeItems = {
+			{Block.blockGold, Item.ingotGold},
+			{Block.blockSteel, Item.ingotIron},
+			{Block.blockDiamond, Item.diamond},
+			{Block.blockRuby, Item.ruby},
+			{Block.blockSapphire, Item.sapphire},
+			{Block.blockRedstone, Item.redstone},
+			{Block.blockCoal, Item.coal},
+			{Block.umbrashardCrystal, Item.umbrashard}
+	};
 
-	public void addRecipes(CraftingManager var1) {
-		for(int var2 = 0; var2 < this.recipeItems.length; ++var2) {
-			Block var3 = (Block)this.recipeItems[var2][0];
-			Item var4 = (Item)this.recipeItems[var2][1];
-			var1.addRecipe(new ItemStack(var3), new Object[]{"###", "###", "###", Character.valueOf('#'), var4});
-			var1.addRecipe(new ItemStack(var4, 9), new Object[]{"#", Character.valueOf('#'), var3});
+	public void addRecipes(CraftingManager craftingManager) {
+		for (Object[] recipeItem : this.recipeItems) {
+			Block var3 = (Block)recipeItem[0];
+			Item var4 = (Item)recipeItem[1];
+			craftingManager.addRecipe(new ItemStack(var3), "###", "###", "###", '#', var4);
+			craftingManager.addRecipe(new ItemStack(var4, 9), "#", '#', var3);
 		}
-
 	}
 }
--- net/minecraft/src/SlotArmor.java
+++ net/minecraft/src/SlotArmor.java
@@ -1,20 +1,61 @@
 package net.minecraft.src;
 
-class SlotArmor extends SlotInventory {
-	final int armorType;
-	final GuiInventory guiInventory;
+public class SlotArmor extends Slot {
+	public final int armorType;
+	public final IInventory playerInventory;
 
-	SlotArmor(GuiInventory var1, GuiContainer var2, IInventory var3, int var4, int var5, int var6, int var7) {
-		super(var2, var3, var4, var5, var6);
-		this.guiInventory = var1;
-		this.armorType = var7;
+	public SlotArmor(IInventory var1, int var2, int var3, int var4, int var5) {
+		super(var1, var2, var3, var4);
+		this.playerInventory = var1;
+		this.armorType = var5;
 	}
 
 	public boolean isItemValid(ItemStack var1) {
-		return var1.getItem() instanceof ItemArmor ? ((ItemArmor)var1.getItem()).armorType == this.armorType : false;
+		Item item = var1.getItem();
+		if (item instanceof ItemVanity) {
+			if (this.armorType < 4 || this.armorType >= 8) return false;
+			ItemVanity vanity = (ItemVanity)var1.getItem();
+
+			for (int i = 0; i < 4; i++) {
+				int slot = this.playerInventory.getInventorySize() - 4 - i;
+
+				ItemStack stack = this.playerInventory.getStack(slot);
+				if (stack == null) continue;
+				Item otherItem = stack.getItem();
+
+//				if (otherItem instanceof ItemVanity
+//						&& ((ItemVanity)otherItem).vanityType == vanity.vanityType
+//						&& ((ItemVanity)otherItem).overrideArmor
+//						&& vanity.overrideArmor)
+//					return false;
+			}
+
+			return true;
+		}
+
+		if (item instanceof ItemCharm) {
+			if (this.armorType < 8) return false;
+			ItemCharm charm = (ItemCharm) item;
+
+			for (int i = 0; i < 3; i++) {
+				int slot = this.playerInventory.getInventorySize() - 1 - i;
+
+				ItemStack stack = this.playerInventory.getStack(slot);
+				if (stack == null) continue;
+				Item otherItem = stack.getItem();
+
+				if (otherItem instanceof ItemCharm
+						&& charm.incompatibleWith((ItemCharm) otherItem))
+					return false;
+			}
+
+			return true;
+		}
+
+		return (item instanceof ItemEquipable && ((ItemEquipable) item).armorType == this.armorType);
 	}
 
 	public int getBackgroundIconIndex() {
-		return 15 + this.armorType * 16;
+		return 31 + this.armorType * 32;
 	}
 }
--- /dev/null
+++ net/minecraft/src/ModelTopHat.java
@@ -1,0 +1,30 @@
+package net.minecraft.src;
+
+public class ModelTopHat extends ModelBiped {
+	public ModelRenderer bipedBrim;
+	public ModelRenderer bipedTopHat;
+
+	public ModelTopHat(float var1) {
+		super(var1);
+		this.bipedBrim = new ModelRenderer(0, 0);
+		this.bipedBrim.addBox(-5.0F, -7.0F, -5.0F, 10, 1, 10, var1);
+		this.bipedBrim.setRotationPoint(0.0F, 0.0F, 0.0F);
+		this.bipedTopHat = new ModelRenderer(0, 16);
+		this.bipedTopHat.addBox(-4.0F, -13.0F, -4.0F, 8, 6, 8, var1);
+		this.bipedTopHat.setRotationPoint(0.0F, 0.0F, 0.0F);
+	}
+
+	public void render(float var1, float var2, float var3, float var4, float var5, float var6) {
+		this.setRotationAngles(var1, var2, var3, var4, var5, var6);
+		this.bipedBrim.render(var6);
+		this.bipedTopHat.render(var6);
+	}
+
+	public void setRotationAngles(float var1, float var2, float var3, float var4, float var5, float var6) {
+		super.setRotationAngles(var1, var2, var3, var4, var5, var6);
+		this.bipedBrim.rotateAngleX = this.bipedTopHat.rotateAngleX = this.bipedHead.rotateAngleX;
+		this.bipedBrim.rotateAngleY = this.bipedTopHat.rotateAngleY = this.bipedHead.rotateAngleY;
+		this.bipedBrim.rotateAngleZ = this.bipedTopHat.rotateAngleZ = this.bipedHead.rotateAngleZ;
+		this.bipedBrim.rotationPointY = this.bipedTopHat.rotationPointY = this.bipedHead.rotationPointY;
+	}
+}
--- net/minecraft/src/ServerCommand.java
+++ net/minecraft/src/ServerCommand.java
@@ -2,9 +2,9 @@
 
 public class ServerCommand {
 	public final String command;
-	public final ICommandListener commandListener;
+	public final IListenToMyCommands commandListener;
 
-	public ServerCommand(String var1, ICommandListener var2) {
+	public ServerCommand(String var1, IListenToMyCommands var2) {
 		this.command = var1;
 		this.commandListener = var2;
 	}
--- net/minecraft/src/EntityClientPlayerMP.java
+++ net/minecraft/src/EntityClientPlayerMP.java
@@ -1,17 +1,17 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
-
 public class EntityClientPlayerMP extends EntityPlayerSP {
-	private NetClientHandler sendQueue;
+	public NetClientHandler sendQueue;
 	private int motionUpdateCounter = 0;
+	private boolean healthReady = false;
 	private double oldPosX;
 	private double oldBasePos;
 	private double oldPosY;
 	private double oldPosZ;
 	private float oldRotationYaw;
 	private float oldRotationPitch;
-	private InventoryPlayer serverSideInventory = new InventoryPlayer((EntityPlayer)null);
+	private boolean wasSneaking = false;
 
 	public EntityClientPlayerMP(Minecraft var1, World var2, Session var3, NetClientHandler var4) {
 		super(var1, var2, var3);
@@ -23,22 +23,7 @@
 		this.sendMotionUpdates();
 	}
 
-	public void onPlayerUpdate() {
-		this.sendMotionUpdates();
-	}
-
 	public void sendMotionUpdates() {
-		if(this.motionUpdateCounter++ == 20) {
-			if(!this.inventory.getInventoryEqual(this.serverSideInventory)) {
-				this.sendQueue.addToSendQueue(new Packet5PlayerInventory(-1, this.inventory.mainInventory));
-				this.sendQueue.addToSendQueue(new Packet5PlayerInventory(-2, this.inventory.craftingInventory));
-				this.sendQueue.addToSendQueue(new Packet5PlayerInventory(-3, this.inventory.armorInventory));
-				this.serverSideInventory = this.inventory.copyInventory();
-			}
-
-			this.motionUpdateCounter = 0;
-		}
-
 		double var1 = this.posX - this.oldPosX;
 		double var3 = this.boundingBox.minY - this.oldBasePos;
 		double var5 = this.posY - this.oldPosY;
@@ -47,7 +32,15 @@
 		double var11 = (double)(this.rotationPitch - this.oldRotationPitch);
 		boolean var13 = var3 != 0.0D || var5 != 0.0D || var1 != 0.0D || var7 != 0.0D;
 		boolean var14 = var9 != 0.0D || var11 != 0.0D;
-		if(var13 && var14) {
+		if(this.ridingEntity != null) {
+			if(var14) {
+				this.sendQueue.addToSendQueue(new Packet11PlayerPosition(this.motionX, -999.0D, -999.0D, this.motionZ, this.onGround));
+			} else {
+				this.sendQueue.addToSendQueue(new Packet13PlayerLookMove(this.motionX, -999.0D, -999.0D, this.motionZ, this.rotationYaw, this.rotationPitch, this.onGround));
+			}
+
+			var13 = false;
+		}  else if(var13 && var14) {
 			this.sendQueue.addToSendQueue(new Packet13PlayerLookMove(this.posX, this.boundingBox.minY, this.posY, this.posZ, this.rotationYaw, this.rotationPitch, this.onGround));
 		} else if(var13) {
 			this.sendQueue.addToSendQueue(new Packet11PlayerPosition(this.posX, this.boundingBox.minY, this.posY, this.posZ, this.onGround));
@@ -57,6 +50,17 @@
 			this.sendQueue.addToSendQueue(new Packet10Flying(this.onGround));
 		}
 
+		boolean sneaking = this.isSneaking();
+		if(sneaking != this.wasSneaking) {
+			if(sneaking) {
+				this.sendQueue.addToSendQueue(new Packet19EntityAction(this, 1));
+			} else {
+				this.sendQueue.addToSendQueue(new Packet19EntityAction(this, 2));
+			}
+
+			this.wasSneaking = sneaking;
+		}
+
 		if(var13) {
 			this.oldPosX = this.posX;
 			this.oldBasePos = this.boundingBox.minY;
@@ -69,18 +73,11 @@
 			this.oldRotationPitch = this.rotationPitch;
 		}
 
+		this.sendQueue.addToSendQueue(new Packet54LoadChunks());
+
 	}
 
 	protected void joinEntityItemWithWorld(EntityItem var1) {
-		System.out.println("Dropping?");
-		Packet21PickupSpawn var2 = new Packet21PickupSpawn(var1);
-		this.sendQueue.addToSendQueue(var2);
-		var1.posX = (double)var2.xPosition / 32.0D;
-		var1.posY = (double)var2.yPosition / 32.0D;
-		var1.posZ = (double)var2.zPosition / 32.0D;
-		var1.motionX = (double)var2.rotation / 128.0D;
-		var1.motionY = (double)var2.pitch / 128.0D;
-		var1.motionZ = (double)var2.roll / 128.0D;
 	}
 
 	public void sendChatMessage(String var1) {
@@ -90,5 +87,35 @@
 	public void swingItem() {
 		super.swingItem();
 		this.sendQueue.addToSendQueue(new Packet18ArmAnimation(this, 1));
+	}
+
+	public boolean attackEntityFrom(Entity var1, int var2) {
+		return false;
+	}
+
+	public void setHealth(int var1) {
+		if (this.healthReady) {
+			super.setHealth(var1);
+		} else {
+			this.health = var1;
+			this.healthReady = true;
+		}
+	}
+
+	public void heal(int var1) {
+	}
+
+	public void respawnPlayer() {
+		this.sendQueue.addToSendQueue(new Packet9Respawn());
+	}
+
+	public void closeCurrentInventory() {
+		this.sendQueue.addToSendQueue(new Packet101CloseWindow(this.craftingInventory.windowId));
+		this.inventory.setDraggedItemStack((ItemStack)null);
+		super.closeCurrentInventory();
+	}
+
+	public void dropOneItem() {
+		this.sendQueue.addToSendQueue(new Packet14BlockDig(4, 0, 0, 0, 0));
 	}
 }
--- net/minecraft/src/BlockRedstoneTorch.java
+++ net/minecraft/src/BlockRedstoneTorch.java
@@ -32,7 +32,7 @@
 		return false;
 	}
 
-	protected BlockRedstoneTorch(int var1, int var2, boolean var3) {
+	public BlockRedstoneTorch(int var1, int var2, boolean var3) {
 		super(var1, var2);
 		this.torchActive = var3;
 		this.setTickOnLoad(true);
@@ -47,18 +47,6 @@
 			super.onBlockAdded(var1, var2, var3, var4);
 		}
 
-		if(this.torchActive) {
-			var1.notifyBlocksOfNeighborChange(var2, var3 - 1, var4, this.blockID);
-			var1.notifyBlocksOfNeighborChange(var2, var3 + 1, var4, this.blockID);
-			var1.notifyBlocksOfNeighborChange(var2 - 1, var3, var4, this.blockID);
-			var1.notifyBlocksOfNeighborChange(var2 + 1, var3, var4, this.blockID);
-			var1.notifyBlocksOfNeighborChange(var2, var3, var4 - 1, this.blockID);
-			var1.notifyBlocksOfNeighborChange(var2, var3, var4 + 1, this.blockID);
-		}
-
-	}
-
-	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
 		if(this.torchActive) {
 			var1.notifyBlocksOfNeighborChange(var2, var3 - 1, var4, this.blockID);
 			var1.notifyBlocksOfNeighborChange(var2, var3 + 1, var4, this.blockID);
--- net/minecraft/src/NetHandler.java
+++ net/minecraft/src/NetHandler.java
@@ -1,6 +1,8 @@
 package net.minecraft.src;
 
-public class NetHandler {
+public abstract class NetHandler {
+	public static final int PROTOCOL_VERSION = 85000008;
+
 	public void handleMapChunk(Packet51MapChunk var1) {
 	}
 
@@ -74,10 +76,6 @@
 		this.registerPacket(var1);
 	}
 
-	public void handleAddToInventory(Packet17AddToInventory var1) {
-		this.registerPacket(var1);
-	}
-
 	public void handleVehicleSpawn(Packet23VehicleSpawn var1) {
 		this.registerPacket(var1);
 	}
@@ -107,6 +105,98 @@
 	}
 
 	public void handleSpawnPosition(Packet6SpawnPosition var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleWorldType(Packet70WorldType var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleEntityStatus(Packet38EntityStatus var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleUseEntity(Packet7UseEntity var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleHealth(Packet8UpdateHealth var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleRespawnPacket(Packet9Respawn var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleEntityAction(Packet19EntityAction var1) {
+		this.registerPacket(var1);
+	}
+
+    public void handleExplosion(Packet60Explosion var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleOpenWindow(Packet100OpenWindow var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleCloseWindow(Packet101CloseWindow var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleWindowClick(Packet102WindowClick var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleSetSlot(Packet103SetSlot var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleWindowItems(Packet104WindowItems var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleUpdateSign(Packet130UpdateSign var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleProgressBar(Packet105UpgradeProgressbar var1) {
+        this.registerPacket(var1);
+    }
+
+    public void handleTransaction(Packet106Transaction var1) {
+        this.registerPacket(var1);
+    }
+
+	public void handleAttachEntity(Packet39AttachEntity var1) {
+        this.registerPacket(var1);
+    }
+
+	public void handleEntityVelocity(Packet28EntityVelocity var1) {
+        this.registerPacket(var1);
+    }
+
+	public void handleEntityMetadata(Packet40EntityMetadata var1) {
+        this.registerPacket(var1);
+    }
+
+	public void handleEntityPainting(Packet25EntityPainting var1) {
+        this.registerPacket(var1);
+    }
+
+	public void handleLoadChunks(Packet54LoadChunks var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleDoorChange(Packet61DoorChange var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleAddEffect(Packet41AddEffect var1) {
+		this.registerPacket(var1);
+	}
+
+	public void handleRemoveEffect(Packet42RemoveEffect var1) {
 		this.registerPacket(var1);
 	}
 }
--- /dev/null
+++ net/minecraft/src/BitFlag.java
@@ -1,0 +1,39 @@
+package net.minecraft.src;
+
+public class BitFlag implements IBitField {
+	public final int offset;
+	private final int mask;
+	private final int nmask;
+	private final String name;
+
+	public BitFlag(String name, int offset) {
+		if (offset < 0 || offset >= IBitField.BITS) {
+			throw new IllegalArgumentException("Offset out of range");
+		}
+
+		this.offset = offset;
+		this.mask = 1 << offset;
+		this.nmask = ~this.mask;
+		this.name = name;
+	}
+
+	public boolean get(int number) {
+		return (number & this.mask) > 0;
+	}
+
+	public int set(int number, boolean value) {
+		int maskedNumber = number & this.nmask;
+		if (value) {
+			maskedNumber |= this.mask;
+		}
+		return maskedNumber;
+	}
+
+	public String getName() {
+		return this.name;
+	}
+
+	public String getString(int number) {
+		return this.get(number) ? "true" : "false";
+	}
+}
--- net/minecraft/src/Frustum.java
+++ net/minecraft/src/Frustum.java
@@ -19,4 +19,12 @@
 	public boolean isBoundingBoxInFrustum(AxisAlignedBB var1) {
 		return this.isBoxInFrustum(var1.minX, var1.minY, var1.minZ, var1.maxX, var1.maxY, var1.maxZ);
 	}
+
+	public boolean isBoxInFrustumFully(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
+		return this.clippingHelper.isBoxInFrustumFully(minX - this.xPosition, minY - this.yPosition, minZ - this.zPosition, maxX - this.xPosition, maxY - this.yPosition, maxZ - this.zPosition);
+	}
+
+	public boolean isBoundingBoxInFrustumFully(AxisAlignedBB aab) {
+		return this.isBoxInFrustumFully(aab.minX, aab.minY, aab.minZ, aab.maxX, aab.maxY, aab.maxZ);
+	}
 }
--- net/minecraft/src/MCHashEntry.java
+++ /dev/null
@@ -1,50 +1,0 @@
-package net.minecraft.src;
-
-class MCHashEntry {
-	final int hashEntry;
-	Object valueEntry;
-	MCHashEntry nextEntry;
-	final int slotHash;
-
-	MCHashEntry(int var1, int var2, Object var3, MCHashEntry var4) {
-		this.valueEntry = var3;
-		this.nextEntry = var4;
-		this.hashEntry = var2;
-		this.slotHash = var1;
-	}
-
-	public final int getHash() {
-		return this.hashEntry;
-	}
-
-	public final Object getValue() {
-		return this.valueEntry;
-	}
-
-	public final boolean equals(Object var1) {
-		if(!(var1 instanceof MCHashEntry)) {
-			return false;
-		} else {
-			MCHashEntry var2 = (MCHashEntry)var1;
-			Integer var3 = Integer.valueOf(this.getHash());
-			Integer var4 = Integer.valueOf(var2.getHash());
-			if(var3 == var4 || var3 != null && var3.equals(var4)) {
-				Object var5 = this.getValue();
-				Object var6 = var2.getValue();
-				if(var5 == var6 || var5 != null && var5.equals(var6)) {
-					return true;
-				}
-			}
-
-			return false;
-		}
-	}
-
-	public final int hashCode() {
-		return MCHashTable.getHash(this.hashEntry);
-	}
-
-	public final String toString() {
-		return this.getHash() + "=" + this.getValue();
-	}
-}
--- net/minecraft/isom/IsomPreviewApplet.java
+++ net/minecraft/isom/IsomPreviewApplet.java
@@ -2,6 +2,7 @@
 
 import java.applet.Applet;
 import java.awt.BorderLayout;
+
 import net.minecraft.src.CanvasIsomPreview;
 
 public class IsomPreviewApplet extends Applet {
--- net/minecraft/src/ItemBoat.java
+++ net/minecraft/src/ItemBoat.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import java.util.List;
+
 public class ItemBoat extends Item {
 	public ItemBoat(int var1) {
 		super(var1);
@@ -11,7 +13,7 @@
 		float var5 = var3.prevRotationPitch + (var3.rotationPitch - var3.prevRotationPitch) * var4;
 		float var6 = var3.prevRotationYaw + (var3.rotationYaw - var3.prevRotationYaw) * var4;
 		double var7 = var3.prevPosX + (var3.posX - var3.prevPosX) * (double)var4;
-		double var9 = var3.prevPosY + (var3.posY - var3.prevPosY) * (double)var4;
+		double var9 = var3.prevPosY + (var3.posY - var3.prevPosY) * (double)var4 + 1.62D - (double)var3.yOffset;
 		double var11 = var3.prevPosZ + (var3.posZ - var3.prevPosZ) * (double)var4;
 		Vec3D var13 = Vec3D.createVector(var7, var9, var11);
 		float var14 = MathHelper.cos(-var6 * ((float)Math.PI / 180.0F) - (float)Math.PI);
@@ -22,19 +24,44 @@
 		float var20 = var14 * var16;
 		double var21 = 5.0D;
 		Vec3D var23 = var13.addVector((double)var18 * var21, (double)var17 * var21, (double)var20 * var21);
-		MovingObjectPosition var24 = var2.rayTraceBlocks_do(var13, var23, true);
+		MovingObjectPosition var24 = var2.rayTraceBlocks(var13, var23, true);
 		if(var24 == null) {
 			return var1;
 		} else {
-			if(var24.typeOfHit == 0) {
-				int var25 = var24.blockX;
-				int var26 = var24.blockY;
-				int var27 = var24.blockZ;
-				var2.spawnEntityInWorld(new EntityBoat(var2, (double)((float)var25 + 0.5F), (double)((float)var26 + 1.5F), (double)((float)var27 + 0.5F)));
-				--var1.stackSize;
-			}
-
-			return var1;
+			Vec3D var25 = var3.getLook(var4);
+			boolean var26 = false;
+			float var27 = 1.0F;
+			List var28 = var2.getEntitiesWithinAABBExcludingEntity(var3, var3.boundingBox.addCoord(var25.xCoord * var21, var25.yCoord * var21, var25.zCoord * var21).expand((double)var27, (double)var27, (double)var27));
+
+			for(int var29 = 0; var29 < var28.size(); ++var29) {
+				Entity var30 = (Entity)var28.get(var29);
+				if(var30.canBeCollidedWith()) {
+					AxisAlignedBB var32 = var30.boundingBox.expand((double)0.1F, (double)0.1F, (double)0.1F);
+					if(var32.isVecInside(var13)) {
+						var26 = true;
+					}
+				}
+			}
+
+			if(var26) {
+				return var1;
+			} else {
+				if(var24.typeOfHit == 0) {
+					int var33 = var24.blockX;
+					int var34 = var24.blockY;
+					int var35 = var24.blockZ;
+					if(var2.canDoClientAction()) {
+						if(var2.getBlockId(var33, var34, var35) == Block.snow.blockID) {
+							--var34;
+						}
+
+						var2.spawnEntityInWorld(new EntityBoat(var2, (double)((float)var33 + 0.5F), (double)((float)var34 + 1.0F), (double)((float)var35 + 0.5F)));
+					}
+					--var1.stackSize;
+				}
+
+				return var1;
+			}
 		}
 	}
 }
--- net/minecraft/src/InventoryLargeChest.java
+++ net/minecraft/src/InventoryLargeChest.java
@@ -11,37 +11,41 @@
 		this.lowerChest = var3;
 	}
 
-	public int getSizeInventory() {
-		return this.upperChest.getSizeInventory() + this.lowerChest.getSizeInventory();
+	public int getInventorySize() {
+		return this.upperChest.getInventorySize() + this.lowerChest.getInventorySize();
 	}
 
-	public String getInvName() {
+	public String getInventoryName() {
 		return this.name;
 	}
 
-	public ItemStack getStackInSlot(int var1) {
-		return var1 >= this.upperChest.getSizeInventory() ? this.lowerChest.getStackInSlot(var1 - this.upperChest.getSizeInventory()) : this.upperChest.getStackInSlot(var1);
-	}
-
-	public ItemStack decrStackSize(int var1, int var2) {
-		return var1 >= this.upperChest.getSizeInventory() ? this.lowerChest.decrStackSize(var1 - this.upperChest.getSizeInventory(), var2) : this.upperChest.decrStackSize(var1, var2);
-	}
-
-	public void setInventorySlotContents(int var1, ItemStack var2) {
-		if(var1 >= this.upperChest.getSizeInventory()) {
-			this.lowerChest.setInventorySlotContents(var1 - this.upperChest.getSizeInventory(), var2);
+	public ItemStack getStack(int var1) {
+		return var1 >= this.upperChest.getInventorySize() ? this.lowerChest.getStack(var1 - this.upperChest.getInventorySize()) : this.upperChest.getStack(var1);
+	}
+
+	public ItemStack decrStack(int var1, int var2) {
+		return var1 >= this.upperChest.getInventorySize() ? this.lowerChest.decrStack(var1 - this.upperChest.getInventorySize(), var2) : this.upperChest.decrStack(var1, var2);
+	}
+
+	public void setInventorySlotItem(int var1, ItemStack var2) {
+		if(var1 >= this.upperChest.getInventorySize()) {
+			this.lowerChest.setInventorySlotItem(var1 - this.upperChest.getInventorySize(), var2);
 		} else {
-			this.upperChest.setInventorySlotContents(var1, var2);
+			this.upperChest.setInventorySlotItem(var1, var2);
 		}
 
 	}
 
-	public int getInventoryStackLimit() {
-		return this.upperChest.getInventoryStackLimit();
-	}
-
-	public void onInventoryChanged() {
-		this.upperChest.onInventoryChanged();
-		this.lowerChest.onInventoryChanged();
+	public int getStackLimit() {
+		return this.upperChest.getStackLimit();
+	}
+
+	public void onInventoryChange() {
+		this.upperChest.onInventoryChange();
+		this.lowerChest.onInventoryChange();
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return this.upperChest.isNearPlayer(var1) && this.lowerChest.isNearPlayer(var1);
 	}
 }
--- net/minecraft/src/NetworkWriterThread.java
+++ net/minecraft/src/NetworkWriterThread.java
@@ -1,7 +1,7 @@
 package net.minecraft.src;
 
-class NetworkWriterThread extends Thread {
-	final NetworkManager netManager;
+public class NetworkWriterThread extends Thread {
+	public final NetworkManager netManager;
 
 	NetworkWriterThread(NetworkManager var1, String var2) {
 		super(var2);
--- net/minecraft/src/PlayerInstance.java
+++ net/minecraft/src/PlayerInstance.java
@@ -4,7 +4,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-class PlayerInstance {
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
+public class PlayerInstance {
 	private List players;
 	private int chunkX;
 	private int chunkZ;
@@ -17,12 +19,13 @@
 	private int maxY;
 	private int minZ;
 	private int maxZ;
-	final PlayerManager playerManager;
+	private int updateBlockLayers;
+	public final PlayerManager playerManager;
 
 	public PlayerInstance(PlayerManager var1, int var2, int var3) {
 		this.playerManager = var1;
 		this.players = new ArrayList();
-		this.blocksToUpdate = new short[10];
+		this.blocksToUpdate = new short[64];
 		this.numBlocksToUpdate = 0;
 		this.chunkX = var2;
 		this.chunkZ = var3;
@@ -32,7 +35,8 @@
 
 	public void addPlayer(EntityPlayerMP var1) {
 		if(this.players.contains(var1)) {
-			throw new IllegalStateException("Failed to add player. " + var1 + " already is in chunk " + this.chunkX + ", " + this.chunkZ);
+//			throw new IllegalStateException("Failed to add player. " + var1 + " already is in chunk " + this.chunkX + ", " + this.chunkZ);
+			// Just don't do anything
 		} else {
 			var1.loadChunks.add(this.currentChunk);
 			var1.playerNetServerHandler.sendPacket(new Packet50PreChunk(this.currentChunk.chunkXPos, this.currentChunk.chunkZPos, true));
@@ -43,7 +47,7 @@
 
 	public void removePlayer(EntityPlayerMP var1) {
 		if(!this.players.contains(var1)) {
-			(new IllegalStateException("Failed to remove player. " + var1 + " isn\'t in chunk " + this.chunkX + ", " + this.chunkZ)).printStackTrace();
+			return;
 		} else {
 			this.players.remove(var1);
 			if(this.players.size() == 0) {
@@ -96,7 +100,8 @@
 			this.maxZ = var3;
 		}
 
-		if(this.numBlocksToUpdate < 10) {
+		this.updateBlockLayers |= 1 << (var2 >> 4);
+		if(this.numBlocksToUpdate < 64) {
 			short var4 = (short)(var1 << 12 | var3 << 8 | var2);
 
 			for(int var5 = 0; var5 < this.numBlocksToUpdate; ++var5) {
@@ -110,7 +115,7 @@
 
 	}
 
-	public void sendTileEntity(Packet var1) {
+	public void sendPacketToPlayersInInstance(Packet var1) {
 		for(int var2 = 0; var2 < this.players.size(); ++var2) {
 			EntityPlayerMP var3 = (EntityPlayerMP)this.players.get(var2);
 			if(var3.loadChunks.contains(this.currentChunk)) {
@@ -121,21 +126,22 @@
 	}
 
 	public void onUpdate() throws IOException {
+		WorldServer world = PlayerManager.getMinecraftServer(this.playerManager).worldMngr;
 		if(this.numBlocksToUpdate != 0) {
 			int var1;
 			int var2;
 			int var3;
 			if(this.numBlocksToUpdate == 1) {
-				var1 = this.chunkX * 16 + this.minX;
-				var2 = this.minY;
-				var3 = this.chunkZ * 16 + this.minZ;
-				this.sendTileEntity(new Packet53BlockChange(var1, var2, var3, PlayerManager.getMinecraftServer(this.playerManager).worldMngr));
-				if(Block.isBlockContainer[PlayerManager.getMinecraftServer(this.playerManager).worldMngr.getBlockId(var1, var2, var3)]) {
-					this.sendTileEntity(new Packet59ComplexEntity(var1, var2, var3, PlayerManager.getMinecraftServer(this.playerManager).worldMngr.getBlockTileEntity(var1, var2, var3)));
+				var1 = this.chunkX * 16 + (this.blocksToUpdate[0] >> 12 & 15);
+				var2 = this.blocksToUpdate[0] & 255;
+				var3 = this.chunkZ * 16 + (this.blocksToUpdate[0] >> 8 & 15);
+				this.sendPacketToPlayersInInstance(new Packet53BlockChange(var1, var2, var3, world));
+				if(Block.isBlockContainer[world.getBlockId(var1, var2, var3)]) {
+					this.addTileEntity(world.getBlockTileEntity(var1, var2, var3));
 				}
 			} else {
 				int var4;
-				if(this.numBlocksToUpdate == 10) {
+				if(this.numBlocksToUpdate == 64) {
 					this.minY = this.minY / 2 * 2;
 					this.maxY = (this.maxY / 2 + 1) * 2;
 					var1 = this.minX + this.chunkX * 16;
@@ -144,28 +150,41 @@
 					var4 = this.maxX - this.minX + 1;
 					int var5 = this.maxY - this.minY + 2;
 					int var6 = this.maxZ - this.minZ + 1;
-					this.sendTileEntity(new Packet51MapChunk(var1, var2, var3, var4, var5, var6, PlayerManager.getMinecraftServer(this.playerManager).worldMngr));
-					List var7 = PlayerManager.getMinecraftServer(this.playerManager).worldMngr.getTileEntityList(var1, var2, var3, var1 + var4, var2 + var5, var3 + var6);
+					this.sendPacketToPlayersInInstance(new Packet51MapChunk(var1, var2, var3, var4, var5, var6, world, false));
+					for (int y = 0; y < CHUNK_HEIGHT / 16; y++) {
+						if ((this.updateBlockLayers & 1 << y) != 0) {
+							int by = y << 4;
+							List var7 = world.getTileEntityList(var1, by, var3, var1 + 16, by + 16, var3 + 16);
 
-					for(int var8 = 0; var8 < var7.size(); ++var8) {
-						TileEntity var9 = (TileEntity)var7.get(var8);
-						this.sendTileEntity(new Packet59ComplexEntity(var9.xCoord, var9.yCoord, var9.zCoord, var9));
+							for(int var8 = 0; var8 < var7.size(); ++var8) {
+								this.addTileEntity((TileEntity)var7.get(var8));
+							}
+						}
 					}
 				} else {
-					this.sendTileEntity(new Packet52MultiBlockChange(this.chunkX, this.chunkZ, this.blocksToUpdate, this.numBlocksToUpdate, PlayerManager.getMinecraftServer(this.playerManager).worldMngr));
+					this.sendPacketToPlayersInInstance(new Packet52MultiBlockChange(this.chunkX, this.chunkZ, this.blocksToUpdate, this.numBlocksToUpdate, world));
 
 					for(var1 = 0; var1 < this.numBlocksToUpdate; ++var1) {
 						var2 = this.chunkX * 16 + (this.numBlocksToUpdate >> 12 & 15);
 						var3 = this.numBlocksToUpdate & 255;
 						var4 = this.chunkZ * 16 + (this.numBlocksToUpdate >> 8 & 15);
-						if(Block.isBlockContainer[PlayerManager.getMinecraftServer(this.playerManager).worldMngr.getBlockId(var2, var3, var4)]) {
-							this.sendTileEntity(new Packet59ComplexEntity(var2, var3, var4, PlayerManager.getMinecraftServer(this.playerManager).worldMngr.getBlockTileEntity(var2, var3, var4)));
+						if(Block.isBlockContainer[world.getBlockId(var2, var3, var4)]) {
+							this.addTileEntity(world.getBlockTileEntity(var2, var3, var4));
 						}
 					}
 				}
 			}
 
 			this.numBlocksToUpdate = 0;
+		}
+	}
+
+	private void addTileEntity(TileEntity var1) {
+		if(var1 != null) {
+			Packet var2 = var1.getPacket();
+			if(var2 != null) {
+				this.sendPacketToPlayersInInstance(var2);
+			}
 		}
 	}
 }
--- /dev/null
+++ net/minecraft/src/CreateWorldInfo.java
@@ -1,0 +1,28 @@
+package net.minecraft.src;
+
+public class CreateWorldInfo {
+	public String name;
+	public long seed;
+	public WorldType worldType;
+	public boolean creative;
+
+	public CreateWorldInfo withName(String name) {
+		this.name = name;
+		return this;
+	}
+
+	public CreateWorldInfo withSeed(long seed) {
+		this.seed = seed;
+		return this;
+	}
+
+	public CreateWorldInfo withWorldType(WorldType worldType) {
+		this.worldType = worldType;
+		return this;
+	}
+
+	public CreateWorldInfo withCreative(boolean creative) {
+		this.creative = creative;
+		return this;
+	}
+}
--- net/minecraft/src/BlockObsidian.java
+++ net/minecraft/src/BlockObsidian.java
@@ -2,9 +2,9 @@
 
 import java.util.Random;
 
-public class BlockObsidian extends BlockStone {
+public class BlockObsidian extends Block {
 	public BlockObsidian(int var1, int var2) {
-		super(var1, var2);
+		super(var1, var2, Material.rock);
 	}
 
 	public int quantityDropped(Random var1) {
--- /dev/null
+++ net/minecraft/src/SpawnerUnderworld.java
@@ -1,0 +1,45 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class SpawnerUnderworld extends SpawnerAnimals {
+	private static final List<Class<? extends EntityLiving>> underworldMobs = Arrays.asList(
+			EntityZombie.class,
+			EntitySkeleton.class,
+			EntityCreeper.class,
+			EntitySpider.class
+	);
+
+	public SpawnerUnderworld(int var1, Class var2) {
+		super(var1, var2);
+	}
+
+	protected ChunkPosition getRandomSpawningPointInChunk(World var1, int var2, int var3) {
+		int var4 = var2 + var1.rand.nextInt(16);
+		int var5 = var1.rand.nextInt(var1.rand.nextInt(28) + 4);
+		int var6 = var3 + var1.rand.nextInt(16);
+		return new ChunkPosition(var4, var5, var6);
+	}
+
+	public Class<? extends EntityLiving> getEntity(World world, Biome biome) {
+		return underworldMobs.get(world.rand.nextInt(underworldMobs.size()));
+	}
+
+	public int performSpawning(World var1) {
+		boolean canSpawn = false;
+		for (Object playerObj : var1.playerEntities) {
+			EntityPlayer player = (EntityPlayer)playerObj;
+			if (player.boundingBox.minY < 32) {
+				canSpawn = true;
+				break;
+			}
+		}
+
+		if (canSpawn) {
+			return super.performSpawning(var1);
+		}
+		return 0;
+	}
+}
--- net/minecraft/src/RenderTNTPrimed.java
+++ net/minecraft/src/RenderTNTPrimed.java
@@ -31,14 +31,14 @@
 
 		var10 = (1.0F - ((float)var1.fuse - var9 + 1.0F) / 100.0F) * 0.8F;
 		this.loadTexture("/terrain.png");
-		this.blockRenderer.renderBlockOnInventory(Block.tnt);
+		this.blockRenderer.renderBlockOnInventory(Block.tnt, 0);
 		if(var1.fuse / 5 % 2 == 0) {
 			GL11.glDisable(GL11.GL_TEXTURE_2D);
 			GL11.glDisable(GL11.GL_LIGHTING);
 			GL11.glEnable(GL11.GL_BLEND);
 			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_DST_ALPHA);
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, var10);
-			this.blockRenderer.renderBlockOnInventory(Block.tnt);
+			this.blockRenderer.renderBlockOnInventory(Block.tnt, 0);
 			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 			GL11.glDisable(GL11.GL_BLEND);
 			GL11.glEnable(GL11.GL_LIGHTING);
--- net/minecraft/src/ItemAxe.java
+++ net/minecraft/src/ItemAxe.java
@@ -1,9 +1,38 @@
 package net.minecraft.src;
 
+import java.util.stream.Stream;
+
+import static net.minecraft.src.ItemTooltip.*;
+
 public class ItemAxe extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.planks, Block.bookshelf, Block.wood, Block.chest};
+	private static final Block[] blocksEffectiveAgainst = new Block[] {
+			Block.planks,
+			Block.wood,
+			Block.leaves,
+			Block.chest,
+			Block.bookshelf,
+			Block.stairCompactWood,
+			Block.workbench,
+			Block.doorWood,
+			Block.jukebox,
+			Block.fence,
+			Block.woodStairDouble,
+			Block.woodStairSingle,
+			Block.crate
+	};
 
 	public ItemAxe(int var1, int var2) {
-		super(var1, 3, var2, blocksEffectiveAgainst);
+		super(var1, 3, Math.abs(var2), blocksEffectiveAgainst, var2 < 0);
+		if (var2 < 0) {
+			this.efficiencyOnProperMaterial *= 2.5F;
+			this.maxDamage *= 4;
+		}
+	}
+
+	public Object[] getTooltipInfo() {
+		return Stream.of(new Object[] {
+				"Break a log while crouching", DESCRIPTION_COL,
+				"to fell trees.", DESCRIPTION_COL
+		}, super.getTooltipInfo()).flatMap(Stream::of).toArray();
 	}
 }
--- net/minecraft/src/NBTTagDouble.java
+++ net/minecraft/src/NBTTagDouble.java
@@ -14,11 +14,11 @@
 		this.doubleValue = var1;
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeDouble(this.doubleValue);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.doubleValue = var1.readDouble();
 	}
 
@@ -27,6 +27,10 @@
 	}
 
 	public String toString() {
-		return "" + this.doubleValue;
+		return String.valueOf(this.doubleValue);
+	}
+
+	public NBTBase copy() {
+		return new NBTTagDouble(this.doubleValue).setKey(this.getKey());
 	}
 }
--- /dev/null
+++ net/minecraft/src/BiomeOcean.java
@@ -1,0 +1,12 @@
+package net.minecraft.src;
+
+public class BiomeOcean extends Biome {
+	protected BiomeOcean(int id, String name, float priority, ClimateZone... climateZones) {
+		super(id, name, priority, climateZones);
+		this.spawnableAnimals.clear();
+	}
+
+	public int[] getMapColor() {
+		return new int[] { 0, 0, 127 };
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiHeaderPicker.java
@@ -1,0 +1,61 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+import org.lwjgl.opengl.GL11;
+
+public class GuiHeaderPicker extends GuiCreative {
+	protected GuiScreen parentScreen;
+
+	public GuiHeaderPicker(GuiScreen parentScreen, Minecraft mc) {
+		super(null, mc);
+		this.title = "Pick header block";
+		this.parentScreen = parentScreen;
+	}
+
+	public boolean doesGuiPauseGame() {
+		return true;
+	}
+
+	protected void setupItems() {
+		((ContainerCreative)this.inventorySlots).setupBlocks(this.row);
+	}
+
+	protected void mouseClicked(int var1, int var2, int var3) {
+		this.handleControls(var1, var2, var3);
+		if (var3 != 0) return;
+
+		Slot slot = this.getSlotAtPosition(var1, var2);
+		if (slot == null) return;
+
+		ItemStack itemStack = slot.getStack();
+		if (itemStack == null
+				|| itemStack.itemID <= 0
+				|| itemStack.itemID >= 10000) return;
+
+		Item item = itemStack.getItem();
+		if (!(item instanceof ItemBlock)) return;
+
+		Block block = Block.blocksList[item.shiftedIndex];
+		if (!block.isOpaqueCube()) return;
+
+		this.mc.options.headerBlockID = itemStack.itemID;
+		this.mc.options.headerBlockMeta = itemStack.itemMetadata;
+		this.mc.options.saveOptions();
+		this.mc.displayGuiScreen(this.parentScreen);
+	}
+
+	protected void keyTyped(char var1, int var2) {
+		if (var2 == 1 || var2 == this.mc.options.keyBindInventory.keyCode) {
+			this.mc.displayGuiScreen(this.parentScreen);
+		}
+	}
+
+	public void drawTooltip(ItemTooltip tooltip, int x, int y) {
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		super.drawScreen(var1, var2, var3);
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+	}
+}
--- /dev/null
+++ net/minecraft/src/EffectType.java
@@ -1,0 +1,25 @@
+package net.minecraft.src;
+
+public class EffectType {
+	public static EffectType[] effectsList = new EffectType[256];
+
+	public static EffectType sugarRush = new EffectSugarRush(0, "Sugar Rush");
+	public static EffectType shieldDelay = new EffectType(1, "Shield Delay");
+	public static EffectType gluttony = new EffectType(2, "Gluttony");
+
+	public final int id;
+	public final String name;
+
+	public EffectType(int id, String name) {
+		if (effectsList[id] != null) {
+			throw new IllegalArgumentException("Effect " + id + " already exists");
+		}
+
+		this.id = id;
+		this.name = name;
+		effectsList[id] = this;
+	}
+
+	public void doEffect(EntityPlayer player, Effect effect) {
+	}
+}
--- net/minecraft/src/Block.java
+++ net/minecraft/src/Block.java
@@ -1,8 +1,11 @@
 package net.minecraft.src;
 
 import java.util.ArrayList;
+import java.util.Objects;
 import java.util.Random;
 
+import static net.minecraft.src.Constants.CHUNK_BIT_OFFSET;
+
 public class Block {
 	public static final StepSound soundPowderFootstep = new StepSound("stone", 1.0F, 1.0F);
 	public static final StepSound soundWoodFootstep = new StepSound("wood", 1.0F, 1.0F);
@@ -13,98 +16,173 @@
 	public static final StepSound soundGlassFootstep = new StepSoundGlass("stone", 1.0F, 1.0F);
 	public static final StepSound soundClothFootstep = new StepSound("cloth", 1.0F, 1.0F);
 	public static final StepSound soundSandFootstep = new StepSoundSand("sand", 1.0F, 1.0F);
-	public static final Block[] blocksList = new Block[256];
-	public static final boolean[] tickOnLoad = new boolean[256];
-	public static final boolean[] opaqueCubeLookup = new boolean[256];
-	public static final boolean[] isBlockContainer = new boolean[256];
-	public static final int[] lightOpacity = new int[256];
-	public static final boolean[] canBlockGrass = new boolean[256];
-	public static final int[] lightValue = new int[256];
-	public static final Block stone = (new BlockStone(1, 1)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+
+	public static final Block[] blocksList = new Block[65536];
+	public static final boolean[] tickOnLoad = new boolean[65536];
+	public static final boolean[] opaqueCubeLookup = new boolean[65536];
+	public static final boolean[] isBlockContainer = new boolean[65536];
+	public static final int[] lightOpacity = new int[65536];
+	public static final boolean[] canBlockGrass = new boolean[65536];
+	public static final int[] lightValue = new int[65536];
+
+	public static final Block stone = (new BlockSmoothStone(1, textureXY(12, 0))).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep);
 	public static final BlockGrass grass = (BlockGrass)(new BlockGrass(2)).setHardness(0.6F).setStepSound(soundGrassFootstep);
-	public static final Block dirt = (new BlockDirt(3, 2)).setHardness(0.5F).setStepSound(soundGravelFootstep);
-	public static final Block cobblestone = (new Block(4, 16, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
-	public static final Block planks = (new Block(5, 4, Material.wood)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
-	public static final Block sapling = (new BlockSapling(6, 15)).setHardness(0.0F).setStepSound(soundGrassFootstep);
-	public static final Block bedrock = (new Block(7, 17, Material.rock)).setHardness(-1.0F).setResistance(6000000.0F).setStepSound(soundStoneFootstep);
+	public static final Block dirt = (new Block(3, textureXY(0, 2), Material.grass)).setHardness(0.5F).setStepSound(soundGravelFootstep);
+	public static final Block cobblestone = (new BlockStone(4, textureXY(15, 0))).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block planks = (new BlockWood(5, textureXY(2, 8), Material.wood)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block sapling = (new BlockSapling(6, textureXY(5, 8))).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final Block bedrock = (new Block(7, textureXY(1, 3), Material.rock)).setHardness(-1.0F).setResistance(6000000.0F).setStepSound(soundStoneFootstep);
 	public static final Block waterMoving = (new BlockFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3);
 	public static final Block waterStill = (new BlockStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3);
 	public static final Block lavaMoving = (new BlockFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setLightOpacity(255);
 	public static final Block lavaStill = (new BlockStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setLightOpacity(255);
-	public static final Block sand = (new BlockSand(12, 18)).setHardness(0.5F).setStepSound(soundSandFootstep);
-	public static final Block gravel = (new BlockGravel(13, 19)).setHardness(0.6F).setStepSound(soundGravelFootstep);
-	public static final Block oreGold = (new BlockOre(14, 32)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
-	public static final Block oreIron = (new BlockOre(15, 33)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
-	public static final Block oreCoal = (new BlockOre(16, 34)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block sand = (new BlockSand(12, textureXY(1, 0))).setHardness(0.5F).setStepSound(soundSandFootstep);
+	public static final Block gravel = (new BlockGravel(13, textureXY(1, 1))).setHardness(0.6F).setStepSound(soundGravelFootstep);
+	public static final Block oreGold = (new BlockOre(14, textureXY(25, 8), 10121)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block oreIron = (new BlockOre(15, textureXY(26, 8), 10120)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block oreCoal = (new BlockOre(16, textureXY(27, 8), 10007)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
 	public static final Block wood = (new BlockLog(17)).setHardness(2.0F).setStepSound(soundWoodFootstep);
-	public static final BlockLeaves leaves = (BlockLeaves)(new BlockLeaves(18, 52)).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep);
-	public static final Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep);
-	public static final Block glass = (new BlockGlass(20, 49, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep);
-	public static final Block clothRed = null;
-	public static final Block clothOrange = null;
-	public static final Block clothYellow = null;
-	public static final Block clothChartreuse = null;
-	public static final Block clothGreen = null;
-	public static final Block clothSpringGreen = null;
-	public static final Block clothCyan = null;
-	public static final Block clothCapri = null;
-	public static final Block clothUltramarine = null;
-	public static final Block clothViolet = null;
-	public static final Block clothPurple = null;
-	public static final Block clothMagenta = null;
-	public static final Block clothRose = null;
-	public static final Block clothDarkGray = null;
-	public static final Block cloth = (new Block(35, 64, Material.cloth)).setHardness(0.8F).setStepSound(soundClothFootstep);
-	public static final Block clothWhite = null;
-	public static final BlockFlower plantYellow = (BlockFlower)(new BlockFlower(37, 13)).setHardness(0.0F).setStepSound(soundGrassFootstep);
-	public static final BlockFlower plantRed = (BlockFlower)(new BlockFlower(38, 12)).setHardness(0.0F).setStepSound(soundGrassFootstep);
-	public static final BlockFlower mushroomBrown = (BlockFlower)(new BlockMushroom(39, 29)).setHardness(0.0F).setStepSound(soundGrassFootstep).setLightValue(2.0F / 16.0F);
-	public static final BlockFlower mushroomRed = (BlockFlower)(new BlockMushroom(40, 28)).setHardness(0.0F).setStepSound(soundGrassFootstep);
-	public static final Block blockGold = (new BlockOreBlock(41, 39)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
-	public static final Block blockSteel = (new BlockOreBlock(42, 38)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
-	public static final Block stairDouble = (new BlockStep(43, true)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
-	public static final Block stairSingle = (new BlockStep(44, false)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
-	public static final Block brick = (new Block(45, 7, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
-	public static final Block tnt = (new BlockTNT(46, 8)).setHardness(0.0F).setStepSound(soundGrassFootstep);
-	public static final Block bookshelf = (new BlockBookshelf(47, 35)).setHardness(1.5F).setStepSound(soundWoodFootstep);
-	public static final Block cobblestoneMossy = (new Block(48, 36, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
-	public static final Block obsidian = (new BlockObsidian(49, 37)).setHardness(10.0F).setResistance(2000.0F).setStepSound(soundStoneFootstep);
-	public static final Block torch = (new BlockTorch(50, 80)).setHardness(0.0F).setLightValue(15.0F / 16.0F).setStepSound(soundWoodFootstep);
-	public static final BlockFire fire = (BlockFire)((BlockFire)(new BlockFire(51, 31)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep));
-	public static final Block mobSpawner = (new BlockMobSpawner(52, 65)).setHardness(5.0F).setStepSound(soundMetalFootstep);
-	public static final Block stairCompactWood = new BlockStairs(53, planks);
+	public static final BlockLeaves leaves = (BlockLeaves)(new BlockLeaves(18, textureXY(3, 8))).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep);
+	public static final Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundWoodFootstep);
+	public static final Block glass = (new BlockGlass(20, textureXY(2, 2), Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep);
+	public static final Block polishedStone = (new BlockStone(21, textureXY(14, 0))).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block woodStairDouble = (new BlockStep(22, Material.wood, true, new BlockStepType[] {
+			new BlockStepType("oak", textureXY(2, 8)),
+			new BlockStepType("spruce", textureXY(2, 9)),
+			new BlockStepType("maple", textureXY(2, 10)),
+			new BlockStepType("mahogany", textureXY(2, 11)),
+	})).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block woodStairSingle = (new BlockStep(23, Material.wood, false, ((BlockStep) woodStairDouble).slabTypes)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block brickStairDouble = (new BlockStep(24, Material.rock, true, new BlockStepType[] {
+			new BlockStepType("old_brick", textureXY(3, 1))
+	})).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block brickStairSingle = (new BlockStep(25, Material.rock, false, ((BlockStep) brickStairDouble).slabTypes)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block stoneBricks = (new BlockStone(26, textureXY(17, 0))).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block stairCompactStone = new BlockStairs(27, Material.rock, new ModelBlock[] {
+			new ModelBlock("stone", textureXY(12, 0)),
+			new ModelBlock("marble", textureXY(12, 1)),
+			new ModelBlock("slate", textureXY(12, 2)),
+			new ModelBlock("granite", textureXY(12, 3)),
+			new ModelBlock("shadorite", textureXY(12, 4)),
+	}).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block stairCompactPolishedStone = new BlockStairs(28, Material.rock, new ModelBlock[] {
+			new ModelBlock("polished_stone", textureXY(14, 0)),
+			new ModelBlock("polished_marble", textureXY(14, 1)),
+			new ModelBlock("polished_slate", textureXY(14, 2)),
+			new ModelBlock("polished_granite", textureXY(14, 3)),
+			new ModelBlock("polished_shadorite", textureXY(14, 4)),
+	}).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block stairCompactStoneBricks = new BlockStairs(29, Material.rock, new ModelBlock[] {
+			new ModelBlock("stone_brick", textureXY(17, 0)),
+			new ModelBlock("marble_brick", textureXY(17, 1)),
+			new ModelBlock("slate_brick", textureXY(17, 2)),
+			new ModelBlock("granite_brick", textureXY(17, 3)),
+			new ModelBlock("shadorite_brick", textureXY(17, 4)),
+	}).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block cloth = (new BlockWool(35, textureXY(28, 24), Material.cloth)).setHardness(0.8F).setStepSound(soundClothFootstep);
+	public static final BlockFlower plantBlue = (BlockFlower)(new BlockFlower(36, textureXY(2, 5))).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final BlockFlower plantYellow = (BlockFlower)(new BlockFlower(37, textureXY(1, 5))).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final BlockFlower plantRed = (BlockFlower)(new BlockFlower(38, textureXY(0, 5))).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final BlockFlower mushroomBrown = (BlockFlower)(new BlockMushroom(39, textureXY(1, 6))).setHardness(0.0F).setStepSound(soundGrassFootstep).setLightValue(0.125F);
+	public static final BlockFlower mushroomRed = (BlockFlower)(new BlockMushroom(40, textureXY(0, 6))).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final Block blockGold = (new BlockOreBlock(41, textureXY(28, 1))).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block blockSteel = (new BlockOreBlock(42, textureXY(27, 1))).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block stairDouble = (new BlockStep(43, Material.rock, true, new BlockStepType[] {
+			new BlockStepType("cobblestone", textureXY(15, 0)),
+			new BlockStepType("cobbled_marble", textureXY(15, 1)),
+			new BlockStepType("cobbled_slate", textureXY(15, 2)),
+			new BlockStepType("stone", textureXY(12, 0)),
+			new BlockStepType("marble", textureXY(12, 1)),
+			new BlockStepType("slate", textureXY(12, 2)),
+			new BlockStepType("polished_stone", textureXY(14, 0), true),
+			new BlockStepType("polished_marble", textureXY(14, 1), true),
+			new BlockStepType("polished_slate", textureXY(14, 2), true),
+			new BlockStepType("cobbled_granite", textureXY(15, 3)),
+			new BlockStepType("granite", textureXY(12, 3)),
+			new BlockStepType("polished_granite", textureXY(14, 3), true),
+			new BlockStepType("stone_brick", textureXY(17, 0)),
+			new BlockStepType("marble_brick", textureXY(17, 1)),
+			new BlockStepType("slate_brick", textureXY(17, 2)),
+			new BlockStepType("granite_brick", textureXY(17, 3)),
+			new BlockStepType("brick", textureXY(3, 1)),
+			new BlockStepType("cobbled_shadorite", textureXY(15, 4)),
+			new BlockStepType("shadorite", textureXY(12, 4)),
+			new BlockStepType("polished_shadorite", textureXY(14, 4), true),
+			new BlockStepType("shadorite_brick", textureXY(17, 4)),
+	})).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block stairSingle = (new BlockStep(44, Material.rock, false, ((BlockStep) stairDouble).slabTypes)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block brick = (new Block(45, textureXY(3, 1), Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block tnt = (new BlockTNT(46, textureXY(4, 1))).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final Block bookshelf = (new BlockBookshelf(47, textureXY(3, 2))).setHardness(1.5F).setStepSound(soundWoodFootstep);
+	public static final Block cobblestoneMossy = (new BlockStone(48, textureXY(16, 0))).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block obsidian = (new BlockObsidian(49, textureXY(2, 3))).setHardness(10.0F).setResistance(2000.0F).setStepSound(soundStoneFootstep);
+	public static final Block torch = (new BlockTorch(50, textureXY(3, 4))).setHardness(0.0F).setLightValue(0.9375F).setStepSound(soundWoodFootstep);
+	public static final BlockFire fire = (BlockFire) (new BlockFire(51, textureXY(28, 30))).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep);
+	public static final Block mobSpawner = (new BlockMobSpawner(52, textureXY(2, 4))).setHardness(5.0F).setStepSound(soundMetalFootstep);
+	public static final Block stairCompactWood = new BlockStairs(53, Material.wood, new ModelBlock[] {
+			new ModelBlock("oak", textureXY(2, 8)),
+			new ModelBlock("spruce", textureXY(2, 9)),
+			new ModelBlock("maple", textureXY(2, 10)),
+			new ModelBlock("mahogany", textureXY(2, 11))
+	}).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
 	public static final Block chest = (new BlockChest(54)).setHardness(2.5F).setStepSound(soundWoodFootstep);
-	public static final Block redstoneWire = (new BlockRedstoneWire(55, 84)).setHardness(0.0F).setStepSound(soundPowderFootstep);
-	public static final Block oreDiamond = (new BlockOre(56, 50)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
-	public static final Block blockDiamond = (new BlockOreBlock(57, 40)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block redstoneWire = (new BlockRedstoneWire(55, textureXY(5, 6))).setHardness(0.0F).setStepSound(soundPowderFootstep);
+	public static final Block oreDiamond = (new BlockOre(56, textureXY(28, 8), 10008)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block blockDiamond = (new BlockOreBlock(57, textureXY(29, 1))).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
 	public static final Block workbench = (new BlockWorkbench(58)).setHardness(2.5F).setStepSound(soundWoodFootstep);
-	public static final Block crops = (new BlockCrops(59, 88)).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final Block crops = (new BlockCrops(59, textureXY(24, 7))).setHardness(0.0F).setStepSound(soundGrassFootstep);
 	public static final Block tilledField = (new BlockFarmland(60)).setHardness(0.6F).setStepSound(soundGravelFootstep);
 	public static final Block stoneOvenIdle = (new BlockFurnace(61, false)).setHardness(3.5F).setStepSound(soundStoneFootstep);
-	public static final Block stoneOvenActive = (new BlockFurnace(62, true)).setHardness(3.5F).setStepSound(soundStoneFootstep).setLightValue(14.0F / 16.0F);
+	public static final Block stoneOvenActive = (new BlockFurnace(62, true)).setHardness(3.5F).setStepSound(soundStoneFootstep).setLightValue(0.875F);
 	public static final Block signStanding = (new BlockSign(63, TileEntitySign.class, true)).setHardness(1.0F).setStepSound(soundWoodFootstep);
 	public static final Block doorWood = (new BlockDoor(64, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep);
-	public static final Block ladder = (new BlockLadder(65, 83)).setHardness(0.4F).setStepSound(soundWoodFootstep);
-	public static final Block minecartTrack = (new BlockMinecartTrack(66, 128)).setHardness(0.7F).setStepSound(soundMetalFootstep);
-	public static final Block stairCompactStone = new BlockStairs(67, cobblestone);
+	public static final Block ladder = (new BlockLadder(65, textureXY(8, 8))).setHardness(0.4F).setStepSound(soundWoodFootstep);
+	public static final Block minecartTrack = (new BlockMinecartTrack(66, textureXY(3, 7))).setHardness(0.7F).setStepSound(soundMetalFootstep);
+	public static final Block stairCompactCobblestone = new BlockStairs(67, Material.rock, new ModelBlock[] {
+			new ModelBlock("cobblestone", textureXY(15, 0)),
+			new ModelBlock("cobbled_marble", textureXY(15, 1)),
+			new ModelBlock("cobbled_slate", textureXY(15, 2)),
+			new ModelBlock("cobbled_granite", textureXY(15, 3)),
+			new ModelBlock("cobbled_shadorite", textureXY(15, 4)),
+	}).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
 	public static final Block signWall = (new BlockSign(68, TileEntitySign.class, false)).setHardness(1.0F).setStepSound(soundWoodFootstep);
-	public static final Block lever = (new BlockLever(69, 96)).setHardness(0.5F).setStepSound(soundWoodFootstep);
+	public static final Block lever = (new BlockLever(69, textureXY(3, 5))).setHardness(0.5F).setStepSound(soundWoodFootstep);
 	public static final Block pressurePlateStone = (new BlockPressurePlate(70, stone.blockIndexInTexture, EnumMobType.mobs)).setHardness(0.5F).setStepSound(soundStoneFootstep);
 	public static final Block doorSteel = (new BlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep);
 	public static final Block pressurePlateWood = (new BlockPressurePlate(72, planks.blockIndexInTexture, EnumMobType.everything)).setHardness(0.5F).setStepSound(soundWoodFootstep);
-	public static final Block oreRedstone = (new BlockRedstoneOre(73, 51, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
-	public static final Block oreRedstoneGlowing = (new BlockRedstoneOre(74, 51, true)).setLightValue(10.0F / 16.0F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
-	public static final Block torchRedstoneIdle = (new BlockRedstoneTorch(75, 115, false)).setHardness(0.0F).setStepSound(soundWoodFootstep);
-	public static final Block torchRedstoneActive = (new BlockRedstoneTorch(76, 99, true)).setHardness(0.0F).setLightValue(0.5F).setStepSound(soundWoodFootstep);
+	public static final Block oreRedstone = (new BlockRedstoneOre(73, textureXY(29, 8), false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block oreRedstoneGlowing = (new BlockRedstoneOre(74, textureXY(29, 8), true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block torchRedstoneIdle = (new BlockRedstoneTorch(75, textureXY(4, 5), false)).setHardness(0.0F).setStepSound(soundWoodFootstep);
+	public static final Block torchRedstoneActive = (new BlockRedstoneTorch(76, textureXY(4, 4), true)).setHardness(0.0F).setLightValue(0.5F).setStepSound(soundWoodFootstep);
 	public static final Block button = (new BlockButton(77, stone.blockIndexInTexture)).setHardness(0.5F).setStepSound(soundStoneFootstep);
-	public static final Block snow = (new BlockSnow(78, 66)).setHardness(0.1F).setStepSound(soundClothFootstep);
-	public static final Block ice = (new BlockIce(79, 67)).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep);
-	public static final Block blockSnow = (new BlockSnowBlock(80, 66)).setHardness(0.2F).setStepSound(soundClothFootstep);
-	public static final Block cactus = (new BlockCactus(81, 70)).setHardness(0.4F).setStepSound(soundClothFootstep);
-	public static final Block blockClay = (new BlockClay(82, 72)).setHardness(0.6F).setStepSound(soundGravelFootstep);
-	public static final Block reed = (new BlockReed(83, 73)).setHardness(0.0F).setStepSound(soundGrassFootstep);
-	public static final Block jukebox = (new BlockJukeBox(84, 74)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
-	public static final Block fence = (new BlockFence(85, 4)).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final Block snow = (new BlockSnow(78, textureXY(0, 3))).setHardness(0.1F).setStepSound(soundClothFootstep);
+	public static final Block ice = (new BlockIce(79, textureXY(1, 4))).setHardness(0.5F).setLightOpacity(3).setStepSound(soundGlassFootstep);
+	public static final Block blockSnow = (new BlockSnowBlock(80, textureXY(0, 3))).setHardness(0.2F).setStepSound(soundClothFootstep);
+	public static final Block cactus = (new BlockCactus(81, textureXY(1, 7))).setHardness(0.4F).setStepSound(soundClothFootstep);
+	public static final Block blockClay = (new BlockClay(82, textureXY(1, 2))).setHardness(0.6F).setStepSound(soundGravelFootstep);
+	public static final Block reed = (new BlockReed(83, textureXY(2, 6))).setHardness(0.0F).setStepSound(soundGrassFootstep);
+	public static final Block jukebox = (new BlockJukeBox(84, textureXY(31, 4))).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block fence = (new BlockFence(85, textureXY(2, 8), Material.wood, new ModelBlock[] {
+			new ModelBlock("oak", textureXY(2, 8)),
+			new ModelBlock("spruce", textureXY(2, 9)),
+			new ModelBlock("maple", textureXY(2, 10)),
+			new ModelBlock("mahogany", textureXY(2, 11)),
+	})).setHardness(2.0F).setResistance(5.0F).setStepSound(soundWoodFootstep);
+	public static final BlockSpeleothem speleothem = (BlockSpeleothem)(new BlockSpeleothem(86, textureXY(0, 16))).setHardness(0.5F).setStepSound(soundStoneFootstep);
+	public static final Block oreRuby = (new BlockOre(87, textureXY(30, 8), 10094)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block oreSapphire = (new BlockOre(88, textureXY(31, 8), 10095)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep);
+	public static final Block blockRuby = (new BlockOreBlock(89, textureXY(30, 1))).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block blockSapphire = (new BlockOreBlock(90, textureXY(31, 1))).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block blasterIdle = (new BlockBlaster(91, false)).setHardness(7.0F).setStepSound(soundMetalFootstep);
+	public static final Block blasterActive = (new BlockBlaster(92, true)).setHardness(7.0F).setStepSound(soundMetalFootstep).setLightValue(0.875F);
+	public static final Block refabricator = (new BlockRefabricator(93)).setHardness(10.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setLightValue(0.5F);
+	public static final Block boosterTrack = (new BlockMinecartTrack(94, textureXY(4, 7))).setHardness(0.7F).setStepSound(soundMetalFootstep);
+	public static final Block starLantern = (new Block(95, textureXY(3, 3), Material.glass)).setHardness(0.5F).setStepSound(soundGlassFootstep).setLightValue(1.0F);
+	public static final Block blockRedstone = (new BlockOreBlock(96, textureXY(26, 1))).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep);
+	public static final Block blockCoal = (new Block(97, textureXY(27, 6), Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep);
+	public static final Block crate = (new BlockCrate(98)).setHardness(2.5F).setStepSound(soundWoodFootstep);
+	public static final Block umbrashardCrystal = (new BlockUmbrashardCrystal(99, textureXY(26, 6))).setHardness(3.0F).setResistance(15.0F).setStepSound(soundGlassFootstep).setLightValue(0.55F);
+	public final BitFieldGroup fields = new BitFieldGroup();
 	public int blockIndexInTexture;
 	public final int blockID;
 	protected float hardness;
@@ -119,8 +197,13 @@
 	public float blockParticleGravity;
 	public final Material material;
 	public float slipperiness;
-
-	protected Block(int var1, Material var2) {
+	public int maxStackSize = 64;
+
+	public static int textureXY(int x, int y) {
+		return y * 32 + x;
+	}
+
+	public Block(int var1, Material var2) {
 		this.stepSound = soundPowderFootstep;
 		this.blockParticleGravity = 1.0F;
 		this.slipperiness = 0.6F;
@@ -138,33 +221,41 @@
 		}
 	}
 
-	protected Block(int var1, int var2, Material var3) {
+	public Block(int var1, int var2, Material var3) {
 		this(var1, var3);
 		this.blockIndexInTexture = var2;
 	}
 
-	protected Block setStepSound(StepSound var1) {
+	public static void override(int var1) {
+		blocksList[var1] = null;
+		opaqueCubeLookup[var1] = false;
+		lightOpacity[var1] = 0;
+		canBlockGrass[var1] = false;
+		isBlockContainer[var1] = false;
+	}
+
+	public Block setStepSound(StepSound var1) {
 		this.stepSound = var1;
 		return this;
 	}
 
-	protected Block setLightOpacity(int var1) {
+	public Block setLightOpacity(int var1) {
 		lightOpacity[this.blockID] = var1;
 		return this;
 	}
 
-	protected Block setLightValue(float var1) {
+	public Block setLightValue(float var1) {
 		lightValue[this.blockID] = (int)(15.0F * var1);
 		return this;
 	}
 
-	protected Block setResistance(float var1) {
+	public Block setResistance(float var1) {
 		this.resistance = var1 * 3.0F;
 		return this;
 	}
 
 	private boolean getCanBlockGrass() {
-		return false;
+		return !this.isOpaqueCube();
 	}
 
 	public boolean renderAsNormalBlock() {
@@ -175,7 +266,7 @@
 		return 0;
 	}
 
-	protected Block setHardness(float var1) {
+	public Block setHardness(float var1) {
 		this.hardness = var1;
 		if(this.resistance < var1 * 5.0F) {
 			this.resistance = var1 * 5.0F;
@@ -188,21 +279,26 @@
 		tickOnLoad[this.blockID] = var1;
 	}
 
-	public void setBlockBounds(float var1, float var2, float var3, float var4, float var5, float var6) {
+	public Block setBlockBounds(float var1, float var2, float var3, float var4, float var5, float var6) {
 		this.minX = (double)var1;
 		this.minY = (double)var2;
 		this.minZ = (double)var3;
 		this.maxX = (double)var4;
 		this.maxY = (double)var5;
 		this.maxZ = (double)var6;
+		return this;
 	}
 
 	public float getBlockBrightness(IBlockAccess var1, int var2, int var3, int var4) {
 		return var1.getBrightness(var2, var3, var4);
 	}
 
+	public float getBlockRenderBrightness(IBlockAccess var1, int var2, int var3, int var4) {
+		return this.getBlockBrightness(var1, var2, var3, var4) * (1 - RenderGlobal.globalBrightness) + RenderGlobal.globalBrightness;
+	}
+
 	public boolean shouldSideBeRendered(IBlockAccess var1, int var2, int var3, int var4, int var5) {
-		return var5 == 0 && this.minY > 0.0D ? true : (var5 == 1 && this.maxY < 1.0D ? true : (var5 == 2 && this.minZ > 0.0D ? true : (var5 == 3 && this.maxZ < 1.0D ? true : (var5 == 4 && this.minX > 0.0D ? true : (var5 == 5 && this.maxX < 1.0D ? true : !var1.isBlockNormalCube(var2, var3, var4))))));
+		return var5 == 0 && this.minY > 0.0D || (var5 == 1 && this.maxY < 1.0D || (var5 == 2 && this.minZ > 0.0D || (var5 == 3 && this.maxZ < 1.0D || (var5 == 4 && this.minX > 0.0D || (var5 == 5 && this.maxX < 1.0D || !var1.isBlockNormalCube(var2, var3, var4))))));
 	}
 
 	public int getBlockTexture(IBlockAccess var1, int var2, int var3, int var4, int var5) {
@@ -275,27 +371,59 @@
 		return this.blockID;
 	}
 
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return 0;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return this.quantityDropped(var1);
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.idDropped(var1, var2);
+	}
+
+	public int metadataDroppedSilk(int var1, int var2, Random var3) {
+		return metadataDropped(var1, var2, var3);
+	}
+
 	public float blockStrength(EntityPlayer var1) {
-		return this.hardness < 0.0F ? 0.0F : (!var1.canHarvestBlock(this) ? 1.0F / this.hardness / 100.0F : var1.getCurrentPlayerStrVsBlock(this) / this.hardness / 30.0F);
+		return var1.creative ? Float.POSITIVE_INFINITY
+		: this.hardness < 0.0F ? 0.0F
+		: (!var1.canHarvestBlock(this) ? 1.0F / this.hardness / 100.0F
+		: var1.getCurrentPlayerStrVsBlock(this) / this.hardness / 30.0F);
 	}
 
 	public void dropBlockAsItem(World var1, int var2, int var3, int var4, int var5) {
-		this.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, 1.0F);
+		this.dropBlockAsItemWithChanceAndSilk(var1, var2, var3, var4, var5, 1.0F, false);
 	}
 
 	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
-		if(!var1.multiplayerWorld) {
-			int var7 = this.quantityDropped(var1.rand);
+		this.dropBlockAsItemWithChanceAndSilk(var1, var2, var3, var4, var5, var6, false);
+	}
+
+	public void dropBlockAsItemWithChanceAndSilk(World var1, int var2, int var3, int var4, int var5, float var6, boolean silk) {
+		if(var1.canDoClientAction()) {
+			int var7 = silk
+					? this.quantityDroppedSilk(var1.rand)
+					: this.quantityDropped(var1.rand);
 
 			for(int var8 = 0; var8 < var7; ++var8) {
 				if(var1.rand.nextFloat() <= var6) {
-					int var9 = this.idDropped(var5, var1.rand);
+					int var9 = silk
+							? this.idDroppedSilk(var5, var1.rand)
+							: this.idDropped(var5, var1.rand);
 					if(var9 > 0) {
+						ItemStack itemStack = new ItemStack(var9);
+						itemStack.itemMetadata = silk
+								? this.metadataDroppedSilk(var5, var9, var1.rand)
+								: this.metadataDropped(var5, var9, var1.rand);
+
 						float var10 = 0.7F;
 						double var11 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
 						double var13 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
 						double var15 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
-						EntityItem var17 = new EntityItem(var1, (double)var2 + var11, (double)var3 + var13, (double)var4 + var15, new ItemStack(var9));
+						EntityItem var17 = new EntityItem(var1, (double)var2 + var11, (double)var3 + var13, (double)var4 + var15, itemStack);
 						var17.delayBeforeCanPickup = 10;
 						var1.spawnEntityInWorld(var17);
 					}
@@ -431,7 +559,11 @@
 	public void onEntityWalking(World var1, int var2, int var3, int var4, Entity var5) {
 	}
 
-	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
+	public int onBlockPlaced(World var1, int var2, int var3, int var4, int var5, float hitx, float hity, float hitz, int meta) {
+		return meta;
+	}
+
+	public void onBlockPlacedBy(World var1, int var2, int var3, int var4, EntityPlayer var5, ItemStack var6) {
 	}
 
 	public void onBlockClicked(World var1, int var2, int var3, int var4, EntityPlayer var5) {
@@ -469,16 +601,104 @@
 		this.dropBlockAsItem(var1, var2, var3, var4, var5);
 	}
 
+	public void harvestBlockSilk(World var1, int var2, int var3, int var4, int var5) {
+		this.dropBlockAsItemWithChanceAndSilk(var1, var2, var3, var4, var5, 1.0F, true);
+	}
+
 	public boolean canBlockStay(World var1, int var2, int var3, int var4) {
 		return true;
 	}
 
+	public int[] availableMetadata() {
+		return new int[] { 0 };
+	}
+
+	public boolean equals(Object o) {
+		if (this == o) return true;
+		if (o == null || getClass() != o.getClass()) return false;
+		Block block = (Block) o;
+		return blockID == block.blockID;
+	}
+
+	public int hashCode() {
+		return Objects.hash(blockID);
+	}
+
+	public static void onChunkUpdate(Chunk chunk, int version, int x, int y, int z, int id, int metadata) {
+		int offset = x << CHUNK_BIT_OFFSET + 4 | z << CHUNK_BIT_OFFSET | y;
+
+		if (version < Chunk.CHUNK_VERSION_0_2) {
+			if (id == Block.leaves.blockID) {
+				chunk.setBlockMetadata(x, y, z, 0);
+			}
+
+			if (id == Block.stairDouble.blockID && metadata == 9) {
+				chunk.blocks[offset] = 24;
+				chunk.setBlockMetadata(x, y, z, 0);
+			}
+
+			if (id == Block.stairSingle.blockID && metadata == 9) {
+				chunk.blocks[offset] = 25;
+				chunk.setBlockMetadata(x, y, z, 0);
+			}
+
+			if (metadata == 1) {
+				chunk.setBlockMetadata(x, y, z, 2);
+			}
+		}
+
+		if (version < Chunk.CHUNK_VERSION_0_3) {
+			if (id == 24) {
+				chunk.blocks[offset] = (byte)Block.stairDouble.blockID;
+				chunk.setBlockMetadata(x, y, z, 16);
+			}
+
+			if (id == 25) {
+				chunk.blocks[offset] = (byte)Block.stairSingle.blockID;
+				chunk.setBlockMetadata(x, y, z, 16);
+			}
+
+			if (id == Block.speleothem.blockID) {
+				Block.speleothem.updateMetadata(chunk, x, y, z);
+			}
+		}
+
+		if (version < Chunk.CHUNK_VERSION_0_3_1) {
+			if (id == 3 && (metadata & 2) != 0) {
+				chunk.blocks[offset] = (byte)Block.grass.blockID;
+				chunk.data[offset] = 1;
+			}
+		}
+	}
+
+	public Block setTooltip(ItemTooltip tooltip) {
+		ItemTooltip.items[this.blockID] = tooltip;
+		return this;
+	}
+
+	public Block setMetaTooltip(int data, ItemTooltip tooltip) {
+		if (ItemTooltip.fromMetadata[this.blockID] == null)
+			ItemTooltip.fromMetadata[this.blockID] = new ItemTooltip[256];
+		ItemTooltip.fromMetadata[this.blockID][data] = tooltip;
+		return this;
+	}
+
+	public float getAOModifier(IBlockAccess var1, int var2, int var3, int var4) {
+		return var1.isBlockNormalCube(var2, var3, var4) ? 0.0F : 1.0F;
+	}
+
 	static {
-		for(int var0 = 0; var0 < 256; ++var0) {
-			if(blocksList[var0] != null) {
-				Item.itemsList[var0] = new ItemBlock(var0 - 256);
+		canBlockGrass[0] = true;
+
+		Item.itemsList[stairSingle.blockID] = new ItemStep((BlockStep)stairSingle, (BlockStep)stairDouble);
+		Item.itemsList[brickStairSingle.blockID] = new ItemStep((BlockStep)brickStairSingle, (BlockStep)brickStairDouble);
+		Item.itemsList[woodStairSingle.blockID] = new ItemStep((BlockStep)woodStairSingle, (BlockStep)woodStairDouble);
+
+		for(int var0 = 0; var0 < 10000; ++var0) {
+			if(blocksList[var0] != null && Item.itemsList[var0] == null) {
+				Item.itemsList[var0] = new ItemBlock(var0 - 10000);
+				Item.itemsList[var0].maxStackSize = blocksList[var0].maxStackSize;
 			}
 		}
-
 	}
 }
--- /dev/null
+++ net/minecraft/src/GuiWorldPanel.java
@@ -1,0 +1,70 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+import org.lwjgl.opengl.GL11;
+
+public class GuiWorldPanel extends GuiButton {
+	private final GuiSelectWorldNew parent;
+	public final String name;
+	public final String folder;
+	public final String desc1;
+	public final String desc2;
+	public final byte worldType;
+	public final long lastPlayed;
+
+	public GuiWorldPanel(GuiSelectWorldNew parent, int var1, int var2, int var3, String folder, NBTTagCompound level) {
+		super(var1, var2, var3, 256, 48, folder);
+		this.parent = parent;
+
+		String name = level.getString("DisplayName");
+		if (name == null || name.isEmpty())
+			name = folder;
+
+		NBTBase worldTypeTag = level.getTag("WorldType");
+		this.name = name;
+		this.folder = folder;
+		this.worldType = worldTypeTag instanceof NBTTagByte ? ((NBTTagByte) worldTypeTag).byteValue : -1;
+		this.lastPlayed = level.getLong("LastPlayed");
+
+		boolean creative = level.getBoolean("Creative");
+		long sizeOnDisk = level.getLong("SizeOnDisk");
+		int gameVersion = level.hasKey("GameVersion") ? level.getInteger("GameVersion") : -1;
+
+		this.desc1 = (creative ? "Creative" : "Survival")
+					+ " | "
+					+ (this.worldType < 0 || this.worldType >= WorldType.values().length
+							? "Unknown" : WorldType.values()[this.worldType].getName())
+					+ (level.getTagList("Mods").tagCount() > 0 ? " (Modded)" : "");
+		this.desc2 = ((float)(sizeOnDisk / 1024L * 100L / 1024L) / 100.0F)
+				+ "MB | "
+				+ (gameVersion < 1 || gameVersion >= World.VERSION_NAMES.length
+						? "Unknown" : World.VERSION_NAMES[gameVersion]);
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
+	}
+
+	public void drawWorldPanel(Minecraft var1) {
+		if (this.visible) {
+			FontRenderer var4 = var1.fontRenderer;
+
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("@@/gui/panel.png"));
+			this.drawTexturedModalRect(this.xPosition, this.yPosition, 0, 0, 256, 48);
+			this.drawTexturedModalRect(this.xPosition + 7, this.yPosition + 7, 0, 48, 34, 34);
+
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture(
+					"/gui/world_" + (worldType < 0 ? "unknown" : worldType) + ".png"));
+			this.drawTexturedModalRect(this.xPosition + 8, this.yPosition + 8, 0, 0, 32, 32, 32.0F);
+
+			var4.drawBoldStringWithShadow(this.name, this.xPosition + 47, this.yPosition + 7, 0xFFFF55);
+			var4.drawStringWithShadow(desc1, this.xPosition + 47, this.yPosition + 16, 0xFFFFFF);
+			var4.drawStringWithShadow(desc2, this.xPosition + 47, this.yPosition + 25, 0xFFFFFF);
+		}
+	}
+
+	public boolean mousePressed(Minecraft var1, int var2, int var3) {
+		return super.mousePressed(var1, var2, var3)
+				&& var3 > 32 && var3 < this.parent.height - 32;
+	}
+}
--- net/minecraft/src/EntityTracker.java
+++ net/minecraft/src/EntityTracker.java
@@ -4,11 +4,11 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+
 import net.minecraft.server.MinecraftServer;
-
 public class EntityTracker {
 	private Set trackedEntitySet = new HashSet();
-	private MCHashTable trackedEntityHashTable = new MCHashTable();
+	private MCHashTableInteger trackedEntityHashTable = new MCHashTableInteger();
 	private MinecraftServer mcServer;
 	private int maxTrackingDistanceThreshold;
 
@@ -19,7 +19,7 @@
 
 	public void trackEntity(Entity var1) {
 		if(var1 instanceof EntityPlayerMP) {
-			this.trackEntity(var1, 512, 2);
+			this.trackEntity(var1, 512, 2, false);
 			EntityPlayerMP var2 = (EntityPlayerMP)var1;
 			Iterator var3 = this.trackedEntitySet.iterator();
 
@@ -30,16 +30,26 @@
 				}
 			}
 		} else if(var1 instanceof EntityItem) {
-			this.trackEntity(var1, 64, 20);
+			this.trackEntity(var1, 64, 20, true);
 		} else if(var1 instanceof EntityMinecart) {
-			this.trackEntity(var1, 160, 4);
-		} else if(var1 instanceof IAnimals) {
-			this.trackEntity(var1, 160, 2);
+			this.trackEntity(var1, 80, 3, true);
+		} else if(var1 instanceof EntityBoat) {
+			this.trackEntity(var1, 80, 3, true);
+		} else if(var1 instanceof IAnimal || var1 instanceof IMobs) {
+			this.trackEntity(var1, 160, 3, false);
+		} else if(var1 instanceof EntitySnowball) {
+			this.trackEntity(var1, 64, 5, true);
+		} else if(var1 instanceof EntityArrow) {
+			this.trackEntity(var1, 64, 5, true);
+		} else if(var1 instanceof EntityFallingSand) {
+			this.trackEntity(var1, 160, 20, true);
+		} else if(var1 instanceof EntityPainting) {
+			this.trackEntity(var1, 160, Integer.MAX_VALUE, false);
 		}
 
 	}
 
-	public void trackEntity(Entity var1, int var2, int var3) {
+	public void trackEntity(Entity var1, int var2, int var3, boolean varb) {
 		if(var2 > this.maxTrackingDistanceThreshold) {
 			var2 = this.maxTrackingDistanceThreshold;
 		}
@@ -47,7 +57,7 @@
 		if(this.trackedEntityHashTable.containsItem(var1.entityID)) {
 			throw new IllegalStateException("Entity is already tracked!");
 		} else {
-			EntityTrackerEntry var4 = new EntityTrackerEntry(var1, var2, var3);
+			EntityTrackerEntry var4 = new EntityTrackerEntry(var1, var2, var3, varb);
 			this.trackedEntitySet.add(var4);
 			this.trackedEntityHashTable.addKey(var1.entityID, var4);
 			var4.updatePlayerEntities(this.mcServer.worldMngr.playerEntities);
@@ -94,6 +104,21 @@
 		if(var3 != null) {
 			var3.sendPacketToTrackedPlayers(var2);
 		}
-
+	}
+
+	public void sendPacketToTrackedPlayersAndTrackedEntity(Entity var1, Packet var2) {
+		EntityTrackerEntry var3 = (EntityTrackerEntry)this.trackedEntityHashTable.lookup(var1.entityID);
+		if(var3 != null) {
+			var3.sendPacketToTrackedPlayersAndTrackedEntity(var2);
+		}
+	}
+
+	public void removeTrackedPlayerSymmetric(EntityPlayerMP var1) {
+		Iterator var2 = this.trackedEntitySet.iterator();
+
+		while(var2.hasNext()) {
+			EntityTrackerEntry var3 = (EntityTrackerEntry)var2.next();
+			var3.removeTrackedPlayerSymmetric(var1);
+		}
 	}
 }
--- net/minecraft/src/CraftingInventoryCB.java
+++ /dev/null
@@ -1,19 +1,0 @@
-package net.minecraft.src;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class CraftingInventoryCB {
-	protected List list = new ArrayList();
-
-	public void onCraftGuiClosed(EntityPlayer var1) {
-		InventoryPlayer var2 = var1.inventory;
-		if(var2.draggedItemStack != null) {
-			var1.dropPlayerItem(var2.draggedItemStack);
-		}
-
-	}
-
-	public void onCraftMatrixChanged(IInventory var1) {
-	}
-}
--- net/minecraft/src/NetworkMasterThread.java
+++ net/minecraft/src/NetworkMasterThread.java
@@ -1,7 +1,7 @@
 package net.minecraft.src;
 
-class NetworkMasterThread extends Thread {
-	final NetworkManager netManager;
+public class NetworkMasterThread extends Thread {
+	public final NetworkManager netManager;
 
 	NetworkMasterThread(NetworkManager var1) {
 		this.netManager = var1;
--- net/minecraft/src/GuiScreen.java
+++ net/minecraft/src/GuiScreen.java
@@ -3,14 +3,21 @@
 import java.awt.Toolkit;
 import java.awt.datatransfer.DataFlavor;
 import java.awt.datatransfer.Transferable;
+import java.awt.image.BufferedImage;
 import java.util.ArrayList;
 import java.util.List;
+
 import net.minecraft.client.Minecraft;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.util.glu.GLU;
 
 public class GuiScreen extends Gui {
+	private static int bgType = 0;
+	private static int panoramaFB;
+	public static int panoramaCounter;
+
 	protected Minecraft mc;
 	public int width;
 	public int height;
@@ -19,6 +26,10 @@
 	protected FontRenderer fontRenderer;
 	private GuiButton selectedButton = null;
 
+	public static void setBgType(int type) {
+		bgType = type;
+	}
+
 	public void drawScreen(int var1, int var2, float var3) {
 		for(int var4 = 0; var4 < this.controlList.size(); ++var4) {
 			GuiButton var5 = (GuiButton)this.controlList.get(var4);
@@ -70,6 +81,9 @@
 
 	}
 
+	protected void mouseScrolled(int delta) {
+	}
+
 	protected void actionPerformed(GuiButton var1) {
 	}
 
@@ -78,6 +92,7 @@
 		this.fontRenderer = var1.fontRenderer;
 		this.width = var2;
 		this.height = var3;
+		this.controlList.clear();
 		this.initGui();
 	}
 
@@ -108,6 +123,9 @@
 			this.mouseMovedOrUp(var1, var2, Mouse.getEventButton());
 		}
 
+		if(Mouse.getEventDWheel() != 0) {
+			this.mouseScrolled(Mouse.getEventDWheel());
+		}
 	}
 
 	public void handleKeyboardInput() {
@@ -128,33 +146,203 @@
 	public void onGuiClosed() {
 	}
 
-	public void drawDefaultBackground() {
-		this.drawWorldBackground(0);
+	public void drawDefaultBackground(float var3) {
+		this.drawWorldBackground(0, var3);
 	}
 
-	public void drawWorldBackground(int var1) {
+	public void drawWorldBackground(int var1, float var3) {
 		if(this.mc.theWorld != null) {
 			this.drawGradientRect(0, 0, this.width, this.height, -1072689136, -804253680);
 		} else {
-			this.drawBackground(var1);
-		}
-
-	}
-
-	public void drawBackground(int var1) {
+			this.drawBackground(var1, var3);
+		}
+
+	}
+
+	public void drawBackground(int var1, float var3) {
+		drawBackground(var1, 0xFFFFFF, var3);
+	}
+
+	private void func_35355_b(float var3) {
+		Tessellator var4 = Tessellator.instance;
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+		GL11.glLoadIdentity();
+		GLU.gluPerspective(120.0F, 1.0F, 0.05F, 10.0F);
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPushMatrix();
+		GL11.glLoadIdentity();
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glDisable(GL11.GL_ALPHA_TEST);
+		GL11.glDisable(GL11.GL_CULL_FACE);
+		GL11.glDepthMask(false);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		byte var5 = 8;
+
+		for(int var6 = 0; var6 < var5 * var5; ++var6) {
+			GL11.glPushMatrix();
+			float var7 = ((float)(var6 % var5) / (float)var5 - 0.5F) / 64.0F;
+			float var8 = ((float)(var6 / var5) / (float)var5 - 0.5F) / 64.0F;
+			float var9 = 0.0F;
+			GL11.glTranslatef(var7, var8, var9);
+			GL11.glRotatef(-MathHelper.sin(((float)panoramaCounter + var3) / 400.0F) * 25.0F + 20.0F, 1.0F, 0.0F, 0.0F);
+			GL11.glRotatef(-((float)panoramaCounter + var3) * 0.1F, 0.0F, 1.0F, 0.0F);
+
+			for(int var10 = 0; var10 < 6; ++var10) {
+				GL11.glPushMatrix();
+				if(var10 == 1) {
+					GL11.glRotatef(90.0F, 0.0F, 1.0F, 0.0F);
+				}
+
+				if(var10 == 2) {
+					GL11.glRotatef(180.0F, 0.0F, 1.0F, 0.0F);
+				}
+
+				if(var10 == 3) {
+					GL11.glRotatef(-90.0F, 0.0F, 1.0F, 0.0F);
+				}
+
+				if(var10 == 4) {
+					GL11.glRotatef(90.0F, 1.0F, 0.0F, 0.0F);
+				}
+
+				if(var10 == 5) {
+					GL11.glRotatef(-90.0F, 1.0F, 0.0F, 0.0F);
+				}
+
+				GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/title/bg/panorama" + var10 + ".png"));
+				var4.startDrawingQuads();
+				var4.setColorRGBA(255, 255, 255, 255 / (var6 + 1));
+				float var11 = 0.0F;
+				var4.addVertexWithUV(-1.0D, -1.0D, 1.0D, (double)(0.0F + var11), (double)(0.0F + var11));
+				var4.addVertexWithUV(1.0D, -1.0D, 1.0D, (double)(1.0F - var11), (double)(0.0F + var11));
+				var4.addVertexWithUV(1.0D, 1.0D, 1.0D, (double)(1.0F - var11), (double)(1.0F - var11));
+				var4.addVertexWithUV(-1.0D, 1.0D, 1.0D, (double)(0.0F + var11), (double)(1.0F - var11));
+				var4.draw();
+				GL11.glPopMatrix();
+			}
+
+			GL11.glPopMatrix();
+			GL11.glColorMask(true, true, true, false);
+		}
+
+		var4.setTranslationD(0.0D, 0.0D, 0.0D);
+		GL11.glColorMask(true, true, true, true);
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPopMatrix();
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+		GL11.glDepthMask(true);
+		GL11.glEnable(GL11.GL_CULL_FACE);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glEnable(GL11.GL_DEPTH_TEST);
+	}
+
+	private void func_35354_a(float var1) {
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, panoramaFB);
+		GL11.glCopyTexSubImage2D(GL11.GL_TEXTURE_2D, 0, 0, 0, 0, 0, 256, 256);
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+		GL11.glColorMask(true, true, true, false);
+		Tessellator var2 = Tessellator.instance;
+		var2.startDrawingQuads();
+		byte var3 = 3;
+
+		for(int var4 = 0; var4 < var3; ++var4) {
+			var2.setColorRGBA_F(1.0F, 1.0F, 1.0F, 1.0F / (float)(var4 + 1));
+			int var5 = this.width;
+			int var6 = this.height;
+			float var7 = (float)(var4 - var3 / 2) / 256.0F;
+			var2.addVertexWithUV((double)var5, (double)var6, (double)this.zLevel, (double)(0.0F + var7), 0.0D);
+			var2.addVertexWithUV((double)var5, 0.0D, (double)this.zLevel, (double)(1.0F + var7), 0.0D);
+			var2.addVertexWithUV(0.0D, 0.0D, (double)this.zLevel, (double)(1.0F + var7), 1.0D);
+			var2.addVertexWithUV(0.0D, (double)var6, (double)this.zLevel, (double)(0.0F + var7), 1.0D);
+		}
+
+		var2.draw();
+		GL11.glColorMask(true, true, true, true);
+	}
+
+	private void func_35356_c(float var3) {
+		GL11.glViewport(0, 0, 256, 256);
+		this.func_35355_b(var3);
+		this.func_35354_a(var3);
+		this.func_35354_a(var3);
+		this.func_35354_a(var3);
+		this.func_35354_a(var3);
+		this.func_35354_a(var3);
+		this.func_35354_a(var3);
+		this.func_35354_a(var3);
+		this.func_35354_a(var3);
+		GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+		Tessellator var4 = Tessellator.instance;
+		var4.startDrawingQuads();
+		float var5 = this.width > this.height ? 120.0F / (float)this.width : 120.0F / (float)this.height;
+		float var6 = (float)this.height * var5 / 256.0F;
+		float var7 = (float)this.width * var5 / 256.0F;
+		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
+		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+		var4.setColorRGBA_F(1.0F, 1.0F, 1.0F, 1.0F);
+		int var8 = this.width;
+		int var9 = this.height;
+		var4.addVertexWithUV(0.0D, (double)var9, (double)this.zLevel, (double)(0.5F - var6), (double)(0.5F + var7));
+		var4.addVertexWithUV((double)var8, (double)var9, (double)this.zLevel, (double)(0.5F - var6), (double)(0.5F - var7));
+		var4.addVertexWithUV((double)var8, 0.0D, (double)this.zLevel, (double)(0.5F + var6), (double)(0.5F - var7));
+		var4.addVertexWithUV(0.0D, 0.0D, (double)this.zLevel, (double)(0.5F + var6), (double)(0.5F + var7));
+		var4.draw();
+	}
+
+	public void drawBackground(int var1, int tint, float var3) {
+		if (panoramaFB == 0) {
+			panoramaFB = this.mc.renderEngine.allocateAndSetupTexture(new BufferedImage(256, 256, 2));
+		}
+		func_35356_c(var3);
+
+		if (this.mc.options.darkMode) {
+			tint &= 0xFCFCFC;
+			tint >>= 2;
+		}
+
+		if (tint < 0xFFFFFF) {
+			GL11.glDisable(GL11.GL_TEXTURE_2D);
+			GL11.glEnable(GL11.GL_BLEND);
+			GL11.glDisable(GL11.GL_ALPHA_TEST);
+			GL11.glBlendFunc(GL11.GL_DST_COLOR, GL11.GL_ZERO);
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			Tessellator var15 = Tessellator.instance;
+			var15.startDrawingQuads();
+			var15.setColorOpaque_I(tint);
+			var15.addVertex(this.width, 0.0D, 0.0D);
+			var15.addVertex(0.0D, 0.0D, 0.0D);
+			var15.addVertex(0.0D, this.height, 0.0D);
+			var15.addVertex(this.width, this.height, 0.0D);
+			var15.draw();
+			GL11.glDisable(GL11.GL_BLEND);
+			GL11.glEnable(GL11.GL_ALPHA_TEST);
+			GL11.glEnable(GL11.GL_TEXTURE_2D);
+		}
+
+		/*
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glDisable(GL11.GL_FOG);
 		Tessellator var2 = Tessellator.instance;
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/dirt.png"));
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/bg" + bgType + ".png"));
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-		float var3 = 32.0F;
+		float var3 = 1024.0F;
+
+		double var4 = (System.currentTimeMillis() % 200000L) / 100000.0D;
+		double var5 = (Math.sin(var4 * Math.PI) / 2.0D + 0.5D) * (1.0D - this.height / 1024.0D);
+
 		var2.startDrawingQuads();
-		var2.setColorOpaque_I(4210752);
-		var2.addVertexWithUV(0.0D, (double)this.height, 0.0D, 0.0D, (double)((float)this.height / var3 + (float)var1));
-		var2.addVertexWithUV((double)this.width, (double)this.height, 0.0D, (double)((float)this.width / var3), (double)((float)this.height / var3 + (float)var1));
-		var2.addVertexWithUV((double)this.width, 0.0D, 0.0D, (double)((float)this.width / var3), (double)(0 + var1));
-		var2.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, (double)(0 + var1));
+		var2.setColorOpaque_I(tint);
+		var2.addVertexWithUV(0.0D,			this.height,	0.0D,	var4,								((float)this.height / var3 + (float)var1) + var5);
+		var2.addVertexWithUV(this.width,	this.height,	0.0D,	((float)this.width / var3) + var4,	((float)this.height / var3 + (float)var1) + var5);
+		var2.addVertexWithUV(this.width,	0.0D,			0.0D,	((float)this.width / var3) + var4,	var1 + var5);
+		var2.addVertexWithUV(0.0D,			0.0D,			0.0D,	var4,								var1 + var5);
 		var2.draw();
+		 */
 	}
 
 	public boolean doesGuiPauseGame() {
@@ -162,5 +350,49 @@
 	}
 
 	public void deleteWorld(boolean var1, int var2) {
+	}
+
+	public void drawHeader(String title) {
+		GL11.glColor4f(0.75F, 0.75F, 0.75F, 1.0F);
+
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
+		int tex = Block.blocksList[this.mc.options.headerBlockID]
+				.getBlockTextureFromSideAndMetadata(3, this.mc.options.headerBlockMeta);
+		int tx = tex % 32 * 16;
+		int ty = tex / 32 * 16;
+
+		for (int x = 0; x < this.width; x += 16) {
+			this.drawTexturedModalRect(x, 0, tx, ty, 16, 16, 512.0F);
+			this.drawTexturedModalRect(x, 16, tx, ty, 16, 16, 512.0F);
+			this.drawTexturedModalRect(x, this.height - 32, tx, ty, 16, 16, 512.0F);
+			this.drawTexturedModalRect(x, this.height - 16, tx, ty, 16, 16, 512.0F);
+		}
+
+		this.drawGradientRect(0, 32, this.width, 48, 0x7F000000, 0);
+		this.drawGradientRect(0, this.height - 48, this.width, this.height - 32, 0, 0x7F000000);
+
+		int titleWidth = this.fontRenderer.getStringWidth(title);
+		this.drawRect((this.width - titleWidth - 8) / 2, 6, (this.width + titleWidth + 8) / 2, 22, 0xC0000000);
+		this.drawCenteredString(this.fontRenderer, title, this.width / 2, 10, 0xFFFFFF);
+	}
+
+	public void drawTooltip(ItemTooltip tooltip, int x, int y) {
+		int tooltipWidth = 0;
+		for (String line : tooltip.lines) {
+			int newWidth = this.fontRenderer.getStringWidth(line);
+			if (newWidth > tooltipWidth) {
+				tooltipWidth = newWidth;
+			}
+		}
+		if ((x + tooltipWidth + 48) > this.width) {
+			x -= tooltipWidth + 24;
+		}
+
+		int tooltipHeight = tooltip.size() * 9;
+		this.drawGradientRect(x + 8, y, x + tooltipWidth + 16, y + tooltipHeight + 8, tooltip.gradient.var0,
+				tooltip.gradient.var1);
+		for (int i = 0; i < tooltip.size(); i++) {
+			this.drawString(this.fontRenderer, tooltip.lines.get(i), x + 12, y + 4 + i * 9, tooltip.colors.get(i));
+		}
 	}
 }
--- net/minecraft/src/EntityPlayerMP.java
+++ net/minecraft/src/EntityPlayerMP.java
@@ -1,12 +1,10 @@
 package net.minecraft.src;
 
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
+import java.util.*;
 import net.minecraft.server.MinecraftServer;
-
-public class EntityPlayerMP extends EntityPlayer {
+public class EntityPlayerMP extends EntityPlayer implements ICrafting {
 	public NetServerHandler playerNetServerHandler;
 	public MinecraftServer mcServer;
 	public ItemInWorldManager theItemInWorldManager;
@@ -15,6 +13,11 @@
 	public List loadedChunks = new LinkedList();
 	public Set loadChunks = new HashSet();
 	public double managedPosY;
+	private int lastHealth = -99999999;
+	private int field_15004_bw = 60;
+	private ItemStack[] armorSlots = new ItemStack[10];
+	private int currentWindowId = 0;
+	public boolean isChangingQuantityOnly;
 
 	public EntityPlayerMP(MinecraftServer var1, World var2, String var3, ItemInWorldManager var4) {
 		super(var2);
@@ -30,55 +33,109 @@
 		this.yOffset = 0.0F;
 	}
 
+	public void addCrafter() {
+		this.craftingInventory.addCrafter(this);
+	}
+
+	public ItemStack[] getInventory() {
+		return this.armorSlots;
+	}
+
+	public void heal(int var1) {
+		super.heal(var1);
+	}
+
 	public void onUpdate() {
+		this.theItemInWorldManager.updateBlockRemoving();
+		--this.field_15004_bw;
+		this.craftingInventory.updateCraftingMatrix();
+
+		for(int var1 = 0; var1 < 10; ++var1) {
+			ItemStack var2 = this.getEquipmentInSlot(var1);
+			if(var2 != this.armorSlots[var1]) {
+				this.mcServer.entityTracker.sendPacketToTrackedPlayers(this, new Packet5PlayerInventory(this.entityID, var1, var2));
+				this.armorSlots[var1] = var2;
+			}
+		}
+	}
+
+	public ItemStack getEquipmentInSlot(int var1) {
+		return var1 == 0 ? this.inventory.getCurrentItem() : this.inventory.armorInventory[var1 - 1];
 	}
 
 	public void onDeath(Entity var1) {
-	}
-
-	public boolean attackEntityFrom(Entity var1, int var2) {
-		return false;
-	}
-
-	public void heal(int var1) {
-	}
-
-	public void onUpdateEntity() {
+		ModLoader.callHook(BaseMod::onEntityDeath, this.getClass(), this, var1);
+
+		this.inventory.dropAllItems();
+	}
+
+	public void onUpdateEntity(boolean b) {
 		super.onUpdate();
+
 		ChunkCoordIntPair var1 = null;
 		double var2 = 0.0D;
 
 		for(int var4 = 0; var4 < this.loadedChunks.size(); ++var4) {
 			ChunkCoordIntPair var5 = (ChunkCoordIntPair)this.loadedChunks.get(var4);
-			double var6 = var5.a(this);
+			double var6 = var5.distanceFrom(this);
 			if(var4 == 0 || var6 < var2) {
 				var1 = var5;
-				var2 = var5.a(this);
-			}
-		}
-
+				var2 = var5.distanceFrom(this);
+			}
+		}
+
+		if(b && !this.loadedChunks.isEmpty()) {
+			ChunkCoordIntPair var10 = (ChunkCoordIntPair)this.loadedChunks.get(0);
+			double var11 = var10.distanceFrom(this);
+
+			for(int var5 = 0; var5 < this.loadedChunks.size(); ++var5) {
+				ChunkCoordIntPair var6 = (ChunkCoordIntPair)this.loadedChunks.get(var5);
+				double var7 = var6.distanceFrom(this);
+				if(var7 < var11) {
+					var10 = var6;
+					var11 = var7;
+				}
+			}
+
+			if(var10 != null) {
+				boolean var14 = false;
+				if(this.playerNetServerHandler.getNumChunkDataPackets() < 4) {
+					var14 = true;
+				}
+
+				if(var14) {
+					WorldServer var15 = this.mcServer.worldMngr;
+					this.loadedChunks.remove(var10);
+					this.playerNetServerHandler.sendPacket(new Packet51MapChunk(var1.chunkXPos * 16, 0, var1.chunkZPos * 16, 16, CHUNK_HEIGHT, 16, this.mcServer.worldMngr, true));
+					List var8 = var15.getTileEntityList(var10.chunkXPos * 16, 0, var10.chunkZPos * 16, var10.chunkXPos * 16 + 16, 256, var10.chunkZPos * 16 + 16);
+
+					for(int var9 = 0; var9 < var8.size(); ++var9) {
+						this.getTileEntityInfo((TileEntity)var8.get(var9));
+					}
+				}
+			}
+		}
+
+		if (this.health != this.lastHealth) {
+			this.playerNetServerHandler.sendPacket(new Packet8UpdateHealth(this.health));
+			this.lastHealth = this.health;
+		}
+	}
+
+	private void func_20063_a(TileEntity var1) {
 		if(var1 != null) {
-			boolean var8 = false;
-			if(var2 < 1024.0D) {
-				var8 = true;
-			}
-
-			if(this.playerNetServerHandler.getNumChunkDataPackets() < 2) {
-				var8 = true;
-			}
-
-			if(var8) {
-				this.loadedChunks.remove(var1);
-				this.playerNetServerHandler.sendPacket(new Packet51MapChunk(var1.chunkXPos * 16, 0, var1.chunkZPos * 16, 16, 128, 16, this.mcServer.worldMngr));
-				List var9 = this.mcServer.worldMngr.getTileEntityList(var1.chunkXPos * 16, 0, var1.chunkZPos * 16, var1.chunkXPos * 16 + 16, 128, var1.chunkZPos * 16 + 16);
-
-				for(int var10 = 0; var10 < var9.size(); ++var10) {
-					TileEntity var7 = (TileEntity)var9.get(var10);
-					this.playerNetServerHandler.sendPacket(new Packet59ComplexEntity(var7.xCoord, var7.yCoord, var7.zCoord, var7));
-				}
+			Packet var2 = var1.getPacket();
+			if(var2 != null) {
+				this.playerNetServerHandler.sendPacket(var2);
 			}
 		}
-
+	}
+
+	protected void updateFallState(double moveY, boolean onGround) {
+	}
+
+	public void handleFalling(double var1, boolean var3) {
+		super.updateFallState(var1, var3);
 	}
 
 	public void onLivingUpdate() {
@@ -88,12 +145,24 @@
 	}
 
 	public void onItemPickup(Entity var1, int var2) {
-		if(!var1.isDead && var1 instanceof EntityItem) {
-			this.playerNetServerHandler.sendPacket(new Packet17AddToInventory(((EntityItem)var1).item, var2));
-			this.mcServer.entityTracker.sendPacketToTrackedPlayers(var1, new Packet22Collect(var1.entityID, this.entityID));
+		if(!var1.isDead) {
+			if(var1 instanceof EntityItem) {
+				this.mcServer.entityTracker.sendPacketToTrackedPlayers(var1, new Packet22Collect(var1.entityID, this.entityID));
+			}
+
+			if(var1 instanceof EntityArrow) {
+				this.mcServer.entityTracker.sendPacketToTrackedPlayers(var1, new Packet22Collect(var1.entityID, this.entityID));
+			}
 		}
 
 		super.onItemPickup(var1, var2);
+		this.craftingInventory.updateCraftingMatrix();
+	}
+
+	public void mountEntity(Entity var1) {
+		super.mountEntity(var1);
+		this.playerNetServerHandler.sendPacket(new Packet39AttachEntity(this, this.ridingEntity));
+		this.playerNetServerHandler.teleportTo(this.posX, this.posY, this.posZ, this.rotationYaw, this.rotationPitch);
 	}
 
 	public void swingItem() {
@@ -107,5 +176,120 @@
 
 	protected float getEyeHeight() {
 		return 1.62F;
+	}
+
+	private void resetWindowId() {
+		this.currentWindowId = this.currentWindowId % 100 + 1;
+	}
+
+	public void displayWorkbenchGUI(int var1, int var2, int var3) {
+		this.resetWindowId();
+		this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, Packet100OpenWindow.WINDOW_WORKBENCH,
+				"Crafting", 9));
+		this.craftingInventory = new ContainerWorkbench(this.inventory, this.worldObj, var1, var2, var3);
+		this.craftingInventory.windowId = this.currentWindowId;
+		this.craftingInventory.addCrafter(this);
+	}
+
+	public void displayGUIChest(IInventory var1) {
+		this.resetWindowId();
+		this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, Packet100OpenWindow.WINDOW_CHEST,
+				var1.getInventoryName(), var1.getInventorySize()));
+		this.craftingInventory = new ContainerChest(this.inventory, var1);
+		this.craftingInventory.windowId = this.currentWindowId;
+		this.craftingInventory.addCrafter(this);
+	}
+
+	public void displayGUICrate(IInventory var1) {
+		this.resetWindowId();
+		this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, Packet100OpenWindow.WINDOW_CRATE,
+				var1.getInventoryName(), var1.getInventorySize()));
+		this.craftingInventory = new ContainerCrate(this.inventory, var1);
+		this.craftingInventory.windowId = this.currentWindowId;
+		this.craftingInventory.addCrafter(this);
+	}
+
+	public void displayGUIFurnace(TileEntityFurnace var1) {
+		this.resetWindowId();
+		this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, Packet100OpenWindow.WINDOW_FURNACE,
+				var1.getInventoryName(), var1.getInventorySize()));
+		this.craftingInventory = new ContainerFurnace(this.inventory, var1);
+		this.craftingInventory.windowId = this.currentWindowId;
+		this.craftingInventory.addCrafter(this);
+	}
+
+	public void displayGUIRefabricator(TileEntityRefabricator var1) {
+		this.resetWindowId();
+		this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, Packet100OpenWindow.WINDOW_REFABRICATOR,
+				var1.getInventoryName(), var1.getInventorySize()));
+		this.craftingInventory = new ContainerRefabricator(this.inventory, var1);
+		this.craftingInventory.windowId = this.currentWindowId;
+		this.craftingInventory.addCrafter(this);
+	}
+
+	public void displayGUICreative() {
+		if (this.creative) {
+			this.resetWindowId();
+			InventoryReadonly var1 = InventoryReadonly.getCreativeInventory();
+			var1.pickOne = true;
+			this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, Packet100OpenWindow.WINDOW_CREATIVE,
+					var1.getInventoryName(), var1.getInventorySize()));
+			this.craftingInventory = new ContainerCreative(this.inventory, var1);
+			((ContainerCreative)this.craftingInventory).setupItems(0);
+			this.craftingInventory.windowId = this.currentWindowId;
+			this.craftingInventory.addCrafter(this);
+		}
+	}
+
+	public void setSlot(Container var1, int var2, ItemStack var3) {
+		if(!(var1.getSlot(var2) instanceof SlotCrafting)) {
+			if(!this.isChangingQuantityOnly) {
+				this.playerNetServerHandler.sendPacket(new Packet103SetSlot(var1.windowId, var2, var3));
+			}
+		}
+	}
+
+	public void setBothSlots(Container var1, List var2) {
+		this.playerNetServerHandler.sendPacket(new Packet104WindowItems(var1.windowId, var2));
+		this.playerNetServerHandler.sendPacket(new Packet103SetSlot(-1, -1, this.inventory.getDraggedItemStack()));
+	}
+
+	public void setOtherSlot(Container var1, int var2, int var3) {
+		this.playerNetServerHandler.sendPacket(new Packet105UpgradeProgressbar(var1.windowId, var2, var3));
+	}
+
+	public void func_20045_a(ItemStack il) {
+	}
+
+	public void closeCurrentInventory() {
+		this.playerNetServerHandler.sendPacket(new Packet101CloseWindow(this.craftingInventory.windowId));
+		this.func_20059_K();
+	}
+
+	public void func_20058_J() {
+		if(!this.isChangingQuantityOnly) {
+			this.playerNetServerHandler.sendPacket(new Packet103SetSlot(-1, -1, this.inventory.getDraggedItemStack()));
+		}
+	}
+
+	public void func_20059_K() {
+		this.craftingInventory.onCraftGuiClosed(this);
+		this.craftingInventory = this.inventorySlots;
+	}
+
+	private void getTileEntityInfo(TileEntity var1) {
+        if (var1 != null) {
+            Packet var2 = var1.getPacket();
+            if (var2 != null) {
+                this.playerNetServerHandler.sendPacket(var2);
+            }
+        }
+    }
+
+
+	public Effect addEffect(EffectType type, int duration, int metadata) {
+		Effect effect = super.addEffect(type, duration, metadata);
+		this.playerNetServerHandler.sendPacket(new Packet41AddEffect(effect));
+		return effect;
 	}
 }
--- /dev/null
+++ net/minecraft/src/RecipesVanity.java
@@ -1,0 +1,27 @@
+package net.minecraft.src;
+
+import java.util.Arrays;
+
+public class RecipesVanity {
+	public void addRecipes(CraftingManager craftingManager) {
+		craftingManager.addRecipe(new ItemStack(Item.moustache), " # ", "# #", '#', Item.fur);
+		craftingManager.addRecipe(new ItemStack(Item.fluffyEars).withMetadata(2), "X X", "#X#", '#', Block.cloth, 'X', Item.fur);
+		craftingManager.addRecipe(new ItemStack(Item.fluffySnout).withMetadata(0), "XOX", "###", '#', Block.cloth, 'X', Item.fur, 'O', Item.flint);
+		craftingManager.addRecipe(new ItemStack(Item.fluffyTail).withMetadata(2), "#", "X", "X", '#', Block.cloth, 'X', Item.fur);
+		craftingManager.addRecipe(new ItemStack(Item.fluffyPaws).withMetadata(14), "X X", "# #", '#', Block.cloth, 'X', Item.fur);
+		craftingManager.addRecipe(new ItemStack(Item.longFluffySnout).withMetadata(0), "XOX", "#X#", "###", '#', Block.cloth, 'X', Item.fur, 'O', Item.flint);
+		createVanityVarying(craftingManager, new ItemStack(Item.topHat), " # ", "###");
+		craftingManager.addRecipe(new ItemStack(Item.sunglasses), "#-#", '#', Item.shardIce, '-', Item.stick);
+		craftingManager.addRecipe(new ItemStack(Item.glasses), "#-#", '#', Item.shardGlass, '-', Item.stick);
+	}
+
+	public static void createVanityVarying(CraftingManager craftingManager, ItemStack result, Object... params) {
+		Object[] varyingParams = Arrays.copyOf(params, params.length + 2);
+		varyingParams[varyingParams.length - 2] = '#';
+
+		for (int i = 0; i < 16; i++) {
+			varyingParams[varyingParams.length - 1] = new Pair<>(Block.cloth, i);
+			craftingManager.addRecipe(result.copy().withMetadata(i), varyingParams);
+		}
+	}
+}
--- net/minecraft/src/RenderHelper.java
+++ net/minecraft/src/RenderHelper.java
@@ -46,4 +46,12 @@
 		colorBuffer.flip();
 		return colorBuffer;
 	}
+
+	public static void enableGUIStandardItemLighting() {
+		GL11.glPushMatrix();
+		GL11.glRotatef(-30.0F, 0.0F, 1.0F, 0.0F);
+		GL11.glRotatef(165.0F, 1.0F, 0.0F, 0.0F);
+		enableStandardItemLighting();
+		GL11.glPopMatrix();
+	}
 }
--- /dev/null
+++ net/minecraft/src/GuiTextureViewer.java
@@ -1,0 +1,42 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+public class GuiTextureViewer extends GuiScreen {
+	private String texture = "/terrain.png";
+
+	public GuiTextureViewer() {
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(1, this.width - 100, 0, 100, 20, "Exit"));
+		this.controlList.add(new GuiButton(2, this.width - 100, 20, 100, 20, "/terrain.png"));
+		this.controlList.add(new GuiButton(3, this.width - 100, 40, 100, 20, "/gui/items.png"));
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		switch (var1.id) {
+			case 1:
+				this.mc.displayGuiScreen(null);
+				break;
+
+			case 2:
+				this.texture = "/terrain.png";
+				break;
+
+			case 3:
+				this.texture = "/gui/items.png";
+				break;
+		}
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		super.drawScreen(var1, var2, var3);
+
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_FOG);
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture(this.texture));
+		this.drawTexturedModalRect(0, 0, 0, 0, 128, 128, 128.0F);
+	}
+}
--- net/minecraft/src/EntityZombie.java
+++ net/minecraft/src/EntityZombie.java
@@ -1,9 +1,8 @@
 package net.minecraft.src;
 
-public class EntityZombie extends EntityMob {
+public class EntityZombie extends EntityLeveledMob {
 	public EntityZombie(World var1) {
-		super(var1);
-		this.texture = "/mob/zombie.png";
+		super(var1, "/mob/zombie");
 		this.moveSpeed = 0.5F;
 		this.attackStrength = 5;
 	}
@@ -19,6 +18,13 @@
 		super.onLivingUpdate();
 	}
 
+	public void setLevel(int level) {
+		super.setLevel(level);
+		this.moveSpeed = 0.5F + this.getLevel() * 0.4F;
+		this.attackStrength = 5 + this.getLevel() * 2;
+		this.heartsHalvesLife = 20 + level * 5;
+	}
+
 	protected String getLivingSound() {
 		return "mob.zombie";
 	}
@@ -29,6 +35,10 @@
 
 	protected String getDeathSound() {
 		return "mob.zombiedeath";
+	}
+
+	protected float getSoundPitch() {
+		return 1.0F - this.getLevel() * 0.3F;
 	}
 
 	protected int getDropItemId() {
--- net/minecraft/src/BlockLeaves.java
+++ net/minecraft/src/BlockLeaves.java
@@ -2,95 +2,173 @@
 
 import java.util.Random;
 
+import net.minecraft.client.Minecraft;
 public class BlockLeaves extends BlockLeavesBase {
-	private int leafTexIndex;
-	private int decayCounter = 0;
-
-	protected BlockLeaves(int var1, int var2) {
+	public final BitField fieldType = this.fields.addBitField("type", 6, BlockWood.woodTypeNames);
+	public final BitFlag fieldDecaying = this.fields.addBitFlag("decaying");
+	public final BitFlag fieldPermanent = this.fields.addBitFlag("permanent");
+
+	private final int leafTexIndex;
+	private int[] adjacentTreeBlocks;
+
+	public static boolean instantUpdate;
+
+	public BlockLeaves(int var1, int var2) {
 		super(var1, var2, Material.leaves, false);
 		this.leafTexIndex = var2;
 		this.setTickOnLoad(true);
 	}
 
-	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		this.decayCounter = 0;
-		this.updateCurrentLeaves(var1, var2, var3, var4);
-		super.onNeighborBlockChange(var1, var2, var3, var4, var5);
-	}
-
-	public void updateConnectedLeaves(World var1, int var2, int var3, int var4, int var5) {
-		if(var1.getBlockId(var2, var3, var4) == this.blockID) {
-			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			if(var6 != 0 && var6 == var5 - 1) {
-				this.updateCurrentLeaves(var1, var2, var3, var4);
-			}
-		}
-	}
-
-	public void updateCurrentLeaves(World var1, int var2, int var3, int var4) {
-		if(this.decayCounter++ < 100) {
-			int var5 = var1.getBlockMaterial(var2, var3 - 1, var4).isSolid() ? 16 : 0;
-			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			if(var6 == 0) {
-				var6 = 1;
-				var1.setBlockMetadataWithNotify(var2, var3, var4, 1);
-			}
-
-			var5 = this.getConnectionStrength(var1, var2, var3 - 1, var4, var5);
-			var5 = this.getConnectionStrength(var1, var2, var3, var4 - 1, var5);
-			var5 = this.getConnectionStrength(var1, var2, var3, var4 + 1, var5);
-			var5 = this.getConnectionStrength(var1, var2 - 1, var3, var4, var5);
-			var5 = this.getConnectionStrength(var1, var2 + 1, var3, var4, var5);
-			int var7 = var5 - 1;
-			if(var7 < 10) {
-				var7 = 1;
-			}
-
-			if(var7 != var6) {
-				var1.setBlockMetadataWithNotify(var2, var3, var4, var7);
-				this.updateConnectedLeaves(var1, var2, var3 - 1, var4, var6);
-				this.updateConnectedLeaves(var1, var2, var3 + 1, var4, var6);
-				this.updateConnectedLeaves(var1, var2, var3, var4 - 1, var6);
-				this.updateConnectedLeaves(var1, var2, var3, var4 + 1, var6);
-				this.updateConnectedLeaves(var1, var2 - 1, var3, var4, var6);
-				this.updateConnectedLeaves(var1, var2 + 1, var3, var4, var6);
-			}
-
-		}
-	}
-
-	private int getConnectionStrength(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = var1.getBlockId(var2, var3, var4);
-		if(var6 == Block.wood.blockID) {
-			return 16;
-		} else {
-			if(var6 == this.blockID) {
-				int var7 = var1.getBlockMetadata(var2, var3, var4);
-				if(var7 != 0 && var7 > var5) {
-					return var7;
-				}
-			}
-
-			return var5;
-		}
-	}
-
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
-		int var6 = var1.getBlockMetadata(var2, var3, var4);
-		if(var6 == 0) {
-			this.decayCounter = 0;
-			this.updateCurrentLeaves(var1, var2, var3, var4);
-		} else if(var6 == 1) {
-			this.removeLeaves(var1, var2, var3, var4);
-		} else if(var5.nextInt(10) == 0) {
-			this.updateCurrentLeaves(var1, var2, var3, var4);
-		}
-
-	}
-
-	private void removeLeaves(World var1, int var2, int var3, int var4) {
-		this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
+		if(var1.canDoClientAction() && instantUpdate) {
+			int var6 = var1.getBlockMetadata(var2, var3, var4);
+			if(!this.fieldPermanent.get(var6) && this.fieldDecaying.get(var6)) {
+				byte var7 = 6;
+				int var8 = var7 + 1;
+				byte var9 = 32;
+				int var10 = var9 * var9;
+				int var11 = var9 / 2;
+				if(this.adjacentTreeBlocks == null) {
+					this.adjacentTreeBlocks = new int[var9 * var9 * var9];
+				}
+
+				int var12;
+				if(var1.checkChunksExist(var2 - var8, var3 - var8, var4 - var8, var2 + var8, var3 + var8, var4 + var8)) {
+					var12 = -var7;
+
+					label111:
+					while(true) {
+						int var13;
+						int var14;
+						int var15;
+						if(var12 > var7) {
+							var12 = 1;
+
+							while(true) {
+								if(var12 > 4) {
+									break label111;
+								}
+
+								for(var13 = -var7; var13 <= var7; ++var13) {
+									for(var14 = -var7; var14 <= var7; ++var14) {
+										for(var15 = -var7; var15 <= var7; ++var15) {
+											if(this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11) * var9 + var15 + var11] == var12 - 1) {
+												if(this.adjacentTreeBlocks[(var13 + var11 - 1) * var10 + (var14 + var11) * var9 + var15 + var11] == -2) {
+													this.adjacentTreeBlocks[(var13 + var11 - 1) * var10 + (var14 + var11) * var9 + var15 + var11] = var12;
+												}
+
+												if(this.adjacentTreeBlocks[(var13 + var11 + 1) * var10 + (var14 + var11) * var9 + var15 + var11] == -2) {
+													this.adjacentTreeBlocks[(var13 + var11 + 1) * var10 + (var14 + var11) * var9 + var15 + var11] = var12;
+												}
+
+												if(this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11 - 1) * var9 + var15 + var11] == -2) {
+													this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11 - 1) * var9 + var15 + var11] = var12;
+												}
+
+												if(this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11 + 1) * var9 + var15 + var11] == -2) {
+													this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11 + 1) * var9 + var15 + var11] = var12;
+												}
+
+												if(this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11) * var9 + (var15 + var11 - 1)] == -2) {
+													this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11) * var9 + (var15 + var11 - 1)] = var12;
+												}
+
+												if(this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11) * var9 + var15 + var11 + 1] == -2) {
+													this.adjacentTreeBlocks[(var13 + var11) * var10 + (var14 + var11) * var9 + var15 + var11 + 1] = var12;
+												}
+											}
+										}
+									}
+								}
+
+								++var12;
+							}
+						}
+
+						for(var13 = -var7; var13 <= var7; ++var13) {
+							for(var14 = -var7; var14 <= var7; ++var14) {
+								var15 = var1.getBlockId(var2 + var12, var3 + var13, var4 + var14);
+								if(var15 == Block.wood.blockID) {
+									this.adjacentTreeBlocks[(var12 + var11) * var10 + (var13 + var11) * var9 + var14 + var11] = 0;
+								} else if(var15 == Block.leaves.blockID) {
+									this.adjacentTreeBlocks[(var12 + var11) * var10 + (var13 + var11) * var9 + var14 + var11] = -2;
+								} else {
+									this.adjacentTreeBlocks[(var12 + var11) * var10 + (var13 + var11) * var9 + var14 + var11] = -1;
+								}
+							}
+						}
+
+						++var12;
+					}
+				}
+
+				var12 = this.adjacentTreeBlocks[var11 * var10 + var11 * var9 + var11];
+				if(var12 >= 0) {
+					var1.setBlockMetadata(var2, var3, var4, this.fieldDecaying.set(var6, false));
+				} else {
+					this.fall(var1, var2, var3, var4);
+				}
+			}
+
+		}
+	}
+
+	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
+		byte var5 = 1;
+		int var6 = var5 + 1;
+		if(var1.checkChunksExist(var2 - var6, var3 - var6, var4 - var6, var2 + var6, var3 + var6, var4 + var6)) {
+			for(int var7 = -var5; var7 <= var5; ++var7) {
+				for(int var8 = -var5; var8 <= var5; ++var8) {
+					for(int var9 = -var5; var9 <= var5; ++var9) {
+						int var10 = var1.getBlockId(var2 + var7, var3 + var8, var4 + var9);
+						if(var10 == Block.leaves.blockID) {
+							int var11 = var1.getBlockMetadata(var2 + var7, var3 + var8, var4 + var9);
+							if (!this.fieldPermanent.get(var11)) {
+								var1.setBlockMetadata(var2 + var7, var3 + var8, var4 + var9, this.fieldDecaying.set(var11, true));
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
+		if (!this.fieldPermanent.get(var5)) {
+			instantUpdate = true;
+			this.updateTick(var1, var2, var3, var4, var1.rand);
+			instantUpdate = false;
+		}
+	}
+
+	public void onBlockPlacedBy(World var1, int var2, int var3, int var4, EntityPlayer var5, ItemStack var6) {
+		var1.setBlockMetadata(var2, var3, var4,
+				this.fieldPermanent.set(var1.getBlockMetadata(var2, var3, var4), true));
+	}
+
+	public void fall(World var1, int var2, int var3, int var4) {
+		if (!var1.canDoClientAction() || var1.getBlockId(var2, var3, var4) != this.blockID) {
+			return;
+		}
+
+		EntityFallingSand fallingLeaves = new EntityFallingSand(var1, var2 + 0.5D, var3 + 0.5D, var4 + 0.5D, Block.leaves.blockID);
+		fallingLeaves.setBlockMetadata(this.fieldType.get(var1.getBlockMetadata(var2, var3, var4)));
+		fallingLeaves.breakOnFall = true;
 		var1.setBlockWithNotify(var2, var3, var4, 0);
+		var1.spawnEntityInWorld(fallingLeaves);
+
+		if (instantUpdate) {
+			for (int x = var2 - 1; x <= var2 + 1; x++) {
+				for (int y = var3 - 1; y <= var3 + 1; y++) {
+					for (int z = var4 - 1; z <= var4 + 1; z++) {
+						if (x == var2 && y == var3 && z == var3) continue;
+						if (var1.getBlockId(x, y, z) == this.blockID) {
+							this.updateTick(var1, x, y, z, var1.rand);
+						}
+					}
+				}
+			}
+		}
 	}
 
 	public int quantityDropped(Random var1) {
@@ -98,7 +176,21 @@
 	}
 
 	public int idDropped(int var1, Random var2) {
-		return Block.sapling.blockID;
+		return var2.nextInt(1000) == 0 ? Item.appleGold.shiftedIndex
+				: var2.nextInt(10) == 0 ? Item.appleRed.shiftedIndex
+				: Block.sapling.blockID;
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var2 == Block.sapling.blockID || var2 == Block.leaves.blockID ? this.fieldType.get(var1) : 0;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return 1;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
 	}
 
 	public boolean isOpaqueCube() {
@@ -108,9 +200,45 @@
 	public void setGraphicsLevel(boolean var1) {
 		this.graphicsLevel = var1;
 		this.blockIndexInTexture = this.leafTexIndex + (var1 ? 0 : 1);
-	}
-
-	public void onEntityWalking(World var1, int var2, int var3, int var4, Entity var5) {
-		super.onEntityWalking(var1, var2, var3, var4, var5);
+		Block.opaqueCubeLookup[this.blockID] = this.isOpaqueCube();
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int side, int metadata) {
+		return this.leafTexIndex + this.fieldType.get(metadata) * 32 + (this.graphicsLevel ? 0 : 1);
+	}
+
+	public int colorMultiplier(IBlockAccess var1, int var2, int var3, int var4) {
+		if (this.fieldType.get(var1.getBlockMetadata(var2, var3, var4)) != 2) {
+			return super.colorMultiplier(var1, var2, var3, var4);
+		}
+
+		if (Minecraft.getInstance().options.fancyGraphics < 2) {
+			return 0xFF7F7F;
+		}
+
+		double res = 0.01D;
+		float redFactor = MathHelper.clamp((SimplexNoise.noise3_ImproveXZ(0, var2 * res, var3 * res, var4 * res)
+				* 1.2F + 1.0F) / 2.0F * 0.8F + 0.1F, 0.0F, 1.0F);
+		int gb = (int)(255 - redFactor * 255.0F);
+		return 255 << 16 | gb << 8 | gb;
+	}
+
+	public float getBlockBrightness(IBlockAccess var1, int var2, int var3, int var4) {
+		if (!Minecraft.getInstance().options.ambientOcclusion || Minecraft.getInstance().options.fancyGraphics < 2) {
+			return super.getBlockBrightness(var1, var2, var3, var4);
+		}
+
+		boolean oldGraphicsLevel = this.graphicsLevel;
+		this.graphicsLevel = false;
+
+		for (int i = 0; i < 6; i++) {
+			if (super.shouldSideBeRendered(var1, var2, var3, var4, i)) {
+				this.graphicsLevel = oldGraphicsLevel;
+				return super.getBlockBrightness(var1, var2, var3, var4);
+			}
+		}
+
+		this.graphicsLevel = oldGraphicsLevel;
+		return super.getBlockBrightness(var1, var2, var3, var4) * 0.5F;
 	}
 }
--- /dev/null
+++ net/minecraft/src/PopulatorHost.java
@@ -1,0 +1,88 @@
+package net.minecraft.src;
+
+import java.util.Random;
+
+public class PopulatorHost {
+	public final IChunkProvider chunkProvider;
+	public final int x;
+	public final int z;
+	public final World worldObj;
+	public final Random rand;
+	public final NoiseGeneratorOctaves noise;
+
+	public PopulatorHost(IChunkProvider chunkProvider, int x, int z, World worldObj, Random rand, NoiseGeneratorOctaves noise) {
+		this.chunkProvider = chunkProvider;
+		this.x = x;
+		this.z = z;
+		this.worldObj = worldObj;
+		this.rand = rand;
+		this.noise = noise;
+	}
+
+	//#region Generate Methods
+	public void generate(WorldGenerator gen, int quantity) {
+		generate(gen, quantity, 0, 128, 0);
+	}
+
+	public void generate(WorldGenerator gen, int quantity, int minY, int maxY) {
+		generate(gen, quantity, minY, maxY, 0);
+	}
+
+	public void generate(WorldGenerator gen, int quantity, int minY, int maxY, int xzOffset) {
+		for (int i = 0; i < quantity; i++) {
+			int genX = x + rand.nextInt(16) + xzOffset;
+			int genY = minY == maxY ? minY : rand.nextInt(maxY - minY) + minY;
+			int genZ = z + rand.nextInt(16) + xzOffset;
+			gen.generate(worldObj, rand, genX, genY, genZ);
+		}
+	}
+
+	public void generateSurface(WorldGenerator gen, int quantity) {
+		generateSurface(gen, quantity, 0);
+	}
+
+	public void generateSurface(WorldGenerator gen, int quantity, int xzOffset) {
+		for (int i = 0; i < quantity; i++) {
+			int genX = x + rand.nextInt(16) + xzOffset;
+			int genZ = z + rand.nextInt(16) + xzOffset;
+			int genY = worldObj.getHeightValue(genX, genZ);
+			gen.generate(worldObj, rand, genX, genY, genZ);
+		}
+	}
+
+	public void generateChance(WorldGenerator gen, int chance) {
+		generateChance(gen, chance, 0, 256, 0);
+	}
+
+	public void generateChance(WorldGenerator gen, int chance, int minY, int maxY) {
+		generateChance(gen, chance, minY, maxY, 0);
+	}
+
+	public void generateChance(WorldGenerator gen, int chance, int minY, int maxY, int xzOffset) {
+		if (rand.nextInt(chance) == 0) {
+			int genX = x + rand.nextInt(16) + xzOffset;
+			int genY = rand.nextInt(maxY - minY) + minY;
+			int genZ = z + rand.nextInt(16) + xzOffset;
+			gen.generate(worldObj, rand, genX, genY, genZ);
+		}
+	}
+
+	public void generateMinable(Block block, int size, int quantity, int minY, int maxY) {
+		generate(new WorldGenMinable(block.blockID, size), quantity, minY, maxY);
+	}
+
+	public void generateMinable(Block block, int size, int quantity, int minY, int maxY, int metadata) {
+		generate(new WorldGenMinable(block.blockID, size, metadata), quantity, minY, maxY);
+	}
+
+	public void generateMinableInStone(Block block, int size, int quantity, int minY, int maxY) {
+		generate(new WorldGenMinable(block.blockID, size).mergeWithStone(), quantity, minY, maxY);
+	}
+
+	public void generateFlowers(int frequency) {
+		generate(new WorldGenFlowers(Block.plantYellow.blockID), frequency, 112, 192, 8);
+		generate(new WorldGenFlowers(Block.plantBlue.blockID), frequency, 112, 192, 8);
+		generate(new WorldGenFlowers(Block.plantRed.blockID), frequency, 112, 192, 8);
+	}
+	//#endregion Generate Methods
+}
--- /dev/null
+++ net/minecraft/src/BiomeDesert.java
@@ -1,0 +1,27 @@
+package net.minecraft.src;
+
+public class BiomeDesert extends Biome {
+	protected BiomeDesert(int id, String name, float priority, ClimateZone... climateZones) {
+		super(id, name, priority, climateZones);
+	}
+
+	public void populate(PopulatorHost host) {
+		int cactiCount = host.rand.nextInt(5) - 2;
+		if (cactiCount > 0)
+			host.generateSurface(new WorldGenCactus().withScale(4, 1, 0), cactiCount, 8);
+	}
+
+	public Block getSurface() {
+		return Block.sand;
+	}
+	public Block getSoil() {
+		return Block.sand;
+	}
+	public int getStoneMetadata() {
+		return 3;
+	}
+
+	public int[] getMapColor() {
+		return new int[] { 255, 128, 0 };
+	}
+}
--- net/minecraft/src/MapGenCaves.java
+++ net/minecraft/src/MapGenCaves.java
@@ -1,18 +1,20 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.util.Random;
 
 public class MapGenCaves extends MapGenBase {
-	protected void generateLargeCaveNode(int var1, int var2, byte[] var3, double var4, double var6, double var8) {
-		this.generateCaveNode(var1, var2, var3, var4, var6, var8, 1.0F + this.rand.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5D);
+	protected void generateLargeCaveNode(long seed, int var1, int var2, short[] var3, double var4, double var6, double var8) {
+		this.generateCaveNode(seed, var1, var2, var3, var4, var6, var8, 1.0F + this.rand.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5D);
 	}
 
-	protected void generateCaveNode(int var1, int var2, byte[] var3, double var4, double var6, double var8, float var10, float var11, float var12, int var13, int var14, double var15) {
+	protected void generateCaveNode(long seed, int var1, int var2, short[] var3, double var4, double var6, double var8, float var10, float var11, float var12, int var13, int var14, double var15) {
 		double var17 = (double)(var1 * 16 + 8);
 		double var19 = (double)(var2 * 16 + 8);
 		float var21 = 0.0F;
 		float var22 = 0.0F;
-		Random var23 = new Random(this.rand.nextLong());
+		Random var23 = new Random(seed);
 		if(var14 <= 0) {
 			int var24 = this.range * 16 - 16;
 			var14 = var24 - var23.nextInt(var24 / 4);
@@ -47,8 +49,8 @@
 			var22 += (var23.nextFloat() - var23.nextFloat()) * var23.nextFloat() * 2.0F;
 			var21 += (var23.nextFloat() - var23.nextFloat()) * var23.nextFloat() * 4.0F;
 			if(!var52 && var13 == var25 && var10 > 1.0F) {
-				this.generateCaveNode(var1, var2, var3, var4, var6, var8, var23.nextFloat() * 0.5F + 0.5F, var11 - (float)Math.PI * 0.5F, var12 / 3.0F, var13, var14, 1.0D);
-				this.generateCaveNode(var1, var2, var3, var4, var6, var8, var23.nextFloat() * 0.5F + 0.5F, var11 + (float)Math.PI * 0.5F, var12 / 3.0F, var13, var14, 1.0D);
+				this.generateCaveNode(var23.nextLong(), var1, var2, var3, var4, var6, var8, var23.nextFloat() * 0.5F + 0.5F, var11 - (float)Math.PI * 0.5F, var12 / 3.0F, var13, var14, 1.0D);
+				this.generateCaveNode(var23.nextLong(), var1, var2, var3, var4, var6, var8, var23.nextFloat() * 0.5F + 0.5F, var11 + (float)Math.PI * 0.5F, var12 / 3.0F, var13, var14, 1.0D);
 				return;
 			}
 
@@ -76,12 +78,12 @@
 						var34 = 16;
 					}
 
-					if(var54 < 1) {
-						var54 = 1;
+					if(var54 < 33) {
+						var54 = 33;
 					}
 
-					if(var36 > 120) {
-						var36 = 120;
+					if(var36 > 176) {
+						var36 = 176;
 					}
 
 					if(var55 < 0) {
@@ -99,8 +101,8 @@
 					for(var40 = var53; !var56 && var40 < var34; ++var40) {
 						for(int var41 = var55; !var56 && var41 < var38; ++var41) {
 							for(int var42 = var36 + 1; !var56 && var42 >= var54 - 1; --var42) {
-								var43 = (var40 * 16 + var41) * 128 + var42;
-								if(var42 >= 0 && var42 < 128) {
+								var43 = (var40 * 16 + var41) * CHUNK_HEIGHT + var42;
+								if(var42 >= 0 && var42 < CHUNK_HEIGHT) {
 									if(var3[var43] == Block.waterMoving.blockID || var3[var43] == Block.waterStill.blockID) {
 										var56 = true;
 									}
@@ -119,25 +121,21 @@
 
 							for(var43 = var55; var43 < var38; ++var43) {
 								double var44 = ((double)(var43 + var2 * 16) + 0.5D - var8) / var27;
-								int var46 = (var40 * 16 + var43) * 128 + var36;
+								int var46 = (var40 * 16 + var43) * CHUNK_HEIGHT + var36;
 								boolean var47 = false;
 
 								for(int var48 = var36 - 1; var48 >= var54; --var48) {
 									double var49 = ((double)var48 + 0.5D - var6) / var29;
 									if(var49 > -0.7D && var57 * var57 + var49 * var49 + var44 * var44 < 1.0D) {
-										byte var51 = var3[var46];
+										short var51 = var3[var46];
 										if(var51 == Block.grass.blockID) {
 											var47 = true;
 										}
 
 										if(var51 == Block.stone.blockID || var51 == Block.dirt.blockID || var51 == Block.grass.blockID) {
-											if(var48 < 10) {
-												var3[var46] = (byte)Block.lavaMoving.blockID;
-											} else {
-												var3[var46] = 0;
-												if(var47 && var3[var46 - 1] == Block.dirt.blockID) {
-													var3[var46 - 1] = (byte)Block.grass.blockID;
-												}
+											var3[var46] = 0;
+											if(var47 && var3[var46 - 1] == Block.dirt.blockID) {
+												var3[var46 - 1] = (short)Block.grass.blockID;
 											}
 										}
 									}
@@ -157,27 +155,27 @@
 
 	}
 
-	protected void recursiveGenerate(World var1, int var2, int var3, int var4, int var5, byte[] var6) {
-		int var7 = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(40) + 1) + 1);
-		if(this.rand.nextInt(15) != 0) {
+	protected void recursiveGenerate(World var1, int var2, int var3, int var4, int var5, short[] var6) {
+		int var7 = this.rand.nextInt(this.rand.nextInt(this.rand.nextInt(60) + 1) + 1);
+		if(this.rand.nextInt(10) != 0) {
 			var7 = 0;
 		}
 
 		for(int var8 = 0; var8 < var7; ++var8) {
 			double var9 = (double)(var2 * 16 + this.rand.nextInt(16));
-			double var11 = (double)this.rand.nextInt(this.rand.nextInt(120) + 8);
+			double var11 = (double)this.rand.nextInt(this.rand.nextInt(96) + 32) + 64;
 			double var13 = (double)(var3 * 16 + this.rand.nextInt(16));
 			int var15 = 1;
 			if(this.rand.nextInt(4) == 0) {
-				this.generateLargeCaveNode(var4, var5, var6, var9, var11, var13);
+				this.generateLargeCaveNode(this.rand.nextLong(), var4, var5, var6, var9, var11, var13);
 				var15 += this.rand.nextInt(4);
 			}
 
 			for(int var16 = 0; var16 < var15; ++var16) {
 				float var17 = this.rand.nextFloat() * (float)Math.PI * 2.0F;
-				float var18 = (this.rand.nextFloat() - 0.5F) * 2.0F / 8.0F;
-				float var19 = this.rand.nextFloat() * 2.0F + this.rand.nextFloat();
-				this.generateCaveNode(var4, var5, var6, var9, var11, var13, var19, var17, var18, 0, 0, 1.0D);
+				float var18 = (this.rand.nextFloat() - 0.5F) / 4.0F;
+				float var19 = this.rand.nextFloat() * 6.0F;
+				this.generateCaveNode(this.rand.nextLong(), var4, var5, var6, var9, var11, var13, var19, var17, var18, 0, 0, 1.0D);
 			}
 		}
 
--- net/minecraft/src/Packet5PlayerInventory.java
+++ net/minecraft/src/Packet5PlayerInventory.java
@@ -5,52 +5,43 @@
 import java.io.IOException;
 
 public class Packet5PlayerInventory extends Packet {
-	public int inventoryType;
-	public ItemStack[] inventory;
+	public int entityID;
+	public int slot;
+	public int itemID;
+	public int itemDamage;
+	public int itemMetadata;
 
 	public Packet5PlayerInventory() {
 	}
 
-	public Packet5PlayerInventory(int var1, ItemStack[] var2) {
-		this.inventoryType = var1;
-		this.inventory = new ItemStack[var2.length];
-
-		for(int var3 = 0; var3 < this.inventory.length; ++var3) {
-			this.inventory[var3] = var2[var3] == null ? null : var2[var3].copy();
+	public Packet5PlayerInventory(int var1, int var2, ItemStack var3) {
+		this.entityID = var1;
+		this.slot = var2;
+		if (var3 == null) {
+			this.itemID = -1;
+			this.itemDamage = 0;
+			this.itemMetadata = 0;
+		} else {
+			this.itemID = var3.itemID;
+			this.itemDamage = var3.itemDmg;
+			this.itemMetadata = var3.itemMetadata;
 		}
-
 	}
 
 	public void readPacketData(DataInputStream var1) throws IOException {
-		this.inventoryType = var1.readInt();
-		short var2 = var1.readShort();
-		this.inventory = new ItemStack[var2];
-
-		for(int var3 = 0; var3 < var2; ++var3) {
-			short var4 = var1.readShort();
-			if(var4 >= 0) {
-				byte var5 = var1.readByte();
-				short var6 = var1.readShort();
-				this.inventory[var3] = new ItemStack(var4, var5, var6);
-			}
-		}
-
+		this.entityID = var1.readInt();
+		this.slot = var1.readShort();
+		this.itemID = var1.readShort();
+		this.itemDamage = var1.readShort();
+		this.itemMetadata = var1.readByte();
 	}
 
 	public void writePacket(DataOutputStream var1) throws IOException {
-		var1.writeInt(this.inventoryType);
-		var1.writeShort(this.inventory.length);
-
-		for(int var2 = 0; var2 < this.inventory.length; ++var2) {
-			if(this.inventory[var2] == null) {
-				var1.writeShort(-1);
-			} else {
-				var1.writeShort((short)this.inventory[var2].itemID);
-				var1.writeByte((byte)this.inventory[var2].stackSize);
-				var1.writeShort((short)this.inventory[var2].itemDmg);
-			}
-		}
-
+		var1.writeInt(this.entityID);
+		var1.writeShort(this.slot);
+		var1.writeShort(this.itemID);
+		var1.writeShort(this.itemDamage);
+		var1.writeByte(this.itemMetadata);
 	}
 
 	public void processPacket(NetHandler var1) {
@@ -58,6 +49,6 @@
 	}
 
 	public int getPacketSize() {
-		return 6 + this.inventory.length * 5;
+		return 11;
 	}
 }
--- net/minecraft/src/EnumOS.java
+++ net/minecraft/src/EnumOS.java
@@ -5,5 +5,5 @@
 	solaris,
 	windows,
 	macos,
-	unknown;
+	unknown
 }
--- /dev/null
+++ net/minecraft/src/RenderPhantom.java
@@ -1,0 +1,20 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+public class RenderPhantom extends RenderLiving {
+	public RenderPhantom(ModelBase var1, float var2) {
+		super(var1, var2);
+	}
+
+	public void doRenderLiving(EntityLiving var1, double var2, double var4, double var6, float var8, float var9) {
+		GL11.glEnable(GL11.GL_BLEND);
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glBlendFunc(GL11.GL_DST_COLOR, GL11.GL_SRC_COLOR);
+
+		super.doRenderLiving(var1, var2, var4, var6, var8, var9);
+
+		GL11.glDisable(GL11.GL_BLEND);
+		GL11.glEnable(GL11.GL_LIGHTING);
+	}
+}
--- net/minecraft/src/EntitySheep.java
+++ net/minecraft/src/EntitySheep.java
@@ -1,17 +1,16 @@
 package net.minecraft.src;
 
 public class EntitySheep extends EntityAnimal {
-	public boolean sheared = false;
-
 	public EntitySheep(World var1) {
 		super(var1);
 		this.texture = "/mob/sheep.png";
 		this.setSize(0.9F, 1.3F);
+		this.dataWatcher.addObject(16, (byte)0);
 	}
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
-		if(!this.sheared && var1 instanceof EntityLiving) {
-			this.sheared = true;
+		if(!this.getSheared() && var1 instanceof EntityLiving && this.worldObj.canDoClientAction()) {
+			this.setSheared(true);
 			int var3 = 1 + this.rand.nextInt(3);
 
 			for(int var4 = 0; var4 < var3; ++var4) {
@@ -27,12 +26,12 @@
 
 	public void writeEntityToNBT(NBTTagCompound var1) {
 		super.writeEntityToNBT(var1);
-		var1.setBoolean("Sheared", this.sheared);
+		var1.setBoolean("Sheared", this.getSheared());
 	}
 
 	public void readEntityFromNBT(NBTTagCompound var1) {
 		super.readEntityFromNBT(var1);
-		this.sheared = var1.getBoolean("Sheared");
+		this.setSheared(var1.getBoolean("Sheared"));
 	}
 
 	protected String getLivingSound() {
@@ -45,5 +44,22 @@
 
 	protected String getDeathSound() {
 		return "mob.sheep";
+	}
+
+	protected int getDropItemId() {
+		return Item.muttonRaw.shiftedIndex;
+	}
+
+	public boolean getSheared() {
+		return (this.dataWatcher.getWatchableObjectByte(16) & 16) != 0;
+	}
+
+	public void setSheared(boolean var1) {
+		byte var2 = this.dataWatcher.getWatchableObjectByte(16);
+		if(var1) {
+			this.dataWatcher.updateObject(16, (byte)(var2 | 16));
+		} else {
+			this.dataWatcher.updateObject(16, (byte)(var2 & -17));
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet102WindowClick.java
@@ -1,0 +1,66 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet102WindowClick extends Packet {
+	public int window_Id;
+	public int inventorySlot;
+	public int mouseClick;
+	public short action;
+	public ItemStack itemStack;
+
+	public Packet102WindowClick() {
+	}
+
+	public Packet102WindowClick(int var1, int var2, int var3, ItemStack var4, short var5) {
+		this.window_Id = var1;
+		this.inventorySlot = var2;
+		this.mouseClick = var3;
+		this.itemStack = var4;
+		this.action = var5;
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleWindowClick(this);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.window_Id = var1.readByte();
+		this.inventorySlot = var1.readShort();
+		this.mouseClick = var1.readByte();
+		this.action = var1.readShort();
+		short var2 = var1.readShort();
+		if(var2 >= 0) {
+			byte var3 = var1.readByte();
+			short var4 = var1.readShort();
+			byte var5 = var1.readByte();
+			this.itemStack = new ItemStack(var2, var3, var4, var5 & 0xFF).withStorage(Packet.readNBT(var1));
+		} else {
+			this.itemStack = null;
+		}
+
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeByte(this.window_Id);
+		var1.writeShort(this.inventorySlot);
+		var1.writeByte(this.mouseClick);
+		var1.writeShort(this.action);
+		if(this.itemStack == null) {
+			var1.writeShort(-1);
+		} else {
+			var1.writeShort(this.itemStack.itemID);
+			var1.writeByte(this.itemStack.stackSize);
+			var1.writeShort(this.itemStack.itemDmg);
+			var1.writeByte(this.itemStack.itemMetadata);
+			Packet.writeNBT(this.itemStack.storage, var1);
+		}
+
+	}
+
+	public int getPacketSize() {
+		return 13;
+	}
+}
--- net/minecraft/src/FontRenderer.java
+++ net/minecraft/src/FontRenderer.java
@@ -8,8 +8,9 @@
 
 public class FontRenderer {
 	private int[] charWidth = new int[256];
-	public int fontTextureName = 0;
+	public int fontTextureName;
 	private int fontDisplayLists;
+	private int boldFontDisplayLists;
 	private IntBuffer buffer = GLAllocation.createDirectIntBuffer(1024);
 
 	public FontRenderer(GameSettings var1, String var2, RenderEngine var3) {
@@ -61,6 +62,7 @@
 
 		this.fontTextureName = var3.allocateAndSetupTexture(var4);
 		this.fontDisplayLists = GLAllocation.generateDisplayLists(288);
+		this.boldFontDisplayLists = GLAllocation.generateDisplayLists(288);
 		Tessellator var19 = Tessellator.instance;
 
 		for(var9 = 0; var9 < 256; ++var9) {
@@ -78,6 +80,21 @@
 			var19.draw();
 			GL11.glTranslatef((float)this.charWidth[var9], 0.0F, 0.0F);
 			GL11.glEndList();
+
+			GL11.glNewList(this.boldFontDisplayLists + var9, GL11.GL_COMPILE);
+			var19.startDrawingQuads();
+			var10 = var9 % 16 * 8;
+			var11 = var9 / 16 * 8;
+			var20 = 7.99F;
+			var21 = 0.0F;
+			var23 = 0.0F;
+			var19.addVertexWithUV(0.0D, (double)(0.0F + var20), 0.0D, (double)((float)var10 / 128.0F + var21), (double)(((float)var11 + var20) / 128.0F + var23));
+			var19.addVertexWithUV((double)(0.0F + var20), (double)(0.0F + var20), 0.0D, (double)(((float)var10 + var20) / 128.0F + var21), (double)(((float)var11 + var20) / 128.0F + var23));
+			var19.addVertexWithUV((double)(0.0F + var20), 0.0D, 0.0D, (double)(((float)var10 + var20) / 128.0F + var21), (double)((float)var11 / 128.0F + var23));
+			var19.addVertexWithUV(0.0D, 0.0D, 0.0D, (double)((float)var10 / 128.0F + var21), (double)((float)var11 / 128.0F + var23));
+			var19.draw();
+			GL11.glTranslatef((float)this.charWidth[var9] + 1.0F, 0.0F, 0.0F);
+			GL11.glEndList();
 		}
 
 		for(var9 = 0; var9 < 32; ++var9) {
@@ -108,20 +125,32 @@
 			GL11.glNewList(this.fontDisplayLists + 256 + var9, GL11.GL_COMPILE);
 			GL11.glColor3f((float)var11 / 255.0F, (float)var12 / 255.0F, (float)var22 / 255.0F);
 			GL11.glEndList();
+
+			GL11.glNewList(this.boldFontDisplayLists + 256 + var9, GL11.GL_COMPILE);
+			GL11.glColor3f((float)var11 / 255.0F, (float)var12 / 255.0F, (float)var22 / 255.0F);
+			GL11.glEndList();
 		}
 
 	}
 
 	public void drawStringWithShadow(String var1, int var2, int var3, int var4) {
-		this.renderString(var1, var2 + 1, var3 + 1, var4, true);
-		this.drawString(var1, var2, var3, var4);
+		this.renderString(var1, var2 + 1, var3 + 1, var4, true, false);
+		this.renderString(var1, var2, var3, var4, false, false);
 	}
 
 	public void drawString(String var1, int var2, int var3, int var4) {
-		this.renderString(var1, var2, var3, var4, false);
-	}
-
-	public void renderString(String var1, int var2, int var3, int var4, boolean var5) {
+		this.renderString(var1, var2, var3, var4, false, false);
+	}
+
+	public void drawBoldStringWithShadow(String var1, int var2, int var3, int var4) {
+		this.renderString(var1, var2 + 1, var3 + 1, var4, true, true);
+		this.renderString(var1, var2 + 2, var3 + 1, var4, true, true);
+		this.renderString(var1, var2, var3, var4, false, true);
+		this.renderString(var1, var2 + 1, var3, var4, false, true);
+	}
+
+	public void renderString(String var1, int var2, int var3, int var4, boolean var5, boolean bold) {
+		int lists = bold ? this.boldFontDisplayLists : this.fontDisplayLists;
 		if(var1 != null) {
 			int var6;
 			if(var5) {
@@ -152,7 +181,7 @@
 						var11 = 15;
 					}
 
-					this.buffer.put(this.fontDisplayLists + 256 + var11 + (var5 ? 16 : 0));
+					this.buffer.put(lists + 256 + var11 + (var5 ? 16 : 0));
 					if(this.buffer.remaining() == 0) {
 						this.buffer.flip();
 						GL11.glCallLists(this.buffer);
@@ -162,7 +191,7 @@
 
 				var11 = " !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\'abcdefghijklmnopqrstuvwxyz{|}~\u2302\u00c7\u00fc\u00e9\u00e2\u00e4\u00e0\u00e5\u00e7\u00ea\u00eb\u00e8\u00ef\u00ee\u00ec\u00c4\u00c5\u00c9\u00e6\u00c6\u00f4\u00f6\u00f2\u00fb\u00f9\u00ff\u00d6\u00dc\u00f8\u00a3\u00d8\u00d7\u0192\u00e1\u00ed\u00f3\u00fa\u00f1\u00d1\u00aa\u00ba\u00bf\u00ae\u00ac\u00bd\u00bc\u00a1\u00ab\u00bb".indexOf(var1.charAt(var6));
 				if(var11 >= 0) {
-					this.buffer.put(this.fontDisplayLists + var11 + 32);
+					this.buffer.put(lists + var11 + 32);
 				}
 
 				if(this.buffer.remaining() == 0) {
@@ -179,6 +208,10 @@
 	}
 
 	public int getStringWidth(String var1) {
+		return this.getStringWidth(var1, false);
+	}
+
+	public int getStringWidth(String var1, boolean bold) {
 		if(var1 == null) {
 			return 0;
 		} else {
@@ -191,11 +224,26 @@
 					int var4 = " !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\'abcdefghijklmnopqrstuvwxyz{|}~\u2302\u00c7\u00fc\u00e9\u00e2\u00e4\u00e0\u00e5\u00e7\u00ea\u00eb\u00e8\u00ef\u00ee\u00ec\u00c4\u00c5\u00c9\u00e6\u00c6\u00f4\u00f6\u00f2\u00fb\u00f9\u00ff\u00d6\u00dc\u00f8\u00a3\u00d8\u00d7\u0192\u00e1\u00ed\u00f3\u00fa\u00f1\u00d1\u00aa\u00ba\u00bf\u00ae\u00ac\u00bd\u00bc\u00a1\u00ab\u00bb".indexOf(var1.charAt(var3));
 					if(var4 >= 0) {
 						var2 += this.charWidth[var4 + 32];
+						if (bold) var2++;
 					}
 				}
 			}
 
 			return var2;
+		}
+	}
+
+	public void drawStringWrapped(String var1, int var2, int var3, int var4, int var5) {
+		int x = 0;
+		int y = 0;
+		for (String str : var1.split("\\s+")) {
+			int width = this.getStringWidth(str);
+			if (x > 0 && x + width > var4) {
+				x = 0;
+				y += 9;
+			}
+			this.drawStringWithShadow(str, x + var2, y + var3, var5);
+			x += width + 4;
 		}
 	}
 }
--- /dev/null
+++ net/minecraft/src/RegionFileCache.java
@@ -1,0 +1,76 @@
+package net.minecraft.src;
+
+/*
+** 2011 January 5
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+*/
+
+// A simple cache and wrapper for efficiently multiple RegionFiles simultaneously.
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.lang.ref.SoftReference;
+import java.util.HashMap;
+import java.util.Map;
+
+public class RegionFileCache {
+	private static final Map<File, Reference<RegionFile>> cache = new HashMap<File, Reference<RegionFile>>();
+
+	private RegionFileCache() { }
+
+	public static synchronized RegionFile getRegionFile(File basePath, int x, int z) {
+		File regionDir = new File(basePath, "region");
+		File file = new File(regionDir, "r." + (x >> 5) + "." + (z >> 5) + ".mcr");
+
+		Reference<RegionFile> ref = cache.get(file);
+
+		if (ref != null && ref.get() != null)
+			return ref.get();
+
+		if (!regionDir.exists())
+			regionDir.mkdirs();
+
+		if (cache.size() >= 256)
+			clear();
+
+		RegionFile reg = new RegionFile(file);
+		cache.put(file, new SoftReference<RegionFile>(reg));
+		return reg;
+	}
+
+	public static synchronized void clear() {
+		for (Reference<RegionFile> ref : cache.values()) {
+			try {
+				if (ref.get() != null)
+					ref.get().close();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		cache.clear();
+	}
+
+	public static int getSizeDelta(File basePath, int x, int z) {
+		RegionFile r = getRegionFile(basePath, x, z);
+		return r.getSizeDelta();
+	}
+
+	public static DataInputStream getChunkDataInputStream(File basePath, int x, int z) {
+		RegionFile r = getRegionFile(basePath, x, z);
+		return r.getChunkDataInputStream(x & 31, z & 31);
+	}
+
+	public static DataOutputStream getChunkDataOutputStream(File basePath, int x, int z) {
+		RegionFile r = getRegionFile(basePath, x, z);
+		return r.getChunkDataOutputStream(x & 31, z & 31);
+	}
+}
--- net/minecraft/src/NBTTagByte.java
+++ net/minecraft/src/NBTTagByte.java
@@ -14,11 +14,11 @@
 		this.byteValue = var1;
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeByte(this.byteValue);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.byteValue = var1.readByte();
 	}
 
@@ -27,6 +27,10 @@
 	}
 
 	public String toString() {
-		return "" + this.byteValue;
+		return String.valueOf(this.byteValue);
+	}
+
+	public NBTBase copy() {
+		return new NBTTagByte(this.byteValue).setKey(this.getKey());
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet25EntityPainting.java
@@ -1,0 +1,52 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet25EntityPainting extends Packet {
+	public int entityId;
+	public int xPosition;
+	public int yPosition;
+	public int zPosition;
+	public int direction;
+	public String title;
+
+	public Packet25EntityPainting() {
+	}
+
+	public Packet25EntityPainting(EntityPainting var1) {
+		this.entityId = var1.entityID;
+		this.title = var1.art.title;
+		this.xPosition = var1.xPosition;
+		this.yPosition = var1.yPosition;
+		this.zPosition = var1.zPosition;
+		this.direction = var1.direction;
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.entityId = var1.readInt();
+		this.title = readString(var1, EnumArt.maxArtTitleLength);
+		this.xPosition = var1.readInt();
+		this.yPosition = var1.readInt();
+		this.zPosition = var1.readInt();
+		this.direction = var1.readInt();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeInt(this.entityId);
+		writeString(this.title, var1);
+		var1.writeInt(this.xPosition);
+		var1.writeInt(this.yPosition);
+		var1.writeInt(this.zPosition);
+		var1.writeInt(this.direction);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleEntityPainting(this);
+	}
+
+	public int getPacketSize() {
+		return 24;
+	}
+}
--- net/minecraft/src/GuiSelectWorld.java
+++ net/minecraft/src/GuiSelectWorld.java
@@ -1,55 +1,89 @@
 package net.minecraft.src;
 
 import java.io.File;
+import java.util.List;
+import java.util.stream.Collectors;
+
 import net.minecraft.client.Minecraft;
-
 public class GuiSelectWorld extends GuiScreen {
 	protected GuiScreen parentScreen;
 	protected String screenTitle = "Select world";
 	private boolean selected = false;
+	private int currentPage;
+	private static final int maxPages = 100 / 5;
+	private File mcDir = Minecraft.getMinecraftDir();
 
 	public GuiSelectWorld(GuiScreen var1) {
 		this.parentScreen = var1;
+		if (var1 instanceof GuiSelectWorld) {
+			this.currentPage = ((GuiSelectWorld) var1).currentPage;
+		}
 	}
 
 	public void initGui() {
-		File var1 = Minecraft.getMinecraftDir();
+		this.controlList.clear();
+		this.initPage();
+		this.initButtons();
+	}
 
+	public void initPage() {
+		this.controlList = (List) this.controlList.stream().filter(button -> ((GuiButton) button).id >= 100).collect(Collectors.toList());
 		for(int var2 = 0; var2 < 5; ++var2) {
-			NBTTagCompound var3 = World.getLevelData(var1, "World" + (var2 + 1));
+			int var22 = var2 + this.currentPage * 5;
+			NBTTagCompound var3 = World.getLevelData(mcDir, "World" + (var22 + 1));
 			if(var3 == null) {
-				this.controlList.add(new GuiButton(var2, this.width / 2 - 100, this.height / 6 + 24 * var2, "- empty -"));
+				this.controlList.add(new GuiButton(var22, this.width / 2 - 100, this.height / 6 + 24 * var2, "- empty -"));
 			} else {
-				String var4 = "World " + (var2 + 1);
+				String var4 = var3.getString("DisplayName");
+				if(var4.isEmpty()) {
+					var4 = "World " + (var22 + 1);
+				}
 				long var5 = var3.getLong("SizeOnDisk");
 				var4 = var4 + " (" + (float)(var5 / 1024L * 100L / 1024L) / 100.0F + " MB)";
-				this.controlList.add(new GuiButton(var2, this.width / 2 - 100, this.height / 6 + 24 * var2, var4));
+				this.controlList.add(new GuiButton(var22, this.width / 2 - 100, this.height / 6 + 24 * var2, var4));
 			}
 		}
-
-		this.initButtons();
 	}
 
 	protected String getSaveName(int var1) {
 		File var2 = Minecraft.getMinecraftDir();
-		return World.getLevelData(var2, "World" + var1) != null ? "World" + var1 : null;
+		NBTTagCompound data = World.getLevelData(var2, "World" + var1);
+		if (data == null) {
+			return null;
+		}
+
+		String displayName = data.getString("DisplayName");
+		if (displayName.isEmpty()) {
+			return "World" + var1;
+		}
+		return displayName;
 	}
 
 	public void initButtons() {
-		this.controlList.add(new GuiButton(5, this.width / 2 - 100, this.height / 6 + 120 + 12, "Delete world..."));
-		this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 6 + 168, "Cancel"));
+		this.controlList.add(new GuiButton(100, this.width / 2 - 100, this.height / 6 + 132, 100, 20, "Delete world..."));
+		this.controlList.add(new GuiButton(101, this.width / 2 - 100, this.height / 6 + 168, "Cancel"));
+		this.controlList.add(new GuiButton(102, this.width / 2 - 140, this.height / 6 + 132, 20, 20, "<"));
+		this.controlList.add(new GuiButton(103, this.width / 2 + 120, this.height / 6 + 132, 20, 20, ">"));
+		this.controlList.add(new GuiButton(104, this.width / 2, this.height / 6 + 132, 100, 20, "Create temporary"));
 	}
 
 	protected void actionPerformed(GuiButton var1) {
 		if(var1.enabled) {
-			if(var1.id < 5) {
+			if(var1.id < 100) {
 				this.selectWorld(var1.id + 1);
-			} else if(var1.id == 5) {
+			} else if(var1.id == 100) {
 				this.mc.displayGuiScreen(new GuiDeleteWorld(this));
-			} else if(var1.id == 6) {
+			} else if(var1.id == 101) {
 				this.mc.displayGuiScreen(this.parentScreen);
+			} else if(var1.id == 102 && this.currentPage > 0) {
+				this.currentPage--;
+				this.initPage();
+			} else if(var1.id == 103 && this.currentPage < maxPages - 1) {
+				this.currentPage++;
+				this.initPage();
+			} else if(var1.id == 104) {
+				this.selectWorld(-1);
 			}
-
 		}
 	}
 
@@ -57,6 +91,13 @@
 		this.mc.displayGuiScreen((GuiScreen)null);
 		if(!this.selected) {
 			this.selected = true;
+
+			NBTTagCompound var3 = World.getLevelData(Minecraft.getMinecraftDir(), "World" + var1);
+			if(var3 == null) {
+				this.mc.displayGuiScreen(new GuiCreateWorld(this));
+				return;
+			}
+
 			this.mc.playerController = new PlayerControllerSP(this.mc);
 			this.mc.startWorld("World" + var1);
 			this.mc.displayGuiScreen((GuiScreen)null);
@@ -64,8 +105,9 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 20, 16777215);
+		this.drawCenteredString(this.fontRenderer, (this.currentPage + 1) + " / " + maxPages, this.width / 2, this.height - 10, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
 }
--- net/minecraft/src/GuiChest.java
+++ net/minecraft/src/GuiChest.java
@@ -5,50 +5,31 @@
 public class GuiChest extends GuiContainer {
 	private IInventory upperChestInventory;
 	private IInventory lowerChestInventory;
-	private int inventoryRows = 0;
+	private int field_980_m = 0;
 
 	public GuiChest(IInventory var1, IInventory var2) {
+		super(new ContainerChest(var1, var2));
 		this.upperChestInventory = var1;
 		this.lowerChestInventory = var2;
 		this.allowUserInput = false;
 		short var3 = 222;
 		int var4 = var3 - 108;
-		this.inventoryRows = var2.getSizeInventory() / 9;
-		this.ySize = var4 + this.inventoryRows * 18;
-		int var5 = (this.inventoryRows - 4) * 18;
-
-		int var6;
-		int var7;
-		for(var6 = 0; var6 < this.inventoryRows; ++var6) {
-			for(var7 = 0; var7 < 9; ++var7) {
-				this.inventorySlots.add(new SlotInventory(this, var2, var7 + var6 * 9, 8 + var7 * 18, 18 + var6 * 18));
-			}
-		}
-
-		for(var6 = 0; var6 < 3; ++var6) {
-			for(var7 = 0; var7 < 9; ++var7) {
-				this.inventorySlots.add(new SlotInventory(this, var1, var7 + (var6 + 1) * 9, 8 + var7 * 18, 103 + var6 * 18 + var5));
-			}
-		}
-
-		for(var6 = 0; var6 < 9; ++var6) {
-			this.inventorySlots.add(new SlotInventory(this, var1, var6, 8 + var6 * 18, 161 + var5));
-		}
-
+		this.field_980_m = var2.getInventorySize() / 9;
+		this.ySize = var4 + this.field_980_m * 18;
 	}
 
 	protected void drawGuiContainerForegroundLayer() {
-		this.fontRenderer.drawString(this.lowerChestInventory.getInvName(), 8, 6, 4210752);
-		this.fontRenderer.drawString(this.upperChestInventory.getInvName(), 8, this.ySize - 96 + 2, 4210752);
+		this.fontRenderer.drawString(this.lowerChestInventory.getInventoryName(), 8, 6, this.mc.options.getTextColor());
+		this.fontRenderer.drawString(this.upperChestInventory.getInventoryName(), 8, this.ySize - 96 + 2, this.mc.options.getTextColor());
 	}
 
 	protected void drawGuiContainerBackgroundLayer(float var1) {
-		int var2 = this.mc.renderEngine.getTexture("/gui/container.png");
+		int var2 = this.mc.renderEngine.getTexture("@@/gui/container.png");
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		this.mc.renderEngine.bindTexture(var2);
 		int var3 = (this.width - this.xSize) / 2;
 		int var4 = (this.height - this.ySize) / 2;
-		this.drawTexturedModalRect(var3, var4, 0, 0, this.xSize, this.inventoryRows * 18 + 17);
-		this.drawTexturedModalRect(var3, var4 + this.inventoryRows * 18 + 17, 0, 126, this.xSize, 96);
+		this.drawTexturedModalRect(var3, var4, 0, 0, this.xSize, this.field_980_m * 18 + 17);
+		this.drawTexturedModalRect(var3, var4 + this.field_980_m * 18 + 17, 0, 126, this.xSize, 96);
 	}
 }
--- net/minecraft/src/Packet15Place.java
+++ net/minecraft/src/Packet15Place.java
@@ -5,37 +5,69 @@
 import java.io.IOException;
 
 public class Packet15Place extends Packet {
-	public int id;
 	public int xPosition;
 	public int yPosition;
 	public int zPosition;
 	public int direction;
+	public ItemStack itemStack;
+	public float hitX;
+	public float hitY;
+	public float hitZ;
 
 	public Packet15Place() {
 	}
 
-	public Packet15Place(int var1, int var2, int var3, int var4, int var5) {
-		this.id = var1;
-		this.xPosition = var2;
-		this.yPosition = var3;
-		this.zPosition = var4;
-		this.direction = var5;
+	public Packet15Place(int var1, int var2, int var3, int var4, ItemStack var5) {
+		this.xPosition = var1;
+		this.yPosition = var2;
+		this.zPosition = var3;
+		this.direction = var4;
+		this.itemStack = var5;
+	}
+
+	public Packet15Place(int var1, int var2, int var3, int var4, ItemStack var5, float var6, float var7, float var8) {
+		this(var1, var2, var3, var4, var5);
+		this.hitX = var6;
+		this.hitY = var7;
+		this.hitZ = var8;
 	}
 
 	public void readPacketData(DataInputStream var1) throws IOException {
-		this.id = var1.readShort();
 		this.xPosition = var1.readInt();
 		this.yPosition = var1.read();
 		this.zPosition = var1.readInt();
 		this.direction = var1.read();
+		short var2 = var1.readShort();
+		if(var2 >= 0) {
+			byte var3 = var1.readByte();
+			short var4 = var1.readShort();
+			byte var5 = var1.readByte();
+			this.itemStack = new ItemStack(var2, var3, var4, var5 & 0xFF).withStorage(Packet.readNBT(var1));
+		} else {
+			this.itemStack = null;
+		}
+		this.hitX = (float)var1.readUnsignedByte() / 16.0F;
+		this.hitY = (float)var1.readUnsignedByte() / 16.0F;
+		this.hitZ = (float)var1.readUnsignedByte() / 16.0F;
 	}
 
 	public void writePacket(DataOutputStream var1) throws IOException {
-		var1.writeShort(this.id);
 		var1.writeInt(this.xPosition);
 		var1.write(this.yPosition);
 		var1.writeInt(this.zPosition);
 		var1.write(this.direction);
+		if(this.itemStack == null) {
+			var1.writeShort(-1);
+		} else {
+			var1.writeShort(this.itemStack.itemID);
+			var1.writeByte(this.itemStack.stackSize);
+			var1.writeShort(this.itemStack.itemDmg);
+			var1.writeByte(this.itemStack.itemMetadata);
+			Packet.writeNBT(this.itemStack.storage, var1);
+		}
+		var1.writeByte((int)(this.hitX * 16.0F));
+		var1.writeByte((int)(this.hitY * 16.0F));
+		var1.writeByte((int)(this.hitZ * 16.0F));
 	}
 
 	public void processPacket(NetHandler var1) {
@@ -43,6 +75,6 @@
 	}
 
 	public int getPacketSize() {
-		return 12;
+		return 16;
 	}
 }
--- /dev/null
+++ net/minecraft/src/RegionTool.java
@@ -1,0 +1,280 @@
+package net.minecraft.src;
+
+/*
+** 2011 January 5
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**/
+
+// A tool to convert to and from chunk/region files
+
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
+import java.io.*;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.zip.GZIPInputStream;
+
+public class RegionTool {
+	private RegionTool() {
+	}
+
+	public static void pack(File worldDir, File targetDir, IProgressUpdate progress) {
+		if (progress != null)
+			progress.setLoadingProgress(0);
+
+		Set<Pair<File, Matcher>> filesToProcess = new HashSet<>();
+		Set<File> processedFiles = null;
+		Set<File> chunkDirectories = null;
+		if (worldDir != targetDir) {
+			processedFiles = new HashSet<>();
+		}
+
+		Pattern chunkFilePattern = Pattern.compile("c\\.(-?[0-9a-z]+)\\.(-?[0-9a-z]+).dat");
+		Pattern chunkFolderPattern = Pattern.compile("[0-9a-z]|1[0-9a-r]");
+
+		int chunksPacked = 0;
+		int chunksSkipped = 0;
+
+		for (File dir1 : worldDir.listFiles()) {
+			if (!dir1.isDirectory())
+				continue;
+
+			if (chunkFolderPattern.matcher(dir1.getName()).matches()) {
+				for (File dir2 : dir1.listFiles()) {
+					if (!dir2.isDirectory())
+						continue;
+
+					if (chunkFolderPattern.matcher(dir2.getName()).matches()) {
+						for (File chunkFile : dir2.listFiles()) {
+							Matcher m = chunkFilePattern.matcher(chunkFile.getName());
+							boolean packed;
+							if (m.matches()) {
+								filesToProcess.add(new Pair<>(chunkFile, m));
+							}
+						}
+					}
+				}
+			}
+		}
+
+		int i = 0;
+		for (Pair<File, Matcher> p : filesToProcess) {
+			if (packChunk(targetDir, p.var0, p.var1))
+				chunksPacked++;
+			else
+				chunksSkipped++;
+
+			if (processedFiles != null)
+				processedFiles.add(p.var0);
+
+			int loadingProgress = (int)Math.round(100.0D * (double)++i / (double)filesToProcess.size());
+			if (progress != null)
+				progress.setLoadingProgress(loadingProgress);
+		}
+
+		updateWorld(new File(worldDir, "level.dat"));
+
+		System.out.println("packed " + chunksPacked + " chunks" +
+			(chunksSkipped > 0 ? ", skipped " + chunksSkipped + " broken chunks": ""));
+
+		if (processedFiles != null)
+			copyDir(worldDir, targetDir, processedFiles);
+
+		for (File file : Objects.requireNonNull(targetDir.listFiles())) {
+			if (file.isDirectory() && !file.getName().equals("region")) {
+				deleteRecursive(file);
+			}
+		}
+	}
+
+	private static void deleteRecursive(File file) {
+	    if (file.isDirectory()) {
+	        for (File f : Objects.requireNonNull(file.listFiles())) {
+	            deleteRecursive(f);
+	        }
+	    }
+		file.delete();
+	}
+
+	private static boolean packChunk(File worldDir, File chunkFile, Matcher m) {
+		int x = Integer.parseInt(m.group(1), 36);
+		int z = Integer.parseInt(m.group(2), 36);
+
+		RegionFile region = RegionFileCache.getRegionFile(worldDir, x, z);
+
+		try {
+			// Load level data, and create output stream.
+			DataInputStream istream = new DataInputStream(
+					new GZIPInputStream(new FileInputStream(chunkFile)));
+			if (istream == null) return false;
+			DataOutputStream out = region.getChunkDataOutputStream(x & 31, z & 31);
+
+			NBTTagCompound oldLevel = CompressedStreamTools.read(istream);
+
+			// Extend blocks
+			byte[] blockArray = oldLevel.getCompoundTag("Level").getByteArray("Blocks");
+			byte[] extendedBlockArray = new byte[256 * CHUNK_HEIGHT];
+
+			for (int i = 0; i < blockArray.length; i += 128) {
+				System.arraycopy(blockArray, i, extendedBlockArray, i * 2 + 64, 128);
+			}
+
+			// Convert all bytes into shorts
+			short[] shortIds = new short[256 * CHUNK_HEIGHT];
+			for(int i = 0; i < extendedBlockArray.length; ++i) {
+				shortIds[i] = (short)(extendedBlockArray[i] & 0xFF);
+			}
+
+			// Get nibble array for metadata
+			byte[] nibbleArray = oldLevel.getCompoundTag("Level").getByteArray("Data");
+
+			// Extend metadata from a nibble array to a byte array
+			byte[] metadataArray = new byte[nibbleArray.length * 2];
+			for(int i = 0; i < metadataArray.length; i++) {
+				int nibbleIndex = i >> 1;
+				if ((i & 1) == 0) {
+					metadataArray[i] = (byte)(nibbleArray[nibbleIndex] & 0xF);
+				} else {
+					metadataArray[i] = (byte)((nibbleArray[nibbleIndex] >> 4) & 0xF);
+				}
+			}
+
+			// Extend and raise metadata so it fits in the world
+			byte[] extendedMetadataArray = new byte[256 * CHUNK_HEIGHT];
+			for (int i = 0; i < metadataArray.length; i += 128) {
+				System.arraycopy(metadataArray, i, extendedMetadataArray, i * 2 + 64, 128);
+			}
+
+			// Store updated block and metadata arrays into the level
+			oldLevel.getCompoundTag("Level").setShortArray("Blocks", shortIds);
+			oldLevel.getCompoundTag("Level").setByteArray("Data", extendedMetadataArray);
+
+			// Extend skylight array
+			byte[] skylightArray = oldLevel.getCompoundTag("Level").getByteArray("SkyLight");
+			byte[] extendedSkylightArray = new byte[128 * CHUNK_HEIGHT];
+			for (int i = 0; i < skylightArray.length; i += 64) {
+				System.arraycopy(skylightArray, i, extendedSkylightArray, i * 2 + 32, 64);
+			}
+
+			// Extend blocklight array
+			byte[] blocklightArray = oldLevel.getCompoundTag("Level").getByteArray("BlockLight");
+			byte[] extendedBlocklightArray = new byte[128 * CHUNK_HEIGHT];
+			for (int i = 0; i < blocklightArray.length; i += 64) {
+				System.arraycopy(blocklightArray, i, extendedBlocklightArray, i * 2 + 32, 64);
+			}
+
+			// Store updated skylight and blocklight arrays
+			oldLevel.getCompoundTag("Level").setByteArray("SkyLight", extendedSkylightArray);
+			oldLevel.getCompoundTag("Level").setByteArray("BlockLight", extendedBlocklightArray);
+
+			// Raise entities
+			NBTTagList entities = oldLevel.getCompoundTag("Level").getTagList("Entities");
+			if (entities.tagCount() > 0) {
+				for (int i = 0; i < entities.tagCount(); i++) {
+					NBTTagCompound entity = (NBTTagCompound)entities.tagAt(i);
+					raiseEntityCompound(entity);
+				}
+			}
+
+			// Raise tile entities
+			NBTTagList tileEntities = oldLevel.getCompoundTag("Level").getTagList("TileEntities");
+			if (tileEntities.tagCount() > 0) {
+				for (int i = 0; i < tileEntities.tagCount(); i++) {
+					NBTTagCompound tileEntity = (NBTTagCompound)tileEntities.tagAt(i);
+					int oldY = tileEntity.getInteger("y");
+					tileEntity.setInteger("y", oldY + 64);
+				}
+			}
+
+			// Fill biomes
+			byte[] biomes = oldLevel.getCompoundTag("Level").getByteArray("Biomes");
+			if (biomes.length == 0) {
+				biomes = new byte[256];
+				Arrays.fill(biomes, (byte)0);
+				oldLevel.getCompoundTag("Level").setByteArray("Biomes", biomes);
+			}
+
+			// Write to output
+			CompressedStreamTools.write(oldLevel, out);
+
+			// Close output and input streams, clear the region file cache.
+			out.close();
+			istream.close();
+			RegionFileCache.clear();
+			return true;
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		RegionFileCache.clear();
+		return false;
+	}
+
+	private static void updateWorld(File levelFile) {
+		if (levelFile == null || !levelFile.exists()) return;
+
+		try {
+			FileInputStream levelFileStream = new FileInputStream(levelFile);
+			NBTTagCompound data = CompressedStreamTools.readCompressed(levelFileStream);
+			levelFileStream.close();
+
+			NBTTagCompound player = data.getCompoundTag("Data").getCompoundTag("Player");
+			raiseEntityCompound(player);
+
+			CompressedStreamTools.writeCompressed(data, new FileOutputStream(levelFile));
+		} catch (IOException e) {
+		}
+	}
+
+	/* copies all files from one directory to another, except for files in the skip set
+	   does not copy empty directories */
+	private static void copyDir(File srcDir, File dstDir, Set<File> skip) {
+		byte[] buf = new byte[4096];
+
+		for (File child : srcDir.listFiles()) {
+			if (child.isDirectory())
+				copyDir(child, new File(dstDir, child.getName()), skip);
+			else {
+				if (!skip.contains(child)) {
+					try {
+						File dstfile = new File(dstDir, child.getName());
+						dstDir.mkdirs();
+						FileOutputStream out = new FileOutputStream(dstfile);
+						FileInputStream in = new FileInputStream(child);
+
+						int len = 0;
+						while (len != -1) {
+							out.write(buf, 0, len);
+							len = in.read(buf);
+						}
+
+						out.close();
+						in.close();
+					} catch (IOException e) {
+						e.printStackTrace();
+					}
+				}
+			}
+		}
+	}
+
+	private static void raiseEntityCompound(NBTTagCompound entity) {
+		NBTTagList oldEntityPos = entity.getTagList("Pos");
+		if (oldEntityPos == null || oldEntityPos.tagCount() == 0) return;
+		NBTTagList entityPos = new NBTTagList();
+		entityPos.setTag(new NBTTagDouble(((NBTTagDouble)oldEntityPos.tagAt(0)).doubleValue));
+		entityPos.setTag(new NBTTagDouble(((NBTTagDouble)oldEntityPos.tagAt(1)).doubleValue + 64.0D));
+		entityPos.setTag(new NBTTagDouble(((NBTTagDouble)oldEntityPos.tagAt(2)).doubleValue));
+		entity.setTag("Pos", entityPos);
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemDye.java
@@ -1,0 +1,34 @@
+package net.minecraft.src;
+
+import java.util.stream.IntStream;
+
+public class ItemDye extends Item {
+	public static final int WHITE = 0;
+	public static final int RED = 1;
+	public static final int ORANGE = 2;
+	public static final int YELLOW = 3;
+	public static final int CHARTREUSE = 4;
+	public static final int GREEN = 5;
+	public static final int SPRING_GREEN = 6;
+	public static final int CYAN = 7;
+	public static final int CAPRI = 8;
+	public static final int ULTRAMARINE = 9;
+	public static final int VIOLET = 10;
+	public static final int PURPLE = 11;
+	public static final int MAGENTA = 12;
+	public static final int ROSE = 13;
+	public static final int BLACK = 14;
+	public static final int GRAY = 15;
+
+	public ItemDye(int id) {
+		super(id);
+	}
+
+	public int getIconIndex(ItemStack var1) {
+		return this.iconIndex + (var1.itemMetadata % 4) + (var1.itemMetadata / 4 * 32);
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, 16).toArray();
+	}
+}
--- net/minecraft/src/ICommandListener.java
+++ /dev/null
@@ -1,7 +1,0 @@
-package net.minecraft.src;
-
-public interface ICommandListener {
-	void addHelpCommandMessage(String var1);
-
-	String getUsername();
-}
--- net/minecraft/src/PlayerController.java
+++ net/minecraft/src/PlayerController.java
@@ -1,7 +1,6 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
-
 public class PlayerController {
 	protected final Minecraft mc;
 	public boolean isInTestMode = false;
@@ -18,17 +17,21 @@
 	}
 
 	public boolean sendBlockRemoved(int var1, int var2, int var3, int var4) {
-		this.mc.effectRenderer.addBlockDestroyEffects(var1, var2, var3);
 		World var5 = this.mc.theWorld;
 		Block var6 = Block.blocksList[var5.getBlockId(var1, var2, var3)];
-		int var7 = var5.getBlockMetadata(var1, var2, var3);
-		boolean var8 = var5.setBlockWithNotify(var1, var2, var3, 0);
-		if(var6 != null && var8) {
-			this.mc.sndManager.playSound(var6.stepSound.getBreakSound(), (float)var1 + 0.5F, (float)var2 + 0.5F, (float)var3 + 0.5F, (var6.stepSound.getVolume() + 1.0F) / 2.0F, var6.stepSound.getPitch() * 0.8F);
-			var6.onBlockDestroyedByPlayer(var5, var1, var2, var3, var7);
+		if(var6 == null) {
+			return false;
+		} else {
+			int var7 = var5.getBlockMetadata(var1, var2, var3);
+			this.mc.theWorld.performActionGeneric(2001, var1, var2, var3, var6.blockID | var7 << 16);
+
+			boolean var8 = var5.setBlockWithNotify(var1, var2, var3, 0);
+			if(var8) {
+				var6.onBlockDestroyedByPlayer(var5, var1, var2, var3, var7);
+			}
+
+			return var8;
 		}
-
-		return var8;
 	}
 
 	public void sendBlockRemoving(int var1, int var2, int var3, int var4) {
@@ -41,13 +44,45 @@
 	}
 
 	public float getBlockReachDistance() {
-		return 5.0F;
+		return this.mc.thePlayer != null && this.mc.thePlayer.creative ? 5.0F : 4.5F;
 	}
 
 	public void flipPlayer(EntityPlayer var1) {
 	}
 
 	public void onUpdate() {
+		this.mc.sndManager.fadeOutTitleMusic();
+
+		EntityPlayer plr = this.mc.thePlayer;
+		int ix = (int)plr.posX;
+		int iy = (int)plr.posY;
+		int iz = (int)plr.posZ;
+
+		this.mc.sndManager.tickMusic();
+		if (this.mc.theWorld.worldType == WorldType.SUPERFLAT) {
+			if (this.mc.sndManager.getMusicType() != SoundManager.MusicType.NORMAL) {
+				this.mc.sndManager.fadeOutBackgroundMusic();
+			}
+			this.mc.sndManager.playRandomMusicIfReady();
+		} else if (iy < 32) {
+			if (this.mc.theWorld.achievements != null) {
+				this.mc.theWorld.achievements.updateProgress(Achievement.MANTLE_DISRUPTION, 1);
+			}
+			if (this.mc.sndManager.getMusicType() != SoundManager.MusicType.UNDERWORLD) {
+				this.mc.sndManager.fadeOutBackgroundMusic();
+			}
+			this.mc.sndManager.playRandomUnderworldMusicIfReady();
+		} else if (iy < 112 && iy < this.mc.theWorld.getHeightValue(ix, iz)) {
+			if (this.mc.sndManager.getMusicType() != SoundManager.MusicType.CAVE) {
+				this.mc.sndManager.fadeOutBackgroundMusic();
+			}
+			this.mc.sndManager.playRandomCaveMusicIfReady();
+		} else {
+			if (iy >= 112 && this.mc.sndManager.getMusicType() != SoundManager.MusicType.NORMAL) {
+				this.mc.sndManager.fadeOutBackgroundMusic();
+			}
+			this.mc.sndManager.playRandomMusicIfReady();
+		}
 	}
 
 	public boolean shouldDrawHUD() {
@@ -57,12 +92,61 @@
 	public void onRespawn(EntityPlayer var1) {
 	}
 
-	public boolean onPlayerRightClick(EntityPlayer var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7) {
+	public boolean sendPlaceBlock(EntityPlayer var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7, Vec3D hit) {
 		int var8 = var2.getBlockId(var4, var5, var6);
-		return var8 > 0 && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1) ? true : (var3 == null ? false : var3.useItem(var1, var2, var4, var5, var6, var7));
+		int oldStackSize = var3 != null ? var3.stackSize : 0;
+		boolean result = var8 > 0 && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1)
+				|| (var3 != null && var3.useItem(var1, var2, var4, var5, var6, var7,
+			(float)hit.xCoord - var4, (float)hit.yCoord - var5, (float)hit.zCoord - var6));
+		if (var1.creative && var3 != null) {
+			var3.stackSize = oldStackSize;
+		}
+		return result;
+	}
+
+	public void attackEntity(EntityPlayer var1, Entity var2) {
+		var1.attackEntity(var2);
+	}
+
+	public void interactWithEntity(EntityPlayer var1, Entity var2) {
+		var1.interactWithEntity(var2);
 	}
 
 	public EntityPlayer createPlayer(World var1) {
 		return new EntityPlayerSP(this.mc, var1, this.mc.session);
+	}
+
+	public boolean sendUseItem(EntityPlayer var1, World var2, ItemStack var3) {
+		int var4 = var3.stackSize;
+		ItemStack var5 = var3.useItemRightClick(var2, var1);
+		if(var5 != var3 || var5 != null && var5.stackSize != var4) {
+			var1.inventory.mainInventory[var1.inventory.currentItem] = var5;
+			if(var5.stackSize == 0) {
+				var1.inventory.mainInventory[var1.inventory.currentItem] = null;
+			}
+
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public void stopBlockRemoving() {
+	}
+
+	public ItemStack func_20085_a(int var1, int var2, int var3, EntityPlayer var4) {
+		return var4.craftingInventory.updateSlots(var2, var3, var4);
+	}
+
+	public void func_20086_a(int var1, EntityPlayer var2) {
+		var2.craftingInventory.onCraftGuiClosed(var2);
+		var2.craftingInventory = var2.inventorySlots;
+	}
+
+	public void displayGuiCreative() {
+		this.mc.thePlayer.displayGUICreative();
+	}
+
+	public void setupCreativeItems(int windowId, int row) {
 	}
 }
--- net/minecraft/src/Tessellator.java
+++ net/minecraft/src/Tessellator.java
@@ -10,7 +10,7 @@
 
 public class Tessellator {
 	private static boolean convertQuadsToTriangles = true;
-	private static boolean tryVBO = false;
+	private static boolean tryVBO = true;
 	private ByteBuffer byteBuffer;
 	private IntBuffer intBuffer;
 	private FloatBuffer floatBuffer;
--- net/minecraft/src/IAnimals.java
+++ /dev/null
@@ -1,4 +1,0 @@
-package net.minecraft.src;
-
-public interface IAnimals {
-}
--- net/minecraft/src/EnumOSIsom.java
+++ net/minecraft/src/EnumOSIsom.java
@@ -1,9 +1,9 @@
 package net.minecraft.src;
 
-enum EnumOSIsom {
+public enum EnumOSIsom {
 	linux,
 	solaris,
 	windows,
 	macos,
-	unknown;
+	unknown
 }
--- net/minecraft/src/NetworkListenThread.java
+++ net/minecraft/src/NetworkListenThread.java
@@ -6,6 +6,7 @@
 import java.util.ArrayList;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+
 import net.minecraft.server.MinecraftServer;
 
 public class NetworkListenThread {
@@ -73,15 +74,15 @@
 
 	}
 
-	static ServerSocket getServerSocket(NetworkListenThread var0) {
+	public static ServerSocket getServerSocket(NetworkListenThread var0) {
 		return var0.serverSocket;
 	}
 
-	static int incrementConnections(NetworkListenThread var0) {
+	public static int incrementConnections(NetworkListenThread var0) {
 		return var0.connectionNumber++;
 	}
 
-	static void addPendingConnection(NetworkListenThread var0, NetLoginHandler var1) {
+	public static void addPendingConnection(NetworkListenThread var0, NetLoginHandler var1) {
 		var0.addPendingConnection(var1);
 	}
 }
--- /dev/null
+++ net/minecraft/src/DyeColor.java
@@ -1,0 +1,24 @@
+package net.minecraft.src;
+
+public enum DyeColor {
+	WHITE,
+	RED,
+	ORANGE,
+	YELLOW,
+	CHARTREUSE,
+	GREEN,
+	SPRING_GREEN,
+	CYAN,
+	CAPRI,
+	ULTRAMARINE,
+	VIOLET,
+	PURPLE,
+	MAGENTA,
+	ROSE,
+	BLACK,
+	GRAY;
+
+	public String toString() {
+		return super.toString().toLowerCase();
+	}
+}
--- net/minecraft/src/NBTTagInt.java
+++ net/minecraft/src/NBTTagInt.java
@@ -14,11 +14,11 @@
 		this.intValue = var1;
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeInt(this.intValue);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.intValue = var1.readInt();
 	}
 
@@ -27,6 +27,10 @@
 	}
 
 	public String toString() {
-		return "" + this.intValue;
+		return String.valueOf(this.intValue);
+	}
+
+	public NBTBase copy() {
+		return new NBTTagInt(this.intValue).setKey(this.getKey());
 	}
 }
--- net/minecraft/src/ItemSword.java
+++ net/minecraft/src/ItemSword.java
@@ -1,17 +1,28 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.ItemTooltip.*;
+
 public class ItemSword extends Item {
-	private int weaponDamage;
+	private final int weaponDamage;
+	private final boolean silk;
 
 	public ItemSword(int var1, int var2) {
 		super(var1);
+		int strengthAbs = Math.abs(var2);
 		this.maxStackSize = 1;
-		this.maxDamage = 32 << var2;
-		if(var2 == 3) {
+		this.maxDamage = 64 << strengthAbs;
+		if (strengthAbs >= 3) {
+			this.maxDamage *= 3;
+		} else if (var2 < 0) {
 			this.maxDamage *= 4;
 		}
 
-		this.weaponDamage = 4 + var2 * 2;
+		this.weaponDamage = 4 + strengthAbs * 2;
+		this.silk = var2 < 0;
+	}
+
+	public boolean isSilk() {
+		return this.silk;
 	}
 
 	public float getStrVsBlock(ItemStack var1, Block var2) {
@@ -32,5 +43,11 @@
 
 	public boolean isFull3D() {
 		return true;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				"$damageVsEntity$ attack damage", INFO_COL
+		};
 	}
 }
--- net/minecraft/src/Packet17AddToInventory.java
+++ net/minecraft/src/Packet17AddToInventory.java
@@ -8,6 +8,7 @@
 	public int itemID;
 	public int count;
 	public int itemDamage;
+	public int itemMetadata;
 
 	public Packet17AddToInventory() {
 	}
@@ -16,29 +17,28 @@
 		this.itemID = var1.readShort();
 		this.count = var1.readByte();
 		this.itemDamage = var1.readShort();
+		this.itemMetadata = var1.readByte() & 0xFF;
 	}
 
 	public void writePacket(DataOutputStream var1) throws IOException {
 		var1.writeShort(this.itemID);
 		var1.writeByte(this.count);
 		var1.writeShort(this.itemDamage);
+		var1.writeByte(this.itemMetadata);
 	}
 
 	public void processPacket(NetHandler var1) {
-		var1.handleAddToInventory(this);
+		var1.registerPacket(this);
 	}
 
 	public int getPacketSize() {
-		return 5;
+		return 6;
 	}
 
 	public Packet17AddToInventory(ItemStack var1, int var2) {
 		this.itemID = var1.itemID;
 		this.count = var2;
 		this.itemDamage = var1.itemDmg;
-		if(var2 == 0) {
-			boolean var3 = true;
-		}
-
+		this.itemMetadata = var1.itemMetadata;
 	}
 }
--- net/minecraft/src/TileEntityChest.java
+++ net/minecraft/src/TileEntityChest.java
@@ -1,68 +1,76 @@
 package net.minecraft.src;
 
 public class TileEntityChest extends TileEntity implements IInventory {
-	private ItemStack[] chestContents = new ItemStack[36];
-
-	public int getSizeInventory() {
+	private ItemStack[] chestContents;
+
+	public TileEntityChest() {
+		this.chestContents = new ItemStack[this.getInventorySize()];
+	}
+
+	public int getInventorySize() {
 		return 27;
 	}
 
-	public ItemStack getStackInSlot(int var1) {
+	public ItemStack getStack(int var1) {
 		return this.chestContents[var1];
 	}
 
-	public ItemStack decrStackSize(int var1, int var2) {
+	public ItemStack decrStack(int var1, int var2) {
 		if(this.chestContents[var1] != null) {
 			ItemStack var3;
 			if(this.chestContents[var1].stackSize <= var2) {
 				var3 = this.chestContents[var1];
 				this.chestContents[var1] = null;
-				this.onInventoryChanged();
-				return var3;
 			} else {
 				var3 = this.chestContents[var1].splitStack(var2);
 				if(this.chestContents[var1].stackSize == 0) {
 					this.chestContents[var1] = null;
 				}
-
-				this.onInventoryChanged();
-				return var3;
 			}
+			this.onInventoryChange();
+			return var3;
 		} else {
 			return null;
 		}
 	}
 
-	public void setInventorySlotContents(int var1, ItemStack var2) {
+	public void setInventorySlotItem(int var1, ItemStack var2) {
 		this.chestContents[var1] = var2;
-		if(var2 != null && var2.stackSize > this.getInventoryStackLimit()) {
-			var2.stackSize = this.getInventoryStackLimit();
+		if(var2 != null && var2.stackSize > this.getStackLimit()) {
+			var2.stackSize = this.getStackLimit();
 		}
 
-		this.onInventoryChanged();
+		this.onInventoryChange();
 	}
 
-	public String getInvName() {
+	public String getInventoryName() {
 		return "Chest";
 	}
 
 	public void readFromNBT(NBTTagCompound var1) {
 		super.readFromNBT(var1);
+		this.readItemsFromNBT(var1);
+	}
+
+	public void writeToNBT(NBTTagCompound var1) {
+		super.writeToNBT(var1);
+		this.writeItemsToNBT(var1);
+	}
+
+	public void readItemsFromNBT(NBTTagCompound var1) {
 		NBTTagList var2 = var1.getTagList("Items");
-		this.chestContents = new ItemStack[this.getSizeInventory()];
+		this.chestContents = new ItemStack[this.getInventorySize()];
 
 		for(int var3 = 0; var3 < var2.tagCount(); ++var3) {
 			NBTTagCompound var4 = (NBTTagCompound)var2.tagAt(var3);
 			int var5 = var4.getByte("Slot") & 255;
-			if(var5 >= 0 && var5 < this.chestContents.length) {
+			if(var5 < this.chestContents.length) {
 				this.chestContents[var5] = new ItemStack(var4);
 			}
 		}
-
 	}
 
-	public void writeToNBT(NBTTagCompound var1) {
-		super.writeToNBT(var1);
+	public void writeItemsToNBT(NBTTagCompound var1) {
 		NBTTagList var2 = new NBTTagList();
 
 		for(int var3 = 0; var3 < this.chestContents.length; ++var3) {
@@ -77,7 +85,12 @@
 		var1.setTag("Items", var2);
 	}
 
-	public int getInventoryStackLimit() {
+	public int getStackLimit() {
 		return 64;
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return this.worldObj.getBlockTileEntity(this.xCoord, this.yCoord, this.zCoord) == this
+				&& var1.getDistanceSq((double) this.xCoord + 0.5D, (double) this.yCoord + 0.5D, (double) this.zCoord + 0.5D) <= 64.0D;
 	}
 }
--- net/minecraft/src/EntitySlime.java
+++ net/minecraft/src/EntitySlime.java
@@ -84,7 +84,7 @@
 
 	}
 
-	public void setEntityDead() {
+	public void onDeath(Entity var0) {
 		if(this.size > 1 && this.health == 0) {
 			for(int var1 = 0; var1 < 4; ++var1) {
 				float var2 = ((float)(var1 % 2) - 0.5F) * (float)this.size / 4.0F;
@@ -96,7 +96,7 @@
 			}
 		}
 
-		super.setEntityDead();
+		super.onDeath(var0);
 	}
 
 	public void onCollideWithPlayer(EntityPlayer var1) {
@@ -119,8 +119,15 @@
 	}
 
 	public boolean getCanSpawnHere() {
-		Chunk var1 = this.worldObj.getChunkFromBlockCoords(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY));
-		return (this.size == 1 || this.worldObj.difficultySetting > 0) && this.rand.nextInt(10) == 0 && var1.getRandomWithSeed(987234911L).nextInt(10) == 0 && this.posY < 16.0D;
+		int x = MathHelper.floor_double(this.posX);
+		int z = MathHelper.floor_double(this.posY);
+
+		if (!this.worldObj.chunkExists(x << 4, z << 4)) {
+			return false;
+		}
+
+		Chunk var1 = this.worldObj.getChunkFromBlockCoords(x, z);
+		return (this.size == 1 || this.worldObj.difficultySetting > 0) && this.rand.nextInt(10) == 0 && var1.getRandomWithSeed(987234911L).nextInt(10) == 0 && this.posY < 80.0D;
 	}
 
 	protected float getSoundVolume() {
--- net/minecraft/src/BlockGrass.java
+++ net/minecraft/src/BlockGrass.java
@@ -3,21 +3,31 @@
 import java.util.Random;
 
 public class BlockGrass extends Block {
-	protected BlockGrass(int var1) {
+	public BlockGrass(int var1) {
 		super(var1, Material.grass);
-		this.blockIndexInTexture = 3;
+		this.blockIndexInTexture = textureXY(0, 1);
 		this.setTickOnLoad(true);
 	}
 
 	public int getBlockTexture(IBlockAccess var1, int var2, int var3, int var4, int var5) {
-		if(var5 == 1) {
-			return 0;
-		} else if(var5 == 0) {
-			return 2;
-		} else {
+		if (var5 >= 2) {
 			Material var6 = var1.getBlockMaterial(var2, var3 + 1, var4);
-			return var6 != Material.snow && var6 != Material.craftedSnow ? 3 : 68;
+			if (var6 == Material.snow || var6 == Material.craftedSnow) {
+				return textureXY(0, 4);
+			}
 		}
+
+		return super.getBlockTexture(var1, var2, var3, var4, var5);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int side, int metadata) {
+		int tex = this.blockIndexInTexture;
+		if (metadata == 1) tex += textureXY(7, 6);
+		return metadata == -2 ? textureXY(6, 5)
+				: metadata == -1 ? textureXY(5, 5)
+				: side == 1 ? tex - 32
+				: side == 0 ? Block.dirt.blockIndexInTexture
+				: tex;
 	}
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
@@ -31,14 +41,29 @@
 			int var6 = var2 + var5.nextInt(3) - 1;
 			int var7 = var3 + var5.nextInt(5) - 3;
 			int var8 = var4 + var5.nextInt(3) - 1;
-			if(var1.getBlockId(var6, var7, var8) == Block.dirt.blockID && var1.getBlockLightValue(var6, var7 + 1, var8) >= 4 && !var1.getBlockMaterial(var6, var7 + 1, var8).getCanBlockGrass()) {
-				var1.setBlockWithNotify(var6, var7, var8, Block.grass.blockID);
+			if((!var1.lazyLoading || var1.chunkExists(var6 << 4, var8 << 4))
+					&& var1.getBlockId(var6, var7, var8) == Block.dirt.blockID
+					&& var1.getBlockLightValue(var6, var7 + 1, var8) >= 4
+					&& !var1.isBlockNormalCube(var6, var7 + 1, var8)) {
+				var1.setBlockAndMetadataWithNotify(var6, var7, var8, Block.grass.blockID, var1.getBlockMetadata(var2, var3, var4));
 			}
 		}
 
 	}
 
 	public int idDropped(int var1, Random var2) {
-		return Block.dirt.idDropped(0, var2);
+		return Block.dirt.blockID;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
+	}
+
+	public int metadataDroppedSilk(int var1, int var2, Random var3) {
+		return var1;
+	}
+
+	public int getRenderType() {
+		return 14;
 	}
 }
--- /dev/null
+++ net/minecraft/src/GuiTransparentButton.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+import org.lwjgl.opengl.GL11;
+
+public class GuiTransparentButton extends GuiButton {
+	public GuiTransparentButton(int var1, int var2, int var3, String var4) {
+		super(var1, var2, var3, var4);
+	}
+
+	public GuiTransparentButton(int var1, int var2, int var3, int var4, int var5, String var6) {
+		super(var1, var2, var3, var4, var5, var6);
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
+		if(this.visible) {
+			FontRenderer fontRenderer4 = var1.fontRenderer;
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			boolean var5 = var2 >= this.xPosition && var3 >= this.yPosition && var2 < this.xPosition + this.width && var3 < this.yPosition + this.height;
+			int var6 = this.getHoverState(var5);
+			this.mouseDragged(var1, var2, var3);
+			if(!this.enabled) {
+				this.drawString(fontRenderer4, this.displayString, this.xPosition, this.yPosition + (this.height - 8) / 2, -6250336);
+			} else if(var5) {
+				this.drawString(fontRenderer4, this.displayString, this.xPosition, this.yPosition + (this.height - 8) / 2, 16777120);
+			} else {
+				this.drawString(fontRenderer4, this.displayString, this.xPosition, this.yPosition + (this.height - 8) / 2, 14737632);
+			}
+
+		}
+	}
+}
--- net/minecraft/src/RenderFallingSand.java
+++ net/minecraft/src/RenderFallingSand.java
@@ -13,10 +13,10 @@
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)var2, (float)var4, (float)var6);
 		this.loadTexture("/terrain.png");
-		Block var10 = Block.blocksList[var1.blockID];
+		Block var10 = Block.blocksList[var1.getBlockID()];
 		World var11 = var1.getWorld();
 		GL11.glDisable(GL11.GL_LIGHTING);
-		this.sandRenderBlocks.renderBlockFallingSand(var10, var11, MathHelper.floor_double(var1.posX), MathHelper.floor_double(var1.posY), MathHelper.floor_double(var1.posZ));
+		this.sandRenderBlocks.renderBlockFallingSand(var10, var11, MathHelper.floor_double(var1.posX), MathHelper.floor_double(var1.posY), MathHelper.floor_double(var1.posZ), var1.getBlockMetadata());
 		GL11.glEnable(GL11.GL_LIGHTING);
 		GL11.glPopMatrix();
 	}
--- /dev/null
+++ net/minecraft/src/GuiRecipeGuide.java
@@ -1,0 +1,143 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+import org.lwjgl.opengl.GL11;
+
+public class GuiRecipeGuide extends GuiContainer {
+	private final List<ItemStack[]> recipes = new ArrayList<>();
+	private int currentRecipe = 0;
+	private final ItemStack filterItem;
+	private final String filterItemName;
+
+	public GuiRecipeGuide() {
+		this(null);
+	}
+
+	public GuiRecipeGuide(ItemStack filterItem) {
+		super(new ContainerRecipeGuide());
+		this.xSize = 176;
+		this.ySize = 216;
+		this.filterItem = filterItem;
+
+		String name = "Crafting";
+		if (filterItem != null) {
+			ItemTooltip tooltip = this.filterItem.getTooltip();
+			if (tooltip != null) {
+				name = tooltip.lines.get(0);
+			}
+		}
+		filterItemName = name;
+
+		this.setupRecipes();
+		this.setupCurrentRecipe();
+	}
+
+	private int getMaxRecipePage() {
+		return this.recipes.size() % 3 == 0 ? this.recipes.size() / 3 - 1 : this.recipes.size() / 3;
+	}
+
+	private void setupRecipes() {
+		this.recipes.clear();
+		int r;
+		for (r = 0; r < CraftingManager.getInstance().guideCount(); r++) {
+			ItemStack[] recipe = CraftingManager.getInstance().getRecipeAsItems(r);
+			if (showRecipe(recipe)) {
+				recipes.add(recipe);
+			}
+		}
+		for (r = 0; r < FurnaceRecipeManager.getInstance().count(); r++) {
+			ItemStack[] recipe = FurnaceRecipeManager.getInstance().getRecipeAsItems(r);
+			if (showRecipe(recipe)) {
+				recipes.add(recipe);
+			}
+		}
+	}
+
+	private boolean showRecipe(ItemStack[] recipe) {
+		Stream<ItemStack> filterStream = Arrays.stream(recipe).filter(Objects::nonNull);
+		return filterItem == null
+				|| filterItem.itemID == 0
+				|| filterStream.anyMatch(i ->
+					i.itemID == filterItem.itemID
+					&& (i.itemMetadata == -1
+						|| i.itemMetadata == filterItem.itemMetadata));
+	}
+
+	protected void drawGuiContainerBackgroundLayer(float var1) {
+		int bg = this.mc.renderEngine.getTexture("@@/gui/guide.png");
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		this.mc.renderEngine.bindTexture(bg);
+		int posX = (this.width - this.xSize) / 2;
+		int posY = (this.height - this.ySize) / 2;
+		this.drawTexturedModalRect(posX, posY, 0, 0, this.xSize, this.ySize);
+	}
+
+	public void initGui() {
+		int posX = (this.width - this.xSize) / 2;
+		int posY = (this.height - this.ySize) / 2;
+		this.controlList.add(new GuiButton(0, 5 + posX, 193 + posY, 18, 18, "<"));
+		this.controlList.add(new GuiButton(1, 153 + posX, 193 + posY, 18, 18, ">"));
+		super.initGui();
+	}
+
+	private void setupCurrentRecipe() {
+		((ContainerRecipeGuide)this.inventorySlots).clear();
+		if (this.recipes.size() == 0) {
+			return;
+		}
+		for (int j = 0; j < 3; j++) {
+			if (this.currentRecipe + j >= recipes.size())
+				break;
+
+			ItemStack[] items = recipes.get(this.currentRecipe + j);
+			for (ItemStack item : items) {
+				if (item != null && item.itemMetadata == -1) {
+					item.itemMetadata = item.itemID == this.filterItem.itemID ? this.filterItem.itemMetadata : 0;
+				}
+			}
+
+			InventoryReadonly inventory = new InventoryReadonly(items, false, null);
+			((ContainerRecipeGuide)this.inventorySlots).addRecipe(inventory);
+		}
+	}
+
+	protected void drawGuiContainerForegroundLayer() {
+		if (this.recipes.size() > 0) {
+			String title =
+					(this.currentRecipe / 3 + 1)
+					+ " / "
+					+ (this.getMaxRecipePage() + 1)
+					+ " "
+					+ this.filterItemName
+					+ " recipes";
+
+			this.drawString(this.fontRenderer, title, 5, 5, 0xFFFFFF);
+		} else {
+			this.drawString(this.fontRenderer, "No recipes", 5, 5, 0xFFFFFF);
+		}
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		switch (var1.id) {
+			case 0:
+				this.currentRecipe -= 3;
+				if (this.currentRecipe < 0) {
+					this.currentRecipe = getMaxRecipePage() * 3;
+				}
+				break;
+
+			case 1:
+				this.currentRecipe += 3;
+				if (this.currentRecipe >= this.recipes.size()) {
+					this.currentRecipe = 0;
+				}
+				break;
+		}
+		this.setupCurrentRecipe();
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemMissing.java
@@ -1,0 +1,18 @@
+package net.minecraft.src;
+
+class ItemMissing extends Item {
+	ItemMissing() {
+		super(55535);
+		this.iconIndex = textureXY(30, 0);
+	}
+
+	public ItemTooltip getTooltip(ItemStack itemStack) {
+		ItemTooltip tooltip = super.getTooltip(itemStack).copy();
+		if (itemStack.storage == null) {
+			return tooltip;
+		}
+		tooltip.addLine("ID: " + (int)itemStack.storage.getShort("MissingItem"), ItemTooltip.INFO_COL);
+		tooltip.addLine("Data: " + itemStack.itemMetadata, ItemTooltip.INFO_COL);
+		return tooltip;
+	}
+}
--- net/minecraft/src/Slot.java
+++ net/minecraft/src/Slot.java
@@ -1,12 +1,17 @@
 package net.minecraft.src;
 
 public class Slot {
-	public final int slotIndex;
-	public final IInventory inventory;
+	private final int slotIndex;
+	private final IInventory inventory;
+	public int id;
+	public int x;
+	public int y;
 
-	public Slot(IInventory var1, int var2) {
+	public Slot(IInventory var1, int var2, int var3, int var4) {
 		this.inventory = var1;
 		this.slotIndex = var2;
+		this.x = var3;
+		this.y = var4;
 	}
 
 	public void onPickupFromSlot() {
@@ -18,11 +23,15 @@
 	}
 
 	public ItemStack getStack() {
-		return this.inventory.getStackInSlot(this.slotIndex);
+		return this.inventory.getStack(this.slotIndex);
+	}
+
+	public boolean func_20005_c() {
+		return this.getStack() != null;
 	}
 
 	public void putStack(ItemStack var1) {
-		this.inventory.setInventorySlotContents(this.slotIndex, var1);
+		this.inventory.setInventorySlotItem(this.slotIndex, var1);
 		this.onSlotChanged();
 	}
 
@@ -31,6 +40,38 @@
 	}
 
 	public void onSlotChanged() {
-		this.inventory.onInventoryChanged();
+		this.inventory.onInventoryChange();
+	}
+
+	public int getSlotStackLimit() {
+		return this.inventory.getStackLimit();
+	}
+
+	public ItemStack decrStackSize(int var1) {
+		return this.inventory.decrStack(this.slotIndex, var1);
+	}
+
+	public boolean matchesSlot(IInventory var1, int var2) {
+		return var1 == this.inventory && var2 == this.slotIndex;
+	}
+
+	public ItemTooltip getTooltip() {
+		return this.getStack().getTooltip();
+	}
+
+	public float getColorR() {
+		return 1.0F;
+	}
+
+	public float getColorG() {
+		return 1.0F;
+	}
+
+	public float getColorB() {
+		return 1.0F;
+	}
+
+	public float getColorA() {
+		return 1.0F;
 	}
 }
--- net/minecraft/src/BlockFurnace.java
+++ net/minecraft/src/BlockFurnace.java
@@ -3,12 +3,18 @@
 import java.util.Random;
 
 public class BlockFurnace extends BlockContainer {
-	private final boolean isActive;
-
-	protected BlockFurnace(int var1, boolean var2) {
-		super(var1, Material.rock);
+	protected final boolean isActive;
+	private final Random random = new Random();
+	private static boolean keepFurnaceInventory = false;
+
+	public BlockFurnace(int var1, boolean var2) {
+		this(var1, var2, Material.rock);
+	}
+
+	public BlockFurnace(int var1, boolean var2, Material var3) {
+		super(var1, var3);
 		this.isActive = var2;
-		this.blockIndexInTexture = 45;
+		this.blockIndexInTexture = textureXY(31, 6);
 	}
 
 	public int idDropped(int var1, Random var2) {
@@ -52,7 +58,7 @@
 			return Block.stone.blockIndexInTexture;
 		} else {
 			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			return var5 != var6 ? this.blockIndexInTexture : (this.isActive ? this.blockIndexInTexture + 16 : this.blockIndexInTexture - 1);
+			return var5 != var6 ? this.blockIndexInTexture : (this.isActive ? this.blockIndexInTexture - 32 : this.blockIndexInTexture - 1);
 		}
 	}
 
@@ -82,26 +88,63 @@
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? Block.stone.blockID : (var1 == 0 ? Block.stone.blockID : (var1 == 3 ? this.blockIndexInTexture - 1 : this.blockIndexInTexture));
+		return var1 == 1 ? Block.stone.blockIndexInTexture : (var1 == 0 ? Block.stone.blockIndexInTexture : (var1 == 3 ? this.blockIndexInTexture - 1 : this.blockIndexInTexture));
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
-		TileEntityFurnace var6 = (TileEntityFurnace)var1.getBlockTileEntity(var2, var3, var4);
-		var5.displayGUIFurnace(var6);
+		if (var1.canDoClientAction()) {
+			TileEntityFurnace var6 = (TileEntityFurnace)var1.getBlockTileEntity(var2, var3, var4);
+			var5.displayGUIFurnace(var6);
+		}
 		return true;
 	}
 
-	public static void updateFurnaceBlockState(boolean var0, World var1, int var2, int var3, int var4) {
+	public void updateFurnaceBlockState(boolean var0, World var1, int var2, int var3, int var4) {
 		int var5 = var1.getBlockMetadata(var2, var3, var4);
 		TileEntity var6 = var1.getBlockTileEntity(var2, var3, var4);
+		keepFurnaceInventory = true;
 		if(var0) {
 			var1.setBlockWithNotify(var2, var3, var4, Block.stoneOvenActive.blockID);
 		} else {
 			var1.setBlockWithNotify(var2, var3, var4, Block.stoneOvenIdle.blockID);
 		}
+		keepFurnaceInventory = false;
 
 		var1.setBlockMetadataWithNotify(var2, var3, var4, var5);
 		var1.setBlockTileEntity(var2, var3, var4, var6);
+	}
+
+	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
+		if (!var1.canDoClientAction() || keepFurnaceInventory) return;
+		TileEntityFurnace var5 = (TileEntityFurnace)var1.getBlockTileEntity(var2, var3, var4);
+
+		for(int var6 = 0; var6 < var5.getInventorySize(); ++var6) {
+			ItemStack var7 = var5.getStack(var6);
+			if(var7 != null) {
+				float var8 = this.random.nextFloat() * 0.8F + 0.1F;
+				float var9 = this.random.nextFloat() * 0.8F + 0.1F;
+				float var10 = this.random.nextFloat() * 0.8F + 0.1F;
+
+				while(var7.stackSize > 0) {
+					int var11 = this.random.nextInt(21) + 10;
+					if(var11 > var7.stackSize) {
+						var11 = var7.stackSize;
+					}
+
+					var7.stackSize -= var11;
+					ItemStack dropped = var7.copy();
+					dropped.stackSize = var11;
+					EntityItem var12 = new EntityItem(var1, (double)((float)var2 + var8), (double)((float)var3 + var9), (double)((float)var4 + var10), dropped);
+					float var13 = 0.05F;
+					var12.motionX = (double)((float)this.random.nextGaussian() * var13);
+					var12.motionY = (double)((float)this.random.nextGaussian() * var13 + 0.2F);
+					var12.motionZ = (double)((float)this.random.nextGaussian() * var13);
+					var1.spawnEntityInWorld(var12);
+				}
+			}
+		}
+
+		super.onBlockRemoval(var1, var2, var3, var4);
 	}
 
 	protected TileEntity getBlockEntity() {
--- net/minecraft/src/SoundManager.java
+++ net/minecraft/src/SoundManager.java
@@ -2,6 +2,7 @@
 
 import java.io.File;
 import java.util.Random;
+
 import paulscode.sound.SoundSystem;
 import paulscode.sound.SoundSystemConfig;
 import paulscode.sound.codecs.CodecJOrbis;
@@ -9,15 +10,28 @@
 import paulscode.sound.libraries.LibraryLWJGLOpenAL;
 
 public class SoundManager {
+	public enum MusicType {
+		NORMAL,
+		CAVE,
+		TITLE,
+		UNDERWORLD,
+		WAITING
+	}
+
 	private static SoundSystem sndSystem;
-	private SoundPool soundPoolSounds = new SoundPool();
-	private SoundPool soundPoolStreaming = new SoundPool();
-	private SoundPool soundPoolMusic = new SoundPool();
+	private final SoundPool soundPoolSounds = new SoundPool();
+	private final SoundPool soundPoolStreaming = new SoundPool();
+	private final SoundPool soundPoolMusic = new SoundPool();
+	private final SoundPool soundPoolCaveMusic = new SoundPool();
+	private final SoundPool soundPoolTitleMusic = new SoundPool();
+	private final SoundPool soundPoolUnderworldMusic = new SoundPool();
 	private int playedSoundsCount = 0;
 	private GameSettings options;
 	private static boolean loaded = false;
 	private Random rand = new Random();
-	private int ticksBeforeMusic = this.rand.nextInt(12000);
+	private int ticksBeforeMusic = 0;
+	private int fadeOutTicks = 0;
+	private MusicType musicType = MusicType.TITLE;
 
 	public void loadSoundSettings(GameSettings var1) {
 		this.soundPoolStreaming.isGetRandomSound = false;
@@ -28,6 +42,10 @@
 
 	}
 
+	public MusicType getMusicType() {
+		return this.musicType;
+	}
+
 	private void tryToSetLibraryAndCodecs() {
 		try {
 			float var1 = this.options.soundVolume;
@@ -83,24 +101,97 @@
 		this.soundPoolMusic.addSound(var1, var2);
 	}
 
-	public void playRandomMusicIfReady() {
+	public void addCaveMusic(String var1, File var2) {
+		this.soundPoolCaveMusic.addSound(var1, var2);
+	}
+
+	public void addTitleMusic(String var1, File var2) {
+		this.soundPoolTitleMusic.addSound(var1, var2);
+	}
+
+	public void addUnderworldMusic(String var1, File var2) {
+		this.soundPoolUnderworldMusic.addSound(var1, var2);
+	}
+
+	public void tickMusic() {
 		if(loaded && this.options.musicVolume != 0.0F) {
 			if(!sndSystem.playing("BgMusic") && !sndSystem.playing("streaming")) {
 				if(this.ticksBeforeMusic > 0) {
 					--this.ticksBeforeMusic;
+				}
+			}
+			if(this.fadeOutTicks > 0) {
+				--this.fadeOutTicks;
+			}
+		}
+	}
+
+	private void playRandomMusicFromPool(SoundPool soundPool, MusicType type) {
+		if(loaded && this.options.musicVolume != 0.0F) {
+			if(!sndSystem.playing("BgMusic") && !sndSystem.playing("streaming")) {
+				if(this.ticksBeforeMusic > 0) {
 					return;
 				}
 
-				SoundPoolEntry var1 = this.soundPoolMusic.getRandomSound();
+				SoundPoolEntry var1 = soundPool.getRandomSound();
 				if(var1 != null) {
-					this.ticksBeforeMusic = this.rand.nextInt(24000) + 24000;
+					this.ticksBeforeMusic = (int) ((this.rand.nextInt(12000) + 12000) * this.options.musicDelay);
 					sndSystem.backgroundMusic("BgMusic", var1.soundUrl, var1.soundName, false);
 					sndSystem.setVolume("BgMusic", this.options.musicVolume);
 					sndSystem.play("BgMusic");
+					this.musicType = type;
 				}
 			}
-
-		}
+		}
+	}
+
+	public void playRandomMusicIfReady() {
+		playRandomMusicFromPool(this.soundPoolMusic, MusicType.NORMAL);
+	}
+
+	public void playRandomCaveMusicIfReady() {
+		playRandomMusicFromPool(this.soundPoolCaveMusic, MusicType.CAVE);
+	}
+
+	public void playRandomTitleMusicIfReady() {
+		playRandomMusicFromPool(this.soundPoolTitleMusic, MusicType.TITLE);
+		this.ticksBeforeMusic = 0;
+	}
+
+	public void playRandomUnderworldMusicIfReady() {
+		playRandomMusicFromPool(this.soundPoolUnderworldMusic, MusicType.UNDERWORLD);
+	}
+
+	public void playRandomWaitingMusicIfReady() {
+		playRandomMusicFromPool(this.soundPoolStreaming, MusicType.WAITING);
+		this.ticksBeforeMusic = 0;
+	}
+
+	public void fadeOutBackgroundMusic() {
+		if (!loaded || fadeOutTicks > 0 || !sndSystem.playing("BgMusic") || this.musicType == MusicType.TITLE) {
+			return;
+		}
+		sndSystem.fadeOut("BgMusic", null, 2500);
+		this.ticksBeforeMusic = 0;
+		this.fadeOutTicks = 60;
+	}
+
+	public void fadeOutTitleMusic() {
+		if (!loaded || fadeOutTicks > 0 || !sndSystem.playing("BgMusic") || this.musicType != MusicType.TITLE) {
+			return;
+		}
+		sndSystem.fadeOut("BgMusic", null, 2500);
+		this.ticksBeforeMusic = 0;
+		this.fadeOutTicks = 60;
+	}
+
+	public void stopBackgroundMusic() {
+		if (!loaded || !sndSystem.playing("BgMusic") || this.musicType == MusicType.TITLE) {
+			return;
+		}
+		sndSystem.stop("BgMusic");
+		this.ticksBeforeMusic = 0;
+		this.fadeOutTicks = 0;
 	}
 
 	public void setListener(EntityLiving var1, float var2) {
--- net/minecraft/src/SlotCrafting.java
+++ net/minecraft/src/SlotCrafting.java
@@ -1,11 +1,11 @@
 package net.minecraft.src;
 
-public class SlotCrafting extends SlotInventory {
+public class SlotCrafting extends Slot {
 	private final IInventory craftMatrix;
 
-	public SlotCrafting(GuiContainer var1, IInventory var2, IInventory var3, int var4, int var5, int var6) {
-		super(var1, var3, var4, var5, var6);
-		this.craftMatrix = var2;
+	public SlotCrafting(IInventory var1, IInventory var2, int var3, int var4, int var5) {
+		super(var2, var3, var4, var5);
+		this.craftMatrix = var1;
 	}
 
 	public boolean isItemValid(ItemStack var1) {
@@ -13,9 +13,9 @@
 	}
 
 	public void onPickupFromSlot() {
-		for(int var1 = 0; var1 < this.craftMatrix.getSizeInventory(); ++var1) {
-			if(this.craftMatrix.getStackInSlot(var1) != null) {
-				this.craftMatrix.decrStackSize(var1, 1);
+		for(int var1 = 0; var1 < this.craftMatrix.getInventorySize(); ++var1) {
+			if(this.craftMatrix.getStack(var1) != null) {
+				this.craftMatrix.decrStack(var1, 1);
 			}
 		}
 
--- net/minecraft/src/GuiFurnace.java
+++ net/minecraft/src/GuiFurnace.java
@@ -6,31 +6,17 @@
 	private TileEntityFurnace furnaceInventory;
 
 	public GuiFurnace(InventoryPlayer var1, TileEntityFurnace var2) {
+		super(new ContainerFurnace(var1, var2));
 		this.furnaceInventory = var2;
-		this.inventorySlots.add(new SlotInventory(this, var2, 0, 56, 17));
-		this.inventorySlots.add(new SlotInventory(this, var2, 1, 56, 53));
-		this.inventorySlots.add(new SlotInventory(this, var2, 2, 116, 35));
-
-		int var3;
-		for(var3 = 0; var3 < 3; ++var3) {
-			for(int var4 = 0; var4 < 9; ++var4) {
-				this.inventorySlots.add(new SlotInventory(this, var1, var4 + (var3 + 1) * 9, 8 + var4 * 18, 84 + var3 * 18));
-			}
-		}
-
-		for(var3 = 0; var3 < 9; ++var3) {
-			this.inventorySlots.add(new SlotInventory(this, var1, var3, 8 + var3 * 18, 142));
-		}
-
 	}
 
 	protected void drawGuiContainerForegroundLayer() {
-		this.fontRenderer.drawString("Furnace", 60, 6, 4210752);
-		this.fontRenderer.drawString("Inventory", 8, this.ySize - 96 + 2, 4210752);
+		this.fontRenderer.drawString("Furnace", 60, 6, this.mc.options.getTextColor());
+		this.fontRenderer.drawString("Inventory", 8, this.ySize - 96 + 2, this.mc.options.getTextColor());
 	}
 
 	protected void drawGuiContainerBackgroundLayer(float var1) {
-		int var2 = this.mc.renderEngine.getTexture("/gui/furnace.png");
+		int var2 = this.mc.renderEngine.getTexture("@@/gui/furnace.png");
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		this.mc.renderEngine.bindTexture(var2);
 		int var3 = (this.width - this.xSize) / 2;
--- net/minecraft/src/Packet53BlockChange.java
+++ net/minecraft/src/Packet53BlockChange.java
@@ -19,7 +19,7 @@
 		this.xPosition = var1.readInt();
 		this.yPosition = var1.read();
 		this.zPosition = var1.readInt();
-		this.type = var1.read();
+		this.type = var1.readShort();
 		this.metadata = var1.read();
 	}
 
@@ -27,7 +27,7 @@
 		var1.writeInt(this.xPosition);
 		var1.write(this.yPosition);
 		var1.writeInt(this.zPosition);
-		var1.write(this.type);
+		var1.writeShort(this.type);
 		var1.write(this.metadata);
 	}
 
@@ -36,7 +36,7 @@
 	}
 
 	public int getPacketSize() {
-		return 11;
+		return 12;
 	}
 
 	public Packet53BlockChange(int var1, int var2, int var3, World var4) {
--- net/minecraft/src/OSMapIsom.java
+++ /dev/null
@@ -1,28 +1,0 @@
-package net.minecraft.src;
-
-class OSMapIsom {
-	static final int[] osValues = new int[EnumOSIsom.values().length];
-
-	static {
-		try {
-			osValues[EnumOSIsom.linux.ordinal()] = 1;
-		} catch (NoSuchFieldError var4) {
-		}
-
-		try {
-			osValues[EnumOSIsom.solaris.ordinal()] = 2;
-		} catch (NoSuchFieldError var3) {
-		}
-
-		try {
-			osValues[EnumOSIsom.windows.ordinal()] = 3;
-		} catch (NoSuchFieldError var2) {
-		}
-
-		try {
-			osValues[EnumOSIsom.macos.ordinal()] = 4;
-		} catch (NoSuchFieldError var1) {
-		}
-
-	}
-}
--- net/minecraft/src/Packet51MapChunk.java
+++ net/minecraft/src/Packet51MapChunk.java
@@ -15,12 +15,35 @@
 	public int ySize;
 	public int zSize;
 	public byte[] chunkData;
+	public boolean includeInitialize;
 	private int tempLength;
 
 	public Packet51MapChunk() {
 		this.isChunkDataPacket = true;
 	}
 
+	public Packet51MapChunk(int var1, int var2, int var3, int var4, int var5, int var6, World var7, boolean var8) {
+		this.isChunkDataPacket = true;
+		this.xPosition = var1;
+		this.yPosition = var2;
+		this.zPosition = var3;
+		this.xSize = var4;
+		this.ySize = var5;
+		this.zSize = var6;
+		this.includeInitialize = var8;
+		byte[] var9 = var7.getChunkData(var1, var2, var3, var4, var5, var6);
+		Deflater var10 = new Deflater(1);
+
+		try {
+			var10.setInput(var9);
+			var10.finish();
+			this.chunkData = new byte[var4 * var5 * var6 * 8 / 2];
+			this.tempLength = var10.deflate(this.chunkData);
+		} finally {
+			var10.end();
+		}
+	}
+
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.xPosition = var1.readInt();
 		this.yPosition = var1.readShort();
@@ -28,10 +51,11 @@
 		this.xSize = var1.read() + 1;
 		this.ySize = var1.read() + 1;
 		this.zSize = var1.read() + 1;
+		this.includeInitialize = var1.readBoolean();
 		int var2 = var1.readInt();
 		byte[] var3 = new byte[var2];
 		var1.readFully(var3);
-		this.chunkData = new byte[this.xSize * this.ySize * this.zSize * 5 / 2];
+		this.chunkData = new byte[this.xSize * this.ySize * this.zSize * 8 / 2];
 		Inflater var4 = new Inflater();
 		var4.setInput(var3);
 
@@ -52,6 +76,7 @@
 		var1.write(this.xSize - 1);
 		var1.write(this.ySize - 1);
 		var1.write(this.zSize - 1);
+		var1.writeBoolean(this.includeInitialize);
 		var1.writeInt(this.tempLength);
 		var1.write(this.chunkData, 0, this.tempLength);
 	}
@@ -61,28 +86,6 @@
 	}
 
 	public int getPacketSize() {
-		return 17 + this.tempLength;
-	}
-
-	public Packet51MapChunk(int var1, int var2, int var3, int var4, int var5, int var6, World var7) {
-		this.isChunkDataPacket = true;
-		this.xPosition = var1;
-		this.yPosition = var2;
-		this.zPosition = var3;
-		this.xSize = var4;
-		this.ySize = var5;
-		this.zSize = var6;
-		byte[] var8 = var7.getChunkData(var1, var2, var3, var4, var5, var6);
-		Deflater var9 = new Deflater(1);
-
-		try {
-			var9.setInput(var8);
-			var9.finish();
-			this.chunkData = new byte[var4 * var5 * var6 * 5 / 2];
-			this.tempLength = var9.deflate(this.chunkData);
-		} finally {
-			var9.end();
-		}
-
+		return 20 + this.tempLength;
 	}
 }
--- /dev/null
+++ net/minecraft/src/Hook3.java
@@ -1,0 +1,9 @@
+package net.minecraft.src;
+
+public interface Hook3<T1, T2, T3> {
+	void call(BaseMod mod, T1 t1, T2 t2, T3 t3);
+
+	default Hook bind(T1 t1, T2 t2, T3 t3) {
+		return (BaseMod mod) -> call(mod, t1, t2, t3);
+	}
+}
--- /dev/null
+++ net/minecraft/src/Packet41AddEffect.java
@@ -1,0 +1,44 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet41AddEffect extends Packet {
+	public int type;
+	public int duration;
+	public int maxDuration;
+	public int metadata;
+
+	public Packet41AddEffect() {
+	}
+
+	public Packet41AddEffect(Effect effect) {
+		this.type = effect.type.id;
+		this.duration = effect.duration;
+		this.maxDuration = effect.maxDuration;
+		this.metadata = effect.metadata;
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.type = var1.read();
+		this.duration = var1.readInt();
+		this.maxDuration = var1.readInt();
+		this.metadata = var1.readInt();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.write(this.type);
+		var1.writeInt(this.duration);
+		var1.writeInt(this.maxDuration);
+		var1.writeInt(this.metadata);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleAddEffect(this);
+	}
+
+	public int getPacketSize() {
+		return 13;
+	}
+}
--- net/minecraft/src/ThreadCommandReader.java
+++ net/minecraft/src/ThreadCommandReader.java
@@ -6,7 +6,7 @@
 import net.minecraft.server.MinecraftServer;
 
 public class ThreadCommandReader extends Thread {
-	final MinecraftServer mcServer;
+	public final MinecraftServer mcServer;
 
 	public ThreadCommandReader(MinecraftServer var1) {
 		this.mcServer = var1;
--- /dev/null
+++ net/minecraft/src/Packet8UpdateHealth.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet8UpdateHealth extends Packet {
+	public int healthMP;
+
+	public Packet8UpdateHealth() {
+	}
+
+	public Packet8UpdateHealth(int var1) {
+		this.healthMP = var1;
+	}
+
+	public void readPacketData(DataInputStream dataInputStream1) throws IOException {
+		this.healthMP = dataInputStream1.readShort();
+	}
+
+	public void writePacket(DataOutputStream dataOutputStream1) throws IOException {
+		dataOutputStream1.writeShort(this.healthMP);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleHealth(this);
+	}
+
+	public int getPacketSize() {
+		return 2;
+	}
+}
--- net/minecraft/src/ConsoleLogFormatter.java
+++ net/minecraft/src/ConsoleLogFormatter.java
@@ -12,7 +12,7 @@
 
 	public String format(LogRecord var1) {
 		StringBuilder var2 = new StringBuilder();
-		var2.append(this.dateFormat.format(Long.valueOf(var1.getMillis())));
+		var2.append(this.dateFormat.format(var1.getMillis()));
 		Level var3 = var1.getLevel();
 		if(var3 == Level.FINEST) {
 			var2.append(" [FINEST] ");
@@ -36,7 +36,7 @@
 		if(var4 != null) {
 			StringWriter var5 = new StringWriter();
 			var4.printStackTrace(new PrintWriter(var5));
-			var2.append(var5.toString());
+			var2.append(var5);
 		}
 
 		return var2.toString();
--- net/minecraft/src/GuiStatsListener.java
+++ net/minecraft/src/GuiStatsListener.java
@@ -3,14 +3,14 @@
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
 
-class GuiStatsListener implements ActionListener {
-	final GuiStatsComponent component;
+public class GuiStatsListener implements ActionListener {
+	public final GuiStatsComponent component;
 
-	GuiStatsListener(GuiStatsComponent var1) {
+	public GuiStatsListener(GuiStatsComponent var1) {
 		this.component = var1;
 	}
 
-	public void actionPerformed(ActionEvent var1) {
+	public void actionPerformed(ActionEvent actionEvent) {
 		GuiStatsComponent.update(this.component);
 	}
 }
--- net/minecraft/src/EntityLiving.java
+++ net/minecraft/src/EntityLiving.java
@@ -4,6 +4,7 @@
 
 public class EntityLiving extends Entity {
 	public int heartsHalvesLife = 20;
+	public int healthRegen = 0;
 	public float unusedRotationPitch2;
 	public float unusedFloat;
 	public float unusedRotationPitch;
@@ -46,14 +47,15 @@
 	private double newPosZ;
 	private double newRotationYaw;
 	private double newRotationPitch;
-	float unusedFloat3 = 0.0F;
+	protected int prevDamage = 0;
 	protected int entityAge = 0;
 	protected float moveStrafing;
 	protected float moveForward;
 	protected float randomYawVelocity;
-	protected boolean isJumping = false;
+	public boolean isJumping = false;
 	protected float defaultPitch = 0.0F;
-	protected float moveSpeed = 0.7F;
+	public float moveSpeed = 0.7F;
+	public float runSpeed = 1.4F;
 	private Entity currentTarget;
 	private int numTicksToChaseTarget = 0;
 
@@ -68,7 +70,7 @@
 		this.stepHeight = 0.5F;
 	}
 
-	protected boolean canEntityBeSeen(Entity var1) {
+	public boolean canEntityBeSeen(Entity var1) {
 		return this.worldObj.rayTraceBlocks(Vec3D.createVector(this.posX, this.posY + (double)this.getEyeHeight(), this.posZ), Vec3D.createVector(var1.posX, var1.posY + (double)var1.getEyeHeight(), var1.posZ)) == null;
 	}
 
@@ -99,7 +101,7 @@
 			this.livingSoundTime = -this.getTalkInterval();
 			String var1 = this.getLivingSound();
 			if(var1 != null) {
-				this.worldObj.playSoundAtEntity(this, var1, this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
+				this.worldObj.playSoundAtEntity(this, var1, this.getSoundVolume(), ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F) * this.getSoundPitch());
 			}
 		}
 
@@ -294,8 +296,13 @@
 	}
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
-		if(this.worldObj.multiplayerWorld) {
-			var2 = 0;
+		if(!this.worldObj.canDoClientAction()) {
+			return false;
+		}
+
+		var2 = ModLoader.callHook(BaseMod::onEntityHurt, this.getClass(), this, var1, var2);
+		if (var2 <= 0) {
+			return false;
 		}
 
 		this.entityAge = 0;
@@ -303,39 +310,50 @@
 			return false;
 		} else {
 			this.limbYaw = 1.5F;
+			boolean hurt = true;
+
 			if((float)this.heartsLife > (float)this.heartsHalvesLife / 2.0F) {
-				if(this.prevHealth - var2 >= this.health) {
+				if(var2 <= this.prevDamage) {
 					return false;
 				}
 
-				this.health = this.prevHealth - var2;
+				this.damageEntity(var2 - this.prevDamage);
+				this.prevDamage = var2;
+				hurt = false;
 			} else {
+				this.prevDamage = var2;
 				this.prevHealth = this.health;
 				this.heartsLife = this.heartsHalvesLife;
-				this.health -= var2;
-				this.hurtTime = this.maxHurtTime = 10;
+				this.damageEntity(var2);
+				this.hurtTime = this.maxHurtTime = this.heartsHalvesLife / 2;
 			}
 
 			this.attackedAtYaw = 0.0F;
-			if(var1 != null) {
-				double var3 = var1.posX - this.posX;
-
-				double var5;
-				for(var5 = var1.posZ - this.posZ; var3 * var3 + var5 * var5 < 1.0E-4D; var5 = (Math.random() - Math.random()) * 0.01D) {
-					var3 = (Math.random() - Math.random()) * 0.01D;
+			if(hurt) {
+				this.worldObj.sendTrackedEntityStatusUpdatePacket(this, (byte) 2);
+				this.setUpdateVelocity();
+				if (var1 != null) {
+					double var3 = var1.posX - this.posX;
+
+					double var5;
+					for(var5 = var1.posZ - this.posZ; var3 * var3 + var5 * var5 < 1.0E-4D; var5 = (Math.random() - Math.random()) * 0.01D) {
+						var3 = (Math.random() - Math.random()) * 0.01D;
+					}
+
+					this.attackedAtYaw = (float)(Math.atan2(var5, var3) * 180.0D / (double)((float)Math.PI)) - this.rotationYaw;
+					this.knockBack(var1, var2, var3, var5);
+				} else {
+					this.attackedAtYaw = (float)((int)(Math.random() * 2.0D) * 180);
 				}
-
-				this.attackedAtYaw = (float)(Math.atan2(var5, var3) * 180.0D / (double)((float)Math.PI)) - this.rotationYaw;
-				this.knockBack(var1, var2, var3, var5);
-			} else {
-				this.attackedAtYaw = (float)((int)(Math.random() * 2.0D) * 180);
 			}
 
 			if(this.health <= 0) {
-				this.worldObj.playSoundAtEntity(this, this.getDeathSound(), this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
+				if (hurt) {
+					this.worldObj.playSoundAtEntity(this, this.getDeathSound(), this.getSoundVolume(), ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F) * this.getSoundPitch());
+				}
 				this.onDeath(var1);
 			} else {
-				this.worldObj.playSoundAtEntity(this, this.getHurtSound(), this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
+				this.worldObj.playSoundAtEntity(this, this.getHurtSound(), this.getSoundVolume(), ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F) * this.getSoundPitch());
 			}
 
 			return true;
@@ -346,6 +364,10 @@
 		return 1.0F;
 	}
 
+	protected float getSoundPitch() {
+		return 1.0F;
+	}
+
 	protected String getLivingSound() {
 		return null;
 	}
@@ -358,15 +380,15 @@
 		return "random.hurt";
 	}
 
-	public void knockBack(Entity var1, int var2, double var3, double var5) {
-		float var7 = MathHelper.sqrt_double(var3 * var3 + var5 * var5);
+	public void knockBack(Entity var1, int var2, double y, double z) {
+		float var7 = MathHelper.sqrt_double(y * y + z * z);
 		float var8 = 0.4F;
 		this.motionX /= 2.0D;
 		this.motionY /= 2.0D;
 		this.motionZ /= 2.0D;
-		this.motionX -= var3 / (double)var7 * (double)var8;
+		this.motionX -= y / (double)var7 * (double)var8;
 		this.motionY += (double)0.4F;
-		this.motionZ -= var5 / (double)var7 * (double)var8;
+		this.motionZ -= z / (double)var7 * (double)var8;
 		if(this.motionY > (double)0.4F) {
 			this.motionY = (double)0.4F;
 		}
@@ -374,37 +396,53 @@
 	}
 
 	public void onDeath(Entity var1) {
+		ModLoader.callHook(BaseMod::onEntityDeath, this.getClass(), this, var1);
+
 		if(this.scoreValue > 0 && var1 != null) {
 			var1.addToPlayerScore(this, this.scoreValue);
 		}
 
 		this.dead = true;
-		int var2 = this.getDropItemId();
-		if(var2 > 0) {
-			int var3 = this.rand.nextInt(3);
-
-			for(int var4 = 0; var4 < var3; ++var4) {
-				this.dropItem(var2, 1);
+		int[] items = this.getDropItems();
+
+		if (this.worldObj.canDoClientAction()) {
+			for (int var2 : items) {
+				if(var2 > 0) {
+					int var3 = this.rand.nextInt(this.getMaxDropItems());
+
+					for(int var4 = 0; var4 < var3; ++var4) {
+						this.dropItem(var2, 1);
+					}
+				}
 			}
 		}
 
+		this.worldObj.sendTrackedEntityStatusUpdatePacket(this, (byte)3);
 	}
 
 	protected int getDropItemId() {
 		return 0;
 	}
 
+	protected int[] getDropItems() {
+		return new int[] { getDropItemId() };
+	}
+
 	protected void fall(float var1) {
+		super.fall(var1);
 		int var2 = (int)Math.ceil((double)(var1 - 3.0F));
 		if(var2 > 0) {
 			this.attackEntityFrom((Entity)null, var2);
 			int var3 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY - (double)0.2F - (double)this.yOffset), MathHelper.floor_double(this.posZ));
 			if(var3 > 0) {
 				StepSound var4 = Block.blocksList[var3].stepSound;
-				this.worldObj.playSoundAtEntity(this, var4.getStepSound(), var4.getVolume() * 0.5F, var4.getPitch() * (12.0F / 16.0F));
+				this.worldObj.playSoundAtEntity(this, var4.getStepSound(), var4.getVolume() * 0.5F, var4.getPitch() * 0.75F);
 			}
 		}
+	}
 
+	protected void damageEntity(int var1) {
+		this.health -= var1;
 	}
 
 	public void moveEntityWithHeading(float var1, float var2) {
@@ -442,7 +480,7 @@
 			}
 
 			float var9 = 0.16277136F / (var8 * var8 * var8);
-			this.moveFlying(var1, var2, this.onGround ? 0.1F * var9 : 0.02F);
+			this.moveFlying(var1, var2, (this.onGround ? var9 * 0.1F : this.isRunning() ? 0.025F : 0.02F) * (this.isRunning() ? this.runSpeed : 1.0F) * (this.flying ? 2.5F : 1.0F));
 			var8 = 0.91F;
 			if(this.onGround) {
 				var8 = 546.0F * 0.1F * 0.1F * 0.1F;
@@ -464,7 +502,9 @@
 				this.motionY = 0.2D;
 			}
 
-			this.motionY -= 0.08D;
+			if (!this.flying) {
+				this.motionY -= 0.08D;
+			}
 			this.motionY *= (double)0.98F;
 			this.motionX *= (double)var8;
 			this.motionZ *= (double)var8;
@@ -491,6 +531,7 @@
 
 	public void writeEntityToNBT(NBTTagCompound var1) {
 		var1.setShort("Health", (short)this.health);
+		var1.setShort("HealthRegen", (short)this.healthRegen);
 		var1.setShort("HurtTime", (short)this.hurtTime);
 		var1.setShort("DeathTime", (short)this.deathTime);
 		var1.setShort("AttackTime", (short)this.attackTime);
@@ -501,6 +542,7 @@
 		if(!var1.hasKey("Health")) {
 			this.health = 10;
 		}
+		this.healthRegen = var1.getShort("HealthRegen");
 
 		this.hurtTime = var1.getShort("HurtTime");
 		this.deathTime = var1.getShort("DeathTime");
@@ -643,7 +685,7 @@
 		double var13 = (double)MathHelper.sqrt_double(var3 * var3 + var7 * var7);
 		float var11 = (float)(Math.atan2(var7, var3) * 180.0D / (double)((float)Math.PI)) - 90.0F;
 		float var12 = (float)(Math.atan2(var5, var13) * 180.0D / (double)((float)Math.PI));
-		this.rotationPitch = this.updateRotation(this.rotationPitch, var12, var2);
+		this.rotationPitch = this.updateRotation(this.rotationPitch, -var12, var2);
 		this.rotationYaw = this.updateRotation(this.rotationYaw, var11, var2);
 	}
 
@@ -725,5 +767,39 @@
 		Vec3D var5 = this.getLook(var3);
 		Vec3D var6 = var4.addVector(var5.xCoord * var1, var5.yCoord * var1, var5.zCoord * var1);
 		return this.worldObj.rayTraceBlocks(var4, var6);
+	}
+
+	public void handleHealthUpdate(byte var1) {
+		if(var1 == 2) {
+			this.limbYaw = 1.5F;
+			this.heartsLife = this.heartsHalvesLife;
+			this.hurtTime = this.maxHurtTime = this.heartsHalvesLife / 2;
+			this.attackedAtYaw = 0.0F;
+			this.worldObj.playSoundAtEntity(this, this.getHurtSound(), this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
+			this.attackEntityFrom(null, 0);
+		} else if(var1 == 3) {
+			this.worldObj.playSoundAtEntity(this, this.getDeathSound(), this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
+			this.health = 0;
+			this.onDeath(null);
+		} else {
+			super.handleHealthUpdate(var1);
+		}
+	}
+
+	public int getMaxDropItems() {
+		return 3;
+	}
+
+	public void performHurtAnimation() {
+		this.hurtTime = this.maxHurtTime = this.heartsHalvesLife / 2;
+		this.attackedAtYaw = 0.0F;
+	}
+
+	public int getMaxSpawnedInChunk() {
+		return 4;
+	}
+
+	public boolean moveInMultiplayer() {
+		return false;
 	}
 }
--- /dev/null
+++ net/minecraft/src/GuiDeleteWorldConfirm.java
@@ -1,0 +1,43 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+public class GuiDeleteWorldConfirm extends GuiScreen {
+	private final GuiScreen parentScreen;
+	private final String world;
+	private final String msg1;
+	private final String msg2;
+	private final String msg3;
+
+	public GuiDeleteWorldConfirm(GuiScreen parentScreen, String world, String displayName) {
+		this.parentScreen = parentScreen;
+		this.world = world;
+		this.msg1 = "Are you sure you want to delete this world?";
+		this.msg2 = displayName;
+		this.msg3 = "It will be lost forever!";
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiSmallButton(0, this.width / 2 - 155, this.height / 2 + 4, "Yes"));
+		this.controlList.add(new GuiSmallButton(1, this.width / 2 + 5, this.height / 2 + 4, "No"));
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		double time = (System.currentTimeMillis() / 1000.0D) % 1.0D;
+		int tint = (int)(128 * time) + 127;
+		this.drawBackground(0, (255 / 2 + tint / 2) << 16 | tint << 8 | tint, var3);
+
+		this.drawCenteredString(this.fontRenderer, this.msg1, this.width / 2, this.height / 2 - 36, 0xFFFFFF);
+		this.fontRenderer.drawStringWithShadow(this.msg2,
+				(this.width - this.fontRenderer.getStringWidth(this.msg2, true)) / 2, this.height / 2 - 24, 0xFF5555);
+		this.drawCenteredString(this.fontRenderer, this.msg3, this.width / 2, this.height / 2 - 12, 0xFFFFFF);
+
+		super.drawScreen(var1, var2, var3);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1.id == 0) {
+			World.deleteWorld(Minecraft.getMinecraftDir(), this.world);
+		}
+		this.mc.displayGuiScreen(this.parentScreen);
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemSlimeShoes.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+public class ItemSlimeShoes extends ItemCharm {
+	public ItemSlimeShoes(int id) {
+		super(id, 64, "slimeshoes");
+	}
+
+	public void updateCharm(EntityPlayer player, ItemStack stack) {
+		player.bounce = 0.5F;
+	}
+}
--- /dev/null
+++ net/minecraft/src/ModSide.java
@@ -1,0 +1,7 @@
+package net.minecraft.src;
+
+public enum ModSide {
+	BOTH,
+	CLIENT,
+	SERVER
+}
--- /dev/null
+++ net/minecraft/src/EntityLeveledMob.java
@@ -1,0 +1,67 @@
+package net.minecraft.src;
+
+public class EntityLeveledMob extends EntityMob {
+	protected final String baseTexture;
+	private boolean levelSet = false;
+
+	public EntityLeveledMob(World var1, String baseTexture) {
+		super(var1);
+		this.baseTexture = baseTexture;
+		this.texture = baseTexture + ".png";
+		this.dataWatcher.addObject(16, (byte)0);
+	}
+
+	public int getLevel() {
+		return this.dataWatcher.getWatchableObjectByte(16);
+	}
+
+	public void setLevel(int level) {
+		if (level < 0) level = 0;
+		if (level > 1) level = 1;
+		this.dataWatcher.updateObject(16, (byte)level);
+
+		if (!levelSet) {
+			if (this.worldObj.canDoClientAction()) {
+				int healthLevel = level;
+				this.health = 20;
+				while (healthLevel > 0) {
+					this.health += healthLevel * 10;
+					healthLevel--;
+				}
+			}
+			this.levelSet = true;
+		}
+		this.texture = level == 0 ? this.baseTexture + ".png" : this.baseTexture + level + ".png";
+	}
+
+	public void writeEntityToNBT(NBTTagCompound var1) {
+		super.writeEntityToNBT(var1);
+		var1.setInteger("Level", this.getLevel());
+	}
+
+	public void readEntityFromNBT(NBTTagCompound var1) {
+		super.readEntityFromNBT(var1);
+		this.levelSet = true;
+		this.setLevel(var1.getInteger("Level"));
+	}
+
+	public int getMaxDropItems() {
+		return super.getMaxDropItems() + this.getLevel();
+	}
+
+	protected Entity findPlayerToAttack() {
+		EntityPlayer var1 = this.worldObj.getClosestPlayerToEntity(this, 16.0D);
+		return var1 != null && this.canEntityBeSeen(var1) && !var1.creative ? var1 : null;
+	}
+
+	public String getTexture() {
+		return this.getLevel() == 0 ? this.baseTexture + ".png" : this.baseTexture + this.getLevel() + ".png";
+	}
+
+	public void onDeath(Entity var1) {
+		super.onDeath(var1);
+		if (this.getLevel() == 1 && this.posY < 32 && this.rand.nextInt(3) == 0) {
+			this.dropItem(Item.voidEssence.shiftedIndex, 1);
+		}
+	}
+}
--- net/minecraft/src/WorldManager.java
+++ net/minecraft/src/WorldManager.java
@@ -1,7 +1,6 @@
 package net.minecraft.src;
 
 import net.minecraft.server.MinecraftServer;
-
 public class WorldManager implements IWorldAccess {
 	private MinecraftServer mcServer;
 
@@ -26,6 +25,9 @@
 	public void markBlockRangeNeedsUpdate(int var1, int var2, int var3, int var4, int var5, int var6) {
 	}
 
+	public void markBlockNeedsRenderUpdate(int var1, int var2, int var3) {
+	}
+
 	public void updateAllRenderers() {
 	}
 
@@ -33,10 +35,14 @@
 		this.mcServer.configManager.markBlockNeedsUpdate(var1, var2, var3);
 	}
 
-	public void playRecord(String var1, int var2, int var3, int var4) {
+	public void playRecord(String var1, int var2, int var3, int var4, String author) {
 	}
 
 	public void doNothingWithTileEntity(int var1, int var2, int var3, TileEntity var4) {
 		this.mcServer.configManager.sentTileEntityToPlayer(var1, var2, var3, var4);
 	}
+
+	public void performAction(EntityPlayer var1, int var2, int var3, int var4, int var5, int var6) {
+        this.mcServer.configManager.sendPacketToOtherPlayers(var1, var3, var4, var5, 64.0D, new Packet61DoorChange(var2, var3, var4, var5, var6));
+    }
 }
--- net/minecraft/src/EnumArt.java
+++ net/minecraft/src/EnumArt.java
@@ -24,15 +24,24 @@
 	Pointer("Pointer", 64, 64, 0, 192),
 	Pigscene("Pigscene", 64, 64, 64, 192),
 	Skeleton("Skeleton", 64, 48, 192, 64),
-	DonkeyKong("DonkeyKong", 64, 48, 192, 112);
+	DonkeyKong("DonkeyKong", 64, 48, 192, 112),
+	SuperbBird("SuperbBird", 32, 32, 160, 128),
+	Arid("Arid", 16, 16, 112, 0),
+	Tropical("Tropical", 32, 16, 160, 32),
+	Maple("Maple", 32, 16, 0, 48),
+	Winter("Winter", 16, 32, 32, 64),
+	PackPNG("PackPNG", 64, 64, 128, 192),
+	LaunchBase("LaunchBase", 32, 16, 32, 48),
+	ChaotixSpecial("ChaotixSpecial", 32, 32, 0, 160);
 
+	public static final int maxArtTitleLength = 16;
 	public final String title;
 	public final int sizeX;
 	public final int sizeY;
 	public final int offsetX;
 	public final int offsetY;
 
-	private EnumArt(String var3, int var4, int var5, int var6, int var7) {
+	EnumArt(String var3, int var4, int var5, int var6, int var7) {
 		this.title = var3;
 		this.sizeX = var4;
 		this.sizeY = var5;
--- net/minecraft/src/BlockDoor.java
+++ net/minecraft/src/BlockDoor.java
@@ -1,11 +1,13 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.util.Random;
 
 public class BlockDoor extends Block {
-	protected BlockDoor(int var1, Material var2) {
+	public BlockDoor(int var1, Material var2) {
 		super(var1, var2);
-		this.blockIndexInTexture = 97;
+		this.blockIndexInTexture = textureXY(6, 9);
 		if(var2 == Material.iron) {
 			++this.blockIndexInTexture;
 		}
@@ -23,7 +25,7 @@
 			} else {
 				int var4 = var3 / 2 + (var1 & 1 ^ var3);
 				var4 += (var2 & 4) / 4;
-				int var5 = this.blockIndexInTexture - (var2 & 8) * 2;
+				int var5 = this.blockIndexInTexture - (var2 & 8) * 4;
 				if((var4 & 1) != 0) {
 					var5 = -var5;
 				}
@@ -104,12 +106,7 @@
 
 				var1.setBlockMetadataWithNotify(var2, var3, var4, var6 ^ 4);
 				var1.markBlocksDirty(var2, var3 - 1, var4, var2, var3, var4);
-				if(Math.random() < 0.5D) {
-					var1.playSoundEffect((double)var2 + 0.5D, (double)var3 + 0.5D, (double)var4 + 0.5D, "random.door_open", 1.0F, var1.rand.nextFloat() * 0.1F + 0.9F);
-				} else {
-					var1.playSoundEffect((double)var2 + 0.5D, (double)var3 + 0.5D, (double)var4 + 0.5D, "random.door_close", 1.0F, var1.rand.nextFloat() * 0.1F + 0.9F);
-				}
-
+				var1.performAction(var5, 1003, var2, var3, var4, 0);
 				return true;
 			}
 		}
@@ -131,12 +128,7 @@
 
 				var1.setBlockMetadataWithNotify(var2, var3, var4, var6 ^ 4);
 				var1.markBlocksDirty(var2, var3 - 1, var4, var2, var3, var4);
-				if(Math.random() < 0.5D) {
-					var1.playSoundEffect((double)var2 + 0.5D, (double)var3 + 0.5D, (double)var4 + 0.5D, "random.door_open", 1.0F, var1.rand.nextFloat() * 0.1F + 0.9F);
-				} else {
-					var1.playSoundEffect((double)var2 + 0.5D, (double)var3 + 0.5D, (double)var4 + 0.5D, "random.door_close", 1.0F, var1.rand.nextFloat() * 0.1F + 0.9F);
-				}
-
+				var1.performAction(null, 1003, var2, var3, var4, 0);
 			}
 		}
 	}
@@ -190,6 +182,6 @@
 	}
 
 	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
-		return var3 >= 127 ? false : var1.isBlockNormalCube(var2, var3 - 1, var4) && super.canPlaceBlockAt(var1, var2, var3, var4) && super.canPlaceBlockAt(var1, var2, var3 + 1, var4);
+		return var3 >= CHUNK_HEIGHT - 1 ? false : var1.isBlockNormalCube(var2, var3 - 1, var4) && super.canPlaceBlockAt(var1, var2, var3, var4) && super.canPlaceBlockAt(var1, var2, var3 + 1, var4);
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet7UseEntity.java
@@ -1,0 +1,40 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet7UseEntity extends Packet {
+	public int playerEntityId;
+	public int targetEntity;
+	public int isLeftClick;
+
+	public Packet7UseEntity() {
+	}
+
+	public Packet7UseEntity(int var1, int var2, int var3) {
+		this.playerEntityId = var1;
+		this.targetEntity = var2;
+		this.isLeftClick = var3;
+	}
+
+	public void readPacketData(DataInputStream dataInputStream1) throws IOException {
+		this.playerEntityId = dataInputStream1.readInt();
+		this.targetEntity = dataInputStream1.readInt();
+		this.isLeftClick = dataInputStream1.readByte();
+	}
+
+	public void writePacket(DataOutputStream dataOutputStream1) throws IOException {
+		dataOutputStream1.writeInt(this.playerEntityId);
+		dataOutputStream1.writeInt(this.targetEntity);
+		dataOutputStream1.writeByte(this.isLeftClick);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleUseEntity(this);
+	}
+
+	public int getPacketSize() {
+		return 9;
+	}
+}
--- /dev/null
+++ net/minecraft/src/Packet38EntityStatus.java
@@ -1,0 +1,36 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet38EntityStatus extends Packet {
+	public int entityId;
+	public byte entityStatus;
+
+	public Packet38EntityStatus() {
+	}
+
+	public Packet38EntityStatus(int var1, byte var2) {
+		this.entityId = var1;
+		this.entityStatus = var2;
+	}
+
+	public void readPacketData(DataInputStream dataInputStream1) throws IOException {
+		this.entityId = dataInputStream1.readInt();
+		this.entityStatus = dataInputStream1.readByte();
+	}
+
+	public void writePacket(DataOutputStream dataOutputStream1) throws IOException {
+		dataOutputStream1.writeInt(this.entityId);
+		dataOutputStream1.writeByte(this.entityStatus);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleEntityStatus(this);
+	}
+
+	public int getPacketSize() {
+		return 5;
+	}
+}
--- net/minecraft/src/BlockStone.java
+++ net/minecraft/src/BlockStone.java
@@ -1,13 +1,49 @@
 package net.minecraft.src;
 
+import java.util.Arrays;
+import java.util.List;
 import java.util.Random;
+import java.util.stream.IntStream;
 
 public class BlockStone extends Block {
+	public static final List<String> stoneTypeNames = Arrays.asList(
+			"stone",
+			"marble",
+			"slate",
+			"granite",
+			"shadorite"
+	);
+
+	public final BitField fieldType = this.fields.addBitField("type", 8, stoneTypeNames);
+
+	protected final int drop;
+
 	public BlockStone(int var1, int var2) {
+		this(var1, var2, var1);
+	}
+
+	public BlockStone(int var1, int var2, int var3) {
 		super(var1, var2, Material.rock);
+		this.drop = var3;
 	}
 
 	public int idDropped(int var1, Random var2) {
-		return Block.cobblestone.blockID;
+		return this.drop;
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var1;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, stoneTypeNames.size()).toArray();
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return this.blockIndexInTexture + var2 * 32;
 	}
 }
--- net/minecraft/src/RenderItem.java
+++ net/minecraft/src/RenderItem.java
@@ -1,12 +1,14 @@
 package net.minecraft.src;
 
 import java.util.Random;
+
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
 
 public class RenderItem extends Render {
 	private RenderBlocks itemRenderBlocks = new RenderBlocks();
 	private Random random = new Random();
+	public float zLevel = 0.0F;
 
 	public RenderItem() {
 		this.shadowSize = 0.15F;
@@ -37,13 +39,10 @@
 		float var16;
 		float var17;
 		float var18;
-		if(var10.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var10.itemID].getRenderType())) {
+		if(var10.itemID < 10000 && RenderBlocks.renderItemIn3d(Block.blocksList[var10.itemID].getRenderType())) {
 			GL11.glRotatef(var12, 0.0F, 1.0F, 0.0F);
 			this.loadTexture("/terrain.png");
 			float var27 = 0.25F;
-			if(!Block.blocksList[var10.itemID].renderAsNormalBlock() && var10.itemID != Block.stairSingle.blockID) {
-				var27 = 0.5F;
-			}
 
 			GL11.glScalef(var27, var27, var27);
 
@@ -56,23 +55,23 @@
 					GL11.glTranslatef(var16, var17, var18);
 				}
 
-				this.itemRenderBlocks.renderBlockOnInventory(Block.blocksList[var10.itemID]);
+				this.itemRenderBlocks.renderBlockOnInventory(Block.blocksList[var10.itemID], Math.max(var10.itemMetadata, 0));
 				GL11.glPopMatrix();
 			}
 		} else {
 			GL11.glScalef(0.5F, 0.5F, 0.5F);
 			int var14 = var10.getIconIndex();
-			if(var10.itemID < 256) {
+			if(var10.itemID < 10000) {
 				this.loadTexture("/terrain.png");
 			} else {
 				this.loadTexture("/gui/items.png");
 			}
 
 			Tessellator var15 = Tessellator.instance;
-			var16 = (float)(var14 % 16 * 16 + 0) / 256.0F;
-			var17 = (float)(var14 % 16 * 16 + 16) / 256.0F;
-			var18 = (float)(var14 / 16 * 16 + 0) / 256.0F;
-			float var19 = (float)(var14 / 16 * 16 + 16) / 256.0F;
+			var16 = (float)(var14 % 32 * 16 + 0) / 512.0F;
+			var17 = (float)(var14 % 32 * 16 + 16) / 512.0F;
+			var18 = (float)(var14 / 32 * 16 + 0) / 512.0F;
+			float var19 = (float)(var14 / 32 * 16 + 16) / 512.0F;
 			float var20 = 1.0F;
 			float var21 = 0.5F;
 			float var22 = 0.25F;
@@ -87,6 +86,7 @@
 				}
 
 				GL11.glRotatef(180.0F - this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
+				GL11.glRotatef(-this.renderManager.playerViewX / 2.0F, 1.0F, 0.0F, 0.0F);
 				var15.startDrawingQuads();
 				var15.setNormal(0.0F, 1.0F, 0.0F);
 				var15.addVertexWithUV((double)(0.0F - var21), (double)(0.0F - var22), 0.0D, (double)var16, (double)var19);
@@ -104,40 +104,64 @@
 
 	public void renderItemIntoGUI(FontRenderer var1, RenderEngine var2, ItemStack var3, int var4, int var5) {
 		if(var3 != null) {
-			if(var3.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var3.itemID].getRenderType())) {
+			if(var3.getItem() instanceof ItemBlock && RenderBlocks.renderItemIn3d(Block.blocksList[var3.itemID].getRenderType())) {
 				int var6 = var3.itemID;
 				var2.bindTexture(var2.getTexture("/terrain.png"));
 				Block var7 = Block.blocksList[var6];
 				GL11.glPushMatrix();
-				GL11.glTranslatef((float)(var4 - 2), (float)(var5 + 3), 0.0F);
+				GL11.glTranslatef((float)(var4 - 2), (float)(var5 + 3), -3.0F);
 				GL11.glScalef(10.0F, 10.0F, 10.0F);
-				GL11.glTranslatef(1.0F, 0.5F, 8.0F);
+				GL11.glTranslatef(1.0F, 0.5F, 1.0F);
+				GL11.glScalef(1.0F, 1.0F, -1.0F);
 				GL11.glRotatef(210.0F, 1.0F, 0.0F, 0.0F);
 				GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
-				GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-				GL11.glScalef(1.0F, 1.0F, 1.0F);
-				this.itemRenderBlocks.renderBlockOnInventory(var7);
+				this.itemRenderBlocks.renderBlockOnInventory(var7, Math.max(var3.itemMetadata, 0));
 				GL11.glPopMatrix();
 			} else if(var3.getIconIndex() >= 0) {
 				GL11.glDisable(GL11.GL_LIGHTING);
-				if(var3.itemID < 256) {
+				if(var3.getItem() instanceof ItemBlock) {
 					var2.bindTexture(var2.getTexture("/terrain.png"));
 				} else {
 					var2.bindTexture(var2.getTexture("/gui/items.png"));
 				}
 
-				this.renderIcon(var4, var5, var3.getIconIndex() % 16 * 16, var3.getIconIndex() / 16 * 16, 16, 16);
+				this.renderIcon(var4, var5, var3.getIconIndex() % 32 * 16, var3.getIconIndex() / 32 * 16, 16, 16);
 				GL11.glEnable(GL11.GL_LIGHTING);
 			}
 
 			GL11.glEnable(GL11.GL_CULL_FACE);
+
+			ItemTrinket trinket = var3.getTrinket();
+			if (trinket != null) {
+				int c = trinket.getColor();
+				float r = ((c >> 16) & 0xFF) / 255.0F;
+				float g = ((c >> 8) & 0xFF) / 255.0F;
+				float b = (c & 0xFF) / 255.0F;
+
+				GL11.glDepthFunc(GL11.GL_GREATER);
+				GL11.glDisable(GL11.GL_LIGHTING);
+				GL11.glDepthMask(false);
+				var2.bindTexture(var2.getTexture("~~/gui/glint.png"));
+				this.zLevel -= 50.0F;
+				GL11.glEnable(GL11.GL_BLEND);
+				GL11.glBlendFunc(GL11.GL_DST_COLOR, GL11.GL_DST_COLOR);
+				GL11.glColor4f(r, g, b, 1.0F);
+				this.func_40266_a(var4 * 431278612 + var5 * 32178161, var4 - 2, var5 - 2, 20, 20);
+				GL11.glDisable(GL11.GL_BLEND);
+				GL11.glDepthMask(true);
+				this.zLevel += 50.0F;
+				GL11.glEnable(GL11.GL_LIGHTING);
+				GL11.glDepthFunc(GL11.GL_LEQUAL);
+				GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+				GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+			}
 		}
 	}
 
 	public void renderItemOverlayIntoGUI(FontRenderer var1, RenderEngine var2, ItemStack var3, int var4, int var5) {
 		if(var3 != null) {
 			if(var3.stackSize > 1) {
-				String var6 = "" + var3.stackSize;
+				String var6 = String.valueOf(var3.stackSize);
 				GL11.glDisable(GL11.GL_LIGHTING);
 				GL11.glDisable(GL11.GL_DEPTH_TEST);
 				var1.drawStringWithShadow(var6, var4 + 19 - 2 - var1.getStringWidth(var6), var5 + 6 + 3, 16777215);
@@ -162,24 +186,31 @@
 				GL11.glEnable(GL11.GL_DEPTH_TEST);
 				GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 			}
+		}
+	}
 
+	public void renderItemHoverOverlayIntoGUI(FontRenderer var1, RenderEngine var2, ItemStack var3, int var4, int var5) {
+		if (var3 != null) {
+			if (var3.getItem() instanceof ItemVanity && ((ItemVanity) var3.getItem()).dyable) {
+				this.renderIcon(var4 + 8, var5 + 8, (var3.itemMetadata % 4 + 28) * 16 + 4, (var3.itemMetadata / 4 + 28) * 16 + 4, 8, 8);
+			}
 		}
 	}
 
 	private void renderQuad(Tessellator var1, int var2, int var3, int var4, int var5, int var6) {
 		var1.startDrawingQuads();
 		var1.setColorOpaque_I(var6);
-		var1.addVertex((double)(var2 + 0), (double)(var3 + 0), 0.0D);
-		var1.addVertex((double)(var2 + 0), (double)(var3 + var5), 0.0D);
-		var1.addVertex((double)(var2 + var4), (double)(var3 + var5), 0.0D);
-		var1.addVertex((double)(var2 + var4), (double)(var3 + 0), 0.0D);
+		var1.addVertex((double)(var2 + 0), (double)(var3 + 0), (double)(this.zLevel));
+		var1.addVertex((double)(var2 + 0), (double)(var3 + var5), (double)(this.zLevel));
+		var1.addVertex((double)(var2 + var4), (double)(var3 + var5), (double)(this.zLevel));
+		var1.addVertex((double)(var2 + var4), (double)(var3 + 0), (double)(this.zLevel));
 		var1.draw();
 	}
 
 	public void renderIcon(int var1, int var2, int var3, int var4, int var5, int var6) {
-		float var7 = 0.0F;
-		float var8 = 0.00390625F;
-		float var9 = 0.00390625F;
+		float var7 = this.zLevel;
+		float var8 = 1.0F / 512.0F;
+		float var9 = 1.0F / 512.0F;
 		Tessellator var10 = Tessellator.instance;
 		var10.startDrawingQuads();
 		var10.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), (double)var7, (double)((float)(var3 + 0) * var8), (double)((float)(var4 + var6) * var9));
@@ -187,6 +218,36 @@
 		var10.addVertexWithUV((double)(var1 + var5), (double)(var2 + 0), (double)var7, (double)((float)(var3 + var5) * var8), (double)((float)(var4 + 0) * var9));
 		var10.addVertexWithUV((double)(var1 + 0), (double)(var2 + 0), (double)var7, (double)((float)(var3 + 0) * var8), (double)((float)(var4 + 0) * var9));
 		var10.draw();
+	}
+
+	private void func_40266_a(int var1, int var2, int var3, int var4, int var5) {
+		for(int var6 = 0; var6 < 2; ++var6) {
+			if(var6 == 0) {
+				GL11.glBlendFunc(GL11.GL_SRC_COLOR, GL11.GL_ONE);
+			}
+
+			if(var6 == 1) {
+				GL11.glBlendFunc(GL11.GL_SRC_COLOR, GL11.GL_ONE);
+			}
+
+			float var7 = 0.00390625F;
+			float var8 = 0.00390625F;
+			float var9 = (float)(System.currentTimeMillis() % (long)(3000 + var6 * 1873)) / (3000.0F + (float)(var6 * 1873)) * 256.0F;
+			float var10 = 0.0F;
+			Tessellator var11 = Tessellator.instance;
+			float var12 = 4.0F;
+			if(var6 == 1) {
+				var12 = -1.0F;
+			}
+
+			var11.startDrawingQuads();
+			var11.addVertexWithUV((double)(var2 + 0), (double)(var3 + var5), (double)this.zLevel, (double)((var9 + (float)var5 * var12) * var7), (double)((var10 + (float)var5) * var8));
+			var11.addVertexWithUV((double)(var2 + var4), (double)(var3 + var5), (double)this.zLevel, (double)((var9 + (float)var4 + (float)var5 * var12) * var7), (double)((var10 + (float)var5) * var8));
+			var11.addVertexWithUV((double)(var2 + var4), (double)(var3 + 0), (double)this.zLevel, (double)((var9 + (float)var4) * var7), (double)((var10 + 0.0F) * var8));
+			var11.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), (double)this.zLevel, (double)((var9 + 0.0F) * var7), (double)((var10 + 0.0F) * var8));
+			var11.draw();
+		}
+
 	}
 
 	public void doRender(Entity var1, double var2, double var4, double var6, float var8, float var9) {
--- /dev/null
+++ net/minecraft/src/BlockStepType.java
@@ -1,0 +1,25 @@
+package net.minecraft.src;
+
+public class BlockStepType {
+	public final String name;
+	public final int sideTexture;
+	public final int topTexture;
+
+	public BlockStepType(String name, int texture) {
+		this(name, texture, texture);
+	}
+
+	public BlockStepType(String name, int texture, boolean autoSide) {
+		this(name, autoSide ? texture - 1 : texture, texture);
+	}
+
+	public BlockStepType(String name, int sideTexture, int topTexture) {
+		this.name = name;
+		this.sideTexture = sideTexture;
+		this.topTexture = topTexture;
+	}
+
+	public int getTextureFromSide(int side) {
+		return side <= 1 ? topTexture : sideTexture;
+	}
+}
--- /dev/null
+++ net/minecraft/src/TileEntityRefabricatorRender.java
@@ -1,0 +1,18 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+public class TileEntityRefabricatorRender extends TileEntitySpecialRenderer {
+	public void renderTileEntityRefabricatorAt(TileEntityRefabricator tileEntity1, double var2, double var4, double var6, float var8) {
+		EntityItem displayItem = tileEntity1.getDisplayItem();
+		if (displayItem != null && displayItem.item != null) {
+			float brightness = tileEntity1.worldObj.getBrightness(tileEntity1.xCoord, tileEntity1.yCoord + 1, tileEntity1.zCoord);
+			GL11.glColor3f(brightness, brightness, brightness);
+			RenderManager.instance.renderEntityWithPosYaw(displayItem, var2 + 0.5D, var4 + 1.2D, var6 + 0.5D, 0.0F, var8);
+		}
+	}
+
+	public void renderTileEntityAt(TileEntity tileEntity1, double var2, double var4, double var6, float var8) {
+		this.renderTileEntityRefabricatorAt((TileEntityRefabricator) tileEntity1, var2, var4, var6, var8);
+	}
+}
--- /dev/null
+++ net/minecraft/src/BiomeSavanna.java
@@ -1,0 +1,28 @@
+package net.minecraft.src;
+
+public class BiomeSavanna extends Biome {
+	private static final TreePopulator trees = new TreePopulator()
+			.withTree(new WorldGenMahoganyTrees())
+			.withShrub(new WorldGenShrubs().withMetadata(3), -5)
+			.withDensity(10.0D, 4.0D, 5.0D, 0.0D, 100.0D);
+
+	protected BiomeSavanna(int id, String name, float priority, ClimateZone... climateZones) {
+		super(id, name, priority, climateZones);
+	}
+
+	public void populate(PopulatorHost host) {
+		trees.populate(host);
+	}
+
+	public int getSurfaceMetadata() {
+		return 1;
+	}
+
+	public int getStoneMetadata() {
+		return 3;
+	}
+
+	public int[] getMapColor() {
+		return new int[] { 255, 255, 0 };
+	}
+}
--- net/minecraft/src/NBTTagEnd.java
+++ net/minecraft/src/NBTTagEnd.java
@@ -5,10 +5,10 @@
 import java.io.IOException;
 
 public class NBTTagEnd extends NBTBase {
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 	}
 
 	public byte getType() {
@@ -17,5 +17,9 @@
 
 	public String toString() {
 		return "END";
+	}
+
+	public NBTBase copy() {
+		return new NBTTagEnd();
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet19EntityAction.java
@@ -1,0 +1,36 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet19EntityAction extends Packet {
+	public int entityId;
+	public int state;
+
+	public Packet19EntityAction() {
+	}
+
+	public Packet19EntityAction(Entity var1, int var2) {
+		this.entityId = var1.entityID;
+		this.state = var2;
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.entityId = var1.readInt();
+		this.state = var1.readByte();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeInt(this.entityId);
+		var1.writeByte(this.state);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleEntityAction(this);
+	}
+
+	public int getPacketSize() {
+		return 5;
+	}
+}
--- net/minecraft/src/RenderSorter.java
+++ net/minecraft/src/RenderSorter.java
@@ -10,9 +10,14 @@
 	}
 
 	public int doCompare(WorldRenderer var1, WorldRenderer var2) {
+		boolean renderUnderworld = this.baseEntity.boundingBox.minY < 64;
 		boolean var3 = var1.isInFrustum;
 		boolean var4 = var2.isInFrustum;
-		return var3 && !var4 ? 1 : (var4 && !var3 ? -1 : (var1.distanceToEntitySquared(this.baseEntity) < var2.distanceToEntitySquared(this.baseEntity) ? 1 : -1));
+		return var3 && !var4
+			? 1
+			: (var4 && !var3
+				? -1
+				: (Float.compare(var2.distanceToEntitySquared(this.baseEntity), var1.distanceToEntitySquared(this.baseEntity))));
 	}
 
 	public int compare(Object var1, Object var2) {
--- net/minecraft/server/MinecraftServer.java
+++ net/minecraft/server/MinecraftServer.java
@@ -11,39 +11,45 @@
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import net.minecraft.src.AxisAlignedBB;
-import net.minecraft.src.ConsoleLogManager;
-import net.minecraft.src.EntityPlayerMP;
-import net.minecraft.src.EntityTracker;
-import net.minecraft.src.ICommandListener;
-import net.minecraft.src.IProgressUpdate;
-import net.minecraft.src.IUpdatePlayerListBox;
-import net.minecraft.src.Item;
-import net.minecraft.src.ItemStack;
+
+import net.minecraft.src.ModLoader;
 import net.minecraft.src.NetworkListenThread;
 import net.minecraft.src.Packet3Chat;
 import net.minecraft.src.Packet4UpdateTime;
+import net.minecraft.src.IListenToMyCommands;
+import net.minecraft.src.IUpdatePlayerListBox;
 import net.minecraft.src.PropertyManager;
 import net.minecraft.src.ServerCommand;
 import net.minecraft.src.ServerConfigurationManager;
-import net.minecraft.src.ServerGUI;
 import net.minecraft.src.ThreadCommandReader;
-import net.minecraft.src.ThreadServerApplication;
 import net.minecraft.src.ThreadSleepForeverServer;
-import net.minecraft.src.Vec3D;
+import net.minecraft.src.ConvertProgressUpdater;
+import net.minecraft.src.ServerGUI;
+import net.minecraft.src.EntityTracker;
 import net.minecraft.src.WorldManager;
 import net.minecraft.src.WorldServer;
+import net.minecraft.src.ConsoleLogManager;
+import net.minecraft.src.IProgressUpdate;
+import net.minecraft.src.AxisAlignedBB;
+import net.minecraft.src.Vec3D;
+import net.minecraft.src.World;
+import net.minecraft.src.RegionTool;
+import net.minecraft.src.EntityPlayerMP;
+import net.minecraft.src.ItemStack;
+import net.minecraft.src.Item;
 
-public class MinecraftServer implements ICommandListener, Runnable {
+public class MinecraftServer implements IListenToMyCommands, Runnable {
 	public static Logger logger = Logger.getLogger("Minecraft");
 	public static HashMap playerList = new HashMap();
+	private static MinecraftServer instance;
 	public NetworkListenThread networkServer;
 	public PropertyManager propertyManagerObj;
 	public WorldServer worldMngr;
 	public ServerConfigurationManager configManager;
 	private boolean serverRunning = true;
 	public boolean serverStopped = false;
-	int deathTime = 0;
+	private int deathTime = 0;
+	private long ticksBehind = 0;
 	public String currentTask;
 	public int percentDone;
 	private List playersOnline = new ArrayList();
@@ -52,15 +58,20 @@
 	public boolean onlineMode;
 
 	public MinecraftServer() {
+		instance = this;
 		new ThreadSleepForeverServer(this);
 	}
 
+	public static MinecraftServer getInstance() {
+		return instance;
+	}
+
 	private boolean startServer() throws IOException {
-		ThreadCommandReader var1 = new ThreadCommandReader(this);
-		var1.setDaemon(true);
-		var1.start();
+		ThreadCommandReader threadCommandReader1 = new ThreadCommandReader(this);
+		threadCommandReader1.setDaemon(true);
+		threadCommandReader1.start();
 		ConsoleLogManager.init();
-		logger.info("Starting minecraft server version 0.2.1");
+		logger.info("Starting Minecraft Diverge server version " + World.VERSION_NAMES[World.CURRENT_VERSION]);
 		if(Runtime.getRuntime().maxMemory() / 1024L / 1024L < 512L) {
 			logger.warning("**** NOT ENOUGH RAM!");
 			logger.warning("To start the server with more ram, launch it as \"java -Xmx1024M -Xms1024M -jar minecraft_server.jar\"");
@@ -69,20 +80,20 @@
 		logger.info("Loading properties");
 		this.propertyManagerObj = new PropertyManager(new File("server.properties"));
 		String var2 = this.propertyManagerObj.getStringProperty("server-ip", "");
-		this.onlineMode = this.propertyManagerObj.getBooleanProperty("online-mode", true);
-		InetAddress var3 = null;
+		this.onlineMode = this.propertyManagerObj.getBooleanProperty("online-mode", false);
+		InetAddress inetAddress3 = null;
 		if(var2.length() > 0) {
-			var3 = InetAddress.getByName(var2);
+			inetAddress3 = InetAddress.getByName(var2);
 		}
 
 		int var4 = this.propertyManagerObj.getIntProperty("server-port", 25565);
 		logger.info("Starting Minecraft server on " + (var2.length() == 0 ? "*" : var2) + ":" + var4);
 
 		try {
-			this.networkServer = new NetworkListenThread(this, var3, var4);
-		} catch (IOException var6) {
+			this.networkServer = new NetworkListenThread(this, inetAddress3, var4);
+		} catch (IOException iOException6) {
 			logger.warning("**** FAILED TO BIND TO PORT!");
-			logger.log(Level.WARNING, "The exception was: " + var6.toString());
+			logger.log(Level.WARNING, "The exception was: " + iOException6);
 			logger.warning("Perhaps a server is already running on that port?");
 			return false;
 		}
@@ -94,6 +105,13 @@
 			logger.warning("To change this, set \"online-mode\" to \"true\" in the server.settings file.");
 		}
 
+		try {
+			ModLoader.init(new File("."), logger::info, this);
+		} catch (Exception e) {
+			logger.log(Level.SEVERE, "Failed to load mods!", e);
+			return false;
+		}
+
 		this.configManager = new ServerConfigurationManager(this);
 		this.entityTracker = new EntityTracker(this);
 		String var5 = this.propertyManagerObj.getStringProperty("level-name", "world");
@@ -103,11 +121,18 @@
 		return true;
 	}
 
-	private void initWorld(String var1) {
-		logger.info("Preparing start region");
-		this.worldMngr = new WorldServer(new File("."), var1, this.propertyManagerObj.getBooleanProperty("monsters", false));
+	private void initWorld(String worldName) {
+		int i2 = World.requiresConversion(new File("."), worldName);
+		if(i2 > 0) {
+			logger.info("Converting map!");
+			this.convertMapFormat(worldName);
+		}
+		this.worldMngr = new WorldServer(this, new File("."), worldName, this.propertyManagerObj.getBooleanProperty("monsters", true), this.propertyManagerObj.getCreateWorldInfo());
 		this.worldMngr.addWorldAccess(new WorldManager(this));
-		this.worldMngr.difficultySetting = 1;
+		this.worldMngr.difficultySetting = this.propertyManagerObj.getIntProperty("difficulty", 1);
+		this.worldMngr.simulationDistance = this.propertyManagerObj.getIntProperty("simulation-distance", 8);
+		this.worldMngr.fastLighting = this.propertyManagerObj.getBooleanProperty("fast-lighting", true);
+		this.worldMngr.lazyLoading = this.propertyManagerObj.getBooleanProperty("lazy-loading", true);
 		this.configManager.setPlayerManager(this.worldMngr);
 		byte var2 = 10;
 
@@ -126,10 +151,15 @@
 		this.clearCurrentTask();
 	}
 
-	private void outputPercentRemaining(String var1, int var2) {
-		this.currentTask = var1;
-		this.percentDone = var2;
-		System.out.println(var1 + ": " + var2 + "%");
+	private void convertMapFormat(String worldName) {
+		File worldDir = new File(".", worldName);
+		RegionTool.pack(worldDir, worldDir, new ConvertProgressUpdater());
+	}
+
+	private void outputPercentRemaining(String currentTask, int percent) {
+		this.currentTask = currentTask;
+		this.percentDone = percent;
+		logger.info(currentTask + ": " + percent + "%");
 	}
 
 	private void clearCurrentTask() {
@@ -168,7 +198,7 @@
 					long var5 = System.currentTimeMillis();
 					long var7 = var5 - var1;
 					if(var7 > 2000L) {
-						logger.warning("Can\'t keep up! Did the system time change, or is the server overloaded?");
+						logger.warning("Can't keep up! Did the system time change, or is the server overloaded?");
 						var7 = 2000L;
 					}
 
@@ -180,12 +210,14 @@
 					var3 += var7;
 					var1 = var5;
 
+					this.ticksBehind = var3 / 50L;
+
 					while(var3 > 50L) {
 						var3 -= 50L;
 						this.doTick();
 					}
 
-					Thread.sleep(1L);
+					Thread.sleep(Math.max(1L, 50L - var3));
 				}
 			} else {
 				while(this.serverRunning) {
@@ -193,22 +225,22 @@
 
 					try {
 						Thread.sleep(10L);
-					} catch (InterruptedException var15) {
-						var15.printStackTrace();
+					} catch (InterruptedException interruptedException15) {
+						interruptedException15.printStackTrace();
 					}
 				}
 			}
-		} catch (Exception var16) {
-			var16.printStackTrace();
-			logger.log(Level.SEVERE, "Unexpected exception", var16);
+		} catch (Throwable exception16) {
+			exception16.printStackTrace();
+			logger.log(Level.SEVERE, "Unexpected exception", exception16);
 
 			while(this.serverRunning) {
 				this.commandLineParser();
 
 				try {
 					Thread.sleep(10L);
-				} catch (InterruptedException var14) {
-					var14.printStackTrace();
+				} catch (InterruptedException interruptedException14) {
+					interruptedException14.printStackTrace();
 				}
 			}
 		} finally {
@@ -220,22 +252,22 @@
 	}
 
 	private void doTick() throws IOException {
-		ArrayList var1 = new ArrayList();
-		Iterator var2 = playerList.keySet().iterator();
+		ArrayList arrayList1 = new ArrayList();
+		Iterator iterator2 = playerList.keySet().iterator();
 
-		while(var2.hasNext()) {
-			String var3 = (String)var2.next();
+		while(iterator2.hasNext()) {
+			String var3 = (String)iterator2.next();
 			int var4 = ((Integer)playerList.get(var3)).intValue();
 			if(var4 > 0) {
-				playerList.put(var3, Integer.valueOf(var4 - 1));
+				playerList.put(var3, var4 - 1);
 			} else {
-				var1.add(var3);
+				arrayList1.add(var3);
 			}
 		}
 
 		int var6;
-		for(var6 = 0; var6 < var1.size(); ++var6) {
-			playerList.remove(var1.get(var6));
+		for(var6 = 0; var6 < arrayList1.size(); ++var6) {
+			playerList.remove(arrayList1.get(var6));
 		}
 
 		AxisAlignedBB.clearBoundingBoxPool();
@@ -247,10 +279,13 @@
 
 		this.worldMngr.tick();
 
-		while(this.worldMngr.updatingLighting()) {
+		while(true) {
+			if(!this.worldMngr.updatingLighting()) {
+				this.worldMngr.updateEntities();
+				break;
+			}
 		}
 
-		this.worldMngr.updateEntities();
 		this.networkServer.handleNetworkListenThread();
 		this.configManager.onTick();
 		this.entityTracker.updateTrackedEntities();
@@ -261,21 +296,20 @@
 
 		try {
 			this.commandLineParser();
-		} catch (Exception var5) {
-			logger.log(Level.WARNING, "Unexpected exception while parsing console command", var5);
+		} catch (Exception exception5) {
+			logger.log(Level.WARNING, "Unexpected exception while parsing console command", exception5);
 		}
-
 	}
 
-	public void addCommand(String var1, ICommandListener var2) {
-		this.commands.add(new ServerCommand(var1, var2));
+	public void addCommand(String command, IListenToMyCommands commandListener) {
+		this.commands.add(new ServerCommand(command, commandListener));
 	}
 
 	public void commandLineParser() {
 		while(this.commands.size() > 0) {
 			ServerCommand var1 = (ServerCommand)this.commands.remove(0);
 			String var2 = var1.command;
-			ICommandListener var3 = var1.commandListener;
+			IListenToMyCommands var3 = var1.commandListener;
 			String var4 = var3.getUsername();
 			if(!var2.toLowerCase().startsWith("help") && !var2.toLowerCase().startsWith("?")) {
 				if(var2.toLowerCase().startsWith("list")) {
@@ -342,7 +376,7 @@
 								var12.playerNetServerHandler.kickPlayer("Kicked by admin");
 								this.print(var4, "Kicking " + var12.username);
 							} else {
-								var3.addHelpCommandMessage("Can\'t find user " + var11 + ". No kick.");
+								var3.addHelpCommandMessage("Can't find user " + var11 + ". No kick.");
 							}
 						} else {
 							String[] var5;
@@ -353,9 +387,9 @@
 									var12 = this.configManager.getPlayerEntity(var5[1]);
 									var7 = this.configManager.getPlayerEntity(var5[2]);
 									if(var12 == null) {
-										var3.addHelpCommandMessage("Can\'t find user " + var5[1] + ". No tp.");
+										var3.addHelpCommandMessage("Can't find user " + var5[1] + ". No tp.");
 									} else if(var7 == null) {
-										var3.addHelpCommandMessage("Can\'t find user " + var5[2] + ". No tp.");
+										var3.addHelpCommandMessage("Can't find user " + var5[2] + ". No tp.");
 									} else {
 										var12.playerNetServerHandler.teleportTo(var7.posX, var7.posY, var7.posZ, var7.rotationYaw, var7.rotationPitch);
 										this.print(var4, "Teleporting " + var5[1] + " to " + var5[2] + ".");
@@ -365,7 +399,7 @@
 								}
 							} else if(var2.toLowerCase().startsWith("give ")) {
 								var5 = var2.split(" ");
-								if(var5.length != 3 && var5.length != 4) {
+								if(var5.length != 3 && var5.length != 4 && var5.length != 5) {
 									return;
 								}
 
@@ -374,11 +408,12 @@
 								if(var7 != null) {
 									try {
 										int var8 = Integer.parseInt(var5[2]);
+										int var8m = var5.length > 3 ? Integer.parseInt(var5[3]) : 0;
 										if(Item.itemsList[var8] != null) {
 											this.print(var4, "Giving " + var7.username + " some " + var8);
 											int var9 = 1;
-											if(var5.length > 3) {
-												var9 = this.parseInt(var5[3], 1);
+											if(var5.length > 4) {
+												var9 = this.parseInt(var5[4], 1);
 											}
 
 											if(var9 < 1) {
@@ -389,15 +424,15 @@
 												var9 = 64;
 											}
 
-											var7.dropPlayerItem(new ItemStack(var8, var9));
+											var7.dropPlayerItem(new ItemStack(var8, var9, -1, var8m));
 										} else {
-											var3.addHelpCommandMessage("There\'s no item with id " + var8);
+											var3.addHelpCommandMessage("There's no item with id " + var8);
 										}
-									} catch (NumberFormatException var10) {
-										var3.addHelpCommandMessage("There\'s no item with id " + var5[2]);
+									} catch (NumberFormatException numberFormatException10) {
+										var3.addHelpCommandMessage("There's no item with id " + var5[2]);
 									}
 								} else {
-									var3.addHelpCommandMessage("Can\'t find user " + var6);
+									var3.addHelpCommandMessage("Can't find user " + var6);
 								}
 							} else if(var2.toLowerCase().startsWith("say ")) {
 								var2 = var2.substring(var2.indexOf(" ")).trim();
@@ -426,23 +461,23 @@
 				var3.addHelpCommandMessage("To run the server without a gui, start it like this:");
 				var3.addHelpCommandMessage("   java -Xmx1024M -Xms1024M -jar minecraft_server.jar nogui");
 				var3.addHelpCommandMessage("Console commands:");
-				var3.addHelpCommandMessage("   help  or  ?               shows this message");
-				var3.addHelpCommandMessage("   kick <player>             removes a player from the server");
-				var3.addHelpCommandMessage("   ban <player>              bans a player from the server");
-				var3.addHelpCommandMessage("   pardon <player>           pardons a banned player so that they can connect again");
-				var3.addHelpCommandMessage("   ban-ip <ip>               bans an IP address from the server");
-				var3.addHelpCommandMessage("   pardon-ip <ip>            pardons a banned IP address so that they can connect again");
-				var3.addHelpCommandMessage("   op <player>               turns a player into an op");
-				var3.addHelpCommandMessage("   deop <player>             removes op status from a player");
-				var3.addHelpCommandMessage("   tp <player1> <player2>    moves one player to the same location as another player");
-				var3.addHelpCommandMessage("   give <player> <id> [num]  gives a player a resource");
+				var3.addHelpCommandMessage("   help  or  ?			   shows this message");
+				var3.addHelpCommandMessage("   kick <player>			 removes a player from the server");
+				var3.addHelpCommandMessage("   ban <player>			  bans a player from the server");
+				var3.addHelpCommandMessage("   pardon <player>		   pardons a banned player so that they can connect again");
+				var3.addHelpCommandMessage("   ban-ip <ip>			   bans an IP address from the server");
+				var3.addHelpCommandMessage("   pardon-ip <ip>			pardons a banned IP address so that they can connect again");
+				var3.addHelpCommandMessage("   op <player>			   turns a player into an op");
+				var3.addHelpCommandMessage("   deop <player>			 removes op status from a player");
+				var3.addHelpCommandMessage("   tp <player1> <player2>	moves one player to the same location as another player");
+				var3.addHelpCommandMessage("   give <player> <id> <meta> [num]  gives a player a resource");
 				var3.addHelpCommandMessage("   tell <player> <message>   sends a private message to a player");
-				var3.addHelpCommandMessage("   stop                      gracefully stops the server");
-				var3.addHelpCommandMessage("   save-all                  forces a server-wide level save");
-				var3.addHelpCommandMessage("   save-off                  disables terrain saving (useful for backup scripts)");
-				var3.addHelpCommandMessage("   save-on                   re-enables terrain saving");
-				var3.addHelpCommandMessage("   list                      lists all currently connected players");
-				var3.addHelpCommandMessage("   say <message>             broadcasts a message to all players");
+				var3.addHelpCommandMessage("   stop					  gracefully stops the server");
+				var3.addHelpCommandMessage("   save-all				  forces a server-wide level save");
+				var3.addHelpCommandMessage("   save-off				  disables terrain saving (useful for backup scripts)");
+				var3.addHelpCommandMessage("   save-on				   re-enables terrain saving");
+				var3.addHelpCommandMessage("   list					  lists all currently connected players");
+				var3.addHelpCommandMessage("   say <message>			 broadcasts a message to all players");
 			}
 		}
 
@@ -454,45 +489,50 @@
 		logger.info(var3);
 	}
 
-	private int parseInt(String var1, int var2) {
+	private int parseInt(String string, int defaultValue) {
 		try {
-			return Integer.parseInt(var1);
-		} catch (NumberFormatException var4) {
-			return var2;
+			return Integer.parseInt(string);
+		} catch (NumberFormatException numberFormatException4) {
+			return defaultValue;
 		}
 	}
 
-	public void addToOnlinePlayerList(IUpdatePlayerListBox var1) {
-		this.playersOnline.add(var1);
+	public void addToOnlinePlayerList(IUpdatePlayerListBox playerListBox) {
+		this.playersOnline.add(playerListBox);
 	}
 
-	public static void main(String[] var0) {
+	public static void main(String[] args) {
 		try {
 			MinecraftServer var1 = new MinecraftServer();
-			if(!GraphicsEnvironment.isHeadless() && (var0.length <= 0 || !var0[0].equals("nogui"))) {
+			if(!GraphicsEnvironment.isHeadless() && (args.length <= 0 || !args[0].equals("nogui"))) {
 				ServerGUI.initGui(var1);
 			}
 
-			(new ThreadServerApplication("Server thread", var1)).start();
-		} catch (Exception var2) {
-			logger.log(Level.SEVERE, "Failed to start the minecraft server", var2);
+//			(new ThreadServerApplication("Server thread", var1)).start();
+			(new Thread(var1, "Server thread")).start();
+		} catch (Exception exception2) {
+			logger.log(Level.SEVERE, "Failed to start the minecraft server", exception2);
 		}
 
 	}
 
-	public File getFile(String var1) {
-		return new File(var1);
+	public File getFile(String fileName) {
+		return new File(fileName);
 	}
 
-	public void addHelpCommandMessage(String var1) {
-		logger.info(var1);
+	public void addHelpCommandMessage(String helpCommandMessage) {
+		logger.info(helpCommandMessage);
 	}
 
 	public String getUsername() {
 		return "CONSOLE";
 	}
 
-	public static boolean isServerRunning(MinecraftServer var0) {
-		return var0.serverRunning;
+	public static boolean isServerRunning(MinecraftServer mcServer) {
+		return mcServer.serverRunning;
+	}
+
+	public long getTicksBehind() {
+		return ticksBehind;
 	}
 }
--- net/minecraft/src/BlockContainer.java
+++ net/minecraft/src/BlockContainer.java
@@ -1,12 +1,12 @@
 package net.minecraft.src;
 
 public abstract class BlockContainer extends Block {
-	protected BlockContainer(int var1, Material var2) {
+	public BlockContainer(int var1, Material var2) {
 		super(var1, var2);
 		isBlockContainer[var1] = true;
 	}
 
-	protected BlockContainer(int var1, int var2, Material var3) {
+	public BlockContainer(int var1, int var2, Material var3) {
 		super(var1, var2, var3);
 	}
 
--- /dev/null
+++ net/minecraft/src/Packet70WorldType.java
@@ -1,0 +1,37 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet70WorldType extends Packet {
+	public CreateWorldInfo info;
+
+	public Packet70WorldType() {
+	}
+
+	public Packet70WorldType(CreateWorldInfo info) {
+		this.info = info;
+	}
+
+	public void readPacketData(DataInputStream dataInputStream1) throws IOException {
+		this.info = new CreateWorldInfo()
+				.withSeed(dataInputStream1.readLong())
+				.withWorldType(WorldType.values()[dataInputStream1.readByte()])
+				.withCreative(dataInputStream1.readBoolean());
+	}
+
+	public void writePacket(DataOutputStream dataOutputStream1) throws IOException {
+		dataOutputStream1.writeLong(this.info.seed);
+		dataOutputStream1.writeByte(this.info.worldType.ordinal());
+		dataOutputStream1.writeBoolean(this.info.creative);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleWorldType(this);
+	}
+
+	public int getPacketSize() {
+		return 6;
+	}
+}
--- /dev/null
+++ net/minecraft/src/WorldGenShrubs.java
@@ -1,0 +1,49 @@
+package net.minecraft.src;
+
+import java.util.Random;
+
+public class WorldGenShrubs extends WorldGenerator {
+	private int metadata = 0;
+
+	public WorldGenShrubs withMetadata(int metadata) {
+		this.metadata = metadata;
+		return this;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		int ground = var1.getBlockId(var3, var4 - 1, var5);
+		if (ground != Block.grass.blockID && ground != Block.dirt.blockID)
+			return false;
+
+		for (int i = 0; i < 3; i++) {
+			int block = var1.getBlockId(var3, var4 + i, var5);
+			if (block != 0 && block != Block.leaves.blockID)
+				return false;
+		}
+
+		var1.setBlockAndMetadata(var3, var4, var5, Block.wood.blockID, metadata);
+
+		int baseThickness = var2.nextInt(3);
+		final int height = 2;
+		for (int y = 0; y < height; y++) {
+			int thickness = height - y + baseThickness;
+
+			for (int x = -thickness; x <= thickness; x++)
+				loopZ: for (int z = -thickness; z <= thickness; z++) {
+					int altitude = 0;
+					while (var1.getBlockId(var3 + x, var4 - altitude - 1, var5 + z) == 0) {
+						altitude++;
+						if (altitude > 3) {
+							continue loopZ;
+						}
+					}
+					if (Math.sqrt(x * x + z * z) > var2.nextDouble() * thickness * 2) continue;
+
+					if (var1.getBlockId(var3 + x, var4 + y - altitude, var5 + z) == 0)
+						var1.setBlockAndMetadata(var3 + x, var4 + y - altitude, var5 + z, Block.leaves.blockID, metadata);
+				}
+		}
+
+		return true;
+	}
+}
--- net/minecraft/src/Packet23VehicleSpawn.java
+++ net/minecraft/src/Packet23VehicleSpawn.java
@@ -3,46 +3,110 @@
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.util.List;
 
 public class Packet23VehicleSpawn extends Packet {
-	public int entityId;
-	public int xPosition;
-	public int yPosition;
-	public int zPosition;
-	public int type;
-
-	public Packet23VehicleSpawn() {
-	}
-
-	public void readPacketData(DataInputStream var1) throws IOException {
-		this.entityId = var1.readInt();
-		this.type = var1.readByte();
-		this.xPosition = var1.readInt();
-		this.yPosition = var1.readInt();
-		this.zPosition = var1.readInt();
-	}
-
-	public void writePacket(DataOutputStream var1) throws IOException {
-		var1.writeInt(this.entityId);
-		var1.writeByte(this.type);
-		var1.writeInt(this.xPosition);
-		var1.writeInt(this.yPosition);
-		var1.writeInt(this.zPosition);
-	}
-
-	public void processPacket(NetHandler var1) {
-		var1.handleVehicleSpawn(this);
-	}
-
-	public int getPacketSize() {
-		return 17;
-	}
-
-	public Packet23VehicleSpawn(Entity var1, int var2) {
-		this.entityId = var1.entityID;
-		this.xPosition = MathHelper.floor_double(var1.posX * 32.0D);
-		this.yPosition = MathHelper.floor_double(var1.posY * 32.0D);
-		this.zPosition = MathHelper.floor_double(var1.posZ * 32.0D);
-		this.type = var2;
-	}
+    public int entityId;
+    public int xPosition;
+    public int yPosition;
+    public int zPosition;
+    public int motionX;
+    public int motionY;
+    public int motionZ;
+    public int type;
+    public int owner;
+	private DataWatcher metaData;
+	private List receivedMetadata;
+
+    public Packet23VehicleSpawn() {
+    }
+
+    public Packet23VehicleSpawn(Entity var1, int var2) {
+        this(var1, var2, 0);
+    }
+
+    public Packet23VehicleSpawn(Entity var1, int var2, int var3) {
+        this.entityId = var1.entityID;
+        this.xPosition = MathHelper.floor_double(var1.posX * 32.0D);
+        this.yPosition = MathHelper.floor_double(var1.posY * 32.0D);
+        this.zPosition = MathHelper.floor_double(var1.posZ * 32.0D);
+        this.type = var2;
+        this.owner = var3;
+        if (var3 > 0) {
+            double var4 = var1.motionX;
+            double var6 = var1.motionY;
+            double var8 = var1.motionZ;
+            double var10 = 3.9D;
+            if (var4 < -var10) {
+                var4 = -var10;
+            }
+
+            if (var6 < -var10) {
+                var6 = -var10;
+            }
+
+            if (var8 < -var10) {
+                var8 = -var10;
+            }
+
+            if (var4 > var10) {
+                var4 = var10;
+            }
+
+            if (var6 > var10) {
+                var6 = var10;
+            }
+
+            if (var8 > var10) {
+                var8 = var10;
+            }
+
+            this.motionX = (int) (var4 * 8000.0D);
+            this.motionY = (int) (var6 * 8000.0D);
+            this.motionZ = (int) (var8 * 8000.0D);
+        }
+        this.metaData = var1.getDataWatcher();
+    }
+
+    public void readPacketData(DataInputStream var1) throws IOException {
+        this.entityId = var1.readInt();
+        this.type = var1.readByte();
+        this.xPosition = var1.readInt();
+        this.yPosition = var1.readInt();
+        this.zPosition = var1.readInt();
+        this.owner = var1.readInt();
+        if (this.owner > 0) {
+            this.motionX = var1.readShort();
+            this.motionY = var1.readShort();
+            this.motionZ = var1.readShort();
+        }
+        this.receivedMetadata = DataWatcher.readWatchableObjects(var1);
+    }
+
+    public void writePacket(DataOutputStream var1) throws IOException {
+        var1.writeInt(this.entityId);
+        var1.writeByte(this.type);
+        var1.writeInt(this.xPosition);
+        var1.writeInt(this.yPosition);
+        var1.writeInt(this.zPosition);
+        var1.writeInt(this.owner);
+        if (this.owner > 0) {
+            var1.writeShort(this.motionX);
+            var1.writeShort(this.motionY);
+            var1.writeShort(this.motionZ);
+        }
+        this.metaData.writeWatchableObjects(var1);
+    }
+
+    public void processPacket(NetHandler var1) {
+        var1.handleVehicleSpawn(this);
+    }
+
+    public int getPacketSize() {
+        return 22 + this.owner > 0 ? 6 : 0;
+    }
+
+    public List getMetadata() {
+        return this.receivedMetadata;
+    }
 }
--- net/minecraft/src/ItemInWorldManager.java
+++ net/minecraft/src/ItemInWorldManager.java
@@ -3,64 +3,77 @@
 public class ItemInWorldManager {
 	private World worldObj;
 	public EntityPlayer thisPlayer;
-	private float removeProgressUnused;
-	private float removeProgress = 0.0F;
 	private int curBlockDurability = 0;
-	private float curblockDamage = 0.0F;
+	private int curblockDamage = 0;
 	private int posX;
 	private int posY;
 	private int posZ;
+	private int initialDamage;
+	private boolean blockHit;
+	private int blockHitX;
+	private int blockHitY;
+	private int blockHitZ;
+	private int blockHitDmg;
 
 	public ItemInWorldManager(World var1) {
 		this.worldObj = var1;
 	}
 
 	public void onBlockClicked(int var1, int var2, int var3) {
-		int var4 = this.worldObj.getBlockId(var1, var2, var3);
-		if(var4 > 0 && this.removeProgress == 0.0F) {
-			Block.blocksList[var4].onBlockClicked(this.worldObj, var1, var2, var3, this.thisPlayer);
-		}
-
-		if(var4 > 0 && Block.blocksList[var4].blockStrength(this.thisPlayer) >= 1.0F) {
+		if(this.thisPlayer.creative) {
 			this.tryHarvestBlock(var1, var2, var3);
-		}
-
-	}
-
-	public void blockRemoving() {
-		this.removeProgress = 0.0F;
-		this.curBlockDurability = 0;
-	}
-
-	public void updateBlockRemoving(int var1, int var2, int var3, int var4) {
-		if(this.curBlockDurability > 0) {
-			--this.curBlockDurability;
 		} else {
-			if(var1 == this.posX && var2 == this.posY && var3 == this.posZ) {
-				int var5 = this.worldObj.getBlockId(var1, var2, var3);
-				if(var5 == 0) {
-					return;
-				}
+			this.initialDamage = this.curblockDamage;
+			int var5 = this.worldObj.getBlockId(var1, var2, var3);
+			if(var5 > 0) {
+				Block.blocksList[var5].onBlockClicked(this.worldObj, var1, var2, var3, this.thisPlayer);
+			}
 
-				Block var6 = Block.blocksList[var5];
-				this.removeProgress += var6.blockStrength(this.thisPlayer);
-				++this.curblockDamage;
-				if(this.removeProgress >= 1.0F) {
-					this.tryHarvestBlock(var1, var2, var3);
-					this.removeProgress = 0.0F;
-					this.removeProgressUnused = 0.0F;
-					this.curblockDamage = 0.0F;
-					this.curBlockDurability = 5;
-				}
+			if(var5 > 0 && Block.blocksList[var5].blockStrength(this.thisPlayer) >= 1.0F) {
+				this.tryHarvestBlock(var1, var2, var3);
 			} else {
-				this.removeProgress = 0.0F;
-				this.removeProgressUnused = 0.0F;
-				this.curblockDamage = 0.0F;
 				this.posX = var1;
 				this.posY = var2;
 				this.posZ = var3;
 			}
-
+		}
+	}
+
+	public void updateBlockRemoving() {
+		++this.curblockDamage;
+		if(this.blockHit) {
+			int var1 = this.curblockDamage - this.blockHitDmg;
+			int var2 = this.worldObj.getBlockId(this.blockHitX, this.blockHitY, this.blockHitZ);
+			if(var2 != 0) {
+				Block var3 = Block.blocksList[var2];
+				float var4 = var3.blockStrength(this.thisPlayer) * (float)(var1 + 1);
+				if(var4 >= 1.0F) {
+					this.blockHit = false;
+					this.tryHarvestBlock(this.blockHitX, this.blockHitY, this.blockHitZ);
+				}
+			} else {
+				this.blockHit = false;
+			}
+		}
+	}
+
+	public void updateBlockRemoving(int var1, int var2, int var3) {
+		if(var1 == this.posX && var2 == this.posY && var3 == this.posZ) {
+			int var4 = this.curblockDamage - this.initialDamage;
+			int var5 = this.worldObj.getBlockId(var1, var2, var3);
+			if(var5 != 0) {
+				Block var6 = Block.blocksList[var5];
+				float var7 = var6.blockStrength(this.thisPlayer) * (float)(var4 + 1);
+				if(var7 >= 0.7F) {
+					this.tryHarvestBlock(var1, var2, var3);
+				} else if(!this.blockHit) {
+					this.blockHit = true;
+					this.blockHitX = var1;
+					this.blockHitY = var2;
+					this.blockHitZ = var3;
+					this.blockHitDmg = this.initialDamage;
+				}
+			}
 		}
 	}
 
@@ -78,25 +91,57 @@
 	public boolean tryHarvestBlock(int var1, int var2, int var3) {
 		int var4 = this.worldObj.getBlockId(var1, var2, var3);
 		int var5 = this.worldObj.getBlockMetadata(var1, var2, var3);
+		this.worldObj.performAction(this.thisPlayer, 2001, var1, var2, var3, var4 | var5 << 16);
 		boolean var6 = this.removeBlock(var1, var2, var3);
-		ItemStack var7 = this.thisPlayer.getCurrentEquippedItem();
-		if(var7 != null) {
-			var7.onDestroyBlock(var4, var1, var2, var3);
-			if(var7.stackSize == 0) {
-				var7.onItemDestroyedByUse(this.thisPlayer);
-				this.thisPlayer.destroyCurrentEquippedItem();
+		if (this.thisPlayer.creative) {
+			((EntityPlayerMP)this.thisPlayer).playerNetServerHandler.sendPacket(new Packet53BlockChange(var1, var2, var3, this.worldObj));
+		} else {
+			boolean silk = false;
+			ItemStack var7 = this.thisPlayer.getCurrentEquippedItem();
+			if(var7 != null) {
+				silk = var7.isSilk();
+				var7.onDestroyBlock(var4, var1, var2, var3);
+				if(var7.stackSize == 0) {
+					var7.onItemDestroyedByUse(this.thisPlayer);
+					this.thisPlayer.destroyCurrentEquippedItem();
+				}
 			}
-		}
 
-		if(var6 && this.thisPlayer.canHarvestBlock(Block.blocksList[var4])) {
-			Block.blocksList[var4].dropBlockAsItem(this.worldObj, var1, var2, var3, var5);
+			if(var6 && this.thisPlayer.canHarvestBlock(Block.blocksList[var4])) {
+				if (silk) {
+					Block.blocksList[var4].harvestBlockSilk(this.worldObj, var1, var2, var3, var5);
+				} else {
+					Block.blocksList[var4].harvestBlock(this.worldObj, var1, var2, var3, var5);
+				}
+			}
 		}
 
 		return var6;
 	}
 
-	public boolean activeBlockOrUseItem(EntityPlayer var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7) {
+	public boolean activeBlockOrUseItem(EntityPlayer var1, World var2, ItemStack var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		int var8 = var2.getBlockId(var4, var5, var6);
-		return var8 > 0 && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1) ? true : (var3 == null ? false : var3.useItem(var1, var2, var4, var5, var6, var7));
+		int oldStackSize = var3 != null ? var3.stackSize : 0;
+		boolean result = var8 > 0 && Block.blocksList[var8].blockActivated(var2, var4, var5, var6, var1)
+				|| (var3 != null && var3.useItem(var1, var2, var4, var5, var6, var7, hitx, hity, hitz));
+		if (var1.creative && var3 != null) {
+			var3.stackSize = oldStackSize;
+		}
+		return result;
+	}
+
+	public boolean func_6154_a(EntityPlayer var1, World var2, ItemStack var3) {
+		int var4 = var3.stackSize;
+		ItemStack var5 = var3.useItemRightClick(var2, var1);
+		if(var5 != var3 || var5 != null && var5.stackSize != var4) {
+			var1.inventory.mainInventory[var1.inventory.currentItem] = var5;
+			if(var5.stackSize == 0) {
+				var1.inventory.mainInventory[var1.inventory.currentItem] = null;
+			}
+
+			return true;
+		} else {
+			return false;
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/src/GameAchievements.java
@@ -1,0 +1,79 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+
+import java.io.*;
+import java.util.HashMap;
+import java.util.Map;
+
+public class GameAchievements {
+	protected Minecraft mc;
+	private final File achievementsFile;
+	private final Map<String, Integer> miscAchievements = new HashMap<>();
+
+	public GameAchievements(Minecraft mc, File dir) {
+		this.mc = mc;
+		this.achievementsFile = new File(dir, "diverge-achievements.txt");
+		this.loadAchievements();
+		this.saveAchievements();
+	}
+
+	public void updateProgress(Achievement achievement, int p) {
+		if (this.mc.thePlayer != null && this.mc.thePlayer.creative && !achievement.isCreativeUnlockable()) return;
+
+		int oldp = achievement.progress;
+		achievement.progress = p;
+
+		if (oldp < achievement.maxProgress && p >= achievement.maxProgress) {
+			this.mc.ingameGUI.addAchievement(achievement);
+		}
+
+		if (p != oldp) this.saveAchievements();
+	}
+
+	public void updateMiscProgress(Achievement achievement) {
+		if (this.miscAchievements.containsKey(achievement.id)) {
+			achievement.progress = this.miscAchievements.remove(achievement.id);
+		}
+	}
+
+	public void saveAchievements() {
+		try {
+			PrintWriter output = new PrintWriter(new FileWriter(this.achievementsFile));
+			for (Achievement achievement : Achievement.list) {
+				output.println(achievement.id + ":" + achievement.progress);
+			}
+			for (Map.Entry<String, Integer> kv : miscAchievements.entrySet()) {
+				output.println(kv.getKey() + ":" + kv.getValue());
+			}
+			output.close();
+		} catch (Exception e) {
+			System.out.println("Failed to save achievements");
+			e.printStackTrace();
+		}
+	}
+
+	public void loadAchievements() {
+		try {
+			if (!this.achievementsFile.exists()) return;
+
+			BufferedReader input = new BufferedReader(new FileReader(this.achievementsFile));
+			String line;
+			while ((line = input.readLine()) != null) {
+				String[] split = line.split(":");
+				String name = split[0];
+				int progress = Integer.parseInt(split[1]);
+
+				Achievement achievement = Achievement.map.get(name);
+				if (achievement != null) {
+					achievement.progress = progress;
+				} else {
+					this.miscAchievements.put(name, progress);
+				}
+			}
+		} catch (Exception e) {
+			System.out.println("Failed to load achievements");
+			e.printStackTrace();
+		}
+	}
+}
--- net/minecraft/src/SpawnerClient.java
+++ net/minecraft/src/SpawnerClient.java
@@ -1,17 +1,21 @@
 package net.minecraft.src;
 
-class SpawnerClient extends SpawnerAnimals {
-	final PlayerControllerSP playerController;
+public class SpawnerClient extends SpawnerAnimals {
+	public final PlayerControllerSP playerController;
 
-	SpawnerClient(PlayerControllerSP var1, int var2, Class var3, Class[] var4) {
-		super(var2, var3, var4);
+	public SpawnerClient(PlayerControllerSP var1, int var2, Class var3) {
+		super(var2, var3);
 		this.playerController = var1;
 	}
 
 	protected ChunkPosition getRandomSpawningPointInChunk(World var1, int var2, int var3) {
 		int var4 = var2 + var1.rand.nextInt(16);
-		int var5 = var1.rand.nextInt(var1.rand.nextInt(120) + 8);
+		int var5 = var1.rand.nextInt(var1.rand.nextInt(120) + 8) + 64;
 		int var6 = var3 + var1.rand.nextInt(16);
 		return new ChunkPosition(var4, var5, var6);
+	}
+
+	public Class<? extends EntityLiving> getEntity(World world, Biome biome) {
+		return biome.spawnableMonsters.get(world.rand.nextInt(biome.spawnableMonsters.size()));
 	}
 }
--- net/minecraft/src/MapGenBase.java
+++ net/minecraft/src/MapGenBase.java
@@ -6,7 +6,7 @@
 	protected int range = 8;
 	protected Random rand = new Random();
 
-	public void generate(ChunkProviderGenerate var1, World var2, int var3, int var4, byte[] var5) {
+	public void generate(ChunkProviderGenerate var1, World var2, int var3, int var4, short[] var5) {
 		int var6 = this.range;
 		this.rand.setSeed(var2.randomSeed);
 		long var7 = this.rand.nextLong() / 2L * 2L + 1L;
@@ -21,6 +21,6 @@
 
 	}
 
-	protected void recursiveGenerate(World var1, int var2, int var3, int var4, int var5, byte[] var6) {
+	protected void recursiveGenerate(World var1, int var2, int var3, int var4, int var5, short[] var6) {
 	}
 }
--- /dev/null
+++ net/minecraft/src/ItemTrinket.java
@@ -1,0 +1,40 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+public abstract class ItemTrinket extends Item {
+	public final String shortName;
+
+	public ItemTrinket(int var1, String var2) {
+		super(var1);
+		this.shortName = var2;
+		this.maxStackSize = 1;
+	}
+
+	public abstract boolean isApplicable(Item item);
+
+	public abstract int getColor();
+
+	public float modifyDamageTaken(float damage) {
+		return damage;
+	}
+
+	public int modifyAttackDamage(int damage) {
+		return damage;
+	}
+
+	public int modifyHeartsLife(int heartsLife) {
+		return heartsLife;
+	}
+
+	public float modifyToolStrength(float strength) {
+		return strength;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				"Can be applied", INFO_COL,
+				"at a Refabricator", INFO_COL
+		};
+	}
+}
--- /dev/null
+++ net/minecraft/src/EntitySnowballType.java
@@ -1,0 +1,33 @@
+package net.minecraft.src;
+
+public class EntitySnowballType {
+	public static final EntitySnowballType[] list = new EntitySnowballType[256];
+
+	public static final EntitySnowballType snowball = new EntitySnowballType(0, Item.textureXY(17, 3), 1);
+	public static final EntitySnowballType ruby = new EntitySnowballType(1, Item.textureXY(8, 5), 10, 100, 1.0F);
+	public static final EntitySnowballType sapphire = new EntitySnowballType(2, Item.textureXY(9, 5), 6, 0, 2.0F);
+	public static final EntitySnowballType sparkle = new EntitySnowballType(3, Item.textureXY(10, 5), 6, 0, 1.0F);
+
+	public final int id;
+	public int iconIndex;
+	public int damage;
+	public int burn;
+	public float pierce;
+
+	public EntitySnowballType(int id, int iconIndex, int damage) {
+		this(id, iconIndex, damage, 0, 1.0F);
+	}
+
+	public EntitySnowballType(int id, int iconIndex, int damage, int burn, float pierce) {
+		if (list[id] != null) {
+			throw new RuntimeException("Snowball type " + id + " already exists!");
+		}
+
+		this.id = id;
+		this.iconIndex = iconIndex;
+		this.damage = damage;
+		this.burn = burn;
+		this.pierce = pierce;
+		list[id] = this;
+	}
+}
--- net/minecraft/src/NBTTagLong.java
+++ net/minecraft/src/NBTTagLong.java
@@ -14,11 +14,11 @@
 		this.longValue = var1;
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeLong(this.longValue);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.longValue = var1.readLong();
 	}
 
@@ -27,6 +27,10 @@
 	}
 
 	public String toString() {
-		return "" + this.longValue;
+		return String.valueOf(this.longValue);
+	}
+
+	public NBTBase copy() {
+		return new NBTTagLong(this.longValue).setKey(this.getKey());
 	}
 }
--- net/minecraft/src/RecipesWeapons.java
+++ net/minecraft/src/RecipesWeapons.java
@@ -4,17 +4,20 @@
 	private String[][] recipePatterns = new String[][]{{"X", "X", "#"}};
 	private Object[][] recipeItems = new Object[][]{{Block.planks, Block.cobblestone, Item.ingotIron, Item.diamond, Item.ingotGold}, {Item.swordWood, Item.swordStone, Item.swordSteel, Item.swordDiamond, Item.swordGold}};
 
-	public void addRecipes(CraftingManager var1) {
+	public void addRecipes(CraftingManager craftingManager) {
 		for(int var2 = 0; var2 < this.recipeItems[0].length; ++var2) {
 			Object var3 = this.recipeItems[0][var2];
 
 			for(int var4 = 0; var4 < this.recipeItems.length - 1; ++var4) {
 				Item var5 = (Item)this.recipeItems[var4 + 1][var2];
-				var1.addRecipe(new ItemStack(var5), new Object[]{this.recipePatterns[var4], Character.valueOf('#'), Item.stick, Character.valueOf('X'), var3});
+				craftingManager.addRecipe(new ItemStack(var5), this.recipePatterns[var4], '#', Item.stick, 'X', var3);
 			}
 		}
 
-		var1.addRecipe(new ItemStack(Item.bow, 1), new Object[]{" #X", "# X", " #X", Character.valueOf('X'), Item.silk, Character.valueOf('#'), Item.stick});
-		var1.addRecipe(new ItemStack(Item.arrow, 4), new Object[]{"X", "#", "Y", Character.valueOf('Y'), Item.feather, Character.valueOf('X'), Item.flint, Character.valueOf('#'), Item.stick});
+		craftingManager.addRecipe(new ItemStack(Item.bow, 1), " #X", "# X", " #X", 'X', Item.silk, '#', Item.stick);
+		craftingManager.addRecipe(new ItemStack(Item.arrow, 4), "X", "#", "Y", 'Y', Item.feather, 'X', Item.flint, '#', Item.stick);
+		craftingManager.addRecipe(new ItemStack(Item.staffRuby, 1), "#", "o", "/", '#', Item.ruby, 'o', Item.ingotGold, '/', Item.stick);
+		craftingManager.addRecipe(new ItemStack(Item.staffSapphire, 1), "#", "o", "/", '#', Item.sapphire, 'o', Item.ingotIron, '/', Item.stick);
+		craftingManager.addRecipe(new ItemStack(Item.staffSparkle, 1), "#", "/", "/", '#', Item.starChunk, '/', Item.stick);
 	}
 }
--- net/minecraft/src/NBTTagCompound.java
+++ net/minecraft/src/NBTTagCompound.java
@@ -1,16 +1,23 @@
 package net.minecraft.src;
 
+import java.io.BufferedReader;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.IntBuffer;
+import java.util.AbstractMap;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 public class NBTTagCompound extends NBTBase {
 	private Map tagMap = new HashMap();
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		Iterator var2 = this.tagMap.values().iterator();
 
 		while(var2.hasNext()) {
@@ -21,7 +28,7 @@
 		var1.writeByte(0);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.tagMap.clear();
 
 		while(true) {
@@ -39,7 +46,11 @@
 	}
 
 	public void setTag(String var1, NBTBase var2) {
-		this.tagMap.put(var1, var2.setKey(var1));
+		if (var2 == null) {
+			this.tagMap.remove(var1);
+		} else {
+			this.tagMap.put(var1, var2.setKey(var1));
+		}
 	}
 
 	public void setByte(String var1, byte var2) {
@@ -74,6 +85,21 @@
 		this.tagMap.put(var1, (new NBTTagByteArray(var2)).setKey(var1));
 	}
 
+	public void setIntArray(String var1, int[] var2) {
+		this.tagMap.put(var1, (new NBTTagIntArray(var2)).setKey(var1));
+	}
+
+	public void setShortArray(String var1, short[] var2) {
+		int[] ints = new int[(var2.length + 1) / 2];
+
+		ByteBuffer buffer = ByteBuffer.allocate(var2.length * 2);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asShortBuffer().put(var2);
+		buffer.asIntBuffer().get(ints);
+
+		this.tagMap.put(var1, (new NBTTagIntArray(ints)).setKey(var1));
+	}
+
 	public void setCompoundTag(String var1, NBTTagCompound var2) {
 		this.tagMap.put(var1, var2.setKey(var1));
 	}
@@ -86,6 +112,10 @@
 		return this.tagMap.containsKey(var1);
 	}
 
+	public byte getType(String var1) {
+		return !this.tagMap.containsKey(var1) ? 0 : ((NBTBase)this.tagMap.get(var1)).getType();
+	}
+
 	public byte getByte(String var1) {
 		return !this.tagMap.containsKey(var1) ? 0 : ((NBTTagByte)this.tagMap.get(var1)).byteValue;
 	}
@@ -118,10 +148,35 @@
 		return !this.tagMap.containsKey(var1) ? new byte[0] : ((NBTTagByteArray)this.tagMap.get(var1)).byteArray;
 	}
 
+	public int[] getIntArray(String var1) {
+		return !this.tagMap.containsKey(var1) ? new int[0] : ((NBTTagIntArray)this.tagMap.get(var1)).intArray;
+	}
+
+	public short[] getShortArray(String var1) {
+		if (!this.tagMap.containsKey(var1)) return new short[0];
+		NBTBase tag = (NBTBase)this.tagMap.get(var1);
+		if (tag instanceof NBTTagShortArray) return ((NBTTagShortArray) tag).shortArray;
+
+		int[] ints = ((NBTTagIntArray)tag).intArray;
+		if (ints.length == 0) return new short[0];
+
+		short[] shorts = new short[ints.length * 2];
+
+		ByteBuffer buffer = ByteBuffer.allocate(ints.length * 4);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().put(ints);
+		buffer.asShortBuffer().get(shorts);
+		return shorts;
+	}
+
 	public NBTTagCompound getCompoundTag(String var1) {
 		return !this.tagMap.containsKey(var1) ? new NBTTagCompound() : (NBTTagCompound)this.tagMap.get(var1);
 	}
 
+	public NBTBase getTag(String var1) {
+		return (NBTBase)this.tagMap.get(var1);
+	}
+
 	public NBTTagList getTagList(String var1) {
 		return !this.tagMap.containsKey(var1) ? new NBTTagList() : (NBTTagList)this.tagMap.get(var1);
 	}
@@ -130,7 +185,17 @@
 		return this.getByte(var1) != 0;
 	}
 
+	public boolean isEmpty() { return this.tagMap.isEmpty(); }
+
 	public String toString() {
-		return "" + this.tagMap.size() + " entries";
+		return this.tagMap.size() + " entries";
+	}
+
+	public NBTTagCompound copy() {
+		NBTTagCompound compound = new NBTTagCompound();
+		compound.tagMap = ((Stream<Map.Entry<String, NBTBase>>)this.tagMap.entrySet().stream())
+				.map(x -> new AbstractMap.SimpleImmutableEntry<>(x.getKey(), x.getValue().copy()))
+				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+		return (NBTTagCompound)compound.setKey(this.getKey());
 	}
 }
--- net/minecraft/src/BlockLog.java
+++ net/minecraft/src/BlockLog.java
@@ -1,22 +1,100 @@
 package net.minecraft.src;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 
-public class BlockLog extends Block {
-	protected BlockLog(int var1) {
-		super(var1, Material.wood);
-		this.blockIndexInTexture = 20;
+public class BlockLog extends BlockWood {
+	private final List<int[]> leavesToUpdate = new ArrayList<>();
+
+	public BlockLog(int id) {
+		super(id, textureXY(0, 8), Material.wood);
 	}
 
 	public int quantityDropped(Random var1) {
 		return 1;
 	}
 
-	public int idDropped(int var1, Random var2) {
-		return Block.wood.blockID;
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var1;
+	}
+
+	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
+		byte var5 = 4;
+		int var6 = var5 + 1;
+		if(var1.checkChunksExist(var2 - var6, var3 - var6, var4 - var6, var2 + var6, var3 + var6, var4 + var6)) {
+			for(int var7 = -var5; var7 <= var5; ++var7) {
+				for(int var8 = -var5; var8 <= var5; ++var8) {
+					for(int var9 = -var5; var9 <= var5; ++var9) {
+						int var10 = var1.getBlockId(var2 + var7, var3 + var8, var4 + var9);
+						if(var10 == Block.leaves.blockID) {
+							int var11 = var1.getBlockMetadata(var2 + var7, var3 + var8, var4 + var9);
+							if(!Block.leaves.fieldPermanent.get(var11) && !Block.leaves.fieldDecaying.get(var11)) {
+								var1.setBlockMetadata(var2 + var7, var3 + var8, var4 + var9, Block.leaves.fieldDecaying.set(var11, true));
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		return this.blockIndexInTexture + var2 * 32 + (var1 <= 1 ? 1 : 0);
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? 21 : (var1 == 0 ? 21 : 20);
+		return this.blockIndexInTexture + (var1 <= 1 ? 1 : 0);
+	}
+
+	private boolean recursiveDestroy(World worldObj, int x, int y, int z, int metadata, EntityPlayer player, ItemStack currentItem) {
+		for (int rx = x - 1; rx <= x + 1; rx++) {
+			for (int ry = y; ry <= y + 1; ry++) {
+				for (int rz = z - 1; rz <= z + 1; rz++) {
+					if (worldObj.getBlockId(rx, ry, rz) == this.blockID
+							&& worldObj.getBlockMetadata(rx, ry, rz) == metadata
+							&& currentItem.itemDmg <= currentItem.getMaxDamage()
+							&& (rx != x || ry != y || rz != z)) {
+						currentItem.onDestroyBlock(this.blockID, rx, ry, rz);
+						if (currentItem.stackSize == 0) {
+							currentItem.onItemDestroyedByUse(player);
+							player.destroyCurrentEquippedItem();
+							return false;
+						}
+
+						this.dropBlockAsItem(worldObj, rx, ry, rz, metadata);
+						worldObj.setBlockWithNotify(rx, ry, rz, 0);
+						if (!this.recursiveDestroy(worldObj, rx, ry, rz, metadata, player, currentItem)) {
+							return false;
+						}
+					} else if (worldObj.getBlockId(rx, ry, rz) == Block.leaves.blockID) {
+						leavesToUpdate.add(new int[] {rx, ry, rz});
+					}
+				}
+			}
+		}
+		return true;
+	}
+
+	public void onBlockDestroyedByPlayer(World var1, int var2, int var3, int var4, int var5) {
+		EntityPlayer player = var1.getClosestPlayer(var2, var3, var4, 10);
+		ItemStack currentItem = player.inventory.getCurrentItem();
+		if (currentItem == null) {
+			return;
+		}
+		Item heldItem = currentItem.getItem();
+		if (!(heldItem instanceof ItemTool
+			  && ((ItemTool) heldItem).effectiveAgainst(this)
+			  && player.isSneaking())) {
+			return;
+		}
+
+		recursiveDestroy(var1, var2, var3, var4, var5, player, currentItem);
+		BlockLeaves.instantUpdate = true;
+		for (int[] leaf : leavesToUpdate) {
+			Block.leaves.updateTick(var1, leaf[0], leaf[1], leaf[2], var1.rand);
+		}
+		BlockLeaves.instantUpdate = false;
+		leavesToUpdate.clear();
 	}
 }
--- net/minecraft/src/EntityItem.java
+++ net/minecraft/src/EntityItem.java
@@ -33,6 +33,12 @@
 			--this.delayBeforeCanPickup;
 		}
 
+		if (this.item != null && this.item.itemID == Item.starChunk.shiftedIndex
+			&& this.worldObj.isDaytime()) {
+			this.setEntityDead();
+			return;
+		}
+
 		this.prevPosX = this.posX;
 		this.prevPosY = this.posY;
 		this.prevPosZ = this.posZ;
@@ -177,14 +183,28 @@
 	}
 
 	public void onCollideWithPlayer(EntityPlayer var1) {
-		if(!this.worldObj.multiplayerWorld) {
+		if(this.worldObj.canDoClientAction()) {
 			int var2 = this.item.stackSize;
 			if(this.delayBeforeCanPickup == 0 && var1.inventory.addItemStackToInventory(this.item)) {
 				this.worldObj.playSoundAtEntity(this, "random.pop", 0.2F, ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.7F + 1.0F) * 2.0F);
 				var1.onItemPickup(this, var2);
 				this.setEntityDead();
 			}
-
 		}
+	}
+
+	public float getBrightness(float var1) {
+		return this.item.itemID == Item.starChunk.shiftedIndex ? 1.0F : super.getBrightness(var1);
+	}
+
+	public boolean isInRangeToRenderDist(double var1) {
+		if (this.item != null && this.item.itemID == Item.starChunk.shiftedIndex) return true;
+		double var3 = this.boundingBox.getAverageEdgeLength();
+		var3 *= 256.0D * this.renderDistanceWeight;
+		return var1 < var3 * var3;
+	}
+
+	public void onChunkUpdate(int chunkVersion) {
+		this.item.onChunkUpdate(chunkVersion);
 	}
 }
--- net/minecraft/src/SlotInventory.java
+++ net/minecraft/src/SlotInventory.java
@@ -1,22 +1,12 @@
 package net.minecraft.src;
 
 public class SlotInventory extends Slot {
-	private final GuiContainer guiContainer;
-	public final int xDisplayPosition;
-	public final int yDisplayPosition;
-
-	public SlotInventory(GuiContainer var1, IInventory var2, int var3, int var4, int var5) {
-		super(var2, var3);
-		this.guiContainer = var1;
-		this.xDisplayPosition = var4;
-		this.yDisplayPosition = var5;
-	}
-
-	public boolean getIsMouseOverSlot(int var1, int var2) {
-		int var3 = (this.guiContainer.width - this.guiContainer.xSize) / 2;
-		int var4 = (this.guiContainer.height - this.guiContainer.ySize) / 2;
-		var1 -= var3;
-		var2 -= var4;
-		return var1 >= this.xDisplayPosition - 1 && var1 < this.xDisplayPosition + 16 + 1 && var2 >= this.yDisplayPosition - 1 && var2 < this.yDisplayPosition + 16 + 1;
+	private final GuiContainer guiContainer = null;
+	public final int xDisplayPosition = 0;
+	public final int yDisplayPosition = 0;
+
+	public SlotInventory(IInventory var1, int var2, int var3, int var4) {
+		super(var1, var2, var3, var4);
+		throw new RuntimeException("SlotInventory is obsolete!");
 	}
 }
--- net/minecraft/src/ModelRenderer.java
+++ net/minecraft/src/ModelRenderer.java
@@ -18,6 +18,7 @@
 	public boolean mirror = false;
 	public boolean showModel = true;
 	public boolean isHidden = false;
+	public boolean bigTex = false;
 
 	public ModelRenderer(int var1, int var2) {
 		this.textureOffsetX = var1;
@@ -62,12 +63,12 @@
 		this.corners[5] = var16;
 		this.corners[6] = var17;
 		this.corners[7] = var18;
-		this.faces[0] = new TexturedQuad(new PositionTexureVertex[]{var16, var12, var13, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6 + var5);
-		this.faces[1] = new TexturedQuad(new PositionTexureVertex[]{var20, var15, var18, var14}, this.textureOffsetX + 0, this.textureOffsetY + var6, this.textureOffsetX + var6, this.textureOffsetY + var6 + var5);
-		this.faces[2] = new TexturedQuad(new PositionTexureVertex[]{var16, var15, var20, var12}, this.textureOffsetX + var6, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6);
-		this.faces[3] = new TexturedQuad(new PositionTexureVertex[]{var13, var14, var18, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4 + var4, this.textureOffsetY + var6);
-		this.faces[4] = new TexturedQuad(new PositionTexureVertex[]{var12, var20, var14, var13}, this.textureOffsetX + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6 + var5);
-		this.faces[5] = new TexturedQuad(new PositionTexureVertex[]{var15, var16, var17, var18}, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6 + var4, this.textureOffsetY + var6 + var5);
+		this.faces[0] = new TexturedQuad(new PositionTexureVertex[]{var16, var12, var13, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6 + var5, this.bigTex);
+		this.faces[1] = new TexturedQuad(new PositionTexureVertex[]{var20, var15, var18, var14}, this.textureOffsetX + 0, this.textureOffsetY + var6, this.textureOffsetX + var6, this.textureOffsetY + var6 + var5, this.bigTex);
+		this.faces[2] = new TexturedQuad(new PositionTexureVertex[]{var16, var15, var20, var12}, this.textureOffsetX + var6, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6, this.bigTex);
+		this.faces[3] = new TexturedQuad(new PositionTexureVertex[]{var13, var14, var18, var17}, this.textureOffsetX + var6 + var4, this.textureOffsetY + 0, this.textureOffsetX + var6 + var4 + var4, this.textureOffsetY + var6, this.bigTex);
+		this.faces[4] = new TexturedQuad(new PositionTexureVertex[]{var12, var20, var14, var13}, this.textureOffsetX + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4, this.textureOffsetY + var6 + var5, this.bigTex);
+		this.faces[5] = new TexturedQuad(new PositionTexureVertex[]{var15, var16, var17, var18}, this.textureOffsetX + var6 + var4 + var6, this.textureOffsetY + var6, this.textureOffsetX + var6 + var4 + var6 + var4, this.textureOffsetY + var6 + var5, this.bigTex);
 		if(this.mirror) {
 			for(int var19 = 0; var19 < this.faces.length; ++var19) {
 				this.faces[var19].flipFace();
--- /dev/null
+++ net/minecraft/src/BaseMod.java
@@ -1,0 +1,83 @@
+package net.minecraft.src;
+
+public abstract class BaseMod {
+	// Get the name of the mod
+	public abstract String getName();
+
+	// Get the version of the mod
+	public abstract String getVersion();
+
+	// Get the author of the mod
+	public abstract String getAuthor();
+
+	// Is the mod for the client, server or both?
+	public ModSide getSide() {
+		return ModSide.BOTH;
+	}
+
+	// Get the path to the mod icon image
+	public String getIcon() {
+		return "/unknown.png";
+	}
+
+	public final String toString() {
+		return this.getName() + " " + this.getVersion() + " by " + this.getAuthor();
+	}
+
+	public final void writeToNBT(NBTTagCompound compound) {
+		compound.setString("Name", this.getName());
+		compound.setString("Author", this.getAuthor());
+		compound.setString("Version", this.getVersion());
+	}
+
+	// Called while the mod is loading
+	public abstract void load() throws Exception;
+
+	// Called after every mod has loaded
+	public void postLoad() {
+	}
+
+	// Called when the world ticks
+	public void onWorldTick(World world) {
+	}
+
+	// Called when an entity is hurt
+	public <E extends EntityLiving> int onEntityHurt(Class<? extends E> clazz, E target, Entity enemy, int damage) {
+		return damage;
+	}
+
+	// Called when an entity is dead
+	public <E extends EntityLiving> void onEntityDeath(Class<? extends E> clazz, E target, Entity enemy) {
+	}
+
+	// Called before EntityLiving.onLivingUpdate
+	public void onPlayerPreUpdate(EntityPlayer player) {
+	}
+
+	// Called after EntityLiving.onLivingUpdate
+	public void onPlayerUpdate(EntityPlayer player) {
+	}
+
+	// Called at the end of EntityPlayer.onLivingUpdate
+	public void onPlayerPostUpdate(EntityPlayer player) {
+	}
+
+	// Add items to the creative menu
+	public void setupCreativeInventory(CreativeInventoryBuilder inv) {
+	}
+
+	// Render custom models for custom blocks
+	public boolean renderBlockByRenderType(IBlockAccess blockAccess, Block block, int x, int y, int z, int type) {
+		return false;
+	}
+
+	// Render custom blocks in 3D
+	public boolean renderItemIn3d(int type) {
+		return false;
+	}
+
+	// Render custom blocks as items
+	public boolean renderItemOnInventory(Tessellator tesselator, Block block, int metadata, int type) {
+		return false;
+	}
+}
--- /dev/null
+++ net/minecraft/src/NBTTagIntArray.java
@@ -1,0 +1,50 @@
+package net.minecraft.src;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+public class NBTTagIntArray extends NBTBase {
+	public int[] intArray;
+
+	public NBTTagIntArray() {
+	}
+
+	public NBTTagIntArray(int[] var1) {
+		this.intArray = var1;
+	}
+
+	protected void writeTagContents(DataOutput var1) throws IOException {
+		var1.writeInt(this.intArray.length);
+		ByteBuffer buffer = ByteBuffer.allocate(this.intArray.length * 4);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().put(this.intArray);
+		byte[] bytes = buffer.array();
+		var1.write(bytes);
+	}
+
+	protected void readTagContents(DataInput var1) throws IOException {
+		int var2 = var1.readInt();
+		this.intArray = new int[var2];
+		byte[] byteArray = new byte[var2 * 4];
+		var1.readFully(byteArray);
+		ByteBuffer buffer = ByteBuffer.wrap(byteArray);
+		buffer.order(ByteOrder.BIG_ENDIAN);
+		buffer.asIntBuffer().get(this.intArray);
+	}
+
+	public byte getType() {
+		return (byte)11;
+	}
+
+	public String toString() {
+		return "[" + this.intArray.length + " ints]";
+	}
+
+	public NBTBase copy() {
+		return new NBTTagIntArray(Arrays.copyOf(this.intArray, this.intArray.length)).setKey(this.getKey());
+	}
+}
--- net/minecraft/src/NetworkAcceptThread.java
+++ net/minecraft/src/NetworkAcceptThread.java
@@ -2,11 +2,12 @@
 
 import java.io.IOException;
 import java.net.Socket;
+
 import net.minecraft.server.MinecraftServer;
 
-class NetworkAcceptThread extends Thread {
-	final MinecraftServer minecraftServer;
-	final NetworkListenThread networkListenThread;
+public class NetworkAcceptThread extends Thread {
+	public final MinecraftServer minecraftServer;
+	public final NetworkListenThread networkListenThread;
 
 	NetworkAcceptThread(NetworkListenThread var1, String var2, MinecraftServer var3) {
 		super(var2);
--- net/minecraft/src/CanvasMojangLogo.java
+++ net/minecraft/src/CanvasMojangLogo.java
@@ -8,7 +8,7 @@
 import java.io.IOException;
 import javax.imageio.ImageIO;
 
-class CanvasMojangLogo extends Canvas {
+public class CanvasMojangLogo extends Canvas {
 	private BufferedImage logo;
 
 	public CanvasMojangLogo() {
--- /dev/null
+++ net/minecraft/src/ItemHasteTrinket.java
@@ -1,0 +1,40 @@
+package net.minecraft.src;
+
+import java.util.stream.Stream;
+
+import static net.minecraft.src.ItemTooltip.DESCRIPTION_COL;
+
+public class ItemHasteTrinket extends ItemTrinket {
+	public final float attackTimeMultiplier;
+	public final float toolSpeedMultiplier;
+
+	public ItemHasteTrinket(int var1, String var2, float var3, float var4) {
+		super(var1, var2);
+		this.attackTimeMultiplier = var3;
+		this.toolSpeedMultiplier = var4;
+	}
+
+	public int getColor() {
+		return 0x999933;
+	}
+
+	public boolean isApplicable(Item item) {
+		return item instanceof ItemSword || item instanceof ItemTool;
+	}
+
+	public int modifyHeartsLife(int heartsLife) {
+		return (int)(heartsLife * this.attackTimeMultiplier);
+	}
+
+	public float modifyToolStrength(float strength) {
+		return strength * this.toolSpeedMultiplier;
+	}
+
+	public Object[] getTooltipInfo() {
+		return Stream.of(new Object[] {
+				"Reduces enemy invinicibility", DESCRIPTION_COL,
+				"frames by " + (int)(100.0F - this.attackTimeMultiplier * 100.0F) + "%", DESCRIPTION_COL,
+				"Increases tool speed by " + (int)(this.toolSpeedMultiplier * 100.0F - 100.0F) + "%", DESCRIPTION_COL
+		}, super.getTooltipInfo()).flatMap(Stream::of).toArray();
+	}
+}
--- net/minecraft/src/NBTTagString.java
+++ net/minecraft/src/NBTTagString.java
@@ -17,11 +17,11 @@
 		}
 	}
 
-	void writeTagContents(DataOutput var1) throws IOException {
+	protected void writeTagContents(DataOutput var1) throws IOException {
 		var1.writeUTF(this.stringValue);
 	}
 
-	void readTagContents(DataInput var1) throws IOException {
+	protected void readTagContents(DataInput var1) throws IOException {
 		this.stringValue = var1.readUTF();
 	}
 
@@ -30,6 +30,10 @@
 	}
 
 	public String toString() {
-		return "" + this.stringValue;
+		return this.stringValue;
+	}
+
+	public NBTBase copy() {
+		return new NBTTagString(this.stringValue).setKey(this.getKey());
 	}
 }
--- net/minecraft/src/ItemSpade.java
+++ net/minecraft/src/ItemSpade.java
@@ -1,13 +1,25 @@
 package net.minecraft.src;
 
 public class ItemSpade extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.grass, Block.dirt, Block.sand, Block.gravel, Block.snow, Block.blockSnow, Block.blockClay};
+	private static Block[] blocksEffectiveAgainst = new Block[] {
+			Block.grass,
+			Block.dirt,
+			Block.sand,
+			Block.gravel,
+			Block.snow,
+			Block.blockSnow,
+			Block.blockClay
+	};
 
 	public ItemSpade(int var1, int var2) {
-		super(var1, 1, var2, blocksEffectiveAgainst);
+		super(var1, 1, Math.abs(var2), blocksEffectiveAgainst, var2 < 0);
+		if (var2 < 0) {
+			this.efficiencyOnProperMaterial *= 2.5F;
+			this.maxDamage *= 4;
+		}
 	}
 
 	public boolean canHarvestBlock(Block var1) {
-		return var1 == Block.snow ? true : var1 == Block.blockSnow;
+		return var1 == Block.snow || var1 == Block.blockSnow;
 	}
 }
--- net/minecraft/src/SpawnerServer.java
+++ net/minecraft/src/SpawnerServer.java
@@ -1,17 +1,21 @@
 package net.minecraft.src;
 
-class SpawnerServer extends SpawnerAnimals {
-	final WorldServer worldServer;
+public class SpawnerServer extends SpawnerAnimals {
+	public final WorldServer worldServer;
 
-	SpawnerServer(WorldServer var1, int var2, Class var3, Class[] var4) {
-		super(var2, var3, var4);
+	public SpawnerServer(WorldServer var1, int var2, Class var3) {
+		super(var2, var3);
 		this.worldServer = var1;
 	}
 
 	protected ChunkPosition getRandomSpawningPointInChunk(World var1, int var2, int var3) {
 		int var4 = var2 + var1.rand.nextInt(16);
-		int var5 = var1.rand.nextInt(var1.rand.nextInt(120) + 8);
+		int var5 = var1.rand.nextInt(var1.rand.nextInt(120) + 8) + 64;
 		int var6 = var3 + var1.rand.nextInt(16);
 		return new ChunkPosition(var4, var5, var6);
+	}
+
+	public Class<? extends EntityLiving> getEntity(World world, Biome biome) {
+		return biome.spawnableMonsters.get(world.rand.nextInt(biome.spawnableMonsters.size()));
 	}
 }
--- net/minecraft/src/ItemFood.java
+++ net/minecraft/src/ItemFood.java
@@ -1,17 +1,49 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.ItemTooltip.*;
+
 public class ItemFood extends Item {
-	private int healAmount;
+	private final int healAmount;
+	private final EffectType effect;
+	private final int effectDuration;
 
 	public ItemFood(int var1, int var2) {
+		this(var1, var2, null, 0);
+	}
+
+	public ItemFood(int var1, int var2, EffectType effect, int duration) {
 		super(var1);
 		this.healAmount = var2;
-		this.maxStackSize = 1;
+		this.effect = effect;
+		this.effectDuration = duration;
+		this.maxStackSize = 8;
 	}
 
 	public ItemStack onItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
-		--var1.stackSize;
-		var3.heal(this.healAmount);
+		if (var3.hasEffect(EffectType.gluttony) || (var3.health + var3.healthRegen >= 20 && effect == null)) {
+			return var1;
+		}
+
+		if (!var3.creative) --var1.stackSize;
+		var3.healthRegen = Math.min(var3.healthRegen + this.healAmount, 20 - var3.health);
+		var2.playSoundAtEntity(var3, "random.eat", 1.0F, 1.0F);
+		if (var2.canDoClientAction() && this.effect != null) {
+			 var3.addEffect(this.effect, this.effectDuration);
+		}
+
+		var3.addEffect(EffectType.gluttony, this.effect != null ? 50 : 100);
 		return var1;
+	}
+
+	public Object[] getTooltipInfo() {
+		return this.effect != null
+				? new Object[] {
+						"Heals " + healAmount + " health", INFO_COL,
+						"Provides " + this.effect.name + " for " + formatFloat(this.effectDuration / 20.0F)
+								+ (this.effectDuration == 20 ? " second" : " seconds"), INFO_COL
+				}
+				: new Object[] {
+						"Heals " + healAmount + " health", INFO_COL
+				};
 	}
 }
--- /dev/null
+++ net/minecraft/src/ICrafting.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+import java.util.List;
+
+public interface ICrafting {
+	void setBothSlots(Container dw, List list);
+
+	void setSlot(Container dw, int integer, ItemStack il);
+
+	void setOtherSlot(Container dw, int integer2, int integer3);
+}
--- net/minecraft/src/RenderBlocks.java
+++ net/minecraft/src/RenderBlocks.java
@@ -1,5 +1,6 @@
 package net.minecraft.src;
 
+import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 
 public class RenderBlocks {
@@ -7,6 +8,65 @@
 	private int overrideBlockTexture = -1;
 	private boolean flipTexture = false;
 	private boolean renderAllFaces = false;
+	private boolean enableAO = false;
+	private int field_31087_g = 0;
+	private int field_31086_h = 0;
+	private int field_31085_i = 0;
+	private int field_31084_j = 0;
+	private int field_31083_k = 0;
+	private int field_31082_l = 0;
+	private float lightValueOwn;
+	private float aoLightValueXNeg;
+	private float aoLightValueYNeg;
+	private float aoLightValueZNeg;
+	private float aoLightValueXPos;
+	private float aoLightValueYPos;
+	private float aoLightValueZPos;
+	private float field_22377_m;
+	private float field_22376_n;
+	private float field_22375_o;
+	private float field_22374_p;
+	private float field_22373_q;
+	private float field_22372_r;
+	private float field_22371_s;
+	private float field_22370_t;
+	private float field_22369_u;
+	private float field_22368_v;
+	private float field_22367_w;
+	private float field_22366_x;
+	private float field_22365_y;
+	private float field_22364_z;
+	private float field_22362_A;
+	private float field_22360_B;
+	private float field_22358_C;
+	private float field_22356_D;
+	private float field_22354_E;
+	private float field_22353_F;
+	private int field_22352_G = 1;
+	private float colorRedTopLeft;
+	private float colorRedBottomLeft;
+	private float colorRedBottomRight;
+	private float colorRedTopRight;
+	private float colorGreenTopLeft;
+	private float colorGreenBottomLeft;
+	private float colorGreenBottomRight;
+	private float colorGreenTopRight;
+	private float colorBlueTopLeft;
+	private float colorBlueBottomLeft;
+	private float colorBlueBottomRight;
+	private float colorBlueTopRight;
+	private boolean field_22339_T;
+	private boolean field_22338_U;
+	private boolean field_22337_V;
+	private boolean field_22336_W;
+	private boolean field_22335_X;
+	private boolean field_22334_Y;
+	private boolean field_22333_Z;
+	private boolean field_22363_aa;
+	private boolean field_22361_ab;
+	private boolean field_22359_ac;
+	private boolean field_22357_ad;
+	private boolean field_22355_ae;
 
 	public RenderBlocks(IBlockAccess var1) {
 		this.blockAccess = var1;
@@ -24,13 +84,29 @@
 	public boolean renderBlockByRenderType(Block var1, int var2, int var3, int var4) {
 		int var5 = var1.getRenderType();
 		var1.setBlockBoundsBasedOnState(this.blockAccess, var2, var3, var4);
-		return var5 == 0 ? this.renderStandardBlock(var1, var2, var3, var4) : (var5 == 4 ? this.renderBlockFluids(var1, var2, var3, var4) : (var5 == 13 ? this.renderBlockCactus(var1, var2, var3, var4) : (var5 == 1 ? this.renderBlockReed(var1, var2, var3, var4) : (var5 == 6 ? this.renderBlockCrops(var1, var2, var3, var4) : (var5 == 2 ? this.renderBlockTorch(var1, var2, var3, var4) : (var5 == 3 ? this.renderBlockFire(var1, var2, var3, var4) : (var5 == 5 ? this.renderBlockRedstoneWire(var1, var2, var3, var4) : (var5 == 8 ? this.renderBlockLadder(var1, var2, var3, var4) : (var5 == 7 ? this.renderBlockDoor(var1, var2, var3, var4) : (var5 == 9 ? this.renderBlockMinecartTrack(var1, var2, var3, var4) : (var5 == 10 ? this.renderBlockStairs(var1, var2, var3, var4) : (var5 == 11 ? this.renderBlockFence(var1, var2, var3, var4) : (var5 == 12 ? this.renderBlockLever(var1, var2, var3, var4) : false)))))))))))));
+		return ModLoader.callHook(BaseMod::renderBlockByRenderType, this.blockAccess, var1, var2, var3, var4, var5)
+				|| (var5 == 0 ? this.renderStandardBlock(var1, var2, var3, var4)
+				: var5 == 1 ? this.renderBlockReed(var1, var2, var3, var4)
+				: var5 == 2 ? this.renderBlockTorch(var1, var2, var3, var4)
+				: var5 == 3 ? this.renderBlockFire(var1, var2, var3, var4)
+				: var5 == 4 ? this.renderBlockFluids(var1, var2, var3, var4)
+				: var5 == 5 ? this.renderBlockRedstoneWire(var1, var2, var3, var4)
+				: var5 == 6 ? this.renderBlockCrops(var1, var2, var3, var4)
+				: var5 == 7 ? this.renderBlockDoor(var1, var2, var3, var4)
+				: var5 == 8 ? this.renderBlockLadder(var1, var2, var3, var4)
+				: var5 == 9 ? this.renderBlockMinecartTrack(var1, var2, var3, var4)
+				: var5 == 10 ? this.renderBlockStairs(var1, var2, var3, var4)
+				: var5 == 11 ? this.renderBlockFence(var1, var2, var3, var4)
+				: var5 == 12 ? this.renderBlockLever(var1, var2, var3, var4)
+				: var5 == 13 ? this.renderBlockCactus(var1, var2, var3, var4)
+				: var5 == 14 ? this.renderBlockGrass(var1, var2, var3, var4)
+				: false);
 	}
 
 	public boolean renderBlockTorch(Block var1, int var2, int var3, int var4) {
 		int var5 = this.blockAccess.getBlockMetadata(var2, var3, var4);
 		Tessellator var6 = Tessellator.instance;
-		float var7 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var7 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		if(Block.lightValue[var1.blockID] > 0) {
 			var7 = 1.0F;
 		}
@@ -86,7 +162,7 @@
 			this.overrideBlockTexture = -1;
 		}
 
-		float var13 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var13 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		if(Block.lightValue[var1.blockID] > 0) {
 			var13 = 1.0F;
 		}
@@ -97,12 +173,12 @@
 			var14 = this.overrideBlockTexture;
 		}
 
-		int var15 = (var14 & 15) << 4;
-		int var16 = var14 & 240;
-		float var17 = (float)var15 / 256.0F;
-		float var18 = ((float)var15 + 15.99F) / 256.0F;
-		float var19 = (float)var16 / 256.0F;
-		float var20 = ((float)var16 + 15.99F) / 256.0F;
+		int var15 = var14 % 32 * 16;
+		int var16 = var14 / 32 * 16;
+		float var17 = (float)var15 / 512.0F;
+		float var18 = ((float)var15 + 15.99F) / 512.0F;
+		float var19 = (float)var16 / 512.0F;
+		float var20 = ((float)var16 + 15.99F) / 512.0F;
 		Vec3D[] var21 = new Vec3D[8];
 		float var22 = 1.0F / 16.0F;
 		float var23 = 1.0F / 16.0F;
@@ -153,7 +229,7 @@
 				var21[var25].zCoord += (double)var4 + 0.5D;
 			} else {
 				var21[var25].xCoord += (double)var2 + 0.5D;
-				var21[var25].yCoord += (double)((float)var3 + 2.0F / 16.0F);
+				var21[var25].yCoord += (double)((float)var3 + 0.125F);
 				var21[var25].zCoord += (double)var4 + 0.5D;
 			}
 		}
@@ -165,15 +241,15 @@
 
 		for(int var29 = 0; var29 < 6; ++var29) {
 			if(var29 == 0) {
-				var17 = (float)(var15 + 7) / 256.0F;
-				var18 = ((float)(var15 + 9) - 0.01F) / 256.0F;
-				var19 = (float)(var16 + 6) / 256.0F;
-				var20 = ((float)(var16 + 8) - 0.01F) / 256.0F;
+				var17 = (float)(var15 + 7) / 512.0F;
+				var18 = ((float)(var15 + 9) - 0.01F) / 512.0F;
+				var19 = (float)(var16 + 6) / 512.0F;
+				var20 = ((float)(var16 + 8) - 0.01F) / 512.0F;
 			} else if(var29 == 2) {
-				var17 = (float)(var15 + 7) / 256.0F;
-				var18 = ((float)(var15 + 9) - 0.01F) / 256.0F;
-				var19 = (float)(var16 + 6) / 256.0F;
-				var20 = ((float)(var16 + 16) - 0.01F) / 256.0F;
+				var17 = (float)(var15 + 7) / 512.0F;
+				var18 = ((float)(var15 + 9) - 0.01F) / 512.0F;
+				var19 = (float)(var16 + 6) / 512.0F;
+				var20 = ((float)(var16 + 16) - 0.01F) / 512.0F;
 			}
 
 			if(var29 == 0) {
@@ -224,14 +300,14 @@
 			var6 = this.overrideBlockTexture;
 		}
 
-		float var7 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var7 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var7, var7, var7);
-		int var8 = (var6 & 15) << 4;
-		int var9 = var6 & 240;
-		double var10 = (double)((float)var8 / 256.0F);
-		double var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-		double var14 = (double)((float)var9 / 256.0F);
-		double var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+		int var8 = var6 % 32 * 16;
+		int var9 = var6 / 32 * 16;
+		double var10 = (double)((float)var8 / 512.0F);
+		double var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+		double var14 = (double)((float)var9 / 512.0F);
+		double var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 		float var18 = 1.4F;
 		double var21;
 		double var23;
@@ -244,10 +320,10 @@
 			float var37 = 0.2F;
 			float var20 = 1.0F / 16.0F;
 			if((var2 + var3 + var4 & 1) == 1) {
-				var10 = (double)((float)var8 / 256.0F);
-				var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-				var14 = (double)((float)(var9 + 16) / 256.0F);
-				var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+				var10 = (double)((float)var8 / 512.0F);
+				var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+				var14 = (double)((float)(var9 + 16) / 512.0F);
+				var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 			}
 
 			if((var2 / 2 + var3 / 2 + var4 / 2 & 1) == 1) {
@@ -309,10 +385,10 @@
 				var31 = (double)var2 + 0.5D + 0.5D;
 				var33 = (double)var4 + 0.5D - 0.5D;
 				double var35 = (double)var4 + 0.5D + 0.5D;
-				var10 = (double)((float)var8 / 256.0F);
-				var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-				var14 = (double)((float)var9 / 256.0F);
-				var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+				var10 = (double)((float)var8 / 512.0F);
+				var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+				var14 = (double)((float)var9 / 512.0F);
+				var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 				++var3;
 				var18 = -0.2F;
 				if((var2 + var3 + var4 & 1) == 0) {
@@ -320,10 +396,10 @@
 					var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 0), var12, var16);
 					var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 1), var10, var16);
 					var5.addVertexWithUV(var29, (double)((float)var3 + var18), (double)(var4 + 1), var10, var14);
-					var10 = (double)((float)var8 / 256.0F);
-					var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-					var14 = (double)((float)(var9 + 16) / 256.0F);
-					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+					var10 = (double)((float)var8 / 512.0F);
+					var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+					var14 = (double)((float)(var9 + 16) / 512.0F);
+					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 					var5.addVertexWithUV(var31, (double)((float)var3 + var18), (double)(var4 + 1), var12, var14);
 					var5.addVertexWithUV(var23, (double)(var3 + 0), (double)(var4 + 1), var12, var16);
 					var5.addVertexWithUV(var23, (double)(var3 + 0), (double)(var4 + 0), var10, var16);
@@ -333,10 +409,10 @@
 					var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var27, var12, var16);
 					var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var27, var10, var16);
 					var5.addVertexWithUV((double)(var2 + 1), (double)((float)var3 + var18), var35, var10, var14);
-					var10 = (double)((float)var8 / 256.0F);
-					var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-					var14 = (double)((float)(var9 + 16) / 256.0F);
-					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+					var10 = (double)((float)var8 / 512.0F);
+					var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+					var14 = (double)((float)(var9 + 16) / 512.0F);
+					var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 					var5.addVertexWithUV((double)(var2 + 1), (double)((float)var3 + var18), var33, var12, var14);
 					var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var25, var12, var16);
 					var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var25, var10, var16);
@@ -360,10 +436,10 @@
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 0), var12, var16);
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 1), var10, var16);
 			var5.addVertexWithUV(var29, (double)((float)var3 + var18), (double)(var4 + 1), var10, var14);
-			var10 = (double)((float)var8 / 256.0F);
-			var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-			var14 = (double)((float)(var9 + 16) / 256.0F);
-			var16 = (double)(((float)var9 + 15.99F + 16.0F) / 256.0F);
+			var10 = (double)((float)var8 / 512.0F);
+			var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+			var14 = (double)((float)(var9 + 16) / 512.0F);
+			var16 = (double)(((float)var9 + 15.99F + 16.0F) / 512.0F);
 			var5.addVertexWithUV((double)(var2 + 1), (double)((float)var3 + var18), var33, var12, var14);
 			var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var25, var12, var16);
 			var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var25, var10, var16);
@@ -388,10 +464,10 @@
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 1), var10, var16);
 			var5.addVertexWithUV(var21, (double)(var3 + 0), (double)(var4 + 0), var12, var16);
 			var5.addVertexWithUV(var29, (double)((float)var3 + var18), (double)(var4 + 0), var12, var14);
-			var10 = (double)((float)var8 / 256.0F);
-			var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-			var14 = (double)((float)var9 / 256.0F);
-			var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+			var10 = (double)((float)var8 / 512.0F);
+			var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+			var14 = (double)((float)var9 / 512.0F);
+			var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 			var5.addVertexWithUV((double)(var2 + 0), (double)((float)var3 + var18), var33, var10, var14);
 			var5.addVertexWithUV((double)(var2 + 0), (double)(var3 + 0), var25, var10, var16);
 			var5.addVertexWithUV((double)(var2 + 1), (double)(var3 + 0), var25, var12, var16);
@@ -412,16 +488,16 @@
 			var6 = this.overrideBlockTexture;
 		}
 
-		float var7 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var7 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var7, var7, var7);
-		int var8 = (var6 & 15) << 4;
-		int var9 = var6 & 240;
-		double var10 = (double)((float)var8 / 256.0F);
-		double var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-		double var14 = (double)((float)var9 / 256.0F);
-		double var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+		int var8 = var6 % 32 * 16;
+		int var9 = var6 / 32 * 16;
+		double var10 = (double)((float)var8 / 512.0F);
+		double var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+		double var14 = (double)((float)var9 / 512.0F);
+		double var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 		float var18 = 0.0F;
-		float var19 = 0.03125F;
+		float var19 = 1.0F / 32.0F;
 		boolean var20 = BlockRedstoneWire.isPowerProviderOrWire(this.blockAccess, var2 - 1, var3, var4) || !this.blockAccess.isBlockNormalCube(var2 - 1, var3, var4) && BlockRedstoneWire.isPowerProviderOrWire(this.blockAccess, var2 - 1, var3 - 1, var4);
 		boolean var21 = BlockRedstoneWire.isPowerProviderOrWire(this.blockAccess, var2 + 1, var3, var4) || !this.blockAccess.isBlockNormalCube(var2 + 1, var3, var4) && BlockRedstoneWire.isPowerProviderOrWire(this.blockAccess, var2 + 1, var3 - 1, var4);
 		boolean var22 = BlockRedstoneWire.isPowerProviderOrWire(this.blockAccess, var2, var3, var4 - 1) || !this.blockAccess.isBlockNormalCube(var2, var3, var4 - 1) && BlockRedstoneWire.isPowerProviderOrWire(this.blockAccess, var2, var3 - 1, var4 - 1);
@@ -444,7 +520,7 @@
 			}
 		}
 
-		float var24 = 5.0F / 16.0F;
+		float var24 = 5.0F / 32.0F;
 		float var25 = (float)(var2 + 0);
 		float var26 = (float)(var2 + 1);
 		float var27 = (float)(var4 + 0);
@@ -459,16 +535,16 @@
 		}
 
 		if(var29 != 0) {
-			var10 = (double)((float)(var8 + 16) / 256.0F);
-			var12 = (double)(((float)(var8 + 16) + 15.99F) / 256.0F);
-			var14 = (double)((float)var9 / 256.0F);
-			var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+			var10 = (double)((float)(var8 + 16) / 512.0F);
+			var12 = (double)(((float)(var8 + 16) + 15.99F) / 512.0F);
+			var14 = (double)((float)var9 / 512.0F);
+			var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 		}
 
 		if(var29 == 0) {
 			if(var21 || var22 || var23 || var20) {
 				if(!var20) {
-					var25 += var24;
+					var25 += var24 * 2.0F;
 				}
 
 				if(!var20) {
@@ -476,7 +552,7 @@
 				}
 
 				if(!var21) {
-					var26 -= var24;
+					var26 -= var24 * 2.0F;
 				}
 
 				if(!var21) {
@@ -484,7 +560,7 @@
 				}
 
 				if(!var22) {
-					var27 += var24;
+					var27 += var24 * 2.0F;
 				}
 
 				if(!var22) {
@@ -492,7 +568,7 @@
 				}
 
 				if(!var23) {
-					var28 -= var24;
+					var28 -= var24 * 2.0F;
 				}
 
 				if(!var23) {
@@ -520,10 +596,10 @@
 			var5.addVertexWithUV((double)(var25 - var18), (double)((float)var3 + var19), (double)(var28 + var18), var12, var14);
 		}
 
-		var10 = (double)((float)(var8 + 16) / 256.0F);
-		var12 = (double)(((float)(var8 + 16) + 15.99F) / 256.0F);
-		var14 = (double)((float)var9 / 256.0F);
-		var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+		var10 = (double)((float)(var8 + 16) / 512.0F);
+		var12 = (double)(((float)(var8 + 16) + 15.99F) / 512.0F);
+		var14 = (double)((float)var9 / 512.0F);
+		var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 		if(!this.blockAccess.isBlockNormalCube(var2, var3 + 1, var4)) {
 			if(this.blockAccess.isBlockNormalCube(var2 - 1, var3, var4) && this.blockAccess.getBlockId(var2 - 1, var3 + 1, var4) == Block.redstoneWire.blockID) {
 				var5.addVertexWithUV((double)((float)var2 + var19), (double)((float)(var3 + 1) + var18), (double)((float)(var4 + 1) + var18), var12, var14);
@@ -565,14 +641,14 @@
 			var7 = this.overrideBlockTexture;
 		}
 
-		float var8 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var8 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var8, var8, var8);
-		int var9 = (var7 & 15) << 4;
-		int var10 = var7 & 240;
-		double var11 = (double)((float)var9 / 256.0F);
-		double var13 = (double)(((float)var9 + 15.99F) / 256.0F);
-		double var15 = (double)((float)var10 / 256.0F);
-		double var17 = (double)(((float)var10 + 15.99F) / 256.0F);
+		int var9 = var7 % 32 * 16;
+		int var10 = var7 / 32 * 16;
+		double var11 = (double)((float)var9 / 512.0F);
+		double var13 = (double)(((float)var9 + 15.99F) / 512.0F);
+		double var15 = (double)((float)var10 / 512.0F);
+		double var17 = (double)(((float)var10 + 15.99F) / 512.0F);
 		float var19 = 1.0F / 16.0F;
 		float var20 = (float)(var2 + 1);
 		float var21 = (float)(var2 + 1);
@@ -645,14 +721,14 @@
 			var6 = this.overrideBlockTexture;
 		}
 
-		float var7 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var7 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var7, var7, var7);
-		int var8 = (var6 & 15) << 4;
-		int var9 = var6 & 240;
-		double var10 = (double)((float)var8 / 256.0F);
-		double var12 = (double)(((float)var8 + 15.99F) / 256.0F);
-		double var14 = (double)((float)var9 / 256.0F);
-		double var16 = (double)(((float)var9 + 15.99F) / 256.0F);
+		int var8 = var6 % 32 * 16;
+		int var9 = var6 / 32 * 16;
+		double var10 = (double)((float)var8 / 512.0F);
+		double var12 = (double)(((float)var8 + 15.99F) / 512.0F);
+		double var14 = (double)((float)var9 / 512.0F);
+		double var16 = (double)(((float)var9 + 15.99F) / 512.0F);
 		int var18 = this.blockAccess.getBlockMetadata(var2, var3, var4);
 		float var19 = 0.0F;
 		float var20 = 0.05F;
@@ -689,7 +765,7 @@
 
 	public boolean renderBlockReed(Block var1, int var2, int var3, int var4) {
 		Tessellator var5 = Tessellator.instance;
-		float var6 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var6 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var6, var6, var6);
 		this.renderCrossedSquares(var1, this.blockAccess.getBlockMetadata(var2, var3, var4), (double)var2, (double)var3, (double)var4);
 		return true;
@@ -697,7 +773,7 @@
 
 	public boolean renderBlockCrops(Block var1, int var2, int var3, int var4) {
 		Tessellator var5 = Tessellator.instance;
-		float var6 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var6 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		var5.setColorOpaque_F(var6, var6, var6);
 		this.renderBlockCropsImpl(var1, this.blockAccess.getBlockMetadata(var2, var3, var4), (double)var2, (double)((float)var3 - 1.0F / 16.0F), (double)var4);
 		return true;
@@ -710,16 +786,16 @@
 			var13 = this.overrideBlockTexture;
 		}
 
-		int var14 = (var13 & 15) << 4;
-		int var15 = var13 & 240;
-		float var16 = (float)var14 / 256.0F;
-		float var17 = ((float)var14 + 15.99F) / 256.0F;
-		float var18 = (float)var15 / 256.0F;
-		float var19 = ((float)var15 + 15.99F) / 256.0F;
-		double var20 = (double)var16 + 1.75D / 64.0D;
-		double var22 = (double)var18 + 6.0D / 256.0D;
-		double var24 = (double)var16 + 9.0D / 256.0D;
-		double var26 = (double)var18 + 1.0D / 32.0D;
+		int var14 = var13 % 32 * 16;
+		int var15 = var13 / 32 * 16;
+		float var16 = (float)var14 / 512.0F;
+		float var17 = ((float)var14 + 15.99F) / 512.0F;
+		float var18 = (float)var15 / 512.0F;
+		float var19 = ((float)var15 + 15.99F) / 512.0F;
+		double var20 = (double)var16 + 1.75D / 128.0D;
+		double var22 = (double)var18 + 6.0D / 512.0D;
+		double var24 = (double)var16 + 9.0D / 512.0D;
+		double var26 = (double)var18 + 1.0D / 64.0D;
 		var2 += 0.5D;
 		var6 += 0.5D;
 		double var28 = var2 - 0.5D;
@@ -757,16 +833,21 @@
 			var10 = this.overrideBlockTexture;
 		}
 
-		int var11 = (var10 & 15) << 4;
-		int var12 = var10 & 240;
-		double var13 = (double)((float)var11 / 256.0F);
-		double var15 = (double)(((float)var11 + 15.99F) / 256.0F);
-		double var17 = (double)((float)var12 / 256.0F);
-		double var19 = (double)(((float)var12 + 15.99F) / 256.0F);
-		double var21 = var3 + 0.5D - (double)0.45F;
-		double var23 = var3 + 0.5D + (double)0.45F;
-		double var25 = var7 + 0.5D - (double)0.45F;
-		double var27 = var7 + 0.5D + (double)0.45F;
+		int var11 = var10 % 32 * 16;
+		int var12 = var10 / 32 * 16;
+		double var13 = (double)((float)var11 / 512.0F);
+		double var15 = (double)(((float)var11 + 15.99F) / 512.0F);
+		double var17 = (double)((float)var12 / 512.0F);
+		double var19 = (double)(((float)var12 + 15.99F) / 512.0F);
+		double var21 = -0.45D;
+		double var23 = 0.45D;
+		double var25 = -0.45D;
+		double var27 = 0.45D;
+		var21 += var3 + 0.5D;
+		var23 += var3 + 0.5D;
+		var25 += var7 + 0.5D;
+		var27 += var7 + 0.5D;
+
 		var9.addVertexWithUV(var21, var5 + 1.0D, var25, var13, var17);
 		var9.addVertexWithUV(var21, var5 + 0.0D, var25, var13, var19);
 		var9.addVertexWithUV(var23, var5 + 0.0D, var27, var15, var19);
@@ -792,12 +873,12 @@
 			var10 = this.overrideBlockTexture;
 		}
 
-		int var11 = (var10 & 15) << 4;
-		int var12 = var10 & 240;
-		double var13 = (double)((float)var11 / 256.0F);
-		double var15 = (double)(((float)var11 + 15.99F) / 256.0F);
-		double var17 = (double)((float)var12 / 256.0F);
-		double var19 = (double)(((float)var12 + 15.99F) / 256.0F);
+		int var11 = var10 % 32 * 16;
+		int var12 = var10 / 32 * 16;
+		double var13 = (double)((float)var11 / 512.0F);
+		double var15 = (double)(((float)var11 + 15.99F) / 512.0F);
+		double var17 = (double)((float)var12 / 512.0F);
+		double var19 = (double)(((float)var12 + 15.99F) / 512.0F);
 		double var21 = var3 + 0.5D - 0.25D;
 		double var23 = var3 + 0.5D + 0.25D;
 		double var25 = var7 + 0.5D - 0.5D;
@@ -874,20 +955,20 @@
 					var24 = var1.getBlockTextureFromSideAndMetadata(2, var19);
 				}
 
-				int var26 = (var24 & 15) << 4;
-				var27 = var24 & 240;
-				double var28 = ((double)var26 + 8.0D) / 256.0D;
-				double var30 = ((double)var27 + 8.0D) / 256.0D;
+				int var26 = var24 % 32 * 16;
+				var27 = var24 / 32 * 16;
+				double var28 = ((double)var26 + 8.0D) / 512.0D;
+				double var30 = ((double)var27 + 8.0D) / 512.0D;
 				if(var25 < -999.0F) {
 					var25 = 0.0F;
 				} else {
-					var28 = (double)((float)(var26 + 16) / 256.0F);
-					var30 = (double)((float)(var27 + 16) / 256.0F);
+					var28 = (double)((float)(var26 + 16) / 512.0F);
+					var30 = (double)((float)(var27 + 16) / 512.0F);
 				}
 
-				var32 = MathHelper.sin(var25) * 8.0F / 256.0F;
-				var33 = MathHelper.cos(var25) * 8.0F / 256.0F;
-				var34 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+				var32 = MathHelper.sin(var25) * 8.0F / 512.0F;
+				var33 = MathHelper.cos(var25) * 8.0F / 512.0F;
+				var34 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 				var5.setColorOpaque_F(var11 * var34, var11 * var34, var11 * var34);
 				var5.addVertexWithUV((double)(var2 + 0), (double)((float)var3 + var20), (double)(var4 + 0), var28 - (double)var33 - (double)var32, var30 - (double)var33 + (double)var32);
 				var5.addVertexWithUV((double)(var2 + 0), (double)((float)var3 + var21), (double)(var4 + 1), var28 - (double)var33 + (double)var32, var30 + (double)var33 + (double)var32);
@@ -896,7 +977,7 @@
 			}
 
 			if(this.renderAllFaces || var7) {
-				float var48 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
+				float var48 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
 				var5.setColorOpaque_F(var10 * var48, var10 * var48, var10 * var48);
 				this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTextureFromSide(0));
 				var9 = true;
@@ -922,8 +1003,8 @@
 				}
 
 				int var50 = var1.getBlockTextureFromSideAndMetadata(var24 + 2, var19);
-				int var29 = (var50 & 15) << 4;
-				int var51 = var50 & 240;
+				int var29 = var50 % 32 * 16;
+				int var51 = var50 / 32 * 16;
 				if(this.renderAllFaces || var8[var24]) {
 					float var31;
 					float var35;
@@ -959,12 +1040,12 @@
 					}
 
 					var9 = true;
-					double var37 = (double)((float)(var29 + 0) / 256.0F);
-					double var39 = ((double)(var29 + 16) - 0.01D) / 256.0D;
-					double var41 = (double)(((float)var51 + (1.0F - var31) * 16.0F) / 256.0F);
-					double var43 = (double)(((float)var51 + (1.0F - var32) * 16.0F) / 256.0F);
-					double var45 = ((double)(var51 + 16) - 0.01D) / 256.0D;
-					float var47 = var1.getBlockBrightness(this.blockAccess, var49, var3, var27);
+					double var37 = (double)((float)(var29 + 0) / 512.0F);
+					double var39 = ((double)(var29 + 16) - 0.01D) / 512.0D;
+					double var41 = (double)(((float)var51 + (1.0F - var31) * 16.0F) / 512.0F);
+					double var43 = (double)(((float)var51 + (1.0F - var32) * 16.0F) / 512.0F);
+					double var45 = ((double)(var51 + 16) - 0.01D) / 512.0D;
+					float var47 = var1.getBlockRenderBrightness(this.blockAccess, var49, var3, var27);
 					if(var24 < 2) {
 						var47 *= var12;
 					} else {
@@ -1017,56 +1098,56 @@
 		return 1.0F - var6 / (float)var5;
 	}
 
-	public void renderBlockFallingSand(Block var1, World var2, int var3, int var4, int var5) {
+	public void renderBlockFallingSand(Block var1, World var2, int var3, int var4, int var5, int m) {
 		float var6 = 0.5F;
 		float var7 = 1.0F;
 		float var8 = 0.8F;
 		float var9 = 0.6F;
 		Tessellator var10 = Tessellator.instance;
 		var10.startDrawingQuads();
-		float var11 = var1.getBlockBrightness(var2, var3, var4, var5);
-		float var12 = var1.getBlockBrightness(var2, var3, var4 - 1, var5);
+		float var11 = var1.getBlockRenderBrightness(var2, var3, var4, var5);
+		float var12 = var1.getBlockRenderBrightness(var2, var3, var4 - 1, var5);
 		if(var12 < var11) {
 			var12 = var11;
 		}
 
 		var10.setColorOpaque_F(var6 * var12, var6 * var12, var6 * var12);
-		this.renderBottomFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSide(0));
-		var12 = var1.getBlockBrightness(var2, var3, var4 + 1, var5);
+		this.renderBottomFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSideAndMetadata(0, m));
+		var12 = var1.getBlockRenderBrightness(var2, var3, var4 + 1, var5);
 		if(var12 < var11) {
 			var12 = var11;
 		}
 
 		var10.setColorOpaque_F(var7 * var12, var7 * var12, var7 * var12);
-		this.renderTopFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSide(1));
-		var12 = var1.getBlockBrightness(var2, var3, var4, var5 - 1);
-		if(var12 < var11) {
-			var12 = var11;
-		}
-
-		var10.setColorOpaque_F(var8 * var12, var8 * var12, var8 * var12);
-		this.renderEastFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSide(2));
-		var12 = var1.getBlockBrightness(var2, var3, var4, var5 + 1);
-		if(var12 < var11) {
-			var12 = var11;
-		}
-
-		var10.setColorOpaque_F(var8 * var12, var8 * var12, var8 * var12);
-		this.renderWestFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSide(3));
-		var12 = var1.getBlockBrightness(var2, var3 - 1, var4, var5);
-		if(var12 < var11) {
-			var12 = var11;
-		}
-
-		var10.setColorOpaque_F(var9 * var12, var9 * var12, var9 * var12);
-		this.renderNorthFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSide(4));
-		var12 = var1.getBlockBrightness(var2, var3 + 1, var4, var5);
-		if(var12 < var11) {
-			var12 = var11;
-		}
-
-		var10.setColorOpaque_F(var9 * var12, var9 * var12, var9 * var12);
-		this.renderSouthFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSide(5));
+		this.renderTopFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSideAndMetadata(1, m));
+		var12 = var1.getBlockRenderBrightness(var2, var3, var4, var5 - 1);
+		if(var12 < var11) {
+			var12 = var11;
+		}
+
+		var10.setColorOpaque_F(var8 * var12, var8 * var12, var8 * var12);
+		this.renderEastFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSideAndMetadata(2, m));
+		var12 = var1.getBlockRenderBrightness(var2, var3, var4, var5 + 1);
+		if(var12 < var11) {
+			var12 = var11;
+		}
+
+		var10.setColorOpaque_F(var8 * var12, var8 * var12, var8 * var12);
+		this.renderWestFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSideAndMetadata(3, m));
+		var12 = var1.getBlockRenderBrightness(var2, var3 - 1, var4, var5);
+		if(var12 < var11) {
+			var12 = var11;
+		}
+
+		var10.setColorOpaque_F(var9 * var12, var9 * var12, var9 * var12);
+		this.renderNorthFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSideAndMetadata(4, m));
+		var12 = var1.getBlockRenderBrightness(var2, var3 + 1, var4, var5);
+		if(var12 < var11) {
+			var12 = var11;
+		}
+
+		var10.setColorOpaque_F(var9 * var12, var9 * var12, var9 * var12);
+		this.renderSouthFace(var1, -0.5D, -0.5D, -0.5D, var1.getBlockTextureFromSideAndMetadata(5, m));
 		var10.draw();
 	}
 
@@ -1075,7 +1156,442 @@
 		float var6 = (float)(var5 >> 16 & 255) / 255.0F;
 		float var7 = (float)(var5 >> 8 & 255) / 255.0F;
 		float var8 = (float)(var5 & 255) / 255.0F;
-		return this.renderStandardBlockWithColorMultiplier(var1, var2, var3, var4, var6, var7, var8);
+		return Minecraft.getInstance().options.ambientOcclusion
+			? this.renderStandardBlockWithAmbientOcclusion(var1, var2, var3, var4, var6, var7, var8)
+			: this.renderStandardBlockWithColorMultiplier(var1, var2, var3, var4, var6, var7, var8);
+	}
+
+	public boolean renderStandardBlockWithAmbientOcclusion(Block var1, int var2, int var3, int var4, float var5, float var6, float var7) {
+		this.enableAO = true;
+		boolean var8 = false;
+		float var9 = this.lightValueOwn;
+		float var10 = this.lightValueOwn;
+		float var11 = this.lightValueOwn;
+		float var12 = this.lightValueOwn;
+		boolean var13 = true;
+		boolean var14 = true;
+		boolean var15 = true;
+		boolean var16 = true;
+		boolean var17 = true;
+		boolean var18 = true;
+		this.lightValueOwn = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4) * var1.getAOModifier(this.blockAccess, var2 - 1, var3, var4);
+		this.aoLightValueXNeg = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4) * var1.getAOModifier(this.blockAccess, var2 - 1, var3, var4);
+		this.aoLightValueYNeg = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4) * var1.getAOModifier(this.blockAccess, var2, var3 - 1, var4);
+		this.aoLightValueZNeg = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1) * var1.getAOModifier(this.blockAccess, var2, var3, var4 - 1);
+		this.aoLightValueXPos = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4) * var1.getAOModifier(this.blockAccess, var2 + 1, var3, var4);
+		this.aoLightValueYPos = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4) * var1.getAOModifier(this.blockAccess, var2, var3 + 1, var4);
+		this.aoLightValueZPos = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1) * var1.getAOModifier(this.blockAccess, var2, var3, var4 + 1);
+		this.field_22338_U = Block.canBlockGrass[this.blockAccess.getBlockId(var2 + 1, var3 + 1, var4)];
+		this.field_22359_ac = Block.canBlockGrass[this.blockAccess.getBlockId(var2 + 1, var3 - 1, var4)];
+		this.field_22334_Y = Block.canBlockGrass[this.blockAccess.getBlockId(var2 + 1, var3, var4 + 1)];
+		this.field_22363_aa = Block.canBlockGrass[this.blockAccess.getBlockId(var2 + 1, var3, var4 - 1)];
+		this.field_22337_V = Block.canBlockGrass[this.blockAccess.getBlockId(var2 - 1, var3 + 1, var4)];
+		this.field_22357_ad = Block.canBlockGrass[this.blockAccess.getBlockId(var2 - 1, var3 - 1, var4)];
+		this.field_22335_X = Block.canBlockGrass[this.blockAccess.getBlockId(var2 - 1, var3, var4 - 1)];
+		this.field_22333_Z = Block.canBlockGrass[this.blockAccess.getBlockId(var2 - 1, var3, var4 + 1)];
+		this.field_22336_W = Block.canBlockGrass[this.blockAccess.getBlockId(var2, var3 + 1, var4 + 1)];
+		this.field_22339_T = Block.canBlockGrass[this.blockAccess.getBlockId(var2, var3 + 1, var4 - 1)];
+		this.field_22355_ae = Block.canBlockGrass[this.blockAccess.getBlockId(var2, var3 - 1, var4 + 1)];
+		this.field_22361_ab = Block.canBlockGrass[this.blockAccess.getBlockId(var2, var3 - 1, var4 - 1)];
+		if(var1.blockIndexInTexture == 3) {
+			var18 = false;
+			var17 = var18;
+			var16 = var18;
+			var15 = var18;
+			var13 = var18;
+		}
+
+		if(this.overrideBlockTexture >= 0) {
+			var18 = false;
+			var17 = var18;
+			var16 = var18;
+			var15 = var18;
+			var13 = var18;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 - 1, var4, 0)) {
+			if(this.field_22352_G <= 0) {
+				var12 = this.aoLightValueYNeg;
+				var11 = var12;
+				var10 = var12;
+				var9 = var12;
+			} else {
+				--var3;
+				this.field_22376_n = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4);
+				this.field_22374_p = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1);
+				this.field_22373_q = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1);
+				this.field_22371_s = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4);
+				if(!this.field_22361_ab && !this.field_22357_ad) {
+					this.field_22377_m = this.field_22376_n;
+				} else {
+					this.field_22377_m = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4 - 1);
+				}
+
+				if(!this.field_22355_ae && !this.field_22357_ad) {
+					this.field_22375_o = this.field_22376_n;
+				} else {
+					this.field_22375_o = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4 + 1);
+				}
+
+				if(!this.field_22361_ab && !this.field_22359_ac) {
+					this.field_22372_r = this.field_22371_s;
+				} else {
+					this.field_22372_r = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4 - 1);
+				}
+
+				if(!this.field_22355_ae && !this.field_22359_ac) {
+					this.field_22370_t = this.field_22371_s;
+				} else {
+					this.field_22370_t = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4 + 1);
+				}
+
+				++var3;
+				var9 = (this.field_22375_o + this.field_22376_n + this.field_22373_q + this.aoLightValueYNeg) / 4.0F;
+				var12 = (this.field_22373_q + this.aoLightValueYNeg + this.field_22370_t + this.field_22371_s) / 4.0F;
+				var11 = (this.aoLightValueYNeg + this.field_22374_p + this.field_22371_s + this.field_22372_r) / 4.0F;
+				var10 = (this.field_22376_n + this.field_22377_m + this.aoLightValueYNeg + this.field_22374_p) / 4.0F;
+			}
+
+			this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = (var13 ? var5 : 1.0F) * 0.5F;
+			this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = (var13 ? var6 : 1.0F) * 0.5F;
+			this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = (var13 ? var7 : 1.0F) * 0.5F;
+			this.colorRedTopLeft *= var9;
+			this.colorGreenTopLeft *= var9;
+			this.colorBlueTopLeft *= var9;
+			this.colorRedBottomLeft *= var10;
+			this.colorGreenBottomLeft *= var10;
+			this.colorBlueBottomLeft *= var10;
+			this.colorRedBottomRight *= var11;
+			this.colorGreenBottomRight *= var11;
+			this.colorBlueBottomRight *= var11;
+			this.colorRedTopRight *= var12;
+			this.colorGreenTopRight *= var12;
+			this.colorBlueTopRight *= var12;
+			this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
+			var8 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 + 1, var4, 1)) {
+			if(this.field_22352_G <= 0) {
+				var12 = this.aoLightValueYPos;
+				var11 = var12;
+				var10 = var12;
+				var9 = var12;
+			} else {
+				++var3;
+				this.field_22368_v = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4);
+				this.field_22364_z = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4);
+				this.field_22366_x = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1);
+				this.field_22362_A = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1);
+				if(!this.field_22339_T && !this.field_22337_V) {
+					this.field_22369_u = this.field_22368_v;
+				} else {
+					this.field_22369_u = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4 - 1);
+				}
+
+				if(!this.field_22339_T && !this.field_22338_U) {
+					this.field_22365_y = this.field_22364_z;
+				} else {
+					this.field_22365_y = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4 - 1);
+				}
+
+				if(!this.field_22336_W && !this.field_22337_V) {
+					this.field_22367_w = this.field_22368_v;
+				} else {
+					this.field_22367_w = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4 + 1);
+				}
+
+				if(!this.field_22336_W && !this.field_22338_U) {
+					this.field_22360_B = this.field_22364_z;
+				} else {
+					this.field_22360_B = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4 + 1);
+				}
+
+				--var3;
+				var12 = (this.field_22367_w + this.field_22368_v + this.field_22362_A + this.aoLightValueYPos) / 4.0F;
+				var9 = (this.field_22362_A + this.aoLightValueYPos + this.field_22360_B + this.field_22364_z) / 4.0F;
+				var10 = (this.aoLightValueYPos + this.field_22366_x + this.field_22364_z + this.field_22365_y) / 4.0F;
+				var11 = (this.field_22368_v + this.field_22369_u + this.aoLightValueYPos + this.field_22366_x) / 4.0F;
+			}
+
+			this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = var14 ? var5 : 1.0F;
+			this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = var14 ? var6 : 1.0F;
+			this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = var14 ? var7 : 1.0F;
+			this.colorRedTopLeft *= var9;
+			this.colorGreenTopLeft *= var9;
+			this.colorBlueTopLeft *= var9;
+			this.colorRedBottomLeft *= var10;
+			this.colorGreenBottomLeft *= var10;
+			this.colorBlueBottomLeft *= var10;
+			this.colorRedBottomRight *= var11;
+			this.colorGreenBottomRight *= var11;
+			this.colorBlueBottomRight *= var11;
+			this.colorRedTopRight *= var12;
+			this.colorGreenTopRight *= var12;
+			this.colorBlueTopRight *= var12;
+			this.renderTopFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
+			var8 = true;
+		}
+
+		int var19;
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 - 1, 2)) {
+			if(this.field_22352_G <= 0) {
+				var12 = this.aoLightValueZNeg;
+				var11 = var12;
+				var10 = var12;
+				var9 = var12;
+			} else {
+				--var4;
+				this.field_22358_C = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4);
+				this.field_22374_p = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
+				this.field_22366_x = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
+				this.field_22356_D = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4);
+				if(!this.field_22335_X && !this.field_22361_ab) {
+					this.field_22377_m = this.field_22358_C;
+				} else {
+					this.field_22377_m = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3 - 1, var4);
+				}
+
+				if(!this.field_22335_X && !this.field_22339_T) {
+					this.field_22369_u = this.field_22358_C;
+				} else {
+					this.field_22369_u = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3 + 1, var4);
+				}
+
+				if(!this.field_22363_aa && !this.field_22361_ab) {
+					this.field_22372_r = this.field_22356_D;
+				} else {
+					this.field_22372_r = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3 - 1, var4);
+				}
+
+				if(!this.field_22363_aa && !this.field_22339_T) {
+					this.field_22365_y = this.field_22356_D;
+				} else {
+					this.field_22365_y = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3 + 1, var4);
+				}
+
+				++var4;
+				var9 = (this.field_22358_C + this.field_22369_u + this.aoLightValueZNeg + this.field_22366_x) / 4.0F;
+				var10 = (this.aoLightValueZNeg + this.field_22366_x + this.field_22356_D + this.field_22365_y) / 4.0F;
+				var11 = (this.field_22374_p + this.aoLightValueZNeg + this.field_22372_r + this.field_22356_D) / 4.0F;
+				var12 = (this.field_22377_m + this.field_22358_C + this.field_22374_p + this.aoLightValueZNeg) / 4.0F;
+			}
+
+			this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = (var15 ? var5 : 1.0F) * 0.8F;
+			this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = (var15 ? var6 : 1.0F) * 0.8F;
+			this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = (var15 ? var7 : 1.0F) * 0.8F;
+			this.colorRedTopLeft *= var9;
+			this.colorGreenTopLeft *= var9;
+			this.colorBlueTopLeft *= var9;
+			this.colorRedBottomLeft *= var10;
+			this.colorGreenBottomLeft *= var10;
+			this.colorBlueBottomLeft *= var10;
+			this.colorRedBottomRight *= var11;
+			this.colorGreenBottomRight *= var11;
+			this.colorBlueBottomRight *= var11;
+			this.colorRedTopRight *= var12;
+			this.colorGreenTopRight *= var12;
+			this.colorBlueTopRight *= var12;
+			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 2);
+			this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, var19);
+
+			var8 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 + 1, 3)) {
+			if(this.field_22352_G <= 0) {
+				var12 = this.aoLightValueZPos;
+				var11 = var12;
+				var10 = var12;
+				var9 = var12;
+			} else {
+				++var4;
+				this.field_22354_E = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4);
+				this.field_22353_F = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4);
+				this.field_22373_q = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
+				this.field_22362_A = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
+				if(!this.field_22333_Z && !this.field_22355_ae) {
+					this.field_22375_o = this.field_22354_E;
+				} else {
+					this.field_22375_o = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3 - 1, var4);
+				}
+
+				if(!this.field_22333_Z && !this.field_22336_W) {
+					this.field_22367_w = this.field_22354_E;
+				} else {
+					this.field_22367_w = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3 + 1, var4);
+				}
+
+				if(!this.field_22334_Y && !this.field_22355_ae) {
+					this.field_22370_t = this.field_22353_F;
+				} else {
+					this.field_22370_t = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3 - 1, var4);
+				}
+
+				if(!this.field_22334_Y && !this.field_22336_W) {
+					this.field_22360_B = this.field_22353_F;
+				} else {
+					this.field_22360_B = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3 + 1, var4);
+				}
+
+				--var4;
+				var9 = (this.field_22354_E + this.field_22367_w + this.aoLightValueZPos + this.field_22362_A) / 4.0F;
+				var12 = (this.aoLightValueZPos + this.field_22362_A + this.field_22353_F + this.field_22360_B) / 4.0F;
+				var11 = (this.field_22373_q + this.aoLightValueZPos + this.field_22370_t + this.field_22353_F) / 4.0F;
+				var10 = (this.field_22375_o + this.field_22354_E + this.field_22373_q + this.aoLightValueZPos) / 4.0F;
+			}
+
+			this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = (var16 ? var5 : 1.0F) * 0.8F;
+			this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = (var16 ? var6 : 1.0F) * 0.8F;
+			this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = (var16 ? var7 : 1.0F) * 0.8F;
+			this.colorRedTopLeft *= var9;
+			this.colorGreenTopLeft *= var9;
+			this.colorBlueTopLeft *= var9;
+			this.colorRedBottomLeft *= var10;
+			this.colorGreenBottomLeft *= var10;
+			this.colorBlueBottomLeft *= var10;
+			this.colorRedBottomRight *= var11;
+			this.colorGreenBottomRight *= var11;
+			this.colorBlueBottomRight *= var11;
+			this.colorRedTopRight *= var12;
+			this.colorGreenTopRight *= var12;
+			this.colorBlueTopRight *= var12;
+			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3);
+			this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 3));
+
+			var8 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 - 1, var3, var4, 4)) {
+			if(this.field_22352_G <= 0) {
+				var12 = this.aoLightValueXNeg;
+				var11 = var12;
+				var10 = var12;
+				var9 = var12;
+			} else {
+				--var2;
+				this.field_22376_n = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
+				this.field_22358_C = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1);
+				this.field_22354_E = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1);
+				this.field_22368_v = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
+				if(!this.field_22335_X && !this.field_22357_ad) {
+					this.field_22377_m = this.field_22358_C;
+				} else {
+					this.field_22377_m = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4 - 1);
+				}
+
+				if(!this.field_22333_Z && !this.field_22357_ad) {
+					this.field_22375_o = this.field_22354_E;
+				} else {
+					this.field_22375_o = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4 + 1);
+				}
+
+				if(!this.field_22335_X && !this.field_22337_V) {
+					this.field_22369_u = this.field_22358_C;
+				} else {
+					this.field_22369_u = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4 - 1);
+				}
+
+				if(!this.field_22333_Z && !this.field_22337_V) {
+					this.field_22367_w = this.field_22354_E;
+				} else {
+					this.field_22367_w = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4 + 1);
+				}
+
+				++var2;
+				var12 = (this.field_22376_n + this.field_22375_o + this.aoLightValueXNeg + this.field_22354_E) / 4.0F;
+				var9 = (this.aoLightValueXNeg + this.field_22354_E + this.field_22368_v + this.field_22367_w) / 4.0F;
+				var10 = (this.field_22358_C + this.aoLightValueXNeg + this.field_22369_u + this.field_22368_v) / 4.0F;
+				var11 = (this.field_22377_m + this.field_22376_n + this.field_22358_C + this.aoLightValueXNeg) / 4.0F;
+			}
+
+			this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = (var17 ? var5 : 1.0F) * 0.6F;
+			this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = (var17 ? var6 : 1.0F) * 0.6F;
+			this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = (var17 ? var7 : 1.0F) * 0.6F;
+			this.colorRedTopLeft *= var9;
+			this.colorGreenTopLeft *= var9;
+			this.colorBlueTopLeft *= var9;
+			this.colorRedBottomLeft *= var10;
+			this.colorGreenBottomLeft *= var10;
+			this.colorBlueBottomLeft *= var10;
+			this.colorRedBottomRight *= var11;
+			this.colorGreenBottomRight *= var11;
+			this.colorBlueBottomRight *= var11;
+			this.colorRedTopRight *= var12;
+			this.colorGreenTopRight *= var12;
+			this.colorBlueTopRight *= var12;
+			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 4);
+			this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, var19);
+
+			var8 = true;
+		}
+
+		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 + 1, var3, var4, 5)) {
+			if(this.field_22352_G <= 0) {
+				var12 = this.aoLightValueXPos;
+				var11 = var12;
+				var10 = var12;
+				var9 = var12;
+			} else {
+				++var2;
+				this.field_22371_s = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
+				this.field_22356_D = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1);
+				this.field_22353_F = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1);
+				this.field_22364_z = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
+				if(!this.field_22359_ac && !this.field_22363_aa) {
+					this.field_22372_r = this.field_22356_D;
+				} else {
+					this.field_22372_r = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4 - 1);
+				}
+
+				if(!this.field_22359_ac && !this.field_22334_Y) {
+					this.field_22370_t = this.field_22353_F;
+				} else {
+					this.field_22370_t = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4 + 1);
+				}
+
+				if(!this.field_22338_U && !this.field_22363_aa) {
+					this.field_22365_y = this.field_22356_D;
+				} else {
+					this.field_22365_y = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4 - 1);
+				}
+
+				if(!this.field_22338_U && !this.field_22334_Y) {
+					this.field_22360_B = this.field_22353_F;
+				} else {
+					this.field_22360_B = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4 + 1);
+				}
+
+				--var2;
+				var9 = (this.field_22371_s + this.field_22370_t + this.aoLightValueXPos + this.field_22353_F) / 4.0F;
+				var12 = (this.aoLightValueXPos + this.field_22353_F + this.field_22364_z + this.field_22360_B) / 4.0F;
+				var11 = (this.field_22356_D + this.aoLightValueXPos + this.field_22365_y + this.field_22364_z) / 4.0F;
+				var10 = (this.field_22372_r + this.field_22371_s + this.field_22356_D + this.aoLightValueXPos) / 4.0F;
+			}
+
+			this.colorRedTopLeft = this.colorRedBottomLeft = this.colorRedBottomRight = this.colorRedTopRight = (var18 ? var5 : 1.0F) * 0.6F;
+			this.colorGreenTopLeft = this.colorGreenBottomLeft = this.colorGreenBottomRight = this.colorGreenTopRight = (var18 ? var6 : 1.0F) * 0.6F;
+			this.colorBlueTopLeft = this.colorBlueBottomLeft = this.colorBlueBottomRight = this.colorBlueTopRight = (var18 ? var7 : 1.0F) * 0.6F;
+			this.colorRedTopLeft *= var9;
+			this.colorGreenTopLeft *= var9;
+			this.colorBlueTopLeft *= var9;
+			this.colorRedBottomLeft *= var10;
+			this.colorGreenBottomLeft *= var10;
+			this.colorBlueBottomLeft *= var10;
+			this.colorRedBottomRight *= var11;
+			this.colorGreenBottomRight *= var11;
+			this.colorBlueBottomRight *= var11;
+			this.colorRedTopRight *= var12;
+			this.colorGreenTopRight *= var12;
+			this.colorBlueTopRight *= var12;
+			var19 = var1.getBlockTexture(this.blockAccess, var2, var3, var4, 5);
+			this.renderSouthFace(var1, (double)var2, (double)var3, (double)var4, var19);
+
+			var8 = true;
+		}
+
+		this.enableAO = false;
+		return var8;
 	}
 
 	public boolean renderStandardBlockWithColorMultiplier(Block var1, int var2, int var3, int var4, float var5, float var6, float var7) {
@@ -1097,17 +1613,17 @@
 		float var23 = var11 * var7;
 		float var24 = var12 * var7;
 		float var25 = var13 * var7;
-		float var26 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var26 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		float var27;
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 - 1, var4, 0)) {
-			var27 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
+			var27 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
 			var8.setColorOpaque_F(var14 * var27, var18 * var27, var22 * var27);
 			this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
 			var9 = true;
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 + 1, var4, 1)) {
-			var27 = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
+			var27 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
 			if(var1.maxY != 1.0D && !var1.material.getIsLiquid()) {
 				var27 = var26;
 			}
@@ -1118,7 +1634,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 - 1, 2)) {
-			var27 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 - 1);
+			var27 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1);
 			if(var1.minZ > 0.0D) {
 				var27 = var26;
 			}
@@ -1129,7 +1645,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 + 1, 3)) {
-			var27 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 + 1);
+			var27 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1);
 			if(var1.maxZ < 1.0D) {
 				var27 = var26;
 			}
@@ -1140,7 +1656,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 - 1, var3, var4, 4)) {
-			var27 = var1.getBlockBrightness(this.blockAccess, var2 - 1, var3, var4);
+			var27 = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4);
 			if(var1.minX > 0.0D) {
 				var27 = var26;
 			}
@@ -1151,7 +1667,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 + 1, var3, var4, 5)) {
-			var27 = var1.getBlockBrightness(this.blockAccess, var2 + 1, var3, var4);
+			var27 = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4);
 			if(var1.maxX < 1.0D) {
 				var27 = var26;
 			}
@@ -1192,17 +1708,17 @@
 		float var24 = var12 * var7;
 		float var25 = var13 * var7;
 		float var26 = 1.0F / 16.0F;
-		float var27 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
+		float var27 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
 		float var28;
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 - 1, var4, 0)) {
-			var28 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
+			var28 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
 			var8.setColorOpaque_F(var14 * var28, var18 * var28, var22 * var28);
 			this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
 			var9 = true;
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3 + 1, var4, 1)) {
-			var28 = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
+			var28 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
 			if(var1.maxY != 1.0D && !var1.material.getIsLiquid()) {
 				var28 = var27;
 			}
@@ -1213,7 +1729,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 - 1, 2)) {
-			var28 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 - 1);
+			var28 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1);
 			if(var1.minZ > 0.0D) {
 				var28 = var27;
 			}
@@ -1226,7 +1742,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2, var3, var4 + 1, 3)) {
-			var28 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 + 1);
+			var28 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1);
 			if(var1.maxZ < 1.0D) {
 				var28 = var27;
 			}
@@ -1239,7 +1755,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 - 1, var3, var4, 4)) {
-			var28 = var1.getBlockBrightness(this.blockAccess, var2 - 1, var3, var4);
+			var28 = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4);
 			if(var1.minX > 0.0D) {
 				var28 = var27;
 			}
@@ -1252,7 +1768,7 @@
 		}
 
 		if(this.renderAllFaces || var1.shouldSideBeRendered(this.blockAccess, var2 + 1, var3, var4, 5)) {
-			var28 = var1.getBlockBrightness(this.blockAccess, var2 + 1, var3, var4);
+			var28 = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4);
 			if(var1.maxX < 1.0D) {
 				var28 = var27;
 			}
@@ -1268,6 +1784,8 @@
 	}
 
 	public boolean renderBlockFence(Block var1, int var2, int var3, int var4) {
+		if (!(var1 instanceof BlockFence)) return false;
+		BlockFence fence = (BlockFence)var1;
 		boolean var5 = false;
 		float var6 = 6.0F / 16.0F;
 		float var7 = 10.0F / 16.0F;
@@ -1275,18 +1793,18 @@
 		this.renderStandardBlock(var1, var2, var3, var4);
 		boolean var8 = false;
 		boolean var9 = false;
-		if(this.blockAccess.getBlockId(var2 - 1, var3, var4) == var1.blockID || this.blockAccess.getBlockId(var2 + 1, var3, var4) == var1.blockID) {
+		if(fence.canAttachToBlock(this.blockAccess, var2 - 1, var3, var4) || fence.canAttachToBlock(this.blockAccess, var2 + 1, var3, var4)) {
 			var8 = true;
 		}
 
-		if(this.blockAccess.getBlockId(var2, var3, var4 - 1) == var1.blockID || this.blockAccess.getBlockId(var2, var3, var4 + 1) == var1.blockID) {
+		if(fence.canAttachToBlock(this.blockAccess, var2, var3, var4 - 1) || fence.canAttachToBlock(this.blockAccess, var2, var3, var4 + 1)) {
 			var9 = true;
 		}
 
-		boolean var10 = this.blockAccess.getBlockId(var2 - 1, var3, var4) == var1.blockID;
-		boolean var11 = this.blockAccess.getBlockId(var2 + 1, var3, var4) == var1.blockID;
-		boolean var12 = this.blockAccess.getBlockId(var2, var3, var4 - 1) == var1.blockID;
-		boolean var13 = this.blockAccess.getBlockId(var2, var3, var4 + 1) == var1.blockID;
+		boolean var10 = fence.canAttachToBlock(this.blockAccess, var2 - 1, var3, var4);
+		boolean var11 = fence.canAttachToBlock(this.blockAccess, var2 + 1, var3, var4);
+		boolean var12 = fence.canAttachToBlock(this.blockAccess, var2, var3, var4 - 1);
+		boolean var13 = fence.canAttachToBlock(this.blockAccess, var2, var3, var4 + 1);
 		if(!var8 && !var9) {
 			var8 = true;
 		}
@@ -1326,32 +1844,9 @@
 	}
 
 	public boolean renderBlockStairs(Block var1, int var2, int var3, int var4) {
-		boolean var5 = false;
-		int var6 = this.blockAccess.getBlockMetadata(var2, var3, var4);
-		if(var6 == 0) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 0.5F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-		} else if(var6 == 1) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 0.5F, 1.0F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.5F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-		} else if(var6 == 2) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 0.5F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 1.0F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-		} else if(var6 == 3) {
-			var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 0.5F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-			var1.setBlockBounds(0.0F, 0.0F, 0.5F, 1.0F, 0.5F, 1.0F);
-			this.renderStandardBlock(var1, var2, var3, var4);
-		}
-
+		((BlockStairs)var1).doShape(this.blockAccess, var2, var3, var4, () -> this.renderStandardBlock(var1, var2, var3, var4));
 		var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-		return var5;
+		return true;
 	}
 
 	public boolean renderBlockDoor(Block var1, int var2, int var3, int var4) {
@@ -1362,8 +1857,8 @@
 		float var9 = 1.0F;
 		float var10 = 0.8F;
 		float var11 = 0.6F;
-		float var12 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4);
-		float var13 = var1.getBlockBrightness(this.blockAccess, var2, var3 - 1, var4);
+		float var12 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4);
+		float var13 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 - 1, var4);
 		if(var6.minY > 0.0D) {
 			var13 = var12;
 		}
@@ -1375,7 +1870,7 @@
 		var5.setColorOpaque_F(var8 * var13, var8 * var13, var8 * var13);
 		this.renderBottomFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 0));
 		var7 = true;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2, var3 + 1, var4);
+		var13 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
 		if(var6.maxY < 1.0D) {
 			var13 = var12;
 		}
@@ -1387,7 +1882,7 @@
 		var5.setColorOpaque_F(var9 * var13, var9 * var13, var9 * var13);
 		this.renderTopFace(var1, (double)var2, (double)var3, (double)var4, var1.getBlockTexture(this.blockAccess, var2, var3, var4, 1));
 		var7 = true;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 - 1);
+		var13 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 - 1);
 		if(var6.minZ > 0.0D) {
 			var13 = var12;
 		}
@@ -1406,7 +1901,7 @@
 		this.renderEastFace(var1, (double)var2, (double)var3, (double)var4, var14);
 		var7 = true;
 		this.flipTexture = false;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2, var3, var4 + 1);
+		var13 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3, var4 + 1);
 		if(var6.maxZ < 1.0D) {
 			var13 = var12;
 		}
@@ -1425,7 +1920,7 @@
 		this.renderWestFace(var1, (double)var2, (double)var3, (double)var4, var14);
 		var7 = true;
 		this.flipTexture = false;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2 - 1, var3, var4);
+		var13 = var1.getBlockRenderBrightness(this.blockAccess, var2 - 1, var3, var4);
 		if(var6.minX > 0.0D) {
 			var13 = var12;
 		}
@@ -1444,7 +1939,7 @@
 		this.renderNorthFace(var1, (double)var2, (double)var3, (double)var4, var14);
 		var7 = true;
 		this.flipTexture = false;
-		var13 = var1.getBlockBrightness(this.blockAccess, var2 + 1, var3, var4);
+		var13 = var1.getBlockRenderBrightness(this.blockAccess, var2 + 1, var3, var4);
 		if(var6.maxX < 1.0D) {
 			var13 = var12;
 		}
@@ -1472,31 +1967,80 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minZ * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
+		int var10 = var8 % 32 * 16;
+		int var11 = var8 / 32 * 16;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
+		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
-		}
-
-		double var20 = var2 + var1.minX;
-		double var22 = var2 + var1.maxX;
-		double var24 = var4 + var1.minY;
-		double var26 = var6 + var1.minZ;
-		double var28 = var6 + var1.maxZ;
-		var9.addVertexWithUV(var20, var24, var28, var12, var18);
-		var9.addVertexWithUV(var20, var24, var26, var12, var16);
-		var9.addVertexWithUV(var22, var24, var26, var14, var16);
-		var9.addVertexWithUV(var22, var24, var28, var14, var18);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
+		}
+
+		double var20 = var14;
+		double var22 = var12;
+		double var24 = var16;
+		double var26 = var18;
+		if(this.field_31082_l == 2) {
+			var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
+			var24 = var16;
+			var26 = var18;
+			var20 = var12;
+			var22 = var14;
+			var16 = var18;
+			var18 = var24;
+		} else if(this.field_31082_l == 1) {
+			var12 = ((double)(var10 + 16) - var1.maxZ * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var12 = var14;
+			var14 = var22;
+			var24 = var18;
+			var26 = var16;
+		} else if(this.field_31082_l == 3) {
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var24 = var16;
+			var26 = var18;
+		}
+
+		double var28 = var2 + var1.minX;
+		double var30 = var2 + var1.maxX;
+		double var32 = var4 + var1.minY;
+		double var34 = var6 + var1.minZ;
+		double var36 = var6 + var1.maxZ;
+		if(this.enableAO) {
+			var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+			var9.addVertexWithUV(var28, var32, var36, var22, var26);
+			var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+			var9.addVertexWithUV(var28, var32, var34, var12, var16);
+			var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+			var9.addVertexWithUV(var30, var32, var34, var20, var24);
+			var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+			var9.addVertexWithUV(var30, var32, var36, var14, var18);
+		} else {
+			var9.addVertexWithUV(var28, var32, var36, var22, var26);
+			var9.addVertexWithUV(var28, var32, var34, var12, var16);
+			var9.addVertexWithUV(var30, var32, var34, var20, var24);
+			var9.addVertexWithUV(var30, var32, var36, var14, var18);
+		}
+
 	}
 
 	public void renderTopFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -1505,31 +2049,80 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minZ * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
+		int var10 = var8 % 32 * 16;
+		int var11 = var8 / 32 * 16;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
+		double var18 = ((double)var11 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
-		}
-
-		double var20 = var2 + var1.minX;
-		double var22 = var2 + var1.maxX;
-		double var24 = var4 + var1.maxY;
-		double var26 = var6 + var1.minZ;
-		double var28 = var6 + var1.maxZ;
-		var9.addVertexWithUV(var22, var24, var28, var14, var18);
-		var9.addVertexWithUV(var22, var24, var26, var14, var16);
-		var9.addVertexWithUV(var20, var24, var26, var12, var16);
-		var9.addVertexWithUV(var20, var24, var28, var12, var18);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
+		}
+
+		double var20 = var14;
+		double var22 = var12;
+		double var24 = var16;
+		double var26 = var18;
+		if(this.field_31083_k == 1) {
+			var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
+			var24 = var16;
+			var26 = var18;
+			var20 = var12;
+			var22 = var14;
+			var16 = var18;
+			var18 = var24;
+		} else if(this.field_31083_k == 2) {
+			var12 = ((double)(var10 + 16) - var1.maxZ * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var12 = var14;
+			var14 = var22;
+			var24 = var18;
+			var26 = var16;
+		} else if(this.field_31083_k == 3) {
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var24 = var16;
+			var26 = var18;
+		}
+
+		double var28 = var2 + var1.minX;
+		double var30 = var2 + var1.maxX;
+		double var32 = var4 + var1.maxY;
+		double var34 = var6 + var1.minZ;
+		double var36 = var6 + var1.maxZ;
+		if(this.enableAO) {
+			var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+			var9.addVertexWithUV(var30, var32, var36, var14, var18);
+			var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+			var9.addVertexWithUV(var30, var32, var34, var20, var24);
+			var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+			var9.addVertexWithUV(var28, var32, var34, var12, var16);
+			var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+			var9.addVertexWithUV(var28, var32, var36, var22, var26);
+		} else {
+			var9.addVertexWithUV(var30, var32, var36, var14, var18);
+			var9.addVertexWithUV(var30, var32, var34, var20, var24);
+			var9.addVertexWithUV(var28, var32, var34, var12, var16);
+			var9.addVertexWithUV(var28, var32, var36, var22, var26);
+		}
+
 	}
 
 	public void renderEastFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -1538,12 +2131,12 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minY * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxY * 16.0D - 0.01D) / 256.0D;
+		int var10 = var8 % 32 * 16;
+		int var11 = var8 / 32 * 16;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -1552,24 +2145,73 @@
 		}
 
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
-		}
-
-		var20 = var2 + var1.minX;
-		double var22 = var2 + var1.maxX;
-		double var24 = var4 + var1.minY;
-		double var26 = var4 + var1.maxY;
-		double var28 = var6 + var1.minZ;
-		var9.addVertexWithUV(var20, var26, var28, var14, var16);
-		var9.addVertexWithUV(var22, var26, var28, var12, var16);
-		var9.addVertexWithUV(var22, var24, var28, var12, var18);
-		var9.addVertexWithUV(var20, var24, var28, var14, var18);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
+		}
+
+		var20 = var14;
+		double var22 = var12;
+		double var24 = var16;
+		double var26 = var18;
+		if(this.field_31087_g == 2) {
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
+			var24 = var16;
+			var26 = var18;
+			var20 = var12;
+			var22 = var14;
+			var16 = var18;
+			var18 = var24;
+		} else if(this.field_31087_g == 1) {
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var12 = var14;
+			var14 = var22;
+			var24 = var18;
+			var26 = var16;
+		} else if(this.field_31087_g == 3) {
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var24 = var16;
+			var26 = var18;
+		}
+
+		double var28 = var2 + var1.minX;
+		double var30 = var2 + var1.maxX;
+		double var32 = var4 + var1.minY;
+		double var34 = var4 + var1.maxY;
+		double var36 = var6 + var1.minZ;
+		if(this.enableAO) {
+			var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+			var9.addVertexWithUV(var28, var34, var36, var20, var24);
+			var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+			var9.addVertexWithUV(var30, var34, var36, var12, var16);
+			var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+			var9.addVertexWithUV(var30, var32, var36, var22, var26);
+			var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+			var9.addVertexWithUV(var28, var32, var36, var14, var18);
+		} else {
+			var9.addVertexWithUV(var28, var34, var36, var20, var24);
+			var9.addVertexWithUV(var30, var34, var36, var12, var16);
+			var9.addVertexWithUV(var30, var32, var36, var22, var26);
+			var9.addVertexWithUV(var28, var32, var36, var14, var18);
+		}
+
 	}
 
 	public void renderWestFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -1578,12 +2220,12 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minX * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minY * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxY * 16.0D - 0.01D) / 256.0D;
+		int var10 = var8 % 32 * 16;
+		int var11 = var8 / 32 * 16;
+		double var12 = ((double)var10 + var1.minX * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxX * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -1592,24 +2234,73 @@
 		}
 
 		if(var1.minX < 0.0D || var1.maxX > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
-		}
-
-		var20 = var2 + var1.minX;
-		double var22 = var2 + var1.maxX;
-		double var24 = var4 + var1.minY;
-		double var26 = var4 + var1.maxY;
-		double var28 = var6 + var1.maxZ;
-		var9.addVertexWithUV(var20, var26, var28, var12, var16);
-		var9.addVertexWithUV(var20, var24, var28, var12, var18);
-		var9.addVertexWithUV(var22, var24, var28, var14, var18);
-		var9.addVertexWithUV(var22, var26, var28, var14, var16);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
+		}
+
+		var20 = var14;
+		double var22 = var12;
+		double var24 = var16;
+		double var26 = var18;
+		if(this.field_31086_h == 1) {
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxX * 16.0D) / 512.0D;
+			var24 = var16;
+			var26 = var18;
+			var20 = var12;
+			var22 = var14;
+			var16 = var18;
+			var18 = var24;
+		} else if(this.field_31086_h == 2) {
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxX * 16.0D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var12 = var14;
+			var14 = var22;
+			var24 = var18;
+			var26 = var16;
+		} else if(this.field_31086_h == 3) {
+			var12 = ((double)(var10 + 16) - var1.minX * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxX * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var24 = var16;
+			var26 = var18;
+		}
+
+		double var28 = var2 + var1.minX;
+		double var30 = var2 + var1.maxX;
+		double var32 = var4 + var1.minY;
+		double var34 = var4 + var1.maxY;
+		double var36 = var6 + var1.maxZ;
+		if(this.enableAO) {
+			var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+			var9.addVertexWithUV(var28, var34, var36, var12, var16);
+			var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+			var9.addVertexWithUV(var28, var32, var36, var22, var26);
+			var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+			var9.addVertexWithUV(var30, var32, var36, var14, var18);
+			var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+			var9.addVertexWithUV(var30, var34, var36, var20, var24);
+		} else {
+			var9.addVertexWithUV(var28, var34, var36, var12, var16);
+			var9.addVertexWithUV(var28, var32, var36, var22, var26);
+			var9.addVertexWithUV(var30, var32, var36, var14, var18);
+			var9.addVertexWithUV(var30, var34, var36, var20, var24);
+		}
+
 	}
 
 	public void renderNorthFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -1618,12 +2309,12 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minZ * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minY * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxY * 16.0D - 0.01D) / 256.0D;
+		int var10 = var8 % 32 * 16;
+		int var11 = var8 / 32 * 16;
+		double var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -1632,24 +2323,73 @@
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
-		}
-
-		var20 = var2 + var1.minX;
-		double var22 = var4 + var1.minY;
-		double var24 = var4 + var1.maxY;
-		double var26 = var6 + var1.minZ;
-		double var28 = var6 + var1.maxZ;
-		var9.addVertexWithUV(var20, var24, var28, var14, var16);
-		var9.addVertexWithUV(var20, var24, var26, var12, var16);
-		var9.addVertexWithUV(var20, var22, var26, var12, var18);
-		var9.addVertexWithUV(var20, var22, var28, var14, var18);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
+		}
+
+		var20 = var14;
+		double var22 = var12;
+		double var24 = var16;
+		double var26 = var18;
+		if(this.field_31084_j == 1) {
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.maxZ * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var24 = var16;
+			var26 = var18;
+			var20 = var12;
+			var22 = var14;
+			var16 = var18;
+			var18 = var24;
+		} else if(this.field_31084_j == 2) {
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.maxZ * 16.0D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var12 = var14;
+			var14 = var22;
+			var24 = var18;
+			var26 = var16;
+		} else if(this.field_31084_j == 3) {
+			var12 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var24 = var16;
+			var26 = var18;
+		}
+
+		double var28 = var2 + var1.minX;
+		double var30 = var4 + var1.minY;
+		double var32 = var4 + var1.maxY;
+		double var34 = var6 + var1.minZ;
+		double var36 = var6 + var1.maxZ;
+		if(this.enableAO) {
+			var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+			var9.addVertexWithUV(var28, var32, var36, var20, var24);
+			var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+			var9.addVertexWithUV(var28, var32, var34, var12, var16);
+			var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+			var9.addVertexWithUV(var28, var30, var34, var22, var26);
+			var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+			var9.addVertexWithUV(var28, var30, var36, var14, var18);
+		} else {
+			var9.addVertexWithUV(var28, var32, var36, var20, var24);
+			var9.addVertexWithUV(var28, var32, var34, var12, var16);
+			var9.addVertexWithUV(var28, var30, var34, var22, var26);
+			var9.addVertexWithUV(var28, var30, var36, var14, var18);
+		}
+
 	}
 
 	public void renderSouthFace(Block var1, double var2, double var4, double var6, int var8) {
@@ -1658,12 +2398,12 @@
 			var8 = this.overrideBlockTexture;
 		}
 
-		int var10 = (var8 & 15) << 4;
-		int var11 = var8 & 240;
-		double var12 = ((double)var10 + var1.minZ * 16.0D) / 256.0D;
-		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 256.0D;
-		double var16 = ((double)var11 + var1.minY * 16.0D) / 256.0D;
-		double var18 = ((double)var11 + var1.maxY * 16.0D - 0.01D) / 256.0D;
+		int var10 = var8 % 32 * 16;
+		int var11 = var8 / 32 * 16;
+		double var12 = ((double)var10 + var1.minZ * 16.0D) / 512.0D;
+		double var14 = ((double)var10 + var1.maxZ * 16.0D - 0.01D) / 512.0D;
+		double var16 = ((double)(var11 + 16) - var1.maxY * 16.0D) / 512.0D;
+		double var18 = ((double)(var11 + 16) - var1.minY * 16.0D - 0.01D) / 512.0D;
 		double var20;
 		if(this.flipTexture) {
 			var20 = var12;
@@ -1672,27 +2412,76 @@
 		}
 
 		if(var1.minZ < 0.0D || var1.maxZ > 1.0D) {
-			var12 = (double)(((float)var10 + 0.0F) / 256.0F);
-			var14 = (double)(((float)var10 + 15.99F) / 256.0F);
+			var12 = (double)(((float)var10 + 0.0F) / 512.0F);
+			var14 = (double)(((float)var10 + 15.99F) / 512.0F);
 		}
 
 		if(var1.minY < 0.0D || var1.maxY > 1.0D) {
-			var16 = (double)(((float)var11 + 0.0F) / 256.0F);
-			var18 = (double)(((float)var11 + 15.99F) / 256.0F);
-		}
-
-		var20 = var2 + var1.maxX;
-		double var22 = var4 + var1.minY;
-		double var24 = var4 + var1.maxY;
-		double var26 = var6 + var1.minZ;
-		double var28 = var6 + var1.maxZ;
-		var9.addVertexWithUV(var20, var22, var28, var12, var18);
-		var9.addVertexWithUV(var20, var22, var26, var14, var18);
-		var9.addVertexWithUV(var20, var24, var26, var14, var16);
-		var9.addVertexWithUV(var20, var24, var28, var12, var16);
+			var16 = (double)(((float)var11 + 0.0F) / 512.0F);
+			var18 = (double)(((float)var11 + 15.99F) / 512.0F);
+		}
+
+		var20 = var14;
+		double var22 = var12;
+		double var24 = var16;
+		double var26 = var18;
+		if(this.field_31085_i == 2) {
+			var12 = ((double)var10 + var1.minY * 16.0D) / 512.0D;
+			var16 = ((double)(var11 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)var10 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)(var11 + 16) - var1.maxZ * 16.0D) / 512.0D;
+			var24 = var16;
+			var26 = var18;
+			var20 = var12;
+			var22 = var14;
+			var16 = var18;
+			var18 = var24;
+		} else if(this.field_31085_i == 1) {
+			var12 = ((double)(var10 + 16) - var1.maxY * 16.0D) / 512.0D;
+			var16 = ((double)var11 + var1.maxZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.minY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minZ * 16.0D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var12 = var14;
+			var14 = var22;
+			var24 = var18;
+			var26 = var16;
+		} else if(this.field_31085_i == 3) {
+			var12 = ((double)(var10 + 16) - var1.minZ * 16.0D) / 512.0D;
+			var14 = ((double)(var10 + 16) - var1.maxZ * 16.0D - 0.01D) / 512.0D;
+			var16 = ((double)var11 + var1.maxY * 16.0D) / 512.0D;
+			var18 = ((double)var11 + var1.minY * 16.0D - 0.01D) / 512.0D;
+			var20 = var14;
+			var22 = var12;
+			var24 = var16;
+			var26 = var18;
+		}
+
+		double var28 = var2 + var1.maxX;
+		double var30 = var4 + var1.minY;
+		double var32 = var4 + var1.maxY;
+		double var34 = var6 + var1.minZ;
+		double var36 = var6 + var1.maxZ;
+		if(this.enableAO) {
+			var9.setColorOpaque_F(this.colorRedTopLeft, this.colorGreenTopLeft, this.colorBlueTopLeft);
+			var9.addVertexWithUV(var28, var30, var36, var22, var26);
+			var9.setColorOpaque_F(this.colorRedBottomLeft, this.colorGreenBottomLeft, this.colorBlueBottomLeft);
+			var9.addVertexWithUV(var28, var30, var34, var14, var18);
+			var9.setColorOpaque_F(this.colorRedBottomRight, this.colorGreenBottomRight, this.colorBlueBottomRight);
+			var9.addVertexWithUV(var28, var32, var34, var20, var24);
+			var9.setColorOpaque_F(this.colorRedTopRight, this.colorGreenTopRight, this.colorBlueTopRight);
+			var9.addVertexWithUV(var28, var32, var36, var12, var16);
+		} else {
+			var9.addVertexWithUV(var28, var30, var36, var22, var26);
+			var9.addVertexWithUV(var28, var30, var34, var14, var18);
+			var9.addVertexWithUV(var28, var32, var34, var20, var24);
+			var9.addVertexWithUV(var28, var32, var36, var12, var16);
+		}
+
 	}
 
-	public void renderBlockAsItem(Block var1, float var2) {
+	public void renderBlockAsItem(Block var1, int metadata, float var2) {
 		int var3 = var1.getRenderType();
 		Tessellator var4 = Tessellator.instance;
 		if(var3 == 0) {
@@ -1704,51 +2493,51 @@
 			float var8 = 0.6F;
 			var4.startDrawingQuads();
 			var4.setColorRGBA_F(var6, var6, var6, var2);
-			this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+			this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, metadata));
 			var4.setColorRGBA_F(var5, var5, var5, var2);
-			this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+			this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, metadata));
 			var4.setColorRGBA_F(var7, var7, var7, var2);
-			this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
-			this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+			this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, metadata));
+			this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, metadata));
 			var4.setColorRGBA_F(var8, var8, var8, var2);
-			this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
-			this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+			this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, metadata));
+			this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, metadata));
 			var4.draw();
 			GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 		}
 
 	}
 
-	public void renderBlockOnInventory(Block var1) {
+	public void renderBlockOnInventory(Block var1, int metadata) {
 		byte var2 = -1;
 		Tessellator var3 = Tessellator.instance;
 		int var4 = var1.getRenderType();
-		if(var4 == 0) {
+		if(var4 == 0 || var4 == 14) {
 			var1.setBlockBoundsForItemRender();
 			GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, -1.0F, 0.0F);
-			this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+			this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, metadata));
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, 1.0F, 0.0F);
-			this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+			this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, metadata));
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, 0.0F, -1.0F);
-			this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
+			this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, metadata));
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, 0.0F, 1.0F);
-			this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+			this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, metadata));
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(-1.0F, 0.0F, 0.0F);
-			this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
+			this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, metadata));
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(1.0F, 0.0F, 0.0F);
-			this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+			this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, metadata));
 			var3.draw();
 			GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 		} else if(var4 == 1) {
@@ -1762,34 +2551,34 @@
 			float var5 = 1.0F / 16.0F;
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, -1.0F, 0.0F);
-			this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+			this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, metadata));
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, 1.0F, 0.0F);
-			this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+			this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, metadata));
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, 0.0F, -1.0F);
 			var3.setTranslationF(0.0F, 0.0F, var5);
-			this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
+			this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, metadata));
 			var3.setTranslationF(0.0F, 0.0F, -var5);
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(0.0F, 0.0F, 1.0F);
 			var3.setTranslationF(0.0F, 0.0F, -var5);
-			this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+			this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, metadata));
 			var3.setTranslationF(0.0F, 0.0F, var5);
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(-1.0F, 0.0F, 0.0F);
 			var3.setTranslationF(var5, 0.0F, 0.0F);
-			this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
+			this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, metadata));
 			var3.setTranslationF(-var5, 0.0F, 0.0F);
 			var3.draw();
 			var3.startDrawingQuads();
 			var3.setNormal(1.0F, 0.0F, 0.0F);
 			var3.setTranslationF(-var5, 0.0F, 0.0F);
-			this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+			this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, metadata));
 			var3.setTranslationF(var5, 0.0F, 0.0F);
 			var3.draw();
 			GL11.glTranslatef(0.5F, 0.5F, 0.5F);
@@ -1818,33 +2607,34 @@
 					GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, -1.0F, 0.0F);
-					this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+					this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, 1.0F, 0.0F);
-					this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+					this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, 0.0F, -1.0F);
-					this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
+					this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, 0.0F, 1.0F);
-					this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+					this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(-1.0F, 0.0F, 0.0F);
-					this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
+					this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(1.0F, 0.0F, 0.0F);
-					this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+					this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, metadata));
 					var3.draw();
 					GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 				}
+				var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
 			} else if(var4 == 11) {
 				for(var7 = 0; var7 < 4; ++var7) {
-					float var6 = 2.0F / 16.0F;
+					float var6 = 0.125F;
 					if(var7 == 0) {
 						var1.setBlockBounds(0.5F - var6, 0.0F, 0.0F, 0.5F + var6, 1.0F, var6 * 2.0F);
 					}
@@ -1865,38 +2655,64 @@
 					GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, -1.0F, 0.0F);
-					this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(0));
+					this.renderBottomFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(0, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, 1.0F, 0.0F);
-					this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(1));
+					this.renderTopFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(1, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, 0.0F, -1.0F);
-					this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(2));
+					this.renderEastFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(2, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(0.0F, 0.0F, 1.0F);
-					this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(3));
+					this.renderWestFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(3, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(-1.0F, 0.0F, 0.0F);
-					this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(4));
+					this.renderNorthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(4, metadata));
 					var3.draw();
 					var3.startDrawingQuads();
 					var3.setNormal(1.0F, 0.0F, 0.0F);
-					this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSide(5));
+					this.renderSouthFace(var1, 0.0D, 0.0D, 0.0D, var1.getBlockTextureFromSideAndMetadata(5, metadata));
 					var3.draw();
 					GL11.glTranslatef(0.5F, 0.5F, 0.5F);
 				}
 
 				var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
-			}
-		}
-
+			} else {
+				ModLoader.callHook(BaseMod::renderItemOnInventory, var3, var1, metadata, var4);
+			}
+		}
+
+	}
+
+	public boolean renderBlockGrass(Block var1, int var2, int var3, int var4) {
+		this.renderStandardBlock(var1, var2, var3, var4);
+		if (Minecraft.getInstance().options.fancyGraphics > 1) {
+			Block blockAbove = this.blockAccess.getBlock(var2, var3 + 1, var4);
+
+			if (blockAbove == null
+					|| (!blockAbove.renderAsNormalBlock() && blockAbove.getRenderType() > 1)) {
+				Tessellator var5 = Tessellator.instance;
+				float var6 = var1.getBlockRenderBrightness(this.blockAccess, var2, var3 + 1, var4);
+				var5.setColorOpaque_F(var6, var6, var6);
+				this.renderCrossedSquares(var1, -1 - this.blockAccess.getBlockMetadata(var2, var3, var4),
+						var2 + SimplexNoise.noise3_ImproveXZ(10000, var2, var3, var4) * 0.1D,
+						var3 + 0.25D + SimplexNoise.noise3_ImproveXZ(20000, var2, var3, var4) * 0.4D,
+						var4 + SimplexNoise.noise3_ImproveXZ(30000, var2, var3, var4) * 0.1D);
+			}
+		}
+		return true;
 	}
 
 	public static boolean renderItemIn3d(int var0) {
-		return var0 == 0 ? true : (var0 == 13 ? true : (var0 == 10 ? true : var0 == 11));
+		return var0 == 0
+				|| var0 == 10
+				|| var0 == 11
+				|| var0 == 13
+				|| var0 == 14
+				|| ModLoader.callHook(BaseMod::renderItemIn3d, var0);
 	}
 }
--- net/minecraft/src/BlockFlowing.java
+++ net/minecraft/src/BlockFlowing.java
@@ -7,7 +7,7 @@
 	boolean[] isOptimalFlowDirection = new boolean[4];
 	int[] flowCost = new int[4];
 
-	protected BlockFlowing(int var1, Material var2) {
+	public BlockFlowing(int var1, Material var2) {
 		super(var1, var2);
 	}
 
--- /dev/null
+++ net/minecraft/src/ItemStep.java
@@ -1,0 +1,73 @@
+package net.minecraft.src;
+
+public class ItemStep extends ItemBlock {
+	private final BlockStep stairSingle;
+	private final BlockStep stairDouble;
+
+	public ItemStep(BlockStep stairSingle, BlockStep stairDouble) {
+		super(stairSingle.blockID - 10000);
+		this.stairSingle = stairSingle;
+		this.stairDouble = stairDouble;
+	}
+
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
+		if(var1.stackSize == 0) {
+			return false;
+		}
+
+		int var8 = var3.getBlockId(var4, var5, var6);
+		int var9 = var3.getBlockMetadata(var4, var5, var6);
+		int var10 = this.stairSingle.fieldType.get(var9);
+		boolean var11 = this.stairSingle.fieldHalf.get(var9);
+		if((var7 == 1 && !var11 || var7 == 0 && var11) && var8 == this.shiftedIndex && var10 == var1.itemMetadata) {
+			if(var3.checkIfAABBIsClear(this.stairDouble.getCollisionBoundingBoxFromPool(var3, var4, var5, var6)) && var3.setBlockAndMetadataWithNotify(var4, var5, var6, this.stairDouble.blockID, var10)) {
+				var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), this.stairDouble.stepSound.getStepSound(), (this.stairDouble.stepSound.getVolume() + 1.0F) / 2.0F, this.stairDouble.stepSound.getPitch() * 0.8F);
+				--var1.stackSize;
+			}
+
+			return true;
+		} else {
+			return this.func_50087_b(var1, var2, var3, var4, var5, var6, var7, hitx, hity, hitz) || super.onItemUse(var1, var2, var3, var4, var5, var6, var7, hitx, hity, hitz);
+		}
+	}
+
+	private boolean func_50087_b(ItemStack var0, EntityPlayer var1, World var2, int var3, int var4, int var5, int var6, float hitx, float hity, float hitz) {
+		if(var6 == 0) {
+			--var4;
+		}
+
+		if(var6 == 1) {
+			++var4;
+		}
+
+		if(var6 == 2) {
+			--var5;
+		}
+
+		if(var6 == 3) {
+			++var5;
+		}
+
+		if(var6 == 4) {
+			--var3;
+		}
+
+		if(var6 == 5) {
+			++var3;
+		}
+
+		int var7 = var2.getBlockId(var3, var4, var5);
+		int var8 = var2.getBlockMetadata(var3, var4, var5);
+		int var9 = this.stairSingle.fieldType.get(var8);
+		if(var7 == this.stairSingle.blockID && var9 == var0.itemMetadata) {
+			if(var2.checkIfAABBIsClear(this.stairDouble.getCollisionBoundingBoxFromPool(var2, var3, var4, var5)) && var2.setBlockAndMetadataWithNotify(var3, var4, var5, this.stairDouble.blockID, var9)) {
+				var2.playSoundEffect((double)((float)var3 + 0.5F), (double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), this.stairDouble.stepSound.getStepSound(), (this.stairDouble.stepSound.getVolume() + 1.0F) / 2.0F, this.stairDouble.stepSound.getPitch() * 0.8F);
+				--var0.stackSize;
+			}
+
+			return true;
+		} else {
+			return false;
+		}
+	}
+}
--- net/minecraft/src/World.java
+++ net/minecraft/src/World.java
@@ -1,20 +1,32 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_BIT_OFFSET;
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
+import java.awt.*;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Iterator;
+import java.util.*;
 import java.util.List;
-import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 
 public class World implements IBlockAccess {
+	public static final String[] VERSION_NAMES = {
+			"Unknown",
+			"0.3-a4.2",
+			"0.3-b1",
+			"0.3-rc1",
+			"0.3-rc2",
+			"0.3",
+			"0.3.1",
+			"0.3.1.1"
+	};
+	public static final int CURRENT_VERSION = VERSION_NAMES.length - 1;
+
+	public final boolean blueFoxDay;
 	private List lightingToUpdate;
 	public List loadedEntityList;
 	private List unloadedEntityList;
@@ -22,7 +34,7 @@
 	private Set scheduledTickSet;
 	public List loadedTileEntityList;
 	public long worldTime;
-	public boolean snowCovered;
+	public WorldType worldType;
 	private long skyColor;
 	private long fogColor;
 	private long cloudColor;
@@ -32,7 +44,7 @@
 	public boolean editingBlocks;
 	public static float[] lightBrightnessTable = new float[16];
 	private final long lockTimestamp;
-	protected int autosavePeriod;
+	public int autosavePeriod;
 	public List playerEntities;
 	public int difficultySetting;
 	public Object fontRenderer;
@@ -42,18 +54,35 @@
 	public int spawnZ;
 	public boolean isNewWorld;
 	protected List worldAccesses;
-	private IChunkProvider chunkProvider;
+	protected IChunkProvider chunkProvider;
+	public final Chunk blankChunk;
 	public File saveDirectory;
 	public long randomSeed;
 	private NBTTagCompound nbtCompoundPlayer;
 	public long sizeOnDisk;
 	public final String levelName;
+	public int saveVersion;
 	public boolean worldChunkLoadOverride;
 	private ArrayList collidingBoundingBoxes;
 	private Set positionsToUpdate;
-	private int soundCounter;
+	public int soundCounter;
 	private List entitiesWithinAABBExcludingEntity;
 	public boolean multiplayerWorld;
+	public String displayName;
+	public boolean creative;
+	public boolean mantleDisrupted;
+	public int starfallChance;
+	public GameAchievements achievements = null;
+	public int simulationDistance;
+	private int lightingUpdatesCounter = 0;
+	public static int lightingUpdatesScheduled = 0;
+	public boolean fastLighting = false;
+	public boolean lazyLoading = true;
+	int[] lightUpdateBlockList;
+	protected SpawnerAnimals monsterSpawner = new SpawnerMobs(70, IMobs.class);
+	protected SpawnerAnimals monsterLvl2Spawner = new SpawnerMobs(100, IMobs.class);
+	protected SpawnerAnimals animalSpawner = new SpawnerAnimals(15, IAnimal.class);
+	protected SpawnerAnimals underworldSpawner = new SpawnerUnderworld(150, IMobs.class);
 
 	public static NBTTagCompound getLevelData(File var0, String var1) {
 		File var2 = new File(var0, "saves");
@@ -97,10 +126,11 @@
 	}
 
 	public World(File var1, String var2) {
-		this(var1, var2, (new Random()).nextLong());
+		this(var1, var2, (new Random()).nextLong(), null);
 	}
 
 	public World(String var1) {
+		this.lightUpdateBlockList = new int[-Short.MIN_VALUE];
 		this.lightingToUpdate = new ArrayList();
 		this.loadedEntityList = new ArrayList();
 		this.unloadedEntityList = new ArrayList();
@@ -108,7 +138,7 @@
 		this.scheduledTickSet = new HashSet();
 		this.loadedTileEntityList = new ArrayList();
 		this.worldTime = 0L;
-		this.snowCovered = false;
+		this.worldType = WorldType.NORMAL;
 		this.skyColor = 8961023L;
 		this.fogColor = 12638463L;
 		this.cloudColor = 16777215L;
@@ -117,24 +147,36 @@
 		this.DIST_HASH_MAGIC = 1013904223;
 		this.editingBlocks = false;
 		this.lockTimestamp = System.currentTimeMillis();
-		this.autosavePeriod = 40;
+		this.autosavePeriod = 1200;
 		this.playerEntities = new ArrayList();
 		this.rand = new Random();
 		this.isNewWorld = false;
 		this.worldAccesses = new ArrayList();
 		this.randomSeed = 0L;
+		this.saveVersion = 19132;
 		this.sizeOnDisk = 0L;
 		this.collidingBoundingBoxes = new ArrayList();
 		this.positionsToUpdate = new HashSet();
 		this.soundCounter = this.rand.nextInt(12000);
 		this.entitiesWithinAABBExcludingEntity = new ArrayList();
 		this.multiplayerWorld = false;
+		this.simulationDistance = 8;
 		this.levelName = var1;
+		this.displayName = var1;
 		this.chunkProvider = this.getChunkProvider(this.saveDirectory);
 		this.calculateInitialSkylight();
+
+		Calendar calendar1 = Calendar.getInstance();
+		calendar1.setTime(new Date());
+		this.blueFoxDay = calendar1.get(Calendar.MONTH) == Calendar.NOVEMBER && calendar1.get(Calendar.DATE) == 8;
+
+		this.blankChunk = new EmptyChunk(this, new short[65536], 0, 0);
+		this.blankChunk.isChunkRendered = true;
+		this.blankChunk.neverSave = true;
 	}
 
-	public World(File var1, String var2, long var3) {
+	public World(File var1, String var2, long var3, CreateWorldInfo info) {
+		this.lightUpdateBlockList = new int[-Short.MIN_VALUE];
 		this.lightingToUpdate = new ArrayList();
 		this.loadedEntityList = new ArrayList();
 		this.unloadedEntityList = new ArrayList();
@@ -142,7 +184,7 @@
 		this.scheduledTickSet = new HashSet();
 		this.loadedTileEntityList = new ArrayList();
 		this.worldTime = 0L;
-		this.snowCovered = false;
+		this.worldType = WorldType.NORMAL;
 		this.skyColor = 8961023L;
 		this.fogColor = 12638463L;
 		this.cloudColor = 16777215L;
@@ -151,23 +193,34 @@
 		this.DIST_HASH_MAGIC = 1013904223;
 		this.editingBlocks = false;
 		this.lockTimestamp = System.currentTimeMillis();
-		this.autosavePeriod = 40;
+		this.autosavePeriod = 1200;
 		this.playerEntities = new ArrayList();
 		this.rand = new Random();
 		this.isNewWorld = false;
 		this.worldAccesses = new ArrayList();
 		this.randomSeed = 0L;
+		this.saveVersion = 19132;
 		this.sizeOnDisk = 0L;
 		this.collidingBoundingBoxes = new ArrayList();
 		this.positionsToUpdate = new HashSet();
 		this.soundCounter = this.rand.nextInt(12000);
 		this.entitiesWithinAABBExcludingEntity = new ArrayList();
 		this.multiplayerWorld = false;
+		this.simulationDistance = 8;
 		this.levelName = var2;
+		this.displayName = var2;
 		var1.mkdirs();
 		this.saveDirectory = new File(var1, var2);
 		this.saveDirectory.mkdirs();
 
+		Calendar calendar1 = Calendar.getInstance();
+		calendar1.setTime(new Date());
+		this.blueFoxDay = calendar1.get(Calendar.MONTH) == Calendar.NOVEMBER && calendar1.get(Calendar.DATE) == 8;
+
+		this.blankChunk = new EmptyChunk(this, new short[65536], 0, 0);
+		this.blankChunk.isChunkRendered = true;
+		this.blankChunk.neverSave = true;
+
 		File var5;
 		try {
 			var5 = new File(this.saveDirectory, "session.lock");
@@ -182,6 +235,8 @@
 			throw new RuntimeException("Failed to check session lock, aborting");
 		}
 
+		boolean var15 = false;
+
 		var5 = new File(this.saveDirectory, "level.dat");
 		this.isNewWorld = !var5.exists();
 		if(var5.exists()) {
@@ -194,7 +249,17 @@
 				this.spawnZ = var7.getInteger("SpawnZ");
 				this.worldTime = var7.getLong("Time");
 				this.sizeOnDisk = var7.getLong("SizeOnDisk");
-				this.snowCovered = var7.getBoolean("SnowCovered");
+				this.worldType = var7.getBoolean("SnowCovered") ? WorldType.WINTER
+						: var7.hasKey("WorldType")
+								? WorldType.values()[var7.getByte("WorldType")]
+								: WorldType.NORMAL;
+				this.displayName = var7.getString("DisplayName");
+				this.creative = var7.getBoolean("Creative");
+				this.mantleDisrupted = var7.getBoolean("MantleDisrupted");
+				this.starfallChance = var7.getInteger("StarfallChance");
+				if(this.displayName.isEmpty()) {
+					this.displayName = var2;
+				}
 				if(var7.hasKey("Player")) {
 					this.nbtCompoundPlayer = var7.getCompoundTag("Player");
 				}
@@ -202,10 +267,16 @@
 				var11.printStackTrace();
 			}
 		} else {
-			this.snowCovered = this.rand.nextInt(4) == 0;
+			if (info != null) {
+				this.applyCreationInfo(info);
+			}
+			var15 = true;
 		}
 
-		boolean var15 = false;
+		this.skyColor = this.worldType.getSkyColor();
+		this.fogColor = this.worldType.getFogColor();
+		this.cloudColor = this.worldType.getCloudColor();
+
 		if(this.randomSeed == 0L) {
 			this.randomSeed = var3;
 			var15 = true;
@@ -215,25 +286,70 @@
 		if(var15) {
 			this.worldChunkLoadOverride = true;
 			this.spawnX = 0;
-			this.spawnY = 64;
-
-			for(this.spawnZ = 0; !this.findSpawn(this.spawnX, this.spawnZ); this.spawnZ += this.rand.nextInt(64) - this.rand.nextInt(64)) {
-				this.spawnX += this.rand.nextInt(64) - this.rand.nextInt(64);
+			this.spawnY = 128;
+			this.spawnZ = 0;
+
+			Random spawnRand = new Random(this.randomSeed);
+
+			int attempts = 0;
+			while (!this.findSpawn(this.spawnX, this.spawnZ)) {
+				this.spawnX += spawnRand.nextInt(129) - 64;
+				this.spawnZ += spawnRand.nextInt(129) - 64;
+				attempts++;
+
+				if (this.spawnX > 1000 || this.spawnX < -1000
+					|| this.spawnZ > 1000 || this.spawnZ < -1000) {
+					this.spawnX = 0;
+					this.spawnY = 128;
+					this.spawnZ = 0;
+				}
+
+				if (attempts > 1000) {
+					System.out.println("Failed to find a suitable spawn!");
+					break;
+				}
+			}
+
+			if (attempts <= 1000) {
+				attempts = 0;
+				do {
+					attempts++;
+					this.spawnX = spawnRand.nextInt(2001) - 1000;
+					this.spawnZ = spawnRand.nextInt(2001) - 1000;
+				} while ((this.spawnY = this.getFirstUncoveredHeight(this.spawnX, this.spawnZ)) < 128 && attempts++ < 1000);
 			}
 
 			this.worldChunkLoadOverride = false;
 		}
 
+		if (this.worldType == WorldType.SUPERFLAT) this.worldTime = 3000L;
+
 		this.calculateInitialSkylight();
 	}
 
-	protected IChunkProvider getChunkProvider(File var1) {
-		return new ChunkProviderLoadOrGenerate(this, new ChunkLoader(var1, true), new ChunkProviderGenerate(this, this.randomSeed));
+	public World(File var1, String var2, long var3, CreateWorldInfo info, GameAchievements achievements) {
+		this(var1, var2, var3, info);
+		this.achievements = achievements;
+	}
+
+	public boolean canDoClientAction() {
+		return !this.multiplayerWorld;
+	}
+
+	public void setWorldType(WorldType worldType) {
+		this.worldType = worldType;
+		this.skyColor = worldType.getSkyColor();
+		this.fogColor = worldType.getFogColor();
+		this.cloudColor = worldType.getCloudColor();
+	}
+
+	public IChunkProvider getChunkProvider(File var1) {
+		return new ChunkProviderLoadOrGenerate(this, new McRegionChunkLoader(var1), new ChunkProviderGenerate(this, this.randomSeed));
 	}
 
 	public void setSpawnLocation() {
 		if(this.spawnY <= 0) {
-			this.spawnY = 64;
+			this.spawnY = 128;
 		}
 
 		while(this.getFirstUncoveredBlock(this.spawnX, this.spawnZ) == 0) {
@@ -244,13 +360,28 @@
 	}
 
 	private boolean findSpawn(int var1, int var2) {
-		int var3 = this.getFirstUncoveredBlock(var1, var2);
-		return var3 == Block.sand.blockID;
+		if (this.worldType == WorldType.SUPERFLAT) {
+			this.spawnX = 0;
+			this.spawnY = 64;
+			this.spawnZ = 0;
+			return true;
+		}
+
+		int var4 = this.spawnY = this.getFirstUncoveredHeight(var1, var2) + 1;
+		return var4 > 128 && var4 < 144;
+	}
+
+	private int getFirstUncoveredHeight(int var1, int var2) {
+		int var3;
+		for(var3 = 127; this.isBlockNormalCube(var1, var3, var2); ++var3) {
+		}
+
+		return var3;
 	}
 
 	private int getFirstUncoveredBlock(int var1, int var2) {
 		int var3;
-		for(var3 = 63; this.getBlockId(var1, var3 + 1, var2) != 0; ++var3) {
+		for(var3 = 127; this.getBlockId(var1, var3 + 1, var2) != 0; ++var3) {
 		}
 
 		return this.getBlockId(var1, var3, var2);
@@ -294,8 +425,14 @@
 		var1.setInteger("SpawnZ", this.spawnZ);
 		var1.setLong("Time", this.worldTime);
 		var1.setLong("SizeOnDisk", this.sizeOnDisk);
-		var1.setBoolean("SnowCovered", this.snowCovered);
+		var1.setByte("WorldType", (byte)this.worldType.ordinal());
+		var1.setString("DisplayName", this.displayName);
+		var1.setBoolean("Creative", this.creative);
+		var1.setBoolean("MantleDisrupted", this.mantleDisrupted);
+		var1.setInteger("StarfallChance", this.starfallChance);
 		var1.setLong("LastPlayed", System.currentTimeMillis());
+		var1.setInteger("version", this.saveVersion);
+		var1.setInteger("GameVersion", CURRENT_VERSION);
 		EntityPlayer var2 = null;
 		if(this.playerEntities.size() > 0) {
 			var2 = (EntityPlayer)this.playerEntities.get(0);
@@ -308,6 +445,14 @@
 			var1.setCompoundTag("Player", var3);
 		}
 
+		NBTTagList mods = new NBTTagList();
+		for (BaseMod mod : ModLoader.mods) {
+			NBTTagCompound compound = new NBTTagCompound();
+			mod.writeToNBT(compound);
+			mods.setTag(compound);
+		}
+		var1.setTag("Mods", mods);
+
 		var3 = new NBTTagCompound();
 		var3.setTag("Data", var1);
 
@@ -348,15 +493,30 @@
 	}
 
 	public int getBlockId(int var1, int var2, int var3) {
-		return var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000 ? (var2 < 0 ? 0 : (var2 >= 128 ? 0 : this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4).getBlockID(var1 & 15, var2, var3 & 15))) : 0;
+		return var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000
+				? (var2 < 0
+					? 0
+					: (var2 >= CHUNK_HEIGHT
+						? 0
+						: this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4).getBlockID(var1 & 15, var2, var3 & 15))
+					)
+				: 0;
 	}
 
 	public boolean blockExists(int var1, int var2, int var3) {
-		return var2 >= 0 && var2 < 128 ? this.chunkExists(var1 >> 4, var3 >> 4) : false;
+		return var2 >= 0 && var2 < CHUNK_HEIGHT && this.chunkExists(var1 >> 4, var3 >> 4);
+	}
+
+	public Biome getBiome(int x, int z) {
+		return this.getChunkFromChunkCoords(x >> 4, z >> 4).getBiome(x & 15, z & 15);
+ 	}
+
+	public boolean doChunksNearChunkExist(int var1, int var2, int var3, int var4) {
+		return this.checkChunksExist(var1 - var4, var2 - var4, var3 - var4, var1 + var4, var2 + var4, var3 + var4);
 	}
 
 	public boolean checkChunksExist(int var1, int var2, int var3, int var4, int var5, int var6) {
-		if(var5 >= 0 && var2 < 128) {
+		if(var5 >= 0 && var2 < CHUNK_HEIGHT) {
 			var1 >>= 4;
 			var2 >>= 4;
 			var3 >>= 4;
@@ -378,7 +538,7 @@
 		}
 	}
 
-	private boolean chunkExists(int var1, int var2) {
+	public boolean chunkExists(int var1, int var2) {
 		return this.chunkProvider.chunkExists(var1, var2);
 	}
 
@@ -394,11 +554,15 @@
 		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
 			if(var2 < 0) {
 				return false;
-			} else if(var2 >= 128) {
+			} else if(var2 >= CHUNK_HEIGHT) {
 				return false;
 			} else {
 				Chunk var6 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
-				return var6.setBlockIDWithMetadata(var1 & 15, var2, var3 & 15, var4, var5);
+				boolean var7 = var6.setBlockIDWithMetadata(var1 & 15, var2, var3 & 15, var4, var5);
+				Profiler.startSection("checkLight");
+				this.updateAllLightTypes(var1, var2, var3);
+				Profiler.endSection();
+				return var7;
 			}
 		} else {
 			return false;
@@ -409,11 +573,15 @@
 		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
 			if(var2 < 0) {
 				return false;
-			} else if(var2 >= 128) {
+			} else if(var2 >= CHUNK_HEIGHT) {
 				return false;
 			} else {
 				Chunk var5 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
-				return var5.setBlockID(var1 & 15, var2, var3 & 15, var4);
+				boolean var6 = var5.setBlockID(var1 & 15, var2, var3 & 15, var4);
+				Profiler.startSection("checkLight");
+				this.updateAllLightTypes(var1, var2, var3);
+				Profiler.endSection();
+				return var6;
 			}
 		} else {
 			return false;
@@ -429,7 +597,7 @@
 		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
 			if(var2 < 0) {
 				return 0;
-			} else if(var2 >= 128) {
+			} else if(var2 >= CHUNK_HEIGHT) {
 				return 0;
 			} else {
 				Chunk var4 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
@@ -450,7 +618,7 @@
 		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
 			if(var2 < 0) {
 				return false;
-			} else if(var2 >= 128) {
+			} else if(var2 >= CHUNK_HEIGHT) {
 				return false;
 			} else {
 				Chunk var5 = this.getChunkFromChunkCoords(var1 >> 4, var3 >> 4);
@@ -521,7 +689,7 @@
 	}
 
 	private void notifyBlockOfNeighborChange(int var1, int var2, int var3, int var4) {
-		if(!this.editingBlocks && !this.multiplayerWorld) {
+		if(!this.editingBlocks && this.canDoClientAction()) {
 			Block var5 = Block.blocksList[this.getBlockId(var1, var2, var3)];
 			if(var5 != null) {
 				var5.onNeighborBlockChange(this, var1, var2, var3, var4);
@@ -543,7 +711,8 @@
 			int var5;
 			if(var4) {
 				var5 = this.getBlockId(var1, var2, var3);
-				if(var5 == Block.stairSingle.blockID || var5 == Block.tilledField.blockID) {
+				Block b = Block.blocksList[var5];
+				if((b instanceof BlockStep && !((BlockStep) b).blockType) || var5 == Block.tilledField.blockID) {
 					int var6 = this.getBlockLightValue_do(var1, var2 + 1, var3, false);
 					int var7 = this.getBlockLightValue_do(var1 + 1, var2, var3, false);
 					int var8 = this.getBlockLightValue_do(var1 - 1, var2, var3, false);
@@ -571,7 +740,7 @@
 
 			if(var2 < 0) {
 				return 0;
-			} else if(var2 >= 128) {
+			} else if(var2 >= CHUNK_HEIGHT) {
 				var5 = 15 - this.skylightSubtracted;
 				if(var5 < 0) {
 					var5 = 0;
@@ -593,7 +762,7 @@
 		if(var1 >= -32000000 && var3 >= -32000000 && var1 < 32000000 && var3 <= 32000000) {
 			if(var2 < 0) {
 				return false;
-			} else if(var2 >= 128) {
+			} else if(var2 >= CHUNK_HEIGHT) {
 				return true;
 			} else if(!this.chunkExists(var1 >> 4, var3 >> 4)) {
 				return false;
@@ -621,6 +790,19 @@
 		}
 	}
 
+	public int getChunkHeightMapMinimum(int var1, int var2) {
+        if (var1 >= -32000000 && var2 >= -32000000 && var1 < 32000000 && var2 < 32000000) {
+            if (!this.chunkExists(var1 >> 4, var2 >> 4)) {
+                return 0;
+            } else {
+                Chunk var3 = this.getChunkFromChunkCoords(var1 >> 4, var2 >> 4);
+                return var3.heightMapMinimum;
+            }
+        } else {
+            return 128;
+        }
+    }
+
 	public void neighborLightPropagationChanged(EnumSkyBlock var1, int var2, int var3, int var4, int var5) {
 		if(this.blockExists(var2, var3, var4)) {
 			if(var1 == EnumSkyBlock.Sky) {
@@ -642,11 +824,14 @@
 	}
 
 	public int getSavedLightValue(EnumSkyBlock var1, int var2, int var3, int var4) {
-		if(var3 >= 0 && var3 < 128 && var2 >= -32000000 && var4 >= -32000000 && var2 < 32000000 && var4 <= 32000000) {
+		if (var3 < 0) var3 = 0;
+		if (var3 >= CHUNK_HEIGHT) var3 = CHUNK_HEIGHT - 1;
+
+		if(var2 >= -32000000 && var4 >= -32000000 && var2 < 32000000 && var4 <= 32000000) {
 			int var5 = var2 >> 4;
 			int var6 = var4 >> 4;
 			if(!this.chunkExists(var5, var6)) {
-				return 0;
+				return var1.defaultLightValue;
 			} else {
 				Chunk var7 = this.getChunkFromChunkCoords(var5, var6);
 				return var7.getSavedLightValue(var1, var2 & 15, var3, var4 & 15);
@@ -659,7 +844,7 @@
 	public void setLightValue(EnumSkyBlock var1, int var2, int var3, int var4, int var5) {
 		if(var2 >= -32000000 && var4 >= -32000000 && var2 < 32000000 && var4 <= 32000000) {
 			if(var3 >= 0) {
-				if(var3 < 128) {
+				if(var3 < CHUNK_HEIGHT) {
 					if(this.chunkExists(var2 >> 4, var4 >> 4)) {
 						Chunk var6 = this.getChunkFromChunkCoords(var2 >> 4, var4 >> 4);
 						var6.setLightValue(var1, var2 & 15, var3, var4 & 15, var5);
@@ -674,6 +859,12 @@
 		}
 	}
 
+	public void markBlockNeedsRenderUpdate(int var1, int var2, int var3) {
+		for(int var4 = 0; var4 < this.worldAccesses.size(); ++var4) {
+			((IWorldAccess)this.worldAccesses.get(var4)).markBlockNeedsRenderUpdate(var1, var2, var3);
+		}
+	}
+
 	public float getBrightness(int var1, int var2, int var3) {
 		return lightBrightnessTable[this.getBlockLightValue(var1, var2, var3)];
 	}
@@ -683,134 +874,151 @@
 	}
 
 	public MovingObjectPosition rayTraceBlocks(Vec3D var1, Vec3D var2) {
-		return this.rayTraceBlocks_do(var1, var2, false);
-	}
-
-	public MovingObjectPosition rayTraceBlocks_do(Vec3D var1, Vec3D var2, boolean var3) {
+		return this.rayTraceBlocks_do(var1, var2, false, false);
+	}
+
+	public MovingObjectPosition rayTraceBlocks(Vec3D var1, Vec3D var2, boolean var3) {
+		return this.rayTraceBlocks_do(var1, var2, var3, false);
+	}
+
+	public MovingObjectPosition rayTraceBlocks_do(Vec3D var1, Vec3D var2, boolean var3, boolean var4) {
 		if(!Double.isNaN(var1.xCoord) && !Double.isNaN(var1.yCoord) && !Double.isNaN(var1.zCoord)) {
 			if(!Double.isNaN(var2.xCoord) && !Double.isNaN(var2.yCoord) && !Double.isNaN(var2.zCoord)) {
-				int var4 = MathHelper.floor_double(var2.xCoord);
-				int var5 = MathHelper.floor_double(var2.yCoord);
-				int var6 = MathHelper.floor_double(var2.zCoord);
-				int var7 = MathHelper.floor_double(var1.xCoord);
-				int var8 = MathHelper.floor_double(var1.yCoord);
-				int var9 = MathHelper.floor_double(var1.zCoord);
-				int var10 = 20;
-
-				while(var10-- >= 0) {
+				int var5 = MathHelper.floor_double(var2.xCoord);
+				int var6 = MathHelper.floor_double(var2.yCoord);
+				int var7 = MathHelper.floor_double(var2.zCoord);
+				int var8 = MathHelper.floor_double(var1.xCoord);
+				int var9 = MathHelper.floor_double(var1.yCoord);
+				int var10 = MathHelper.floor_double(var1.zCoord);
+				int var11 = this.getBlockId(var8, var9, var10);
+				int var12 = this.getBlockMetadata(var8, var9, var10);
+				Block var13 = Block.blocksList[var11];
+				if((!var4 || var13 == null || var13.getCollisionBoundingBoxFromPool(this, var8, var9, var10) != null) && var11 > 0 && var13.canCollideCheck(var12, var3)) {
+					MovingObjectPosition var14 = var13.collisionRayTrace(this, var8, var9, var10, var1, var2);
+					if(var14 != null) {
+						return var14;
+					}
+				}
+
+				var11 = 200;
+
+				while(var11-- >= 0) {
 					if(Double.isNaN(var1.xCoord) || Double.isNaN(var1.yCoord) || Double.isNaN(var1.zCoord)) {
 						return null;
 					}
 
-					if(var7 == var4 && var8 == var5 && var9 == var6) {
+					if(var8 == var5 && var9 == var6 && var10 == var7) {
 						return null;
 					}
 
-					double var11 = 999.0D;
-					double var13 = 999.0D;
+					boolean var39 = true;
+					boolean var40 = true;
+					boolean var41 = true;
 					double var15 = 999.0D;
-					if(var4 > var7) {
-						var11 = (double)var7 + 1.0D;
-					}
-
-					if(var4 < var7) {
-						var11 = (double)var7 + 0.0D;
-					}
-
-					if(var5 > var8) {
-						var13 = (double)var8 + 1.0D;
-					}
-
-					if(var5 < var8) {
-						var13 = (double)var8 + 0.0D;
-					}
-
-					if(var6 > var9) {
-						var15 = (double)var9 + 1.0D;
-					}
-
-					if(var6 < var9) {
-						var15 = (double)var9 + 0.0D;
-					}
-
 					double var17 = 999.0D;
 					double var19 = 999.0D;
+					if(var5 > var8) {
+						var15 = (double)var8 + 1.0D;
+					} else if(var5 < var8) {
+						var15 = (double)var8 + 0.0D;
+					} else {
+						var39 = false;
+					}
+
+					if(var6 > var9) {
+						var17 = (double)var9 + 1.0D;
+					} else if(var6 < var9) {
+						var17 = (double)var9 + 0.0D;
+					} else {
+						var40 = false;
+					}
+
+					if(var7 > var10) {
+						var19 = (double)var10 + 1.0D;
+					} else if(var7 < var10) {
+						var19 = (double)var10 + 0.0D;
+					} else {
+						var41 = false;
+					}
+
 					double var21 = 999.0D;
-					double var23 = var2.xCoord - var1.xCoord;
-					double var25 = var2.yCoord - var1.yCoord;
-					double var27 = var2.zCoord - var1.zCoord;
-					if(var11 != 999.0D) {
-						var17 = (var11 - var1.xCoord) / var23;
-					}
-
-					if(var13 != 999.0D) {
-						var19 = (var13 - var1.yCoord) / var25;
-					}
-
-					if(var15 != 999.0D) {
-						var21 = (var15 - var1.zCoord) / var27;
-					}
-
-					boolean var29 = false;
-					byte var35;
-					if(var17 < var19 && var17 < var21) {
-						if(var4 > var7) {
-							var35 = 4;
-						} else {
-							var35 = 5;
-						}
-
-						var1.xCoord = var11;
-						var1.yCoord += var25 * var17;
-						var1.zCoord += var27 * var17;
-					} else if(var19 < var21) {
+					double var23 = 999.0D;
+					double var25 = 999.0D;
+					double var27 = var2.xCoord - var1.xCoord;
+					double var29 = var2.yCoord - var1.yCoord;
+					double var31 = var2.zCoord - var1.zCoord;
+					if(var39) {
+						var21 = (var15 - var1.xCoord) / var27;
+					}
+
+					if(var40) {
+						var23 = (var17 - var1.yCoord) / var29;
+					}
+
+					if(var41) {
+						var25 = (var19 - var1.zCoord) / var31;
+					}
+
+					boolean var33 = false;
+					byte var42;
+					if(var21 < var23 && var21 < var25) {
 						if(var5 > var8) {
-							var35 = 0;
+							var42 = 4;
 						} else {
-							var35 = 1;
+							var42 = 5;
 						}
 
-						var1.xCoord += var23 * var19;
-						var1.yCoord = var13;
-						var1.zCoord += var27 * var19;
-					} else {
+						var1.xCoord = var15;
+						var1.yCoord += var29 * var21;
+						var1.zCoord += var31 * var21;
+					} else if(var23 < var25) {
 						if(var6 > var9) {
-							var35 = 2;
-						} else {
-							var35 = 3;
-						}
-
-						var1.xCoord += var23 * var21;
-						var1.yCoord += var25 * var21;
-						var1.zCoord = var15;
-					}
-
-					Vec3D var30 = Vec3D.createVector(var1.xCoord, var1.yCoord, var1.zCoord);
-					var7 = (int)(var30.xCoord = (double)MathHelper.floor_double(var1.xCoord));
-					if(var35 == 5) {
-						--var7;
-						++var30.xCoord;
-					}
-
-					var8 = (int)(var30.yCoord = (double)MathHelper.floor_double(var1.yCoord));
-					if(var35 == 1) {
+							var42 = 0;
+						} else {
+							var42 = 1;
+						}
+
+						var1.xCoord += var27 * var23;
+						var1.yCoord = var17;
+						var1.zCoord += var31 * var23;
+					} else {
+						if(var7 > var10) {
+							var42 = 2;
+						} else {
+							var42 = 3;
+						}
+
+						var1.xCoord += var27 * var25;
+						var1.yCoord += var29 * var25;
+						var1.zCoord = var19;
+					}
+
+					Vec3D var34 = Vec3D.createVector(var1.xCoord, var1.yCoord, var1.zCoord);
+					var8 = (int)(var34.xCoord = (double)MathHelper.floor_double(var1.xCoord));
+					if(var42 == 5) {
 						--var8;
-						++var30.yCoord;
+						++var34.xCoord;
 					}
 
-					var9 = (int)(var30.zCoord = (double)MathHelper.floor_double(var1.zCoord));
-					if(var35 == 3) {
+					var9 = (int)(var34.yCoord = (double)MathHelper.floor_double(var1.yCoord));
+					if(var42 == 1) {
 						--var9;
-						++var30.zCoord;
-					}
-
-					int var31 = this.getBlockId(var7, var8, var9);
-					int var32 = this.getBlockMetadata(var7, var8, var9);
-					Block var33 = Block.blocksList[var31];
-					if(var31 > 0 && var33.canCollideCheck(var32, var3)) {
-						MovingObjectPosition var34 = var33.collisionRayTrace(this, var7, var8, var9, var1, var2);
-						if(var34 != null) {
-							return var34;
+						++var34.yCoord;
+					}
+
+					var10 = (int)(var34.zCoord = (double)MathHelper.floor_double(var1.zCoord));
+					if(var42 == 3) {
+						--var10;
+						++var34.zCoord;
+					}
+
+					int var35 = this.getBlockId(var8, var9, var10);
+					int var36 = this.getBlockMetadata(var8, var9, var10);
+					Block var37 = Block.blocksList[var35];
+					if((!var4 || var37 == null || var37.getCollisionBoundingBoxFromPool(this, var8, var9, var10) != null) && var35 > 0 && var37.canCollideCheck(var36, var3)) {
+						MovingObjectPosition var38 = var37.collisionRayTrace(this, var8, var9, var10, var1, var2);
+						if(var38 != null) {
+							return var38;
 						}
 					}
 				}
@@ -838,9 +1046,9 @@
 
 	}
 
-	public void playRecord(String var1, int var2, int var3, int var4) {
+	public void playRecord(String var1, int var2, int var3, int var4, String author) {
 		for(int var5 = 0; var5 < this.worldAccesses.size(); ++var5) {
-			((IWorldAccess)this.worldAccesses.get(var5)).playRecord(var1, var2, var3, var4);
+			((IWorldAccess)this.worldAccesses.get(var5)).playRecord(var1, var2, var3, var4, author);
 		}
 
 	}
@@ -886,7 +1094,6 @@
 		for(int var2 = 0; var2 < this.worldAccesses.size(); ++var2) {
 			((IWorldAccess)this.worldAccesses.get(var2)).releaseEntitySkin(var1);
 		}
-
 	}
 
 	public void setEntityDead(Entity var1) {
@@ -960,7 +1167,7 @@
 		return (int)(var3 * 11.0F);
 	}
 
-	public Vec3D getSkyColor(float var1) {
+	public Vec3D getSkyColor(float var1, float temp, float hum) {
 		float var2 = this.getCelestialAngle(var1);
 		float var3 = MathHelper.cos(var2 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
 		if(var3 < 0.0F) {
@@ -971,9 +1178,20 @@
 			var3 = 1.0F;
 		}
 
-		float var4 = (float)(this.skyColor >> 16 & 255L) / 255.0F;
-		float var5 = (float)(this.skyColor >> 8 & 255L) / 255.0F;
-		float var6 = (float)(this.skyColor & 255L) / 255.0F;
+		float[] hsb = new float[3];
+		Color.RGBtoHSB((int)(this.skyColor >> 16 & 255), (int)(this.skyColor >> 8 & 255), (int)(this.skyColor & 255), hsb);
+
+		if (this.skyColor == WorldType.NORMAL.getSkyColor()) {
+			hsb[0] = MathHelper.floorMod(hsb[0] - (temp - 0.5F) * 0.1F, 1.0F);
+			hsb[1] = MathHelper.clamp(hsb[1] + (hum - 0.5F) * 0.1F, 0.0F, 1.0F);
+			hsb[2] = MathHelper.clamp(hsb[2] + (hum - 0.5F) * 0.1F, 0.0F, 1.0F);
+		}
+
+		int rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);
+		float var4 = (float)(rgb >> 16 & 255L) / 255.0F;
+		float var5 = (float)(rgb >> 8 & 255L) / 255.0F;
+		float var6 = (float)(rgb & 255L) / 255.0F;
+
 		var4 *= var3;
 		var5 *= var3;
 		var6 *= var3;
@@ -1017,7 +1235,7 @@
 		return Vec3D.createVector((double)var4, (double)var5, (double)var6);
 	}
 
-	public Vec3D getFogColor(float var1) {
+	public Vec3D getFogColor(float var1, float temp, float hum) {
 		float var2 = this.getCelestialAngle(var1);
 		float var3 = MathHelper.cos(var2 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
 		if(var3 < 0.0F) {
@@ -1028,18 +1246,29 @@
 			var3 = 1.0F;
 		}
 
-		float var4 = (float)(this.fogColor >> 16 & 255L) / 255.0F;
-		float var5 = (float)(this.fogColor >> 8 & 255L) / 255.0F;
-		float var6 = (float)(this.fogColor & 255L) / 255.0F;
+		float[] hsb = new float[3];
+		Color.RGBtoHSB((int)(this.fogColor >> 16 & 255), (int)(this.fogColor >> 8 & 255), (int)(this.fogColor & 255), hsb);
+
+		if (this.fogColor == WorldType.NORMAL.getFogColor()) {
+			hsb[0] = MathHelper.floorMod(hsb[0] - (temp - 0.5F) * 0.1F, 1.0F);
+			hsb[1] = MathHelper.clamp(hsb[1] + (hum - 0.5F) * 0.1F, 0.0F, 1.0F);
+			hsb[2] = MathHelper.clamp(hsb[2] + (hum - 0.5F) * 0.1F, 0.0F, 1.0F);
+		}
+
+		int rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);
+		float var4 = (float)(rgb >> 16 & 255L) / 255.0F;
+		float var5 = (float)(rgb >> 8 & 255L) / 255.0F;
+		float var6 = (float)(rgb & 255L) / 255.0F;
 		var4 *= var3 * 0.94F + 0.06F;
 		var5 *= var3 * 0.94F + 0.06F;
 		var6 *= var3 * 0.91F + 0.09F;
+
 		return Vec3D.createVector((double)var4, (double)var5, (double)var6);
 	}
 
 	public int getTopSolidOrLiquidBlock(int var1, int var2) {
 		Chunk var3 = this.getChunkFromBlockCoords(var1, var2);
-		int var4 = 127;
+		int var4 = CHUNK_HEIGHT - 1;
 		var1 &= 15;
 
 		for(var2 &= 15; var4 > 0; --var4) {
@@ -1087,6 +1316,8 @@
 	}
 
 	public void updateEntities() {
+		Profiler.startSection("entities");
+		Profiler.startSection("remove");
 		this.loadedEntityList.removeAll(this.unloadedEntityList);
 
 		int var1;
@@ -1107,7 +1338,8 @@
 		}
 
 		this.unloadedEntityList.clear();
-
+		Profiler.endStartSection("regular");
+		
 		for(var1 = 0; var1 < this.loadedEntityList.size(); ++var1) {
 			var2 = (Entity)this.loadedEntityList.get(var1);
 			if(var2.ridingEntity != null) {
@@ -1124,6 +1356,7 @@
 			}
 
 			if(var2.isDead) {
+				Profiler.startSection("remove");
 				var3 = var2.chunkCoordX;
 				var4 = var2.chunkCoordZ;
 				if(var2.addedToChunk && this.chunkExists(var3, var4)) {
@@ -1132,21 +1365,25 @@
 
 				this.loadedEntityList.remove(var1--);
 				this.releaseEntitySkin(var2);
+				Profiler.endSection();
 			}
 		}
 
+		Profiler.endStartSection("tileEntities");
 		for(var1 = 0; var1 < this.loadedTileEntityList.size(); ++var1) {
 			TileEntity var5 = (TileEntity)this.loadedTileEntityList.get(var1);
 			var5.updateEntity();
 		}
 
+		Profiler.endSection();
+		Profiler.endSection();
 	}
 
-	protected void updateEntity(Entity var1) {
+	public void updateEntity(Entity var1) {
 		int var2 = MathHelper.floor_double(var1.posX);
 		int var3 = MathHelper.floor_double(var1.posZ);
-		byte var4 = 16;
-		if(this.checkChunksExist(var2 - var4, 0, var3 - var4, var2 + var4, 128, var3 + var4)) {
+		byte var4 = 32;
+		if(this.checkChunksExist(var2 - var4, 0, var3 - var4, var2 + var4, CHUNK_HEIGHT, var3 + var4)) {
 			var1.lastTickPosX = var1.posX;
 			var1.lastTickPosY = var1.posY;
 			var1.lastTickPosZ = var1.posZ;
@@ -1158,6 +1395,27 @@
 				var1.onUpdate();
 			}
 
+			Profiler.startSection("chunkCheck");
+			if(Double.isNaN(var1.posX) || Double.isInfinite(var1.posX)) {
+				var1.posX = var1.lastTickPosX;
+			}
+
+			if(Double.isNaN(var1.posY) || Double.isInfinite(var1.posY)) {
+				var1.posY = var1.lastTickPosY;
+			}
+
+			if(Double.isNaN(var1.posZ) || Double.isInfinite(var1.posZ)) {
+				var1.posZ = var1.lastTickPosZ;
+			}
+
+			if(Double.isNaN((double)var1.rotationPitch) || Double.isInfinite((double)var1.rotationPitch)) {
+				var1.rotationPitch = var1.prevRotationPitch;
+			}
+
+			if(Double.isNaN((double)var1.rotationYaw) || Double.isInfinite((double)var1.rotationYaw)) {
+				var1.rotationYaw = var1.prevRotationYaw;
+			}
+
 			int var5 = MathHelper.floor_double(var1.posX / 16.0D);
 			int var6 = MathHelper.floor_double(var1.posY / 16.0D);
 			int var7 = MathHelper.floor_double(var1.posZ / 16.0D);
@@ -1167,14 +1425,15 @@
 				}
 
 				if(this.chunkExists(var5, var7)) {
+					var1.addedToChunk = true;
 					this.getChunkFromChunkCoords(var5, var7).addEntity(var1);
 				} else {
 					var1.addedToChunk = false;
-					System.out.println("Removing entity because it\'s not in a chunk!!");
 					var1.setEntityDead();
 				}
 			}
 
+			Profiler.endSection();
 			if(var1.riddenByEntity != null) {
 				if(!var1.riddenByEntity.isDead && var1.riddenByEntity.ridingEntity == var1) {
 					this.updateEntity(var1.riddenByEntity);
@@ -1184,26 +1443,6 @@
 				}
 			}
 
-			if(Double.isNaN(var1.posX) || Double.isInfinite(var1.posX)) {
-				var1.posX = var1.lastTickPosX;
-			}
-
-			if(Double.isNaN(var1.posY) || Double.isInfinite(var1.posY)) {
-				var1.posY = var1.lastTickPosY;
-			}
-
-			if(Double.isNaN(var1.posZ) || Double.isInfinite(var1.posZ)) {
-				var1.posZ = var1.lastTickPosZ;
-			}
-
-			if(Double.isNaN((double)var1.rotationPitch) || Double.isInfinite((double)var1.rotationPitch)) {
-				var1.rotationPitch = var1.prevRotationPitch;
-			}
-
-			if(Double.isNaN((double)var1.rotationYaw) || Double.isInfinite((double)var1.rotationYaw)) {
-				var1.rotationYaw = var1.prevRotationYaw;
-			}
-
 		}
 	}
 
@@ -1455,7 +1694,7 @@
 
 	public boolean isBlockNormalCube(int var1, int var2, int var3) {
 		Block var4 = Block.blocksList[this.getBlockId(var1, var2, var3)];
-		return var4 == null ? false : var4.isOpaqueCube();
+		return var4 != null && var4.isOpaqueCube();
 	}
 
 	public void saveWorldIndirectly(IProgressUpdate var1) {
@@ -1463,17 +1702,6 @@
 	}
 
 	public boolean updatingLighting() {
-		int var1 = 1000;
-
-		while(this.lightingToUpdate.size() > 0) {
-			--var1;
-			if(var1 <= 0) {
-				return true;
-			}
-
-			((MetadataChunkBlock)this.lightingToUpdate.remove(this.lightingToUpdate.size() - 1)).updateLight(this);
-		}
-
 		return false;
 	}
 
@@ -1482,31 +1710,37 @@
 	}
 
 	public void scheduleLightingUpdate_do(EnumSkyBlock var1, int var2, int var3, int var4, int var5, int var6, int var7, boolean var8) {
-		int var9 = (var5 + var2) / 2;
-		int var10 = (var7 + var4) / 2;
-		if(this.blockExists(var9, 64, var10)) {
-			int var11 = this.lightingToUpdate.size();
-			if(var8) {
-				int var12 = 4;
-				if(var12 > var11) {
-					var12 = var11;
-				}
-
-				for(int var13 = 0; var13 < var12; ++var13) {
-					MetadataChunkBlock var14 = (MetadataChunkBlock)this.lightingToUpdate.get(this.lightingToUpdate.size() - var13 - 1);
-					if(var14.skyBlock == var1 && var14.getLightUpdated(var2, var3, var4, var5, var6, var7)) {
-						return;
-					}
-				}
-			}
-
-			this.lightingToUpdate.add(new MetadataChunkBlock(var1, var2, var3, var4, var5, var6, var7));
-			if(this.lightingToUpdate.size() > 100000) {
-				while(this.lightingToUpdate.size() > '\uc350') {
-					this.updatingLighting();
-				}
-			}
-
+		lightingUpdatesScheduled++;
+		try {
+			if (lightingUpdatesScheduled == 50) {
+				return;
+			}
+			int var9 = (var5 + var2) / 2;
+			int var10 = (var7 + var4) / 2;
+			if (this.blockExists(var9, 64, var10)) {
+				int var11 = this.lightingToUpdate.size();
+				if (var8) {
+					int var12 = 5;
+					if (var12 > var11) {
+						var12 = var11;
+					}
+
+					for (int var13 = 0; var13 < var12; ++var13) {
+						MetadataChunkBlock var14 = (MetadataChunkBlock) this.lightingToUpdate.get(this.lightingToUpdate.size() - var13 - 1);
+						if (var14.skyBlock == var1 && var14.getLightUpdated(var2, var3, var4, var5, var6, var7)) {
+							return;
+						}
+					}
+				}
+
+				this.lightingToUpdate.add(new MetadataChunkBlock(var1, var2, var3, var4, var5, var6, var7));
+				if (this.lightingToUpdate.size() > 1000000) {
+					System.out.println("More than 1000000 updates, aborting lighting updates");
+					this.lightingToUpdate.clear();
+				}
+			}
+		} finally {
+			lightingUpdatesScheduled--;
 		}
 	}
 
@@ -1519,6 +1753,17 @@
 	}
 
 	public void tick() {
+		Profiler.startSection("mobSpawner");
+		if (this.canDoClientAction()) {
+			if (this.difficultySetting > 0) {
+				SpawnerAnimals monsterSpawner = this.mantleDisrupted ? this.monsterLvl2Spawner : this.monsterSpawner;
+				if (monsterSpawner != null) monsterSpawner.performSpawning(this);
+				if (this.mantleDisrupted && this.underworldSpawner != null) this.underworldSpawner.performSpawning(this);
+			}
+			if (this.animalSpawner != null) this.animalSpawner.performSpawning(this);
+		}
+
+		Profiler.endStartSection("chunkSource");
 		this.chunkProvider.unload100OldestChunks();
 		int var1 = this.calculateSkylightSubtracted(1.0F);
 		if(var1 != this.skylightSubtracted) {
@@ -1529,46 +1774,74 @@
 			}
 		}
 
-		++this.worldTime;
+		if (this.worldType != WorldType.SUPERFLAT) ++this.worldTime;
 		if(this.worldTime % (long)this.autosavePeriod == 0L) {
+			Profiler.endStartSection("save");
 			this.saveWorld(false, (IProgressUpdate)null);
 		}
 
+		Profiler.endStartSection("tickOther");
+		this.miscUpdates();
+		Profiler.endStartSection("tickPending");
 		this.tickUpdates(false);
+		Profiler.endStartSection("tickChunks");
 		this.updateBlocksAndPlayCaveSounds();
+		Profiler.endSection();
 	}
 
 	protected void updateBlocksAndPlayCaveSounds() {
 		this.positionsToUpdate.clear();
+		Profiler.startSection("buildList");
 
+		int var1;
+		EntityPlayer var2;
 		int var3;
 		int var4;
 		int var6;
 		int var7;
-		for(int var1 = 0; var1 < this.playerEntities.size(); ++var1) {
-			EntityPlayer var2 = (EntityPlayer)this.playerEntities.get(var1);
+		for(var1 = 0; var1 < this.playerEntities.size(); ++var1) {
+			var2 = (EntityPlayer)this.playerEntities.get(var1);
 			var3 = MathHelper.floor_double(var2.posX / 16.0D);
 			var4 = MathHelper.floor_double(var2.posZ / 16.0D);
-			byte var5 = 9;
+			int var5 = this.simulationDistance;
 
 			for(var6 = -var5; var6 <= var5; ++var6) {
 				for(var7 = -var5; var7 <= var5; ++var7) {
-					this.positionsToUpdate.add(new ChunkCoordIntPair(var6 + var3, var7 + var4));
+					if (!this.lazyLoading || this.chunkExists(var6 + var3, var7 + var4)) {
+						this.positionsToUpdate.add(new ChunkCoordIntPair(var6 + var3, var7 + var4));
+					}
 				}
 			}
+
+			this.mantleDisrupted |= var2.posY < 32.0D && this.worldType != WorldType.SUPERFLAT;
 		}
 
 		if(this.soundCounter > 0) {
 			--this.soundCounter;
 		}
 
-		Iterator var12 = this.positionsToUpdate.iterator();
+		Profiler.endStartSection("playerCheckLight");
+		if(!this.playerEntities.isEmpty()) {
+			var1 = this.rand.nextInt(this.playerEntities.size());
+			var2 = (EntityPlayer)this.playerEntities.get(var1);
+			var3 = MathHelper.floor_double(var2.posX) + this.rand.nextInt(11) - 5;
+			var4 = MathHelper.floor_double(var2.posY) + this.rand.nextInt(11) - 5;
+			int var8 = MathHelper.floor_double(var2.posZ) + this.rand.nextInt(11) - 5;
+			this.updateAllLightTypes(var3, var4, var8);
+		}
+		Profiler.endSection();
 
-		while(var12.hasNext()) {
-			ChunkCoordIntPair var13 = (ChunkCoordIntPair)var12.next();
+		for(Object var12 : this.positionsToUpdate) {
+			ChunkCoordIntPair var13 = (ChunkCoordIntPair)var12;
 			var3 = var13.chunkXPos * 16;
 			var4 = var13.chunkZPos * 16;
+			Profiler.startSection("getChunk");
 			Chunk var14 = this.getChunkFromChunkCoords(var13.chunkXPos, var13.chunkZPos);
+			Profiler.endStartSection("tickChunk");
+			var14.updateSkylight();
+			Profiler.endStartSection("checkLight");
+			var14.enqueueRelightChecks();
+			Profiler.endStartSection("moodSound");
 			int var8;
 			int var9;
 			int var10;
@@ -1577,7 +1850,7 @@
 				var6 = this.updateLCG >> 2;
 				var7 = var6 & 15;
 				var8 = var6 >> 8 & 15;
-				var9 = var6 >> 16 & 127;
+				var9 = var6 >> 16 & 255;
 				var10 = var14.getBlockID(var7, var9, var8);
 				var7 += var3;
 				var8 += var4;
@@ -1590,13 +1863,15 @@
 				}
 			}
 
-			if(this.snowCovered && this.rand.nextInt(4) == 0) {
+			Profiler.endStartSection("iceandsnow");
+			if(this.rand.nextInt(16) == 0) {
 				this.updateLCG = this.updateLCG * 3 + this.DIST_HASH_MAGIC;
 				var6 = this.updateLCG >> 2;
 				var7 = var6 & 15;
 				var8 = var6 >> 8 & 15;
 				var9 = this.getTopSolidOrLiquidBlock(var7 + var3, var8 + var4);
-				if(var9 >= 0 && var9 < 128 && var14.getSavedLightValue(EnumSkyBlock.Block, var7, var9, var8) < 10) {
+				if((this.worldType == WorldType.WINTER || var14.getBiome(var7, var8).isSnowy())
+						&& var9 >= 0 && var9 < CHUNK_HEIGHT && var14.getSavedLightValue(EnumSkyBlock.Block, var7, var9, var8) < 10) {
 					var10 = var14.getBlockID(var7, var9 - 1, var8);
 					if(var14.getBlockID(var7, var9, var8) == 0 && Block.snow.canPlaceBlockAt(this, var7 + var3, var9, var8 + var4)) {
 						this.setBlockWithNotify(var7 + var3, var9, var8 + var4, Block.snow.blockID);
@@ -1608,19 +1883,21 @@
 				}
 			}
 
-			for(var6 = 0; var6 < 80; ++var6) {
+			Profiler.endStartSection("tickTiles");
+			for(var6 = 0; var6 < 160; ++var6) {
 				this.updateLCG = this.updateLCG * 3 + this.DIST_HASH_MAGIC;
 				var7 = this.updateLCG >> 2;
 				var8 = var7 & 15;
 				var9 = var7 >> 8 & 15;
-				var10 = var7 >> 16 & 127;
-				byte var15 = var14.blocks[var8 << 11 | var9 << 7 | var10];
+				var10 = var7 >> 16 & 255;
+				short var15 = var14.blocks[var8 << CHUNK_BIT_OFFSET + 4 | var9 << CHUNK_BIT_OFFSET | var10];
 				if(Block.tickOnLoad[var15]) {
 					Block.blocksList[var15].updateTick(this, var8 + var3, var10, var9 + var4, this.rand);
 				}
 			}
-		}
 
+			Profiler.endSection();
+		}
 	}
 
 	public boolean tickUpdates(boolean var1) {
@@ -1765,6 +2042,7 @@
 	}
 
 	public PathEntity getPathToEntity(Entity var1, Entity var2, float var3) {
+		Profiler.startSection("pathfind");
 		int var4 = MathHelper.floor_double(var1.posX);
 		int var5 = MathHelper.floor_double(var1.posY);
 		int var6 = MathHelper.floor_double(var1.posZ);
@@ -1776,10 +2054,12 @@
 		int var12 = var5 + var7;
 		int var13 = var6 + var7;
 		ChunkCache var14 = new ChunkCache(this, var8, var9, var10, var11, var12, var13);
+		Profiler.endSection();
 		return (new Pathfinder(var14)).createEntityPathTo(var1, var2, var3);
 	}
 
 	public PathEntity getEntityPathToXYZ(Entity var1, int var2, int var3, int var4, float var5) {
+		Profiler.startSection("pathfind");
 		int var6 = MathHelper.floor_double(var1.posX);
 		int var7 = MathHelper.floor_double(var1.posY);
 		int var8 = MathHelper.floor_double(var1.posZ);
@@ -1791,7 +2071,9 @@
 		int var14 = var7 + var9;
 		int var15 = var8 + var9;
 		ChunkCache var16 = new ChunkCache(this, var10, var11, var12, var13, var14, var15);
-		return (new Pathfinder(var16)).createEntityPathTo(var1, var2, var3, var4, var5);
+		PathEntity var17 = (new Pathfinder(var16)).createEntityPathTo(var1, var2, var3, var4, var5);
+		Profiler.endSection();
+		return var17;
 	}
 
 	public boolean isBlockProvidingPowerTo(int var1, int var2, int var3, int var4) {
@@ -1836,8 +2118,24 @@
 		return var11;
 	}
 
+	public EntityPlayer getClosestPlayer2D(double var1, double var5, double var7) {
+		double var9 = -1.0D;
+		EntityPlayer var11 = null;
+
+		for(int var12 = 0; var12 < this.playerEntities.size(); ++var12) {
+			EntityPlayer var13 = (EntityPlayer)this.playerEntities.get(var12);
+			double var14 = var13.getDistanceSq(var1, var13.posY, var5);
+			if((var7 < 0.0D || var14 < var7 * var7) && (var9 == -1.0D || var14 < var9)) {
+				var9 = var14;
+				var11 = var13;
+			}
+		}
+
+		return var11;
+	}
+
 	public byte[] getChunkData(int var1, int var2, int var3, int var4, int var5, int var6) {
-		byte[] var7 = new byte[var4 * var5 * var6 * 5 / 2];
+		byte[] var7 = new byte[var4 * var5 * var6 * 8 / 2];
 		int var8 = var1 >> 4;
 		int var9 = var3 >> 4;
 		int var10 = var1 + var4 - 1 >> 4;
@@ -1849,8 +2147,8 @@
 			var13 = 0;
 		}
 
-		if(var14 > 128) {
-			var14 = 128;
+		if(var14 > CHUNK_HEIGHT) {
+			var14 = CHUNK_HEIGHT;
 		}
 
 		for(int var15 = var8; var15 <= var10; ++var15) {
@@ -1882,7 +2180,7 @@
 		return var7;
 	}
 
-	public void setChunkData(int var1, int var2, int var3, int var4, int var5, int var6, byte[] var7) {
+	public void setChunkData(int var1, int var2, int var3, int var4, int var5, int var6, byte[] var7, boolean var8x) {
 		int var8 = var1 >> 4;
 		int var9 = var3 >> 4;
 		int var10 = var1 + var4 - 1 >> 4;
@@ -1894,8 +2192,8 @@
 			var13 = 0;
 		}
 
-		if(var14 > 128) {
-			var14 = 128;
+		if(var14 > CHUNK_HEIGHT) {
+			var14 = CHUNK_HEIGHT;
 		}
 
 		for(int var15 = var8; var15 <= var10; ++var15) {
@@ -1920,7 +2218,9 @@
 					var20 = 16;
 				}
 
-				var12 = this.getChunkFromChunkCoords(var15, var18).setChunkData(var7, var16, var13, var19, var17, var14, var20, var12);
+				Chunk c = this.getChunkFromChunkCoords(var15, var18);
+				if (var8x) c.resetRelightChecks();
+				var12 = c.setChunkData(var7, var16, var13, var19, var17, var14, var20, var12);
 				this.markBlocksDirty(var15 * 16 + var16, var13, var18 * 16 + var19, var15 * 16 + var17, var14, var18 * 16 + var20);
 			}
 		}
@@ -1970,6 +2270,168 @@
 
 	}
 
+	public void applyCreationInfo(CreateWorldInfo info) {
+		this.displayName = info.name;
+		this.randomSeed = info.seed;
+		this.worldType = info.worldType;
+		this.creative = info.creative;
+	}
+
+	public boolean hasSolidCeiling(int x, int y, int z) {
+		for (; y < CHUNK_HEIGHT; y++) {
+			if (this.getBlockMaterial(x, y, z).isSolid()) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public void miscUpdates() {
+		Profiler.startSection("starfall");
+		if (this.starfallChance > 0 && this.canDoClientAction() && this.worldTime % 24000 >= 13000 && this.worldTime % 24000 < 23000) {
+			for (EntityPlayer player : (List<EntityPlayer>)this.playerEntities) {
+				if (rand.nextInt(this.starfallChance) != 0) continue;
+
+				EntityItem star = new EntityItem(
+						this,
+						player.posX + (rand.nextDouble() * 512.0 - 256.0),
+						200,
+						player.posZ + (rand.nextDouble() * 512.0 - 256.0),
+						new ItemStack(Item.starChunk)
+				);
+				this.spawnEntityInWorld(star);
+				star.age = 6000 - (23000 - ((int) this.worldTime % 24000));
+			}
+		} else if (this.worldTime % 24000 < 13000 || this.starfallChance <= 0) {
+			this.starfallChance = rand.nextInt(750) + 250;
+		}
+		Profiler.endSection();
+
+		ModLoader.callHook(BaseMod::onWorldTick, this);
+	}
+
+	public void sendTrackedEntityStatusUpdatePacket(Entity var1, byte var2) {
+	}
+
+	public void removePlayer(Entity var1) {
+		var1.setEntityDead();
+		if(var1 instanceof EntityPlayer) {
+			this.playerEntities.remove((EntityPlayer)var1);
+		}
+
+		int var2 = var1.chunkCoordX;
+		int var3 = var1.chunkCoordZ;
+		if(var1.addedToChunk && this.chunkExists(var2, var3)) {
+			this.getChunkFromChunkCoords(var2, var3).removeEntity(var1);
+		}
+
+		this.loadedEntityList.remove(var1);
+		this.releaseEntitySkin(var1);
+	}
+
+	public float getTemperature(double x, double z) {
+		if (this.worldType == WorldType.CLASSIC || this.worldType == WorldType.SUPERFLAT) return 0.5F;
+		if (this.worldType == WorldType.WINTER) return 0.0F;
+		if (this.worldType == WorldType.ARID) return 1.0F;
+
+		double biomeSize = 0.0005D;
+		float biomeBlend = 0.01F;
+
+		float temperature = MathHelper.clamp(SimplexOctaves.noise3_ImproveXY(this.randomSeed,
+				x * biomeSize, z * biomeSize, 1000, 2) / 1.5F + 0.5F
+				+ (this.rand.nextFloat() * biomeBlend * 2.0F - biomeBlend)
+				+ SimplexNoise.noise3_ImproveXY(this.randomSeed, x / 50.0D, z / 50.0D, 1000) * 0.02F,
+				0.0F, 1.0F);
+
+		if (this.worldType == WorldType.TROPICAL) {
+			temperature = temperature / 3.0F + 0.66F;
+		}
+
+		return temperature;
+	}
+
+	public float getHumidity(double x, double z) {
+		if (this.worldType == WorldType.CLASSIC || this.worldType == WorldType.SUPERFLAT) return 0.5F;
+
+		double biomeSize = 0.0005D;
+		float biomeBlend = 0.01F;
+
+		float humidity = MathHelper.clamp(SimplexOctaves.noise3_ImproveXY(this.randomSeed,
+				x * biomeSize, z * biomeSize, -1000, 2) / 1.5F + 0.5F
+				+ (this.rand.nextFloat() * biomeBlend * 2.0F - biomeBlend)
+				+ SimplexNoise.noise3_ImproveXY(this.randomSeed, x / 50.0D, z / 50.0D, -1000) * 0.02F,
+				0.0F, 1.0F);
+
+		if (this.worldType == WorldType.ARID) {
+			humidity *= 0.35F;
+		} else if (this.worldType == WorldType.TROPICAL) {
+			humidity = humidity / 3.0F + 0.66F;
+		}
+
+		return humidity;
+	}
+
+	public Biome generateBiome(int x, int z) {
+		if (this.worldType == WorldType.CLASSIC || this.worldType == WorldType.SUPERFLAT) {
+			return Biome.forest;
+		}
+
+		if (this.chunkProvider.isOcean(x, z)) {
+			return Biome.ocean;
+		}
+
+		return Biome.getBiome(this.getTemperature(x, z), this.getHumidity(x, z));
+	}
+
+	public static int requiresConversion(File path, String worldName) {
+		File levelData = new File(new File(path, worldName), "level.dat");
+
+		if(levelData.exists()) {
+			try {
+				NBTTagCompound rootNBT = CompressedStreamTools.readCompressed(new FileInputStream(levelData));
+				NBTTagCompound dataCompound = rootNBT.getCompoundTag("Data");
+				int version = dataCompound.getInteger("version");
+
+				boolean doesNotHaveRegion = !(new File(new File(path, worldName), "region").exists());
+				boolean isNotMCRegionVersion = version == 0;
+				if (doesNotHaveRegion && isNotMCRegionVersion) {
+					return 19132;
+				} else {
+					return -1;
+				}
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		} else {
+			return -1;
+		}
+		return -1;
+	}
+
+	public void upgradeChunkHeight(Chunk chunk) {
+		this.chunkProvider.upgradeHeight(this.chunkProvider, chunk, this);
+	}
+
+	public static String toFolderName(String displayName, File saves) {
+		StringBuilder folderName = new StringBuilder();
+
+		for (int i = 0; i < displayName.length(); i++) {
+			char c = displayName.charAt(i);
+			String s = String.valueOf(c);
+			if (!Constants.ALLOWED_CHARACTERS.contains(s)
+					|| Constants.ILLEGAL_FOLDER_CHARACTERS.contains(s)) {
+				folderName.append("_");
+			} else {
+				folderName.append(c);
+			}
+		}
+
+		while (new File(saves, folderName.toString()).exists()) {
+			folderName.append('-');
+		}
+		return folderName.toString();
+	}
+
 	static {
 		float var0 = 0.05F;
 
@@ -1978,5 +2440,274 @@
 			lightBrightnessTable[var1] = (1.0F - var2) / (var2 * 3.0F + 1.0F) * (1.0F - var0) + var0;
 		}
 
+	}
+
+	private int computeSkyLightValue(int var1, int var2, int var3, int var4, int var5, int var6) {
+		int var7 = 0;
+		if(this.canBlockSeeTheSky(var2, var3, var4)) {
+			var7 = 15;
+		} else {
+			if(var6 == 0) {
+				var6 = 1;
+			}
+
+			int var8 = this.getSavedLightValue(EnumSkyBlock.Sky, var2 - 1, var3, var4) - var6;
+			int var9 = this.getSavedLightValue(EnumSkyBlock.Sky, var2 + 1, var3, var4) - var6;
+			int var10 = this.getSavedLightValue(EnumSkyBlock.Sky, var2, var3 - 1, var4) - var6;
+			int var11 = this.getSavedLightValue(EnumSkyBlock.Sky, var2, var3 + 1, var4) - var6;
+			int var12 = this.getSavedLightValue(EnumSkyBlock.Sky, var2, var3, var4 - 1) - var6;
+			int var13 = this.getSavedLightValue(EnumSkyBlock.Sky, var2, var3, var4 + 1) - var6;
+			if(var8 > var7) {
+				var7 = var8;
+			}
+
+			if(var9 > var7) {
+				var7 = var9;
+			}
+
+			if(var10 > var7) {
+				var7 = var10;
+			}
+
+			if(var11 > var7) {
+				var7 = var11;
+			}
+
+			if(var12 > var7) {
+				var7 = var12;
+			}
+
+			if(var13 > var7) {
+				var7 = var13;
+			}
+		}
+
+		return var7;
+	}
+
+	public boolean updateLightByType(EnumSkyBlock var1, int var2, int var3, int var4) {
+        if (!this.doChunksNearChunkExist(var2, var3, var4, 17)) {
+            return false;
+        } else {
+            int var5 = 0;
+            int var6 = 0;
+			Profiler.startSection("getBrightness");
+            int var7 = this.getSavedLightValue(var1, var2, var3, var4);
+            int var8 = this.computeLightValue(var2, var3, var4, var1);
+            int var9;
+            int var10;
+            int var11;
+            int var12;
+            int var13;
+            int var14;
+            int var15;
+            int var16;
+            int var17;
+
+            if (var8 > var7) {
+                this.lightUpdateBlockList[var6++] = 133152;
+            } else if (var8 < var7) {
+                this.lightUpdateBlockList[var6++] = 133152 | var7 << 18;
+
+                while (var5 < var6) {
+                    var9 = this.lightUpdateBlockList[var5++];
+                    var10 = (var9 & 63) - 32 + var2;
+                    var11 = (var9 >> 6 & 63) - 32 + var3;
+                    var12 = (var9 >> 12 & 63) - 32 + var4;
+                    var13 = var9 >> 18 & 15;
+                    var14 = this.getSavedLightValue(var1, var10, var11, var12);
+
+                    if (var14 == var13) {
+                        this.setLightValue(var1, var10, var11, var12, 0);
+
+                        if (var13 > 0) {
+                            var15 = Math.abs(var10 - var2);
+                            var16 = Math.abs(var11 - var3);
+                            var17 = Math.abs(var12 - var4);
+
+                            if (var15 + var16 + var17 < 17) {
+                                for (int var18 = 0; var18 < 6; ++var18) {
+                                    int var19 = var10 + Facing.offsetsXForSide[var18];
+                                    int var20 = var11 + Facing.offsetsYForSide[var18];
+                                    int var21 = var12 + Facing.offsetsZForSide[var18];
+                                    int var22 = Math.max(1, Block.lightOpacity[this.getBlockId(var19, var20, var21)]);
+                                    var14 = this.getSavedLightValue(var1, var19, var20, var21);
+
+                                    if (var14 == var13 - var22 && var6 < this.lightUpdateBlockList.length) {
+                                        this.lightUpdateBlockList[var6++] = var19 - var2 + 32
+                                                | var20 - var3 + 32 << 6 | var21 - var4 + 32 << 12
+                                                | var13 - var22 << 18;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                var5 = 0;
+            }
+			
+			Profiler.endStartSection("tcp < tcc");
+
+            while (var5 < var6) {
+                var9 = this.lightUpdateBlockList[var5++];
+                var10 = (var9 & 63) - 32 + var2;
+                var11 = (var9 >> 6 & 63) - 32 + var3;
+                var12 = (var9 >> 12 & 63) - 32 + var4;
+                var13 = this.getSavedLightValue(var1, var10, var11, var12);
+                var14 = this.computeLightValue(var10, var11, var12, var1);
+
+                if (var14 != var13) {
+                    this.setLightValue(var1, var10, var11, var12, var14);
+
+                    if (var14 > var13) {
+                        var15 = Math.abs(var10 - var2);
+                        var16 = Math.abs(var11 - var3);
+                        var17 = Math.abs(var12 - var4);
+                        boolean var23 = var6 < this.lightUpdateBlockList.length - 6;
+
+                        if (var15 + var16 + var17 < 17 && var23) {
+                            if (this.getSavedLightValue(var1, var10 - 1, var11, var12) < var14) {
+                                this.lightUpdateBlockList[var6++] = var10 - 1 - var2 + 32
+                                        + (var11 - var3 + 32 << 6) + (var12 - var4 + 32 << 12);
+                            }
+
+                            if (this.getSavedLightValue(var1, var10 + 1, var11, var12) < var14) {
+                                this.lightUpdateBlockList[var6++] = var10 + 1 - var2 + 32
+                                        + (var11 - var3 + 32 << 6) + (var12 - var4 + 32 << 12);
+                            }
+
+                            if (this.getSavedLightValue(var1, var10, var11 - 1, var12) < var14) {
+                                this.lightUpdateBlockList[var6++] = var10 - var2 + 32
+                                        + (var11 - 1 - var3 + 32 << 6) + (var12 - var4 + 32 << 12);
+                            }
+
+                            if (this.getSavedLightValue(var1, var10, var11 + 1, var12) < var14) {
+                                this.lightUpdateBlockList[var6++] = var10 - var2 + 32
+                                        + (var11 + 1 - var3 + 32 << 6) + (var12 - var4 + 32 << 12);
+                            }
+
+                            if (this.getSavedLightValue(var1, var10, var11, var12 - 1) < var14) {
+                                this.lightUpdateBlockList[var6++] = var10 - var2 + 32
+                                        + (var11 - var3 + 32 << 6) + (var12 - 1 - var4 + 32 << 12);
+                            }
+
+                            if (this.getSavedLightValue(var1, var10, var11, var12 + 1) < var14) {
+                                this.lightUpdateBlockList[var6++] = var10 - var2 + 32
+                                        + (var11 - var3 + 32 << 6) + (var12 + 1 - var4 + 32 << 12);
+                            }
+                        }
+                    }
+                }
+            }
+
+			Profiler.endSection();
+            return true;
+        }
+    }
+
+	public boolean updateAllLightTypes(int var1, int var2, int var3) {
+		Profiler.startSection("updateLight");
+		boolean success = false;
+		success |= this.updateLightByType(EnumSkyBlock.Sky, var1, var2, var3);
+		success |= this.updateLightByType(EnumSkyBlock.Block, var1, var2, var3);
+		Profiler.endSection();
+		return success;
+	}
+
+	private int computeLightValue(int var1, int var2, int var3, EnumSkyBlock var4) {
+        if (var4 == EnumSkyBlock.Sky && this.canBlockSeeTheSky(var1, var2, var3)) {
+            return 15;
+        } else {
+            int var5 = this.getBlockId(var1, var2, var3);
+            int var6 = var4 == EnumSkyBlock.Sky ? 0 : Block.lightValue[var5];
+            int var7 = Block.lightOpacity[var5];
+
+            if (var7 >= 15 && Block.lightValue[var5] > 0) {
+                var7 = 1;
+            }
+
+            if (var7 < 1) {
+                var7 = 1;
+            }
+
+            if (var7 >= 15) {
+                return 0;
+            } else if (var6 >= 14) {
+                return var6;
+            } else {
+                for (int var8 = 0; var8 < 6; ++var8) {
+                    int var9 = var1 + Facing.offsetsXForSide[var8];
+                    int var10 = var2 + Facing.offsetsYForSide[var8];
+                    int var11 = var3 + Facing.offsetsZForSide[var8];
+                    int var12 = this.getSavedLightValue(var4, var9, var10, var11) - var7;
+
+                    if (var12 > var6) {
+                        var6 = var12;
+                    }
+
+                    if (var6 >= 14) {
+                        return var6;
+                    }
+                }
+
+                return var6;
+            }
+        }
+    }
+
+	public boolean isAABBEmpty(AxisAlignedBB var1) {
+		int var2 = MathHelper.floor_double(var1.minX);
+		int var3 = MathHelper.floor_double(var1.maxX + 1.0D);
+		int var4 = MathHelper.floor_double(var1.minY);
+		int var5 = MathHelper.floor_double(var1.maxY + 1.0D);
+		int var6 = MathHelper.floor_double(var1.minZ);
+		int var7 = MathHelper.floor_double(var1.maxZ + 1.0D);
+		if(var1.minX < 0.0D) {
+			--var2;
+		}
+
+		if(var1.minY < 0.0D) {
+			--var4;
+		}
+
+		if(var1.minZ < 0.0D) {
+			--var6;
+		}
+
+		for(int var8 = var2; var8 < var3; ++var8) {
+			for(int var9 = var4; var9 < var5; ++var9) {
+				for(int var10 = var6; var10 < var7; ++var10) {
+					Block var11 = Block.blocksList[this.getBlockId(var8, var9, var10)];
+					if(var11 != null) {
+						return true;
+					}
+				}
+			}
+		}
+
+		return false;
+	}
+
+	public CreateWorldInfo getCreateWorldInfo() {
+		return new CreateWorldInfo()
+				.withName(this.displayName)
+				.withSeed(this.randomSeed)
+				.withWorldType(this.worldType)
+				.withCreative(this.creative);
+	}
+
+	public void performActionGeneric(int var1, int var2, int var3, int var4, int var5) {
+		this.performAction(null, var1, var2, var3, var4, var5);
+	}
+
+	public void performAction(EntityPlayer var1, int var2, int var3, int var4, int var5, int var6) {
+		for(int var7 = 0; var7 < this.worldAccesses.size(); ++var7) {
+			((IWorldAccess)this.worldAccesses.get(var7)).performAction(var1, var2, var3, var4, var5, var6);
+		}
+	}
+
+	public IChunkProvider getIChunkProvider() {
+		return this.chunkProvider;
 	}
 }
--- /dev/null
+++ net/minecraft/src/ModelBlock.java
@@ -1,0 +1,11 @@
+package net.minecraft.src;
+
+public class ModelBlock {
+	public final String name;
+	public final int texture;
+
+	public ModelBlock(String name, int texture) {
+		this.name = name;
+		this.texture = texture;
+	}
+}
--- net/minecraft/src/StepSoundGlass.java
+++ net/minecraft/src/StepSoundGlass.java
@@ -1,7 +1,7 @@
 package net.minecraft.src;
 
-final class StepSoundGlass extends StepSound {
-	StepSoundGlass(String var1, float var2, float var3) {
+public final class StepSoundGlass extends StepSound {
+	public StepSoundGlass(String var1, float var2, float var3) {
 		super(var1, var2, var3);
 	}
 
--- net/minecraft/src/ItemSign.java
+++ net/minecraft/src/ItemSign.java
@@ -3,11 +3,10 @@
 public class ItemSign extends Item {
 	public ItemSign(int var1) {
 		super(var1);
-		this.maxDamage = 64;
 		this.maxStackSize = 1;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var7 == 0) {
 			return false;
 		} else if(!var3.getBlockMaterial(var4, var5, var6).isSolid()) {
--- net/minecraft/src/BlockSnow.java
+++ net/minecraft/src/BlockSnow.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockSnow extends Block {
-	protected BlockSnow(int var1, int var2) {
+	public BlockSnow(int var1, int var2) {
 		super(var1, var2, Material.snow);
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 2.0F / 16.0F, 1.0F);
 		this.setTickOnLoad(true);
@@ -23,7 +23,7 @@
 
 	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
 		int var5 = var1.getBlockId(var2, var3 - 1, var4);
-		return var5 != 0 && Block.blocksList[var5].isOpaqueCube() ? var1.getBlockMaterial(var2, var3 - 1, var4).getIsSolid() : false;
+		return var5 != 0 && Block.blocksList[var5].isOpaqueCube() || var5 == Block.leaves.blockID ? var1.getBlockMaterial(var2, var3 - 1, var4).getIsSolid() : false;
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
@@ -41,15 +41,25 @@
 	}
 
 	public void harvestBlock(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = Item.snowball.shiftedIndex;
-		float var7 = 0.7F;
-		double var8 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.5D;
-		double var10 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.5D;
-		double var12 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.5D;
-		EntityItem var14 = new EntityItem(var1, (double)var2 + var8, (double)var3 + var10, (double)var4 + var12, new ItemStack(var6));
-		var14.delayBeforeCanPickup = 10;
-		var1.spawnEntityInWorld(var14);
-		var1.setBlockWithNotify(var2, var3, var4, 0);
+		ItemStack itemStack = new ItemStack(Item.snowball.shiftedIndex);
+		float var10 = 0.7F;
+		double var11 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
+		double var13 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
+		double var15 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
+		EntityItem var17 = new EntityItem(var1, (double)var2 + var11, (double)var3 + var13, (double)var4 + var15, itemStack);
+		var17.delayBeforeCanPickup = 10;
+		var1.spawnEntityInWorld(var17);
+	}
+
+	public void harvestBlockSilk(World var1, int var2, int var3, int var4, int var5) {
+		ItemStack itemStack = new ItemStack(this.blockID);
+		float var10 = 0.7F;
+		double var11 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
+		double var13 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
+		double var15 = (double)(var1.rand.nextFloat() * var10) + (double)(1.0F - var10) * 0.5D;
+		EntityItem var17 = new EntityItem(var1, (double)var2 + var11, (double)var3 + var13, (double)var4 + var15, itemStack);
+		var17.delayBeforeCanPickup = 10;
+		var1.spawnEntityInWorld(var17);
 	}
 
 	public int idDropped(int var1, Random var2) {
@@ -58,6 +68,10 @@
 
 	public int quantityDropped(Random var1) {
 		return 0;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
 	}
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
--- net/minecraft/src/EntityRenderer.java
+++ net/minecraft/src/EntityRenderer.java
@@ -1,9 +1,13 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.nio.FloatBuffer;
 import java.util.List;
 import java.util.Random;
+
 import net.minecraft.client.Minecraft;
+import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.GL11;
@@ -27,6 +31,7 @@
 	float fogColorBlue;
 	private float prevFogColor;
 	private float fogColor;
+	private long renderEndNanoTime = 0L;
 
 	public EntityRenderer(Minecraft var1) {
 		this.mc = var1;
@@ -36,7 +41,7 @@
 	public void updateRenderer() {
 		this.prevFogColor = this.fogColor;
 		float var1 = this.mc.theWorld.getBrightness(MathHelper.floor_double(this.mc.thePlayer.posX), MathHelper.floor_double(this.mc.thePlayer.posY), MathHelper.floor_double(this.mc.thePlayer.posZ));
-		float var2 = (float)(3 - this.mc.options.renderDistance) / 3.0F;
+		float var2 = Math.max(MathHelper.log2(this.mc.options.renderDistance) - 1.0F, 0.0F) / 3.0F;
 		float var3 = var1 * (1.0F - var2) + var2;
 		this.fogColor += (var3 - this.fogColor) * 0.1F;
 		++this.rendererUpdateCount;
@@ -50,6 +55,7 @@
 	public void getMouseOver(float var1) {
 		if(this.mc.thePlayer != null) {
 			double var2 = (double)this.mc.playerController.getBlockReachDistance();
+			this.mc.lastObjectMouseOver = this.mc.objectMouseOver;
 			this.mc.objectMouseOver = this.mc.thePlayer.rayTrace(var2, var1);
 			double var4 = var2;
 			Vec3D var6 = this.mc.thePlayer.getPosition(var1);
@@ -93,22 +99,51 @@
 				this.mc.objectMouseOver = new MovingObjectPosition(this.pointedEntity);
 			}
 
+		} else {
+			this.mc.lastObjectMouseOver = null;
 		}
 	}
+
+	private long lastFovUpdate = System.currentTimeMillis();
+	private float fov = 0.0F;
 
 	private float getFOVModifier(float var1) {
+		float delta = Math.min(System.currentTimeMillis() - this.lastFovUpdate, 10000L) / 1000.0F;
+
 		EntityPlayerSP var2 = this.mc.thePlayer;
-		float var3 = 70.0F;
-		if(var2.isInsideOfMaterial(Material.water)) {
-			var3 = 60.0F;
-		}
-
-		if(var2.health <= 0) {
+		float var3 = 30.0F + this.mc.options.fov * 90.0F;
+
+		if (Keyboard.isKeyDown(this.mc.options.keyBindZoom.keyCode) && this.mc.currentScreen == null) {
+			var3 = 30.0F;
+		}
+
+		if (var2.isInsideOfMaterial(Material.water)) {
+			var3 *= 0.85F;
+		}
+
+		if (var2.health <= 0) {
 			float var4 = (float)var2.deathTime + var1;
-			var3 /= (1.0F - 500.0F / (var4 + 500.0F)) * 2.0F + 1.0F;
-		}
-
-		return var3;
+			var3 /= ((1.0F - 500.0F / (var4 + 500.0F)) * 2.0F) * this.mc.options.fovEffects + 1.0F;
+		}
+
+		if (var2.flying) {
+			var3 *= 1.1F;
+		}
+
+		if (var2.isRunning()) {
+			var3 *= 1.0F + (0.1F * this.mc.options.fovEffects - (20.0F - var2.energy) / 400.0F);
+		}
+
+		var3 *= 1.0F + var2.energyBoost * this.mc.options.fovEffects;
+
+		if (fov == 0.0F) {
+			fov = var3;
+		} else {
+			fov = MathHelper.lerp(fov, var3, (float)(1 - Math.pow(0.1D, delta * 5.0F)));
+		}
+
+		this.lastFovUpdate = System.currentTimeMillis();
+		return fov;
 	}
 
 	private void hurtCameraEffect(float var1) {
@@ -131,7 +166,7 @@
 	}
 
 	private void setupViewBobbing(float var1) {
-		if(!this.mc.options.thirdPersonView) {
+		if (this.mc.options.thirdPersonView == 0) {
 			EntityPlayerSP var2 = this.mc.thePlayer;
 			float var3 = var2.distanceWalkedModified - var2.prevDistanceWalkedModified;
 			float var4 = var2.distanceWalkedModified + var3 * var1;
@@ -149,21 +184,34 @@
 		double var3 = var2.prevPosX + (var2.posX - var2.prevPosX) * (double)var1;
 		double var5 = var2.prevPosY + (var2.posY - var2.prevPosY) * (double)var1;
 		double var7 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * (double)var1;
-		if(this.mc.options.thirdPersonView) {
+		if (this.mc.options.thirdPersonView > 0) {
 			double var9 = 4.0D;
 			float var11 = var2.rotationYaw;
 			float var12 = var2.rotationPitch;
+			float var4 = 0.0F;
 			double var13 = (double)(-MathHelper.sin(var11 / 180.0F * (float)Math.PI) * MathHelper.cos(var12 / 180.0F * (float)Math.PI)) * var9;
 			double var15 = (double)(MathHelper.cos(var11 / 180.0F * (float)Math.PI) * MathHelper.cos(var12 / 180.0F * (float)Math.PI)) * var9;
 			double var17 = (double)(-MathHelper.sin(var12 / 180.0F * (float)Math.PI)) * var9;
 
+			if (this.mc.options.thirdPersonView == 2) {
+				var13 = (double)(-MathHelper.sin((var11 + 180.0F) / 180.0F * (float)Math.PI) * MathHelper.cos(-var12 / 180.0F * (float)Math.PI)) * var9;
+				var15 = (double)(MathHelper.cos((var11 + 180.0F) / 180.0F * (float)Math.PI) * MathHelper.cos(-var12 / 180.0F * (float)Math.PI)) * var9;
+				var17 = (double)(-MathHelper.sin(-var12 / 180.0F * (float)Math.PI)) * var9;
+			}
+
 			for(int var19 = 0; var19 < 8; ++var19) {
 				float var20 = (float)((var19 & 1) * 2 - 1);
 				float var21 = (float)((var19 >> 1 & 1) * 2 - 1);
 				float var22 = (float)((var19 >> 2 & 1) * 2 - 1);
-				var20 *= 0.1F;
-				var21 *= 0.1F;
-				var22 *= 0.1F;
+				if (this.mc.options.thirdPersonView == 2) {
+					var20 *= -0.1F;
+					var21 *= -0.1F;
+					var22 *= -0.1F;
+				} else {
+					var20 *= 0.1F;
+					var21 *= 0.1F;
+					var22 *= 0.1F;
+				}
 				MovingObjectPosition var23 = this.mc.theWorld.rayTraceBlocks(Vec3D.createVector(var3 + (double)var20, var5 + (double)var21, var7 + (double)var22), Vec3D.createVector(var3 - var13 + (double)var20 + (double)var22, var5 - var17 + (double)var21, var7 - var15 + (double)var22));
 				if(var23 != null) {
 					double var24 = var23.hitVec.distanceTo(Vec3D.createVector(var3, var5, var7));
@@ -173,8 +221,13 @@
 				}
 			}
 
+			if (this.mc.options.thirdPersonView == 2) {
+				var4 = 180.0F;
+				var9 *= -1.0D;
+			}
+
 			GL11.glRotatef(var2.rotationPitch - var12, 1.0F, 0.0F, 0.0F);
-			GL11.glRotatef(var2.rotationYaw - var11, 0.0F, 1.0F, 0.0F);
+			GL11.glRotatef(var2.rotationYaw - var11 + var4, 0.0F, 1.0F, 0.0F);
 			GL11.glTranslatef(0.0F, 0.0F, (float)(-var9));
 			GL11.glRotatef(var11 - var2.rotationYaw, 0.0F, 1.0F, 0.0F);
 			GL11.glRotatef(var12 - var2.rotationPitch, 1.0F, 0.0F, 0.0F);
@@ -187,7 +240,7 @@
 	}
 
 	private void setupCameraTransform(float var1, int var2) {
-		this.farPlaneDistance = (float)(256 >> this.mc.options.renderDistance);
+		this.farPlaneDistance = 32 * this.mc.options.renderDistance;
 		GL11.glMatrixMode(GL11.GL_PROJECTION);
 		GL11.glLoadIdentity();
 		float var3 = 0.07F;
@@ -211,6 +264,15 @@
 	}
 
 	private void renderHand(float var1, int var2) {
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glLoadIdentity();
+		float var3 = 0.07F;
+		if(this.mc.options.anaglyph) {
+			GL11.glTranslatef((float)(-(var2 * 2 - 1)) * var3, 0.0F, 0.0F);
+		}
+
+		GLU.gluPerspective(MathHelper.lerp(70.0F, this.getFOVModifier(var1), this.mc.options.fovHand), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance);
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
 		GL11.glLoadIdentity();
 		if(this.mc.options.anaglyph) {
 			GL11.glTranslatef((float)(var2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
@@ -222,12 +284,12 @@
 			this.setupViewBobbing(var1);
 		}
 
-		if(!this.mc.options.thirdPersonView) {
+		if(this.mc.options.thirdPersonView == 0) {
 			this.itemRenderer.renderItemInFirstPerson(var1);
 		}
 
 		GL11.glPopMatrix();
-		if(!this.mc.options.thirdPersonView) {
+		if(this.mc.options.thirdPersonView == 0) {
 			this.itemRenderer.renderOverlays(var1);
 			this.hurtCameraEffect(var1);
 		}
@@ -247,6 +309,7 @@
 			this.prevFrameTime = System.currentTimeMillis();
 		}
 
+		Profiler.startSection("mouse");
 		if(this.mc.inGameHasFocus) {
 			this.mc.mouseHelper.mouseXYChange();
 			float var2 = this.mc.options.mouseSensitivity * 0.6F + 0.2F;
@@ -260,16 +323,30 @@
 
 			this.mc.thePlayer.setAngles(var4, var5 * (float)var6);
 		}
+		Profiler.endSection();
 
 		if(!this.mc.skipRenderWorld) {
-			ScaledResolution var7 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
+			ScaledResolution var7 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight, this.mc.options.guiScale);
 			int var8 = var7.getScaledWidth();
 			int var9 = var7.getScaledHeight();
 			int var10 = Mouse.getX() * var8 / this.mc.displayWidth;
 			int var11 = var9 - Mouse.getY() * var9 / this.mc.displayHeight - 1;
 			if(this.mc.theWorld != null) {
-				this.renderWorld(var1);
+				Profiler.startSection("level");
+				int fps = this.mc.options.maxFps;
+				if (fps == 0) {
+					fps = Display.getDisplayMode().getFrequency();
+				}
+
+				if (this.mc.options.maxFps < 250 && this.mc.options.maxFps > 0) {
+					this.renderWorld(var1, this.renderEndNanoTime + 1000000000L / fps);
+				} else {
+					this.renderWorld(var1, 0L);
+				}
+				this.renderEndNanoTime = System.nanoTime();
+				Profiler.endStartSection("gui");
 				this.mc.ingameGUI.renderGameOverlay(var1, this.mc.currentScreen != null, var10, var11);
+				Profiler.endSection();
 			} else {
 				GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
 				GL11.glClearColor(0.0F, 0.0F, 0.0F, 0.0F);
@@ -289,7 +366,8 @@
 		}
 	}
 
-	public void renderWorld(float var1) {
+	public void renderWorld(float var1, long var0) {
+		Profiler.startSection("pick");
 		this.getMouseOver(var1);
 		EntityPlayerSP var2 = this.mc.thePlayer;
 		RenderGlobal var3 = this.mc.renderGlobal;
@@ -298,7 +376,7 @@
 		double var7 = var2.lastTickPosY + (var2.posY - var2.lastTickPosY) * (double)var1;
 		double var9 = var2.lastTickPosZ + (var2.posZ - var2.lastTickPosZ) * (double)var1;
 
-		for(int var11 = 0; var11 < 2; ++var11) {
+		for(int var11 = 0; var11 < (this.mc.options.anaglyph ? 2 : 1); ++var11) {
 			if(this.mc.options.anaglyph) {
 				if(var11 == 0) {
 					GL11.glColorMask(false, true, true, false);
@@ -307,36 +385,57 @@
 				}
 			}
 
+			Profiler.endStartSection("clear");
 			GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
 			this.updateFogColor(var1);
 			GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT | GL11.GL_COLOR_BUFFER_BIT);
 			GL11.glEnable(GL11.GL_CULL_FACE);
+			Profiler.endStartSection("camera");
 			this.setupCameraTransform(var1, var11);
+			Profiler.endStartSection("frustrum");
 			ClippingHelperImplementation.getInstance();
-			if(this.mc.options.renderDistance < 2) {
-				this.setupFog(-1);
-				var3.renderSky(var1);
-			}
+			this.setupFog(-1);
+			Profiler.endStartSection("sky");
+			var3.renderSky(var1);
 
 			GL11.glEnable(GL11.GL_FOG);
 			this.setupFog(1);
+			if (this.mc.options.ambientOcclusion) {
+				GL11.glShadeModel(GL11.GL_SMOOTH);
+			}
+
+			Profiler.endStartSection("culling");
 			Frustum var12 = new Frustum();
 			var12.setPosition(var5, var7, var9);
 			this.mc.renderGlobal.clipRenderersByFrustum(var12, var1);
-			this.mc.renderGlobal.updateRenderers(var2, false);
+			if (var11 == 0) {
+				Profiler.endStartSection("updatechunks");
+				while (!this.mc.renderGlobal.updateRenderers(var2, true)) {
+					long t = var0 - System.nanoTime();
+					if (t < 0L || t > 1000000000L) {
+						break;
+					}
+				}
+			}
 			this.setupFog(0);
 			GL11.glEnable(GL11.GL_FOG);
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
 			RenderHelper.disableStandardItemLighting();
+			Profiler.endStartSection("terrain");
 			var3.sortAndRender(var2, 0, (double)var1);
+			GL11.glShadeModel(GL11.GL_FLAT);
 			RenderHelper.enableStandardItemLighting();
+			Profiler.endStartSection("entities");
 			var3.renderEntities(var2.getPosition(var1), var12, var1);
+			Profiler.endStartSection("litParticles");
 			var4.renderLitParticles(var2, var1);
 			RenderHelper.disableStandardItemLighting();
 			this.setupFog(0);
+			Profiler.endStartSection("particles");
 			var4.renderParticles(var2, var1);
-			if(this.mc.objectMouseOver != null && var2.isInsideOfMaterial(Material.water)) {
+			if(this.mc.objectMouseOver != null && var2.isInsideOfMaterial(Material.water) && this.mc.showHud) {
 				GL11.glDisable(GL11.GL_ALPHA_TEST);
+				Profiler.endStartSection("outline");
 				var3.drawBlockBreaking(var2, this.mc.objectMouseOver, 0, var2.inventory.getCurrentItem(), var1);
 				var3.drawSelectionBox(var2, this.mc.objectMouseOver, 0, var2.inventory.getCurrentItem(), var1);
 				GL11.glEnable(GL11.GL_ALPHA_TEST);
@@ -347,60 +446,79 @@
 			GL11.glEnable(GL11.GL_BLEND);
 			GL11.glDisable(GL11.GL_CULL_FACE);
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
-			if(this.mc.options.fancyGraphics) {
+			if(this.mc.options.fancyGraphics > 0) {
+				Profiler.endStartSection("water");
+				if (this.mc.options.ambientOcclusion) {
+					GL11.glShadeModel(GL11.GL_SMOOTH);
+				}
 				GL11.glColorMask(false, false, false, false);
-				int var13 = var3.sortAndRender(var2, 1, (double)var1);
-				GL11.glColorMask(true, true, true, true);
+				int var13 = this.mc.options.fastRender ? var3.renderAllSortedRenderers(1, (double)var1) : var3.sortAndRender(var2, 1, (double)var1);
+				if (!this.mc.options.fastRender) {
+					GL11.glColorMask(true, true, true, true);
+				}
 				if(this.mc.options.anaglyph) {
 					if(var11 == 0) {
-						GL11.glColorMask(false, true, true, false);
+						GL11.glColorMask(false, true, true, true);
 					} else {
-						GL11.glColorMask(true, false, false, false);
+						GL11.glColorMask(true, false, false, true);
 					}
+				} else if(this.mc.options.fastRender) {
+					GL11.glColorMask(true, true, true, true);
 				}
 
 				if(var13 > 0) {
-					var3.renderAllRenderLists(1, (double)var1);
+					if (Minecraft.fastRender()) {
+						var3.renderAllSortedRenderers(1, (double)var1);
+					} else {
+						var3.renderAllRenderLists(1, (double)var1);
+					}
 				}
+
+				GL11.glShadeModel(GL11.GL_FLAT);
 			} else {
+				Profiler.endStartSection("water");
 				var3.sortAndRender(var2, 1, (double)var1);
 			}
 
 			GL11.glDepthMask(true);
 			GL11.glEnable(GL11.GL_CULL_FACE);
 			GL11.glDisable(GL11.GL_BLEND);
-			if(this.mc.objectMouseOver != null && !var2.isInsideOfMaterial(Material.water)) {
+			if(this.mc.objectMouseOver != null && !var2.isInsideOfMaterial(Material.water) && this.mc.showHud) {
 				GL11.glDisable(GL11.GL_ALPHA_TEST);
+				Profiler.endStartSection("outline");
 				var3.drawBlockBreaking(var2, this.mc.objectMouseOver, 0, var2.inventory.getCurrentItem(), var1);
 				var3.drawSelectionBox(var2, this.mc.objectMouseOver, 0, var2.inventory.getCurrentItem(), var1);
 				GL11.glEnable(GL11.GL_ALPHA_TEST);
 			}
 
+			Profiler.endStartSection("weather");
 			GL11.glDisable(GL11.GL_FOG);
-			if(this.mc.theWorld.snowCovered) {
-				this.renderSnow(var1);
-			}
-
-			if(this.pointedEntity != null) {
-			}
-
+			this.renderSnow(var1);
+
+			Profiler.endStartSection("clouds");
 			this.setupFog(0);
 			GL11.glEnable(GL11.GL_FOG);
 			var3.renderClouds(var1);
 			GL11.glDisable(GL11.GL_FOG);
 			this.setupFog(1);
+			
+			Profiler.endStartSection("hand");
 			GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
-			this.renderHand(var1, var11);
+			if(this.mc.showHud) {
+				this.renderHand(var1, var11);
+			}
 			if(!this.mc.options.anaglyph) {
+				Profiler.endSection();
 				return;
 			}
 		}
 
 		GL11.glColorMask(true, true, true, false);
+		Profiler.endSection();
 	}
 
 	private void addRainParticles() {
-		if(this.mc.options.fancyGraphics) {
+		if(this.mc.options.fancyGraphics > 0) {
 			EntityPlayerSP var1 = this.mc.thePlayer;
 			World var2 = this.mc.theWorld;
 			int var3 = MathHelper.floor_double(var1.posX);
@@ -441,12 +559,16 @@
 		double var10 = var2.lastTickPosY + (var2.posY - var2.lastTickPosY) * (double)var1;
 		double var12 = var2.lastTickPosZ + (var2.posZ - var2.lastTickPosZ) * (double)var1;
 		byte var14 = 5;
-		if(this.mc.options.fancyGraphics) {
+		if(this.mc.options.fancyGraphics > 0) {
 			var14 = 10;
 		}
 
 		for(int var15 = var4 - var14; var15 <= var4 + var14; ++var15) {
 			for(int var16 = var6 - var14; var16 <= var6 + var14; ++var16) {
+				if (var3.getBiome(var15, var16) != Biome.snowyTaiga) {
+					continue;
+				}
+
 				int var17 = var3.getTopSolidOrLiquidBlock(var15, var16);
 				if(var17 < 0) {
 					var17 = 0;
@@ -473,8 +595,8 @@
 					double var27 = (double)((float)var16 + 0.5F) - var2.posZ;
 					float var29 = MathHelper.sqrt_double(var25 * var25 + var27 * var27) / (float)var14;
 					var7.startDrawingQuads();
-					float var30 = var3.getBrightness(var15, 128, var16);
-					GL11.glColor4f(var30, var30, var30, (1.0F - var29 * var29) * 0.7F);
+					float var30 = var3.getBrightness(var15, CHUNK_HEIGHT, var16);
+					GL11.glColor4f(var30, var30, var30, (1.0F - var29 * var29) * (var3.worldType == WorldType.WINTER ? 0.7F : 0.3F));
 					var7.setTranslationD(-var8 * 1.0D, -var10 * 1.0D, -var12 * 1.0D);
 					var7.addVertexWithUV((double)(var15 + 0), (double)var18, (double)(var16 + 0), (double)(0.0F * var20 + var23), (double)((float)var18 * var20 / 8.0F + var22 * var20 + var24));
 					var7.addVertexWithUV((double)(var15 + 1), (double)var18, (double)(var16 + 1), (double)(1.0F * var20 + var23), (double)((float)var18 * var20 / 8.0F + var22 * var20 + var24));
@@ -495,7 +617,7 @@
 	}
 
 	public void setupOverlayRendering() {
-		ScaledResolution var1 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
+		ScaledResolution var1 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight, this.mc.options.guiScale);
 		int var2 = var1.getScaledWidth();
 		int var3 = var1.getScaledHeight();
 		GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
@@ -510,16 +632,36 @@
 	private void updateFogColor(float var1) {
 		World var2 = this.mc.theWorld;
 		EntityPlayerSP var3 = this.mc.thePlayer;
-		float var4 = 1.0F / (float)(4 - this.mc.options.renderDistance);
+		float var4 = 1.0F / Math.max(MathHelper.log2(this.mc.options.renderDistance), 0.1F);
 		var4 = 1.0F - (float)Math.pow((double)var4, 0.25D);
-		Vec3D var5 = var2.getSkyColor(var1);
+		double posX = MathHelper.lerp(var3.lastTickPosX, var3.posX, var1);
+		double posY = MathHelper.lerp(var3.lastTickPosY, var3.posY, var1);
+		double posZ = MathHelper.lerp(var3.lastTickPosZ, var3.posZ, var1);
+		float temp = var2.getTemperature(posX, posZ);
+		float hum = var2.getHumidity(posX, posZ);
+		Vec3D var5 = var2.getSkyColor(var1, temp, hum);
 		float var6 = (float)var5.xCoord;
 		float var7 = (float)var5.yCoord;
 		float var8 = (float)var5.zCoord;
-		Vec3D var9 = var2.getFogColor(var1);
+		Vec3D var9 = var2.getFogColor(var1, temp, hum);
 		this.fogColorRed = (float)var9.xCoord;
 		this.fogColorGreen = (float)var9.yCoord;
 		this.fogColorBlue = (float)var9.zCoord;
+		if (this.mc.theWorld.worldType != WorldType.SUPERFLAT) {
+			if (posY < 32.0D) {
+				this.fogColorRed = var6 = 0.2F;
+				this.fogColorGreen = var7 = 0.1F;
+				this.fogColorBlue = var8 = 0.4F;
+			} else if (posY < 48.0D) {
+				float lerp = (float)((posY - 32.0D) / -16.0D + 1.0D);
+				this.fogColorRed = MathHelper.lerp(this.fogColorRed, 0.2F, lerp);
+				this.fogColorGreen = MathHelper.lerp(this.fogColorGreen, 0.1F, lerp);
+				this.fogColorBlue = MathHelper.lerp(this.fogColorBlue, 0.4F, lerp);
+				var6 = MathHelper.lerp(var6, 0.2F, lerp);
+				var7 = MathHelper.lerp(var7, 0.1F, lerp);
+				var8 = MathHelper.lerp(var8, 0.4F, lerp);
+			}
+		}
 		this.fogColorRed += (var6 - this.fogColorRed) * var4;
 		this.fogColorGreen += (var7 - this.fogColorGreen) * var4;
 		this.fogColorBlue += (var8 - this.fogColorBlue) * var4;
@@ -583,13 +725,19 @@
 				var8 = (var3 * 30.0F + var5 * 70.0F) / 100.0F;
 			}
 		} else {
+			float dist = this.farPlaneDistance;
+			if (this.mc.theWorld.worldType != WorldType.SUPERFLAT) {
+				if (this.mc.thePlayer.posY < 32.0F) {
+					dist = Math.min(dist, 128.0F);
+				} else if (this.mc.thePlayer.posY < 48.0F) {
+					float lerp = (float)((this.mc.thePlayer.posY - 32.0D) / -16.0D + 1.0D);
+					dist = Math.min(dist, MathHelper.lerp(dist, 128.0F, lerp));
+				}
+			}
+
 			GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_LINEAR);
-			GL11.glFogf(GL11.GL_FOG_START, this.farPlaneDistance * 0.25F);
-			GL11.glFogf(GL11.GL_FOG_END, this.farPlaneDistance);
-			if(var1 < 0) {
-				GL11.glFogf(GL11.GL_FOG_START, 0.0F);
-				GL11.glFogf(GL11.GL_FOG_END, this.farPlaneDistance * 0.8F);
-			}
+			GL11.glFogf(GL11.GL_FOG_START, dist * 0.2F);
+			GL11.glFogf(GL11.GL_FOG_END, dist * 0.6F);
 
 			if(GLContext.getCapabilities().GL_NV_fog_distance) {
 				GL11.glFogi(NVFogDistance.GL_FOG_DISTANCE_MODE_NV, NVFogDistance.GL_EYE_RADIAL_NV);
@@ -600,9 +748,9 @@
 		GL11.glColorMaterial(GL11.GL_FRONT, GL11.GL_AMBIENT);
 	}
 
-	private FloatBuffer setFogColorBuffer(float var1, float var2, float var3, float var4) {
+	private FloatBuffer setFogColorBuffer(float r, float g, float b, float a) {
 		this.fogColorBuffer.clear();
-		this.fogColorBuffer.put(var1).put(var2).put(var3).put(var4);
+		this.fogColorBuffer.put(r).put(g).put(b).put(a);
 		this.fogColorBuffer.flip();
 		return this.fogColorBuffer;
 	}
--- /dev/null
+++ net/minecraft/src/MCHashTableLong.java
@@ -1,0 +1,128 @@
+package net.minecraft.src;
+
+public class MCHashTableLong {
+	private transient MCHashEntryLong[] slots = new MCHashEntryLong[16];
+	private transient int count;
+	private int threshold = 12;
+	private final float growFactor = 12.0F / 16.0F;
+	private transient volatile int versionStamp;
+
+	private static int computeHash(long var0) {
+		return computeHash((int)(var0 ^ var0 >>> 32));
+	}
+
+	private static int computeHash(int var0) {
+		var0 ^= var0 >>> 20 ^ var0 >>> 12;
+		return var0 ^ var0 >>> 7 ^ var0 >>> 4;
+	}
+
+	private static int getSlotIndex(int var0, int var1) {
+		return var0 & var1 - 1;
+	}
+
+	public Object lookup(long var1) {
+		int var3 = computeHash(var1);
+
+		for(MCHashEntryLong var4 = this.slots[getSlotIndex(var3, this.slots.length)]; var4 != null; var4 = var4.nextEntry) {
+			if(var4.hashEntry == var1) {
+				return var4.valueEntry;
+			}
+		}
+
+		return null;
+	}
+
+	public void addKey(long var1, Object var3) {
+		int var4 = computeHash(var1);
+		int var5 = getSlotIndex(var4, this.slots.length);
+
+		for(MCHashEntryLong var6 = this.slots[var5]; var6 != null; var6 = var6.nextEntry) {
+			if(var6.hashEntry == var1) {
+				var6.valueEntry = var3;
+			}
+		}
+
+		++this.versionStamp;
+		this.insert(var4, var1, var3, var5);
+	}
+
+	private void grow(int var1) {
+		MCHashEntryLong[] var2 = this.slots;
+		int var3 = var2.length;
+		if(var3 == 1073741824) {
+			this.threshold = Integer.MAX_VALUE;
+		} else {
+			MCHashEntryLong[] var4 = new MCHashEntryLong[var1];
+			this.copyTo(var4);
+			this.slots = var4;
+			this.threshold = (int)((float)var1 * this.growFactor);
+		}
+	}
+
+	private void copyTo(MCHashEntryLong[] var1) {
+		MCHashEntryLong[] var2 = this.slots;
+		int var3 = var1.length;
+
+		for(int var4 = 0; var4 < var2.length; ++var4) {
+			MCHashEntryLong var5 = var2[var4];
+			if(var5 != null) {
+				var2[var4] = null;
+
+				MCHashEntryLong var6;
+				do {
+					var6 = var5.nextEntry;
+					int var7 = getSlotIndex(var5.slotHash, var3);
+					var5.nextEntry = var1[var7];
+					var1[var7] = var5;
+					var5 = var6;
+				} while(var6 != null);
+			}
+		}
+
+	}
+
+	public Object removeObject(long var1) {
+		MCHashEntryLong var3 = this.removeEntry(var1);
+		return var3 == null ? null : var3.valueEntry;
+	}
+
+	public final MCHashEntryLong removeEntry(long var1) {
+		int var3 = computeHash(var1);
+		int var4 = getSlotIndex(var3, this.slots.length);
+		MCHashEntryLong var5 = this.slots[var4];
+
+		MCHashEntryLong var6;
+		MCHashEntryLong var7;
+		for(var6 = var5; var6 != null; var6 = var7) {
+			var7 = var6.nextEntry;
+			if(var6.hashEntry == var1) {
+				++this.versionStamp;
+				--this.count;
+				if(var5 == var6) {
+					this.slots[var4] = var7;
+				} else {
+					var5.nextEntry = var7;
+				}
+
+				return var6;
+			}
+
+			var5 = var6;
+		}
+
+		return var6;
+	}
+
+	private void insert(int var1, long var2, Object var4, int var5) {
+		MCHashEntryLong var6 = this.slots[var5];
+		this.slots[var5] = new MCHashEntryLong(var1, var2, var4, var6);
+		if(this.count++ >= this.threshold) {
+			this.grow(2 * this.slots.length);
+		}
+
+	}
+
+	public static int getHash(long var0) {
+		return computeHash(var0);
+	}
+}
--- net/minecraft/src/PlayerControllerCreative.java
+++ net/minecraft/src/PlayerControllerCreative.java
@@ -1,7 +1,6 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
-
 public class PlayerControllerCreative extends PlayerController {
 	public PlayerControllerCreative(Minecraft var1) {
 		super(var1);
--- net/minecraft/src/BlockLever.java
+++ net/minecraft/src/BlockLever.java
@@ -1,7 +1,7 @@
 package net.minecraft.src;
 
 public class BlockLever extends Block {
-	protected BlockLever(int var1, int var2) {
+	public BlockLever(int var1, int var2) {
 		super(var1, var2, Material.circuits);
 	}
 
@@ -25,31 +25,30 @@
 		return var1.isBlockNormalCube(var2 - 1, var3, var4) ? true : (var1.isBlockNormalCube(var2 + 1, var3, var4) ? true : (var1.isBlockNormalCube(var2, var3, var4 - 1) ? true : (var1.isBlockNormalCube(var2, var3, var4 + 1) ? true : var1.isBlockNormalCube(var2, var3 - 1, var4))));
 	}
 
-	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = var1.getBlockMetadata(var2, var3, var4);
-		int var7 = var6 & 8;
-		var6 &= 7;
+	public int onBlockPlaced(World var1, int var2, int var3, int var4, int var5, float hitx, float hity, float hitz, int meta) {
+		int var7 = meta & 8;
+		meta &= 7;
 		if(var5 == 1 && var1.isBlockNormalCube(var2, var3 - 1, var4)) {
-			var6 = 5 + var1.rand.nextInt(2);
+			meta = 5 + var1.rand.nextInt(2);
 		}
 
 		if(var5 == 2 && var1.isBlockNormalCube(var2, var3, var4 + 1)) {
-			var6 = 4;
+			meta = 4;
 		}
 
 		if(var5 == 3 && var1.isBlockNormalCube(var2, var3, var4 - 1)) {
-			var6 = 3;
+			meta = 3;
 		}
 
 		if(var5 == 4 && var1.isBlockNormalCube(var2 + 1, var3, var4)) {
-			var6 = 2;
+			meta = 2;
 		}
 
 		if(var5 == 5 && var1.isBlockNormalCube(var2 - 1, var3, var4)) {
-			var6 = 1;
+			meta = 1;
 		}
 
-		var1.setBlockMetadataWithNotify(var2, var3, var4, var6 + var7);
+		return meta + var7;
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
--- net/minecraft/src/EntityArrow.java
+++ net/minecraft/src/EntityArrow.java
@@ -18,6 +18,13 @@
 		this.setSize(0.5F, 0.5F);
 	}
 
+	public EntityArrow(World var1, double var2, double var4, double var6) {
+		super(var1);
+		this.setSize(0.5F, 0.5F);
+		this.setPosition(var2, var4, var6);
+		this.yOffset = 0.0F;
+	}
+
 	public EntityArrow(World var1, EntityLiving var2) {
 		super(var1);
 		this.shootingEntity = var2;
@@ -207,15 +214,25 @@
 	}
 
 	public void onCollideWithPlayer(EntityPlayer var1) {
-		if(this.inData && this.shootingEntity == var1 && this.arrowShake <= 0 && var1.inventory.addItemStackToInventory(new ItemStack(Item.arrow.shiftedIndex, 1))) {
-			this.worldObj.playSoundAtEntity(this, "random.pop", 0.2F, ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.7F + 1.0F) * 2.0F);
-			var1.onItemPickup(this, 1);
-			this.setEntityDead();
+		if(this.worldObj.canDoClientAction()) {
+			if(this.inData && this.shootingEntity == var1 && this.arrowShake <= 0 && var1.inventory.addItemStackToInventory(new ItemStack(Item.arrow.shiftedIndex, 1))) {
+				this.worldObj.playSoundAtEntity(this, "random.pop", 0.2F, ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.7F + 1.0F) * 2.0F);
+				var1.onItemPickup(this, 1);
+				this.setEntityDead();
+			}
 		}
-
 	}
 
 	public float getShadowSize() {
 		return 0.0F;
+	}
+
+	public void setVelocity(double var1, double var3, double var5) {
+		super.setVelocity(var1, var3, var5);
+		if(this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F) {
+			float var7 = MathHelper.sqrt_double(var1 * var1 + var5 * var5);
+			this.prevRotationYaw = this.rotationYaw = (float)(Math.atan2(var1, var5) * 180.0D / (double)((float)Math.PI));
+			this.prevRotationPitch = this.rotationPitch = (float)(Math.atan2(var3, (double)var7) * 180.0D / (double)((float)Math.PI));
+		}
 	}
 }
--- net/minecraft/src/BlockSapling.java
+++ net/minecraft/src/BlockSapling.java
@@ -1,9 +1,13 @@
 package net.minecraft.src;
 
 import java.util.Random;
+import java.util.stream.IntStream;
 
 public class BlockSapling extends BlockFlower {
-	protected BlockSapling(int var1, int var2) {
+	public final BitField fieldType = this.fields.addBitField("type", 3, BlockWood.woodTypeNames);
+	public final BitFlag fieldGrown = this.fields.addBitFlag("grown");
+
+	public BlockSapling(int var1, int var2) {
 		super(var1, var2);
 		float var3 = 0.4F;
 		this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 2.0F, 0.5F + var3);
@@ -11,22 +15,57 @@
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		super.updateTick(var1, var2, var3, var4, var5);
-		if(var1.getBlockLightValue(var2, var3 + 1, var4) >= 9 && var5.nextInt(5) == 0) {
-			int var6 = var1.getBlockMetadata(var2, var3, var4);
-			if(var6 < 15) {
-				var1.setBlockMetadataWithNotify(var2, var3, var4, var6 + 1);
+		if(var1.getBlockLightValue(var2, var3 + 1, var4) >= 9 && var5.nextInt(30) == 0) {
+			int type = var1.getBlockMetadata(var2, var3, var4);
+
+			if (!this.fieldGrown.get(type)) {
+				var1.setBlockMetadataWithNotify(var2, var3, var4, this.fieldGrown.set(type, true));
 			} else {
+				type = this.fieldType.get(type);
 				var1.setBlock(var2, var3, var4, 0);
-				Object var7 = new WorldGenTrees();
+				WorldGenerator gen = getTreeGenerator(type);
 				if(var5.nextInt(10) == 0) {
-					var7 = new WorldGenBigTree();
+					gen = getBigTreeGenerator(type);
 				}
 
-				if(!((WorldGenerator)var7).generate(var1, var5, var2, var3, var4)) {
-					var1.setBlock(var2, var3, var4, this.blockID);
+				if(!gen.generate(var1, var5, var2, var3, var4)) {
+					var1.setBlockAndMetadata(var2, var3, var4, this.blockID, type);
 				}
 			}
 		}
-
+	}
+
+	private static WorldGenerator getTreeGenerator(int metadata) {
+		switch (metadata) {
+			default: return new WorldGenTrees();
+			case 1: return new WorldGenSpruceTrees();
+			case 2: return new WorldGenTrees().withAltForm(2, 10).withScale(2, 2, 2);
+			case 3: return new WorldGenMahoganyTrees();
+		}
+	}
+
+	private static WorldGenerator getBigTreeGenerator(int metadata) {
+		switch (metadata) {
+			default: return new WorldGenBigTree();
+			case 1: return new WorldGenSpruceTrees().makeBig().withScale(3, 2, 2);
+			case 2: return new WorldGenBigTree().withAltForm(2, 10);
+			case 3: return new WorldGenMahoganyTrees().withScale(5, 8, 6);
+		}
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int side, int metadata) {
+		return this.blockIndexInTexture + this.fieldType.get(metadata) * 32;
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var1 % 8;
+	}
+
+	public int tickRate() {
+		return 1;
+	}
+
+	public int[] availableMetadata() {
+		return IntStream.range(0, 4).toArray();
 	}
 }
--- /dev/null
+++ net/minecraft/src/BitField.java
@@ -1,0 +1,49 @@
+package net.minecraft.src;
+
+public class BitField implements IBitField {
+	public final int offset;
+    public final int size;
+	private final int mask;
+	private final int nmask;
+	private final String name;
+
+    public BitField(String name, int offset, int size) {
+		if (offset < 0 || offset >= BITS) {
+			throw new IllegalArgumentException("Offset out of range");
+		}
+
+		if (size < 1 || size > BITS) {
+			throw new IllegalArgumentException("Size out of range");
+		}
+
+		if (offset + size > BITS) {
+			throw new IllegalArgumentException("Size and offset out of range");
+		}
+
+        this.offset = offset;
+        this.size = size;
+		this.mask = ((1 << size) - 1) << offset;
+		this.nmask = ~this.mask;
+		this.name = name;
+    }
+
+    public int get(int number) {
+        int maskedNumber = number & this.mask;
+        return maskedNumber >>> this.offset;
+    }
+
+    public int set(int number, int value) {
+        int shiftedValue = value << this.offset;
+        int maskedNumber = number & this.nmask;
+        int maskedValue = shiftedValue & this.mask;
+        return maskedNumber | maskedValue;
+    }
+
+	public String getName() {
+		return this.name;
+	}
+
+	public String getString(int number) {
+		return String.valueOf(this.get(number));
+	}
+}
--- /dev/null
+++ net/minecraft/src/EnumOption.java
@@ -1,0 +1,49 @@
+package net.minecraft.src;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+
+public enum EnumOption {
+	MUSIC               (OptionCategory.AUDIO),
+	SOUND               (OptionCategory.AUDIO),
+	INVERT_MOUSE        (OptionCategory.CONTROLS),
+	SENSITIVITY         (OptionCategory.CONTROLS),
+	RENDER_DISTANCE     (OptionCategory.GRAPHICS),
+	VIEW_BOBBING        (OptionCategory.GRAPHICS),
+	ANAGLYPH            (OptionCategory.GRAPHICS),
+	MAX_FPS             (OptionCategory.GRAPHICS),
+	DIFFICULTY          (OptionCategory.MISC),
+	FANCY_GRAPHICS      (OptionCategory.GRAPHICS),
+	CAVE_SOUNDS         (OptionCategory.AUDIO),
+	BRIGHTNESS          (OptionCategory.GRAPHICS),
+	MUSIC_DELAY         (OptionCategory.AUDIO),
+	DARK_MODE           (OptionCategory.INTERFACE),
+	FOV                 (OptionCategory.GRAPHICS),
+	FOV_EFFECTS         (OptionCategory.GRAPHICS),
+	MINIMAL_DEBUG       (OptionCategory.INTERFACE),
+	GUI_SCALE           (OptionCategory.INTERFACE),
+	HEADER              (OptionCategory.INTERFACE),
+	SMOOTH_LIGHTING     (OptionCategory.GRAPHICS),
+	SIMULATION_DISTANCE (OptionCategory.GRAPHICS),
+	FAST_LIGHTING       (OptionCategory.GRAPHICS),
+	CHUNK_UPDATES       (OptionCategory.GRAPHICS),
+	LAZY_LOADING        (OptionCategory.GRAPHICS),
+	ADVANCED_OPENGL     (OptionCategory.GRAPHICS),
+	DYNAMIC_UPDATES     (OptionCategory.GRAPHICS),
+	AUTOSAVE_INTERVAL   (OptionCategory.MISC),
+	FAST_RENDERING      (OptionCategory.GRAPHICS),
+	FOV_HAND            (OptionCategory.GRAPHICS),
+
+	KEYBINDS(OptionCategory.CONTROLS);
+
+	public final OptionCategory category;
+
+	EnumOption(OptionCategory category) {
+		this.category = category;
+	}
+
+	public static List<EnumOption> inCategory(OptionCategory category) {
+		return Arrays.stream(values()).filter(o -> o.category == category).collect(Collectors.toList());
+	}
+}
--- net/minecraft/src/WorldRenderer.java
+++ net/minecraft/src/WorldRenderer.java
@@ -3,6 +3,8 @@
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+
+import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 
 public class WorldRenderer {
@@ -38,6 +40,14 @@
 	private boolean isInitialized = false;
 	public List tileEntityRenderers = new ArrayList();
 	private List tileEntities;
+    public boolean isVisibleFromPosition = false;
+    public double visibleFromX;
+    public double visibleFromY;
+    public double visibleFromZ;
+    private boolean needsBoxUpdate = false;
+	public boolean isInFrustumFully = false;
+	public static int globalChunkOffsetX = 0;
+	public static int globalChunkOffsetZ = 0;
 
 	public WorldRenderer(World var1, List var2, int var3, int var4, int var5, int var6, int var7) {
 		this.worldObj = var1;
@@ -65,11 +75,9 @@
 			this.posXMinus = var1 - this.posXClip;
 			this.posYMinus = var2 - this.posYClip;
 			this.posZMinus = var3 - this.posZClip;
-			float var4 = 2.0F;
+			float var4 = 0.0F;
 			this.rendererBoundingBox = AxisAlignedBB.getBoundingBox((double)((float)var1 - var4), (double)((float)var2 - var4), (double)((float)var3 - var4), (double)((float)(var1 + this.sizeWidth) + var4), (double)((float)(var2 + this.sizeHeight) + var4), (double)((float)(var3 + this.sizeDepth) + var4));
-			GL11.glNewList(this.glRenderList + 2, GL11.GL_COMPILE);
-			RenderItem.renderAABB(AxisAlignedBB.getBoundingBoxFromPool((double)((float)this.posXClip - var4), (double)((float)this.posYClip - var4), (double)((float)this.posZClip - var4), (double)((float)(this.posXClip + this.sizeWidth) + var4), (double)((float)(this.posYClip + this.sizeHeight) + var4), (double)((float)(this.posZClip + this.sizeDepth) + var4)));
-			GL11.glEndList();
+			this.needsBoxUpdate = true;
 			this.markDirty();
 		}
 	}
@@ -78,9 +86,29 @@
 		GL11.glTranslatef((float)this.posXClip, (float)this.posYClip, (float)this.posZClip);
 	}
 
+	public void loadChunks() {
+		int chunkX = (this.posX - 1) >> 4;
+		int chunkZ = (this.posZ - 1) >> 4;
+		int var8 = (this.posX + this.sizeWidth + 1) >> 4;
+		int var9 = (this.posZ + this.sizeDepth + 1) >> 4;
+
+		for(int var10 = chunkX; var10 <= var8; ++var10) {
+			for(int var11 = chunkZ; var11 <= var9; ++var11) {
+				this.worldObj.getChunkFromChunkCoords(var10, var11);
+			}
+		}
+	}
+
 	public void updateRenderer() {
 		if(this.needsUpdate) {
 			++chunksUpdated;
+			if(this.needsBoxUpdate) {
+				float xMin = 0.0F;
+				GL11.glNewList(this.glRenderList + 2, GL11.GL_COMPILE);
+				RenderItem.renderAABB(AxisAlignedBB.getBoundingBoxFromPool((double)((float)this.posXClip - xMin), (double)((float)this.posYClip - xMin), (double)((float)this.posZClip - xMin), (double)((float)(this.posXClip + this.sizeWidth) + xMin), (double)((float)(this.posYClip + this.sizeHeight) + xMin), (double)((float)(this.posZClip + this.sizeDepth) + xMin)));
+				GL11.glEndList();
+			}
+
 			int var1 = this.posX;
 			int var2 = this.posY;
 			int var3 = this.posZ;
@@ -97,10 +125,13 @@
 			var21.addAll(this.tileEntityRenderers);
 			this.tileEntityRenderers.clear();
 			byte var8 = 1;
+			Profiler.startSection("chunkCache");
 			ChunkCache var9 = new ChunkCache(this.worldObj, var1 - var8, var2 - var8, var3 - var8, var4 + var8, var5 + var8, var6 + var8);
 			RenderBlocks var10 = new RenderBlocks(var9);
+			Profiler.endSection();
 
 			for(int var11 = 0; var11 < 2; ++var11) {
+				Profiler.startSection("render");
 				boolean var12 = false;
 				boolean var13 = false;
 				boolean var14 = false;
@@ -113,14 +144,17 @@
 								if(!var14) {
 									var14 = true;
 									GL11.glNewList(this.glRenderList + var11, GL11.GL_COMPILE);
-									GL11.glPushMatrix();
-									this.setupGLTranslation();
-									float var19 = 1.000001F;
-									GL11.glTranslatef((float)(-this.sizeDepth) / 2.0F, (float)(-this.sizeHeight) / 2.0F, (float)(-this.sizeDepth) / 2.0F);
-									GL11.glScalef(var19, var19, var19);
-									GL11.glTranslatef((float)this.sizeDepth / 2.0F, (float)this.sizeHeight / 2.0F, (float)this.sizeDepth / 2.0F);
+									if (!Minecraft.fastRender()) {
+										GL11.glPushMatrix();
+										this.setupGLTranslation();
+										float var19 = 1.000001F;
+										GL11.glTranslatef((float)(-this.sizeDepth) / 2.0F, (float)(-this.sizeHeight) / 2.0F, (float)(-this.sizeDepth) / 2.0F);
+										GL11.glScalef(var19, var19, var19);
+										GL11.glTranslatef((float)this.sizeDepth / 2.0F, (float)this.sizeHeight / 2.0F, (float)this.sizeDepth / 2.0F);
+									}
 									tessellator.startDrawingQuads();
-									tessellator.setTranslationD((double)(-this.posX), (double)(-this.posY), (double)(-this.posZ));
+									if (Minecraft.fastRender()) tessellator.setTranslationD((double)(-globalChunkOffsetX), 0.0D, (double)(-globalChunkOffsetZ));
+									else tessellator.setTranslationD((double)(-this.posX), (double)(-this.posY), (double)(-this.posZ));
 								}
 
 								if(var11 == 0 && Block.isBlockContainer[var18]) {
@@ -134,7 +168,7 @@
 								int var20 = var24.getRenderBlockPass();
 								if(var20 != var11) {
 									var12 = true;
-								} else if(var20 == var11) {
+								} else {
 									var13 |= var10.renderBlockByRenderType(var24, var17, var15, var16);
 								}
 							}
@@ -142,9 +176,10 @@
 					}
 				}
 
+				Profiler.endStartSection("draw");
 				if(var14) {
 					tessellator.draw();
-					GL11.glPopMatrix();
+					if (!Minecraft.fastRender()) GL11.glPopMatrix();
 					GL11.glEndList();
 					tessellator.setTranslationD(0.0D, 0.0D, 0.0D);
 				} else {
@@ -155,6 +190,7 @@
 					this.skipRenderPass[var11] = false;
 				}
 
+				Profiler.endSection();
 				if(!var12) {
 					break;
 				}
@@ -197,7 +233,13 @@
 	}
 
 	public void updateInFrustum(ICamera var1) {
+		GameSettings options = Minecraft.getInstance().options;
 		this.isInFrustum = var1.isBoundingBoxInFrustum(this.rendererBoundingBox);
+		if(this.isInFrustum && options.advancedOpengl && options.occlusionFancy) {
+			this.isInFrustumFully = var1.isBoundingBoxInFrustumFully(this.rendererBoundingBox);
+		} else {
+			this.isInFrustumFully = false;
+		}
 	}
 
 	public void callOcclusionQueryList() {
--- net/minecraft/src/GuiMultiplayer.java
+++ net/minecraft/src/GuiMultiplayer.java
@@ -65,7 +65,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, "Play Multiplayer", this.width / 2, this.height / 4 - 60 + 20, 16777215);
 		this.drawString(this.fontRenderer, "Minecraft Multiplayer is currently not finished, but there", this.width / 2 - 140, this.height / 4 - 60 + 60 + 0, 10526880);
 		this.drawString(this.fontRenderer, "is some buggy early testing going on.", this.width / 2 - 140, this.height / 4 - 60 + 60 + 9, 10526880);
--- net/minecraft/src/BlockMinecartTrack.java
+++ net/minecraft/src/BlockMinecartTrack.java
@@ -3,9 +3,9 @@
 import java.util.Random;
 
 public class BlockMinecartTrack extends Block {
-	protected BlockMinecartTrack(int var1, int var2) {
+	public BlockMinecartTrack(int var1, int var2) {
 		super(var1, var2, Material.circuits);
-		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 2.0F / 16.0F, 1.0F);
+		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
 	}
 
 	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
@@ -32,7 +32,7 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return var2 >= 6 ? this.blockIndexInTexture - 16 : this.blockIndexInTexture;
+		return var2 >= 6 ? this.blockIndexInTexture - 32 : this.blockIndexInTexture;
 	}
 
 	public boolean renderAsNormalBlock() {
--- net/minecraft/src/EntityCreature.java
+++ net/minecraft/src/EntityCreature.java
@@ -10,6 +10,7 @@
 	}
 
 	protected void updateEntityActionState() {
+		Profiler.startSection("ai");
 		this.hasAttacked = false;
 		float var1 = 16.0F;
 		if(this.entityToAttack == null) {
@@ -23,9 +24,12 @@
 			float var2 = this.entityToAttack.getDistanceToEntity(this);
 			if(this.canEntityBeSeen(this.entityToAttack)) {
 				this.attackEntity(this.entityToAttack, var2);
+			} else {
+				this.attackBlockedEntity(this.entityToAttack, var2);
 			}
 		}
 
+		Profiler.endSection();
 		if(this.hasAttacked || this.entityToAttack == null || this.pathToEntity != null && this.rand.nextInt(20) != 0) {
 			if(this.pathToEntity == null && this.rand.nextInt(80) == 0 || this.rand.nextInt(80) == 0) {
 				boolean var21 = false;
@@ -61,6 +65,7 @@
 		boolean var24 = this.handleLavaMovement();
 		this.rotationPitch = 0.0F;
 		if(this.pathToEntity != null && this.rand.nextInt(100) != 0) {
+			Profiler.startSection("followpath");
 			Vec3D var25 = this.pathToEntity.getPosition(this);
 			double var26 = (double)(this.width * 2.0F);
 
@@ -125,6 +130,7 @@
 				this.isJumping = true;
 			}
 
+			Profiler.endSection();
 		} else {
 			super.updateEntityActionState();
 			this.pathToEntity = null;
@@ -132,6 +138,9 @@
 	}
 
 	protected void attackEntity(Entity var1, float var2) {
+	}
+
+	protected void attackBlockedEntity(Entity var1, float var2) {
 	}
 
 	protected float getBlockPathWeight(int var1, int var2, int var3) {
--- /dev/null
+++ net/minecraft/src/Hook.java
@@ -1,0 +1,5 @@
+package net.minecraft.src;
+
+public interface Hook {
+	void call(BaseMod base);
+}
--- net/minecraft/src/GuiConnecting.java
+++ net/minecraft/src/GuiConnecting.java
@@ -1,7 +1,6 @@
 package net.minecraft.src;
 
 import net.minecraft.client.Minecraft;
-
 public class GuiConnecting extends GuiScreen {
 	private NetClientHandler clientHandler;
 	private boolean cancelled = false;
@@ -39,7 +38,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		if(this.clientHandler == null) {
 			this.drawCenteredString(this.fontRenderer, "Connecting to the server...", this.width / 2, this.height / 2 - 50, 16777215);
 			this.drawCenteredString(this.fontRenderer, "", this.width / 2, this.height / 2 - 10, 16777215);
@@ -51,15 +50,15 @@
 		super.drawScreen(var1, var2, var3);
 	}
 
-	static NetClientHandler setNetClientHandler(GuiConnecting var0, NetClientHandler var1) {
+	public static NetClientHandler setNetClientHandler(GuiConnecting var0, NetClientHandler var1) {
 		return var0.clientHandler = var1;
 	}
 
-	static boolean isCancelled(GuiConnecting var0) {
+	public static boolean isCancelled(GuiConnecting var0) {
 		return var0.cancelled;
 	}
 
-	static NetClientHandler getNetClientHandler(GuiConnecting var0) {
+	public static NetClientHandler getNetClientHandler(GuiConnecting var0) {
 		return var0.clientHandler;
 	}
 }
--- /dev/null
+++ net/minecraft/src/Biome.java
@@ -1,0 +1,289 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+import javax.imageio.ImageIO;
+import java.awt.*;
+import java.awt.image.BufferedImage;
+import java.awt.image.WritableRaster;
+import java.io.File;
+import java.io.IOException;
+import java.time.Duration;
+import java.time.Instant;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+public class Biome {
+	public static Biome[] biomesList = new Biome[256];
+
+	public static final Biome forest = new BiomeForest(0, "Forest", 0, new ClimateZone(0.00F, 0.00F, 1.00F, 1.00F));
+	public static final Biome seasonalForest = new BiomeSeasonalForest(1, "Seasonal Forest", 100, new ClimateZone(0.50F, 0.50F, 1.00F, 1.00F));
+	public static final Biome savanna = new BiomeSavanna(2, "Savanna", 200, new ClimateZone(0.60F, 0.00F, 1.00F, 0.40F));
+	public static final Biome rainforest = new BiomeRainforest(3, "Rainforest", 300, new ClimateZone(0.80F, 0.40F, 1.00F, 1.00F));
+	public static final Biome snowyTaiga = new BiomeTaiga(4, "Snowy Taiga", 400, true, new ClimateZone(0.00F, 0.00F, 0.125F, 1.00F));
+	public static final Biome desert = new BiomeDesert(5, "Desert", 500, new ClimateZone(0.80F, 0.00F, 1.00F, 0.30F));
+	public static final Biome ocean = new BiomeOcean(6, "Ocean", Float.NEGATIVE_INFINITY);
+	public static final Biome taiga = new BiomeTaiga(7, "Taiga", 350, false,
+			new ClimateZone(0.00F, 0.00F, 0.25F, 1.00F), new ClimateZone(0.25F, 0.00F, 0.45F, 0.20F));
+
+	public final byte id;
+	public final String name;
+	public final float priority;
+	private final ClimateZone[] climateZones;
+
+	public List<Class<? extends EntityLiving>> spawnableMonsters = new ArrayList<>();
+	public List<Class<? extends EntityLiving>> spawnableAnimals = new ArrayList<>();
+
+	protected Biome(int id, String name, float priority, ClimateZone... climateZones) {
+		if ((id < 0 || id > Byte.MAX_VALUE) && climateZones.length > 0) {
+			throw new IllegalArgumentException("Biome ID is invalid!");
+		}
+		this.id = (byte)id;
+		this.name = name;
+		this.priority = priority;
+		this.climateZones = climateZones;
+		if (id >= 0 && id <= Byte.MAX_VALUE) {
+			if (Biome.biomesList[id] != null) {
+				throw new IllegalArgumentException("Biome ID is already taken!");
+			}
+			Biome.biomesList[id] = this;
+		}
+
+		this.spawnableMonsters.add(EntityZombie.class);
+		this.spawnableMonsters.add(EntitySkeleton.class);
+		this.spawnableMonsters.add(EntityCreeper.class);
+		this.spawnableMonsters.add(EntitySpider.class);
+		this.spawnableMonsters.add(EntitySlime.class);
+		this.spawnableMonsters.add(EntityPhantom.class);
+
+		this.spawnableAnimals.add(EntitySheep.class);
+		this.spawnableAnimals.add(EntityPig.class);
+		this.spawnableAnimals.add(EntityCow.class);
+		this.spawnableAnimals.add(EntityChicken.class);
+	}
+
+	public Block getSurface() {
+		return Block.grass;
+	}
+
+	public Block getSoil() {
+		return Block.dirt;
+	}
+
+	public int getSurfaceMetadata() {
+		return 0;
+	}
+
+	public int getStoneMetadata() {
+		return 0;
+	}
+
+	public boolean isSnowy() {
+		return false;
+	}
+
+	public int[] getMapColor() {
+		ClimateZone climate = this.climateZones[0];
+		return new int[] {
+				(int) MathHelper.clamp((climate.minTemperature + climate.maxTemperature) / 2.0F * 255.0F, 0.0F, 255.0F),
+				(int) MathHelper.clamp((climate.minHumidity + climate.maxHumidity) / 2.0F * 255.0F, 0.0F, 255.0F),
+				128
+		};
+	}
+
+	public void populate(PopulatorHost host) {
+	}
+
+	public static Biome getBiome(float temp, float hum) {
+		Biome out = Biome.forest;
+		for (Biome biome : Biome.biomesList) {
+			if (biome == null) continue;
+			if (out.priority > biome.priority) continue;
+			for (ClimateZone climate : biome.climateZones) {
+				if (temp >= climate.minTemperature
+						&& temp <= climate.maxTemperature
+						&& hum >= climate.minHumidity
+						&& hum <= climate.maxHumidity) {
+					out = biome;
+					break;
+				}
+			}
+		}
+		return out;
+	}
+
+	public static void generateBiomeMap() throws IOException {
+		Instant generationBegin = Instant.now();
+
+		BufferedImage img = new BufferedImage(1000, 1000, BufferedImage.TYPE_INT_RGB);
+		WritableRaster raster = img.getRaster();
+		Graphics2D gfx = img.createGraphics();
+
+		for (int x = 0; x < 1000; x++)
+			for (int y = 0; y < 1000; y++) {
+				Biome biome = Biome.getBiome(x / 1000.0F, y / 1000.0F);
+				raster.setPixel(x, y, biome.getMapColor());
+			}
+
+		gfx.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+		gfx.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
+
+		gfx.dispose();
+
+		Instant generationEnd = Instant.now();
+		System.out.println("Generated biome map in " + Duration.between(generationBegin, generationEnd).toMillis() + "ms");
+		generationBegin = Instant.now();
+
+		File imgFile = new File(Minecraft.getMinecraftDir(), "/dvmaps/biome.png");
+		imgFile.mkdirs();
+		imgFile.delete();
+		ImageIO.write(img, "png", imgFile);
+
+		generationEnd = Instant.now();
+		System.out.println("Saved biome map to " + Minecraft.getMinecraftDir()
+				+ "/dvmaps/biome.png in " + Duration.between(generationBegin, generationEnd).toMillis() + "ms");
+	}
+
+	public static void generateWorldBiomeMap() throws IOException {
+		Instant generationBegin = Instant.now();
+
+		final int size = 512;
+		final int scale = 100;
+		final double biomeSize = 0.0005D * scale;
+		Random rand = new Random();
+
+		BufferedImage img = new BufferedImage(size * 2, size * 2, BufferedImage.TYPE_INT_RGB);
+		WritableRaster raster = img.getRaster();
+
+		long seed = rand.nextLong();
+		ChunkProviderGenerate generator = new ChunkProviderGenerate(null, seed);
+
+		int[] biomeCounts = new int[256];
+
+		for (int x = 0; x < size; x++)
+			for (int y = 0; y < size; y++) {
+				float temperature = MathHelper.clamp(SimplexOctaves.noise3_ImproveXY(seed,
+								x * biomeSize, y * biomeSize, 1000, 2) / 1.5F + 0.5F,
+						0.0F, 1.0F);
+				float humidity = MathHelper.clamp(SimplexOctaves.noise3_ImproveXY(seed,
+								x * biomeSize, y * biomeSize, -1000, 2) / 1.5F + 0.5F,
+						0.0F, 1.0F);
+
+				Biome biome = (generator.isOcean(x * scale, y * scale)
+						|| generator.isRiver(x * scale, y * scale)) ? Biome.ocean
+						: Biome.getBiome(temperature, humidity);
+				raster.setPixel(x, y, biome.getMapColor());
+
+				int tempCol = (int)(temperature * 255.0F);
+				int humCol = (int)(humidity * 255.0F);
+				raster.setPixel(x + size, y, new int[] { tempCol, tempCol, tempCol });
+				raster.setPixel(x + size, y + size, new int[] { humCol, humCol, humCol });
+				raster.setPixel(x, y + size, new int[] { tempCol, humCol, 0 });
+
+				biomeCounts[biome.id]++;
+			}
+
+		Graphics2D gfx = img.createGraphics();
+		gfx.setColor(Color.BLACK);
+		gfx.drawString("Scale: 1:" + scale, 5, 21);
+		gfx.setColor(Color.WHITE);
+		gfx.drawString("Scale: 1:" + scale, 4, 20);
+
+		int y = 40;
+		for (int i = 0; i < 256; i++) {
+			if (biomeCounts[i] > 0) {
+				String text = Biome.biomesList[i].name + ": " + MathHelper.floor_float(biomeCounts[i] / (float)(size * size) * 100.0F) + "%";
+				gfx.setColor(Color.BLACK);
+				gfx.drawString(text, 9, y + 1);
+				gfx.setColor(Color.WHITE);
+				gfx.drawString(text, 8, y);
+				y += 12;
+			}
+		}
+
+		Instant generationEnd = Instant.now();
+		System.out.println("Generated world biome map in " + Duration.between(generationBegin, generationEnd).toMillis() + "ms");
+		generationBegin = Instant.now();
+
+		File imgFile = new File(Minecraft.getMinecraftDir(), "/dvmaps/worldbiome.png");
+		imgFile.mkdirs();
+		imgFile.delete();
+		ImageIO.write(img, "png", imgFile);
+
+		generationEnd = Instant.now();
+		System.out.println("Saved world biome map to " + Minecraft.getMinecraftDir()
+				+ "/dvmaps/worldbiome.png in " + Duration.between(generationBegin, generationEnd).toMillis() + "ms");
+	}
+
+	private static int grayscaleNoise(double d) {
+		d = d / 16.0D + 0.5D;
+		int g = (int)(d * 255);
+		if (g < 0) g = 0;
+		if (g > 255) g = 255;
+		return g << 16 | g << 8 | g;
+	}
+
+	public static void generateWorldTerrainMap() throws IOException {
+		Instant generationBegin = Instant.now();
+
+		int scale = 256;
+		long seed = System.currentTimeMillis() ^ System.nanoTime();
+		Random rand = new Random(seed);
+		BufferedImage img = new BufferedImage(scale * 4, scale * 3, BufferedImage.TYPE_INT_RGB);
+
+		NoiseGeneratorOctaves noiseGen6 = new NoiseGeneratorOctaves(rand, 4);
+		NoiseGeneratorOctaves noiseGen7 = new NoiseGeneratorOctaves(rand, 4);
+		NoiseGeneratorOctaves noiseGen3 = new NoiseGeneratorOctaves(rand, 4);
+		NoiseGeneratorOctaves noiseGen1 = new NoiseGeneratorOctaves(rand, 4);
+
+		double[] noise6p = noiseGen6.generateNoiseOctaves(null, 0, 0, 0, scale, 1, scale, 0.1D, 0.1D, 0.1D);
+		double[] noise7p = noiseGen7.generateNoiseOctaves(null, 0, 0, 0, scale, 1, scale, 0.2D, 0.2D, 0.2D);
+		double[] noise3p = noiseGen3.generateNoiseOctaves(null, 0, 0, 0, scale, 1, scale, 0.3D, 0.3D, 0.3D);
+		double[] noise1p = noiseGen1.generateNoiseOctaves(null, 0, 0, 0, scale, 1, scale, 0.4D, 0.4D, 0.4D);
+
+		double[] noise6s = SimplexOctaves.noiseArray(null, seed, 4, 0, 0, 0, scale, 1, scale, 0.1D, 0.1D, 0.1D);
+		double[] noise7s = SimplexOctaves.noiseArray(null, seed, 4, 0, 0, 0, scale, 1, scale, 0.2D, 0.2D, 0.2D);
+		double[] noise3s = SimplexOctaves.noiseArray(null, seed, 4, 0, 0, 0, scale, 1, scale, 0.3D, 0.3D, 0.3D);
+		double[] noise1s = SimplexOctaves.noiseArray(null, seed, 4, 0, 0, 0, scale, 1, scale, 0.4D, 0.4D, 0.4D);
+
+		for (int x = 0; x < scale; x++) {
+			for (int y = 0; y < scale; y++) {
+				img.setRGB(x, y, grayscaleNoise(noise6p[x + y * scale]));
+				img.setRGB(x + scale, y, grayscaleNoise(noise7p[x + y * scale]));
+				img.setRGB(x + scale * 2, y, grayscaleNoise(noise3p[x + y * scale]));
+				img.setRGB(x + scale * 3, y, grayscaleNoise(noise1p[x + y * scale]));
+
+				img.setRGB(x, y + scale, grayscaleNoise(noise6s[x + y * scale]));
+				img.setRGB(x + scale, y + scale, grayscaleNoise(noise7s[x + y * scale]));
+				img.setRGB(x + scale * 2, y + scale, grayscaleNoise(noise3s[x + y * scale]));
+				img.setRGB(x + scale * 3, y + scale, grayscaleNoise(noise1s[x + y * scale]));
+
+				img.setRGB(x, y + scale * 2, grayscaleNoise(SimplexOctaves.noise2(0, x / 200.0D, y / 200.0D, 1) * 0.5F + 0.5F));
+				img.setRGB(x + scale, y + scale * 2, grayscaleNoise(SimplexOctaves.noise2(0, x / 200.0D, y / 200.0D, 2) * 0.5F + 0.5F));
+				img.setRGB(x + scale * 2, y + scale * 2, grayscaleNoise(SimplexOctaves.noise2(0, x / 200.0D, y / 200.0D, 3) * 0.5F + 0.5F));
+				img.setRGB(x + scale * 3, y + scale * 2, grayscaleNoise(SimplexOctaves.noise2(0, x / 200.0D, y / 200.0D, 4) * 0.5F + 0.5F));
+			}
+		}
+
+		Instant generationEnd = Instant.now();
+		System.out.println("Generated world terrain map in " + Duration.between(generationBegin, generationEnd).toMillis() + "ms");
+		generationBegin = Instant.now();
+
+		File imgFile = new File(Minecraft.getMinecraftDir(), "/dvmaps/worldterrain.png");
+		imgFile.mkdirs();
+		imgFile.delete();
+		ImageIO.write(img, "png", imgFile);
+
+		generationEnd = Instant.now();
+		System.out.println("Saved world terrain map to " + Minecraft.getMinecraftDir()
+				+ "/dvmaps/worldterrain.png in " + Duration.between(generationBegin, generationEnd).toMillis() + "ms");
+	}
+
+	public static void main(String[] args) {
+		try {
+			generateBiomeMap();
+			generateWorldBiomeMap();
+		} catch (IOException e) {
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/ModelFluffy.java
@@ -1,0 +1,90 @@
+package net.minecraft.src;
+
+public class ModelFluffy extends ModelBiped {
+	public ModelRenderer bipedTail;
+	public ModelRenderer bipedSnout;
+	public ModelRenderer bipedEars;
+	private boolean renderTail = true;
+	private boolean renderSnout = true;
+	private boolean renderEars = true;
+
+	public ModelFluffy(float var1) {
+		super(var1);
+		this.bipedTail = new ModelRenderer(0, 16);
+		this.bipedTail.addBox(-2.0F, -12.0F, 0.0F, 4, 10, 4, var1);
+		this.bipedTail.setRotationPoint(0.0F, 8.0F, 0.5F);
+		this.bipedTail.rotateAngleX = -2.2F;
+		this.bipedSnout = new ModelRenderer(0, 4);
+		this.bipedSnout.addBox(-2.0F, -2.0F + var1, -6.0F - var1, 4, 2, 2, var1 / 4.0F);
+		this.bipedSnout.setRotationPoint(0.0F, 0.0F, 0.0F);
+		this.bipedEars = new ModelRenderer(0, 0);
+		this.bipedEars.addBox(-4.0F, -10.0F - var1, -1.0F - var1, 8, 2, 1, var1 / 4.0F);
+		this.bipedEars.setRotationPoint(0.0F, 0.0F, 0.0F);
+	}
+
+	public ModelFluffy longSnout(float var1) {
+		this.bipedSnout = new ModelRenderer(0, 8);
+		this.bipedSnout.addBox(-2.0F, -3.0F + var1, -8.0F - var1, 4, 3, 4, var1 / 4.0F);
+		this.bipedSnout.setRotationPoint(0.0F, 0.0F, 0.0F);
+		return this;
+	}
+
+	public ModelFluffy tailOnly() {
+		this.renderTail = true;
+		this.renderSnout = false;
+		this.renderEars = false;
+		return this;
+	}
+
+	public ModelFluffy snoutOnly() {
+		this.renderTail = false;
+		this.renderSnout = true;
+		this.renderEars = false;
+		return this;
+	}
+
+	public ModelFluffy earsOnly() {
+		this.renderTail = false;
+		this.renderSnout = false;
+		this.renderEars = true;
+		return this;
+	}
+
+	public void render(float var1, float var2, float var3, float var4, float var5, float var6) {
+		this.setRotationAngles(var1, var2, var3, var4, var5, var6);
+		if (this.renderTail) this.bipedTail.render(var6);
+		if (this.renderSnout) this.bipedSnout.render(var6);
+		if (this.renderEars) this.bipedEars.render(var6);
+	}
+
+	public void setRotationAngles(float var1, float var2, float var3, float var4, float var5, float var6) {
+		super.setRotationAngles(var1, var2, var3, var4, var5, var6);
+
+		this.bipedTail.rotateAngleX = this.bipedBody.rotateAngleX;
+		this.bipedTail.rotateAngleY = this.bipedBody.rotateAngleY;
+		this.bipedTail.rotateAngleX -= 2.2F;
+		this.bipedTail.rotateAngleY += MathHelper.cos(var1 * 0.6662F) * 0.1F * var2;
+		this.bipedTail.rotateAngleZ = MathHelper.sin(var3 * 0.2F) * 0.05F;
+		this.bipedTail.rotationPointZ = this.isSneak ? 4.0F : 0.5F;
+
+		this.bipedEars.rotateAngleX = this.bipedSnout.rotateAngleX = this.bipedHead.rotateAngleX;
+		this.bipedEars.rotateAngleY = this.bipedSnout.rotateAngleY = this.bipedHead.rotateAngleY;
+		this.bipedEars.rotateAngleZ = this.bipedSnout.rotateAngleZ = this.bipedHead.rotateAngleZ;
+		this.bipedEars.rotationPointY = this.bipedSnout.rotationPointY = this.bipedHead.rotationPointY;
+	}
+
+	public void showHead(boolean var1) {
+		super.showHead(var1);
+		this.bipedEars.showModel = var1;
+	}
+
+	public void showBody(boolean var1) {
+		super.showBody(var1);
+		this.bipedSnout.showModel = var1;
+	}
+
+	public void showLeftLeg(boolean var1) {
+		super.showLeftLeg(var1);
+		this.bipedTail.showModel = var1;
+	}
+}
--- /dev/null
+++ net/minecraft/src/BiomeTaiga.java
@@ -1,0 +1,28 @@
+package net.minecraft.src;
+
+public class BiomeTaiga extends Biome {
+	private final boolean snowy;
+	private final TreePopulator trees;
+
+	public BiomeTaiga(int id, String name, float priority, boolean snowy, ClimateZone... climateZones) {
+		super(id, name, priority, climateZones);
+		this.spawnableAnimals.add(EntityFox.class);
+		this.snowy = snowy;
+		this.trees = new TreePopulator()
+				.withTree(new WorldGenSpruceTrees())
+				.withBigTree(new WorldGenSpruceTrees().makeBig().withScale(6, 6, 5), 15, 1)
+				.withDensity(this.snowy ? 1.0D : 2.0D, 0.5D, 0.3D, this.snowy ? 0.0D : 6.0D, 150.0D);
+	}
+
+	public void populate(PopulatorHost host) {
+		trees.populate(host);
+	}
+
+	public boolean isSnowy() {
+		return this.snowy;
+	}
+
+	public int[] getMapColor() {
+		return this.snowy ? new int[] { 128, 255, 255 } : new int[] { 0, 128, 128 };
+	}
+}
--- net/minecraft/src/BlockRedstoneOre.java
+++ net/minecraft/src/BlockRedstoneOre.java
@@ -2,11 +2,11 @@
 
 import java.util.Random;
 
-public class BlockRedstoneOre extends Block {
-	private boolean glowing;
+public class BlockRedstoneOre extends BlockStone {
+	private final boolean glowing;
 
 	public BlockRedstoneOre(int var1, int var2, boolean var3) {
-		super(var1, var2, Material.rock);
+		super(var1, var2);
 		if(var3) {
 			this.setTickOnLoad(true);
 		}
@@ -36,14 +36,16 @@
 	private void glow(World var1, int var2, int var3, int var4) {
 		this.sparkle(var1, var2, var3, var4);
 		if(this.blockID == Block.oreRedstone.blockID) {
-			var1.setBlockWithNotify(var2, var3, var4, Block.oreRedstoneGlowing.blockID);
+			int metadata = var1.getBlockMetadata(var2, var3, var4);
+			var1.setBlockAndMetadataWithNotify(var2, var3, var4, Block.oreRedstoneGlowing.blockID, metadata);
 		}
 
 	}
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(this.blockID == Block.oreRedstoneGlowing.blockID) {
-			var1.setBlockWithNotify(var2, var3, var4, Block.oreRedstone.blockID);
+			int metadata = var1.getBlockMetadata(var2, var3, var4);
+			var1.setBlockAndMetadataWithNotify(var2, var3, var4, Block.oreRedstone.blockID, metadata);
 		}
 
 	}
@@ -52,6 +54,14 @@
 		return Item.redstone.shiftedIndex;
 	}
 
+	public int idDroppedSilk(int var1, Random var2) {
+		return Block.oreRedstone.blockID;
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return var2 != Item.redstone.shiftedIndex ? var1 : 0;
+	}
+
 	public int quantityDropped(Random var1) {
 		return 4 + var1.nextInt(2);
 	}
@@ -60,7 +70,6 @@
 		if(this.glowing) {
 			this.sparkle(var1, var2, var3, var4);
 		}
-
 	}
 
 	private void sparkle(World var1, int var2, int var3, int var4) {
@@ -99,6 +108,5 @@
 				var1.spawnParticle("reddust", var9, var11, var13, 0.0D, 0.0D, 0.0D);
 			}
 		}
-
 	}
 }
--- net/minecraft/src/EntityAnimal.java
+++ net/minecraft/src/EntityAnimal.java
@@ -1,12 +1,16 @@
 package net.minecraft.src;
 
-public abstract class EntityAnimal extends EntityCreature implements IAnimals {
+public abstract class EntityAnimal extends EntityCreature implements IAnimal {
 	public EntityAnimal(World var1) {
 		super(var1);
 	}
 
 	protected float getBlockPathWeight(int var1, int var2, int var3) {
-		return this.worldObj.getBlockId(var1, var2 - 1, var3) == Block.grass.blockID ? 10.0F : this.worldObj.getBrightness(var1, var2, var3) - 0.5F;
+		int block = this.worldObj.getBlockId(var1, var2 - 1, var3);
+		return block == Block.grass.blockID
+				|| block == Block.dirt.blockID
+						? 10.0F
+						: this.worldObj.getBrightness(var1, var2, var3) - 0.5F;
 	}
 
 	public void writeEntityToNBT(NBTTagCompound var1) {
@@ -21,7 +25,13 @@
 		int var1 = MathHelper.floor_double(this.posX);
 		int var2 = MathHelper.floor_double(this.boundingBox.minY);
 		int var3 = MathHelper.floor_double(this.posZ);
-		return this.worldObj.getBlockId(var1, var2 - 1, var3) == Block.grass.blockID && this.worldObj.getBlockLightValue(var1, var2, var3) > 8 && super.getCanSpawnHere();
+		int y = var2;
+		int var4 = 0;
+		while (var4 == 0 && y > 0) {
+			var4 = this.worldObj.getBlockId(var1, --y, var3);
+		}
+		return (var4 == Block.grass.blockID || var4 == Block.dirt.blockID || var4 == Block.snow.blockID)
+				&& var2 >= 64 && this.worldObj.getBlockLightValue(var1, var2, var3) > 8 && super.getCanSpawnHere();
 	}
 
 	public int getTalkInterval() {
--- /dev/null
+++ net/minecraft/src/RecipesDyes.java
@@ -1,0 +1,57 @@
+package net.minecraft.src;
+
+public class RecipesDyes {
+	public void addRecipes(CraftingManager craftingManager) {
+		for (int i = 0; i < 15; i++) {
+			craftingManager.addRecipe(new ItemStack(Block.cloth, 1, i), "X#", 'X', new Pair<>(Item.dye, i), '#', Block.cloth);
+		}
+
+		createDyeSource(craftingManager, DyeColor.CAPRI, Block.plantBlue);
+		createDyeSource(craftingManager, DyeColor.YELLOW, Block.plantYellow);
+		createDyeSource(craftingManager, DyeColor.RED, Block.plantRed);
+		createDyeSource(craftingManager, DyeColor.WHITE, Item.sugar);
+		createDyeSource(craftingManager, DyeColor.BLACK, Item.coal);
+
+		createDyeMix(craftingManager, DyeColor.RED, DyeColor.YELLOW, DyeColor.ORANGE);
+		createDyeMix(craftingManager, DyeColor.YELLOW, DyeColor.CAPRI, DyeColor.GREEN);
+		createDyeMix(craftingManager, DyeColor.CAPRI, DyeColor.RED, DyeColor.VIOLET);
+		createDyeMix(craftingManager, DyeColor.YELLOW, DyeColor.GREEN, DyeColor.CHARTREUSE);
+		createDyeMix(craftingManager, DyeColor.GREEN, DyeColor.CAPRI, DyeColor.SPRING_GREEN);
+		createDyeMix(craftingManager, DyeColor.CAPRI, DyeColor.WHITE, DyeColor.CYAN);
+		createDyeMix(craftingManager, DyeColor.CAPRI, DyeColor.VIOLET, DyeColor.ULTRAMARINE);
+		createDyeMix(craftingManager, DyeColor.VIOLET, DyeColor.WHITE, DyeColor.PURPLE);
+		createDyeMix(craftingManager, DyeColor.RED, DyeColor.VIOLET, DyeColor.ROSE);
+		createDyeMix(craftingManager, DyeColor.ROSE, DyeColor.WHITE, DyeColor.MAGENTA);
+		createDyeMix(craftingManager, DyeColor.BLACK, DyeColor.WHITE, DyeColor.GRAY);
+
+		for (Item item : Item.itemsList) {
+			if (item instanceof ItemVanity && ((ItemVanity) item).dyable) {
+				createDyeVanity(craftingManager, item);
+			}
+		}
+	}
+
+	public static void createDyeSource(CraftingManager craftingManager, DyeColor type, Object source) {
+		craftingManager.addRecipe(new ItemStack(Item.dye, 4).withMetadata(type.ordinal()), "X", 'X', source);
+	}
+
+	public static void createDyeMix(CraftingManager craftingManager, DyeColor a, DyeColor b, DyeColor out) {
+		craftingManager.addRecipe(new ItemStack(Item.dye, 2).withMetadata(out.ordinal()), "AB",
+				'A', new Pair<>(Item.dye, a.ordinal()),
+				'B', new Pair<>(Item.dye, b.ordinal()));
+		craftingManager.addRecipeNoGuide(new ItemStack(Item.dye, 2).withMetadata(out.ordinal()), "BA",
+				'A', new Pair<>(Item.dye, a.ordinal()),
+				'B', new Pair<>(Item.dye, b.ordinal()));
+	}
+
+	public static void createDyeVanity(CraftingManager craftingManager, Item vanity) {
+		for (int i = 0; i < DyeColor.values().length; i++) {
+			craftingManager.addRecipe(new ItemStack(vanity, 1).withMetadata(i), "#X",
+					'#', vanity,
+					'X', new Pair<>(Item.dye, i));
+			craftingManager.addRecipeNoGuide(new ItemStack(vanity, 1).withMetadata(i), "X#",
+					'#', vanity,
+					'X', new Pair<>(Item.dye, i));
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/SimplexOctaves.java
@@ -1,0 +1,71 @@
+package net.minecraft.src;
+
+import java.util.Arrays;
+
+public class SimplexOctaves {
+	public static float noise2(long seed, double x, double y, int octaves) {
+		float value = 0.0F;
+		double amp = 1.0D;
+		float freq = 1.0F;
+		for (int i = 0; i < octaves; i++) {
+			value += SimplexNoise.noise2(seed, x * amp, y * amp) * freq;
+			amp *= 2.0D;
+			freq /= 2.0F;
+		}
+		return value;
+	}
+
+	public static float noise3_ImproveXY(long seed, double x, double y, double z, int octaves) {
+		float value = 0.0F;
+		double amp = 1.0D;
+		float freq = 1.0F;
+		for (int i = 0; i < octaves; i++) {
+			value += SimplexNoise.noise3_ImproveXY(seed, x * amp, y * amp, z * amp) * freq;
+			amp *= 2.0D;
+			freq /= 2.0F;
+		}
+		return value;
+	}
+
+	public static float noise3_ImproveXZ(long seed, double x, double y, double z, int octaves) {
+		float value = 0.0F;
+		double amp = 1.0D;
+		float freq = 1.0F;
+		for (int i = 0; i < octaves; i++) {
+			value += SimplexNoise.noise3_ImproveXZ(seed, x * amp, y * amp, z * amp) * freq;
+			amp *= 2.0D;
+			freq /= 2.0F;
+		}
+		return value;
+	}
+
+	public static double[] noiseArray(double[] arr, long seed, int octaves, double offsetx, double offsety, double offsetz, int width, int height, int depth, double scalex, double scaley, double scalez) {
+		if (arr == null) {
+			arr = new double[width * height * depth];
+		} else {
+			Arrays.fill(arr, 0.0D);
+		}
+
+		scalex /= MathHelper.SQRT_2;
+		scaley /= MathHelper.SQRT_2;
+		scalez /= MathHelper.SQRT_2;
+
+		double amp = 1.0D;
+		double freq = 0.75D;
+		for (int i = 0; i < octaves; i++) {
+			int index = 0;
+			for (int x = 0; x < width; x++) {
+				for (int z = 0; z < depth; z++) {
+					for (int y = 0; y < height; y++) {
+						arr[index++] += SimplexNoise.noise3_ImproveXZ(seed,
+								(x + offsetx) * scalex * amp, (y + offsety) * scaley * amp, (z + offsetz) * scalez * amp) * freq;
+					}
+				}
+			}
+			amp /= 2.0D;
+			freq *= 2.0D;
+		}
+
+		return arr;
+	}
+}
--- /dev/null
+++ net/minecraft/src/IntHookAttackEntityFrom.java
@@ -1,0 +1,5 @@
+package net.minecraft.src;
+
+public interface IntHookAttackEntityFrom<E extends EntityLiving> {
+	int call(BaseMod mod, Class<? extends E> clazz, E target, Entity enemy, int damage);
+}
--- /dev/null
+++ net/minecraft/src/WorldGenSpeleothems.java
@@ -1,0 +1,52 @@
+package net.minecraft.src;
+
+import java.util.Random;
+
+public class WorldGenSpeleothems extends WorldGenerator {
+	public int minY, maxY;
+
+	public WorldGenSpeleothems(int minY, int maxY) {
+		this.minY = minY;
+		this.maxY = maxY;
+	}
+
+	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		boolean stalactite = var2.nextInt(2) == 0;
+		if (stalactite) {
+			var4 = findStalactiteAnchor(var1, var3, var4, var5);
+		} else {
+			var4 = findStalagmiteAnchor(var1, var3, var4, var5);
+		}
+		if (var4 == -1 || var4 < this.minY || var4 > this.maxY) {
+			return false;
+		}
+		int height = var2.nextInt(2) + 1;
+		for (int i = 0; i < height; i++) {
+			var4 += stalactite ? -1 : 1;
+			var1.setBlock(var3, var4, var5, Block.speleothem.blockID);
+		}
+		for (int i = 0; i < height; i++) {
+			var1.setBlockMetadata(var3, var4, var5, Block.speleothem.getMetadataAt(var1, var3, var4, var5));
+			var4 -= stalactite ? -1 : 1;
+		}
+		return true;
+	}
+
+	private int findStalactiteAnchor(World var1, int x, int y, int z) {
+		for (++y; y < this.maxY; y++) {
+			if (var1.isBlockNormalCube(x, y, z) && var1.getBlockId(x, y - 1, z) == 0) {
+				return y;
+			}
+		}
+		return -1;
+	}
+
+	private int findStalagmiteAnchor(World var1, int x, int y, int z) {
+		for (--y; y > this.minY; y--) {
+			if (var1.isBlockNormalCube(x, y, z) && var1.getBlockId(x, y + 1, z) == 0) {
+				return y;
+			}
+		}
+		return -1;
+	}
+}
--- net/minecraft/src/GuiIngame.java
+++ net/minecraft/src/GuiIngame.java
@@ -4,14 +4,15 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
+
 import net.minecraft.client.Minecraft;
-import org.lwjgl.input.Keyboard;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL12;
 
 public class GuiIngame extends Gui {
 	private static RenderItem itemRenderer = new RenderItem();
 	private List chatMessageList = new ArrayList();
+	private List<ScreenAchievement> achievementList = new ArrayList<>();
 	private Random rand = new Random();
 	private Minecraft mc;
 	public String testMessage = null;
@@ -20,24 +21,33 @@
 	private int recordPlayingUpFor = 0;
 	public float damageGuiPartialTime;
 	float prevVignetteBrightness = 1.0F;
+	private static final float debugLineHeight = 12.0F;
+	private float debugLinesLeft = 0.0F, debugLinesRight = 0.0F;
+	private ScaledResolution res;
 
 	public GuiIngame(Minecraft var1) {
 		this.mc = var1;
 	}
 
 	public void renderGameOverlay(float var1, boolean var2, int var3, int var4) {
-		ScaledResolution var5 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
+		if (!var2 && !this.mc.showHud) {
+			return;
+		}
+
+		this.debugLinesLeft = this.debugLinesRight = 0.0F;
+
+		ScaledResolution var5 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight, this.mc.options.guiScale);
 		int var6 = var5.getScaledWidth();
 		int var7 = var5.getScaledHeight();
 		FontRenderer var8 = this.mc.fontRenderer;
 		this.mc.entityRenderer.setupOverlayRendering();
 		GL11.glEnable(GL11.GL_BLEND);
-		if(this.mc.options.fancyGraphics) {
+		if(this.mc.options.fancyGraphics > 0) {
 			this.renderVignette(this.mc.thePlayer.getBrightness(var1), var6, var7);
 		}
 
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/gui.png"));
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("@@/gui/gui.png"));
 		InventoryPlayer var9 = this.mc.thePlayer.inventory;
 		this.zLevel = -90.0F;
 		this.drawTexturedModalRect(var6 / 2 - 91, var7 - 22, 0, 0, 182, 22);
@@ -54,11 +64,17 @@
 
 		int var11 = this.mc.thePlayer.health;
 		int var12 = this.mc.thePlayer.prevHealth;
+		float cf0 = this.mc.thePlayer.energy;
+		float cf1 = this.mc.thePlayer.mana;
+		boolean cz1 = this.mc.thePlayer.tired;
+		boolean cz2 = rand.nextFloat() < this.mc.thePlayer.energyBoost * 25.0F;
+		boolean cz3 = this.mc.thePlayer.showMana;
+		boolean cz4 = this.mc.thePlayer.creative;
 		this.rand.setSeed((long)(this.updateCounter * 312871));
 		int var13;
 		int var14;
 		int var15;
-		if(this.mc.playerController.shouldDrawHUD()) {
+		if(this.mc.playerController.shouldDrawHUD() && !cz4) {
 			var13 = this.mc.thePlayer.getPlayerArmorValue();
 
 			int var16;
@@ -67,15 +83,15 @@
 				if(var13 > 0) {
 					var16 = var6 / 2 + 91 - var14 * 8 - 9;
 					if(var14 * 2 + 1 < var13) {
-						this.drawTexturedModalRect(var16, var15, 34, 9, 9, 9);
+						this.drawTexturedModalRect(var16, var15 - 10, 34, 9, 9, 9);
 					}
 
 					if(var14 * 2 + 1 == var13) {
-						this.drawTexturedModalRect(var16, var15, 25, 9, 9, 9);
+						this.drawTexturedModalRect(var16, var15 - 10, 25, 9, 9, 9);
 					}
 
 					if(var14 * 2 + 1 > var13) {
-						this.drawTexturedModalRect(var16, var15, 16, 9, 9, 9);
+						this.drawTexturedModalRect(var16, var15 - 10, 16, 9, 9, 9);
 					}
 				}
 
@@ -107,28 +123,51 @@
 				if(var14 * 2 + 1 == var11) {
 					this.drawTexturedModalRect(var17, var15, 61, 0, 9, 9);
 				}
+
+				var15 = var7 - 32;
+				if (cz1) {
+					var15 += this.rand.nextInt(2);
+				}
+				var16 = var6 / 2 + 91 - var14 * 8 - 9;
+
+				this.drawTexturedModalRect(var16, var15, 34 + (cz2 ? 9 : 0), 18, 9, 9);
+				int ci3 = MathHelper.floor_float(MathHelper.clamp((var14 * 2 + 2 - cf0) * 9, 0, 9));
+				this.drawTexturedModalRect(var16 + ci3, var15, 52 + ci3, 18, 9, 9);
+
+				if (cz3) {
+					var15 = var7 - 42;
+					var16 = var6 / 2 - 91 + var14 * 8;
+					this.drawTexturedModalRect(var16, var15, 16, 27, 9, 9);
+					int ci5 = MathHelper.floor_float(MathHelper.clamp((cf1 - (var14 * 2 + 1)) * 9, 0, 9));
+					this.drawTexturedModalRect(var16, var15, 25, 27, ci5, 9);
+				}
 			}
 
 			if(this.mc.thePlayer.isInsideOfMaterial(Material.water)) {
+				if (cz3) {
+					var7 -= 10;
+				}
+
 				var14 = (int)Math.ceil((double)(this.mc.thePlayer.air - 2) * 10.0D / 300.0D);
 				var15 = (int)Math.ceil((double)this.mc.thePlayer.air * 10.0D / 300.0D) - var14;
 
 				for(var16 = 0; var16 < var14 + var15; ++var16) {
 					if(var16 < var14) {
-						this.drawTexturedModalRect(var6 / 2 - 91 + var16 * 8, var7 - 32 - 9, 16, 18, 9, 9);
+						this.drawTexturedModalRect(var6 / 2 - 91 + var16 * 8, var7 - 42, 16, 18, 9, 9);
 					} else {
-						this.drawTexturedModalRect(var6 / 2 - 91 + var16 * 8, var7 - 32 - 9, 25, 18, 9, 9);
+						this.drawTexturedModalRect(var6 / 2 - 91 + var16 * 8, var7 - 42, 25, 18, 9, 9);
 					}
+				}
+
+				if (cz3) {
+					var7 += 10;
 				}
 			}
 		}
 
 		GL11.glDisable(GL11.GL_BLEND);
 		GL11.glEnable(GL12.GL_RESCALE_NORMAL);
-		GL11.glPushMatrix();
-		GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
-		RenderHelper.enableStandardItemLighting();
-		GL11.glPopMatrix();
+		RenderHelper.enableGUIStandardItemLighting();
 
 		for(var13 = 0; var13 < 9; ++var13) {
 			var14 = var6 / 2 - 90 + var13 * 20 + 2;
@@ -138,22 +177,63 @@
 
 		RenderHelper.disableStandardItemLighting();
 		GL11.glDisable(GL12.GL_RESCALE_NORMAL);
-		String var21;
-		if(Keyboard.isKeyDown(Keyboard.KEY_F3)) {
-			var8.drawStringWithShadow("Minecraft Alpha v1.1.2_01 (" + this.mc.debug + ")", 2, 2, 16777215);
-			var8.drawStringWithShadow(this.mc.debugInfoRenders(), 2, 12, 16777215);
-			var8.drawStringWithShadow(this.mc.getEntityDebug(), 2, 22, 16777215);
-			var8.drawStringWithShadow(this.mc.debugInfoEntities(), 2, 32, 16777215);
+
+		if(this.mc.options.debugMenu) {
+			boolean min = this.mc.options.minimalDebugInfo;
+
+			this.drawDebugTextLeft(var8, Minecraft.version, var6, Minecraft.developmentVersion ? 0xFF5555 : 0x55FFFF);
+			this.drawDebugTextLeft(var8, this.mc.debug, var6, 14737632);
+			this.drawDebugTextLeft(var8, null, var6);
+			this.drawDebugTextLeft(var8, this.mc.debugInfoLocation(), var6);
+			this.drawDebugTextLeft(var8, this.mc.debugInfoSeed(), var6);
+			this.drawDebugTextLeft(var8, this.mc.debugInfoWorld(), var6);
+			if (!min) {
+				this.drawDebugTextLeft(var8, this.mc.debugInfoClimate(), var6);
+				this.drawDebugTextLeft(var8, null, var6);
+				this.drawDebugTextLeft(var8, this.mc.debugInfoRenders(), var6);
+				this.drawDebugTextLeft(var8, this.mc.getEntityDebug(), var6);
+				this.drawDebugTextLeft(var8, this.mc.debugInfoEntities(), var6);
+
+				String[] genInfo = this.mc.theWorld.getIChunkProvider().getDebugInfo(
+						MathHelper.floor_double(this.mc.thePlayer.posX),
+						MathHelper.floor_double(this.mc.thePlayer.posY),
+						MathHelper.floor_double(this.mc.thePlayer.posZ)
+				);
+
+				if (genInfo != null) {
+					for (String line : genInfo) {
+						this.drawDebugTextLeft(var8, line, var6);
+					}
+				}
+			}
+
 			long var22 = Runtime.getRuntime().maxMemory();
 			long var27 = Runtime.getRuntime().totalMemory();
 			long var28 = Runtime.getRuntime().freeMemory();
 			long var19 = var27 - var28;
-			var21 = "Used memory: " + var19 * 100L / var22 + "% (" + var19 / 1024L / 1024L + "MB) of " + var22 / 1024L / 1024L + "MB";
-			this.drawString(var8, var21, var6 - var8.getStringWidth(var21) - 2, 2, 14737632);
-			var21 = "Allocated memory: " + var27 * 100L / var22 + "% (" + var27 / 1024L / 1024L + "MB)";
-			this.drawString(var8, var21, var6 - var8.getStringWidth(var21) - 2, 12, 14737632);
-		} else {
-			var8.drawStringWithShadow("Minecraft Alpha v1.1.2_01", 2, 2, 16777215);
+			String var21a = "Used memory: " + var19 * 100L / var22 + "% (" + var19 / 1024L / 1024L + "MB) of " + var22 / 1024L / 1024L + "MB";
+			String var21b = "Allocated memory: " + var27 * 100L / var22 + "% (" + var27 / 1024L / 1024L + "MB)";
+			this.drawDebugTextRight(var8, var21a, var6, 14737632);
+			this.drawDebugTextRight(var8, var21b, var6, 14737632);
+
+			MovingObjectPosition obj = this.mc.objectMouseOver;
+			if (!min && obj != null && obj.typeOfHit == 0) {
+				int id = this.mc.theWorld.getBlockId(obj.blockX, obj.blockY, obj.blockZ);
+				int meta = this.mc.theWorld.getBlockMetadata(obj.blockX, obj.blockY, obj.blockZ);
+
+				ItemTooltip tooltip = ItemTooltip.items[id];
+				String name = tooltip.lines.get(0);
+				String title = String.format("Block: %1$s (%2$d#%3$02X)", name, id, meta);
+
+				BitFieldGroup fields = Block.blocksList[id].fields;
+				List<String> states = fields.getStates(meta);
+
+				this.drawDebugTextRight(var8, null, var6);
+				this.drawDebugTextRight(var8, title, var6);
+				for (String state : states) {
+					this.drawDebugTextRight(var8, state, var6, 14737632);
+				}
+			}
 		}
 
 		if(this.recordPlayingUpFor > 0) {
@@ -210,7 +290,7 @@
 				if(var18 > 0) {
 					byte var30 = 2;
 					int var20 = -var15 * 9;
-					var21 = ((ChatLine)this.chatMessageList.get(var15)).message;
+					String var21 = ((ChatLine)this.chatMessageList.get(var15)).message;
 					this.drawRect(var30, var20 - 1, var30 + 320, var20 + 8, var18 / 2 << 24);
 					GL11.glEnable(GL11.GL_BLEND);
 					var8.drawStringWithShadow(var21, var30, var20, 16777215 + (var18 << 24));
@@ -221,6 +301,81 @@
 		GL11.glPopMatrix();
 		GL11.glEnable(GL11.GL_ALPHA_TEST);
 		GL11.glDisable(GL11.GL_BLEND);
+
+		for (ScreenAchievement achievement : this.achievementList) {
+			int x = (var6 - 240) / 2;
+			int y = achievement.getY(var1);
+
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture(
+				"/achievement/" + achievement.type.id + ".png"));
+			this.drawTexturedModalRect(x, y, 0, 0, 32, 32, 32.0F);
+
+			if (achievement.updateTick <= 60) {
+				var8.drawBoldStringWithShadow("Got an achievement!", x + 40, y, 0xFFFF00);
+				var8.drawStringWithShadow(achievement.type.title, x + 40, y + 9, 0xFFFFFF);
+			} else {
+				var8.drawStringWrapped(achievement.type.description, x + 40, y, 196, 0xFFFFFF);
+			}
+		}
+
+		this.achievementList.removeIf(x -> x.updateTick > 160);
+
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/effects.png"));
+		int effectRow = 0;
+		for (Effect effect : this.mc.thePlayer.effects) {
+			float duration = (effect.duration + (1.0F - var1)) / effect.maxDuration;
+			int r = (int)(MathHelper.clamp(duration * -3.0F + 2.0F, 0.0F, 1.0F) * 255);
+			int g = (int)(MathHelper.clamp(duration * 3.0F, 0.0F, 1.0F) * 255);
+			int b = (int)(MathHelper.clamp(duration * 3.0F - 2.0F, 0.0F, 1.0F) * 255);
+			int col = 0xFF000000 | r << 16 | g << 8 | b;
+			int colBg = 0xFF000000 | (r / 8) << 16 | (g / 8) << 8 | (b / 8);
+
+			if (effect.type == null) continue;
+			int id = effect.type.id;
+
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			this.drawTexturedModalRect(4, effectRow * 20 + 4, id % 16 * 16, id / 16 * 16, 16, 16);
+
+			this.drawRect(24, effectRow * 20 + 16, 88, effectRow * 20 + 20, colBg);
+			this.drawRect(24, effectRow * 20 + 15, 24 + (int)(duration * 64), effectRow * 20 + 19, col);
+
+			effectRow++;
+		}
+	}
+
+	private void drawDebugTextLeft(FontRenderer fontRenderer, String text, int ignoredScrWidth) {
+		this.drawDebugTextLeft(fontRenderer, text, ignoredScrWidth, 16777215);
+	}
+
+	private void drawDebugTextLeft(FontRenderer fontRenderer, String text, int ignoredScrWidth, int color) {
+		if (text == null) {
+			this.debugLinesLeft += 0.5F;
+			return;
+		}
+
+		int width = fontRenderer.getStringWidth(text);
+		this.drawRect(0, (int)(this.debugLinesLeft * debugLineHeight),
+				width + 4, (int)((this.debugLinesLeft + 1) * debugLineHeight), 0x80000000);
+		fontRenderer.drawString(text, 2, (int)(this.debugLinesLeft * debugLineHeight + 2), color);
+		this.debugLinesLeft++;
+	}
+
+	private void drawDebugTextRight(FontRenderer fontRenderer, String text, int scrWidth) {
+		this.drawDebugTextRight(fontRenderer, text, scrWidth, 16777215);
+	}
+
+	private void drawDebugTextRight(FontRenderer fontRenderer, String text, int scrWidth, int color) {
+		if (text == null) {
+			this.debugLinesRight += 0.5F;
+			return;
+		}
+
+		int width = fontRenderer.getStringWidth(text);
+		this.drawRect(scrWidth - width - 4, (int)(this.debugLinesRight * debugLineHeight),
+				scrWidth, (int)((this.debugLinesRight + 1) * debugLineHeight), 0x80000000);
+		fontRenderer.drawString(text, scrWidth - width - 2, (int)(this.debugLinesRight * debugLineHeight + 2), color);
+		this.debugLinesRight++;
 	}
 
 	private void renderVignette(float var1, int var2, int var3) {
@@ -284,6 +439,10 @@
 			++((ChatLine)this.chatMessageList.get(var1)).updateCounter;
 		}
 
+		for (ScreenAchievement achievement : this.achievementList) {
+			achievement.updateTick++;
+		}
+
 	}
 
 	public void addChatMessage(String var1) {
@@ -301,7 +460,23 @@
 		while(this.chatMessageList.size() > 50) {
 			this.chatMessageList.remove(this.chatMessageList.size() - 1);
 		}
-
+	}
+
+	public void addAchievement(Achievement achievement) {
+		int row = -1;
+		boolean rowFound = false;
+		while (!rowFound) {
+			row++;
+			rowFound = true;
+			for (ScreenAchievement ach : this.achievementList) {
+				if (ach.row == row) {
+					rowFound = false;
+					break;
+				}
+			}
+		}
+
+		this.achievementList.add(new ScreenAchievement(achievement, row));
 	}
 
 	public void setRecordPlayingMessage(String var1) {
--- net/minecraft/src/ItemHoe.java
+++ net/minecraft/src/ItemHoe.java
@@ -1,13 +1,27 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.ItemTooltip.*;
+
 public class ItemHoe extends Item {
+	private final boolean silk;
+
 	public ItemHoe(int var1, int var2) {
 		super(var1);
 		this.maxStackSize = 1;
-		this.maxDamage = 32 << var2;
-	}
-
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+		this.maxDamage = 64 << Math.abs(var2);
+		if (var2 >= 3) {
+			this.maxDamage *= 3;
+		} else if (var2 < 0) {
+			this.maxDamage *= 4;
+		}
+		this.silk = var2 < 0;
+	}
+
+	public boolean isSilk() {
+		return this.silk;
+	}
+
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		int var8 = var3.getBlockId(var4, var5, var6);
 		Material var9 = var3.getBlockMaterial(var4, var5 + 1, var6);
 		if((var9.isSolid() || var8 != Block.grass.blockID) && var8 != Block.dirt.blockID) {
@@ -17,7 +31,7 @@
 			var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var10.stepSound.getStepSound(), (var10.stepSound.getVolume() + 1.0F) / 2.0F, var10.stepSound.getPitch() * 0.8F);
 			var3.setBlockWithNotify(var4, var5, var6, var10.blockID);
 			var1.damageItem(1);
-			if(var3.rand.nextInt(8) == 0 && var8 == Block.grass.blockID) {
+			if(var3.canDoClientAction() && var3.rand.nextInt(5) == 0 && var8 == Block.grass.blockID) {
 				byte var11 = 1;
 
 				for(int var12 = 0; var12 < var11; ++var12) {
@@ -37,5 +51,12 @@
 
 	public boolean isFull3D() {
 		return true;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				"Right click to create farmland", DESCRIPTION_COL,
+				"and gather seeds.", DESCRIPTION_COL
+		};
 	}
 }
--- /dev/null
+++ net/minecraft/src/OptionCategory.java
@@ -1,0 +1,39 @@
+package net.minecraft.src;
+
+public enum OptionCategory {
+	GRAPHICS("Graphics"),
+	AUDIO("Audio"),
+	INTERFACE("Interface"),
+	CONTROLS("Controls"),
+	MISC("Misc"),
+	MODS("Mods", GuiMods.class),
+	CREDITS("Credits", GuiCredits.class);
+
+	private final String name;
+	private final Class<? extends GuiScreen> nextScreen;
+
+	OptionCategory(String name) {
+		this(name, null);
+	}
+
+	OptionCategory(String name, Class<? extends GuiScreen> nextScreen) {
+		this.name = name;
+		this.nextScreen = nextScreen;
+	}
+
+	public String toString() {
+		return this.name;
+	}
+
+	public GuiScreen getNextScreen(GuiScreen parent) {
+		if (this.nextScreen == null) {
+			return null;
+		}
+
+		try {
+			return this.nextScreen.getConstructor(GuiScreen.class).newInstance(parent);
+		} catch (Exception e) {
+			return null;
+		}
+	}
+}
--- net/minecraft/src/MCHashEntry2.java
+++ /dev/null
@@ -1,50 +1,0 @@
-package net.minecraft.src;
-
-class MCHashEntry2 {
-	final long hashEntry;
-	Object valueEntry;
-	MCHashEntry2 nextEntry;
-	final int slotHash;
-
-	MCHashEntry2(int var1, long var2, Object var4, MCHashEntry2 var5) {
-		this.valueEntry = var4;
-		this.nextEntry = var5;
-		this.hashEntry = var2;
-		this.slotHash = var1;
-	}
-
-	public final long getHash() {
-		return this.hashEntry;
-	}
-
-	public final Object getValue() {
-		return this.valueEntry;
-	}
-
-	public final boolean equals(Object var1) {
-		if(!(var1 instanceof MCHashEntry2)) {
-			return false;
-		} else {
-			MCHashEntry2 var2 = (MCHashEntry2)var1;
-			Long var3 = Long.valueOf(this.getHash());
-			Long var4 = Long.valueOf(var2.getHash());
-			if(var3 == var4 || var3 != null && var3.equals(var4)) {
-				Object var5 = this.getValue();
-				Object var6 = var2.getValue();
-				if(var5 == var6 || var5 != null && var5.equals(var6)) {
-					return true;
-				}
-			}
-
-			return false;
-		}
-	}
-
-	public final int hashCode() {
-		return MCHashTable2.getHash(this.hashEntry);
-	}
-
-	public final String toString() {
-		return this.getHash() + "=" + this.getValue();
-	}
-}
--- net/minecraft/src/TileEntitySign.java
+++ net/minecraft/src/TileEntitySign.java
@@ -21,6 +21,15 @@
 				this.signText[var2] = this.signText[var2].substring(0, 15);
 			}
 		}
-
+	}
+
+	public Packet getPacket() {
+		String[] var1 = new String[4];
+
+		for(int var2 = 0; var2 < 4; ++var2) {
+			var1[var2] = this.signText[var2];
+		}
+
+		return new Packet130UpdateSign(this.xCoord, this.yCoord, this.zCoord, var1);
 	}
 }
--- net/minecraft/src/BlockJukeBox.java
+++ net/minecraft/src/BlockJukeBox.java
@@ -1,12 +1,12 @@
 package net.minecraft.src;
 
 public class BlockJukeBox extends Block {
-	protected BlockJukeBox(int var1, int var2) {
+	public BlockJukeBox(int var1, int var2) {
 		super(var1, var2, Material.wood);
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return this.blockIndexInTexture + (var1 == 1 ? 1 : 0);
+		return this.blockIndexInTexture - (var1 == 1 ? 32 : 0);
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
@@ -20,25 +20,22 @@
 	}
 
 	public void ejectRecord(World var1, int var2, int var3, int var4, int var5) {
-		var1.playRecord((String)null, var2, var3, var4);
-		var1.setBlockMetadataWithNotify(var2, var3, var4, 0);
-		int var6 = Item.record13.shiftedIndex + var5 - 1;
-		float var7 = 0.7F;
-		double var8 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.5D;
-		double var10 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.2D + 0.6D;
-		double var12 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.5D;
-		EntityItem var14 = new EntityItem(var1, (double)var2 + var8, (double)var3 + var10, (double)var4 + var12, new ItemStack(var6));
-		var14.delayBeforeCanPickup = 10;
-		var1.spawnEntityInWorld(var14);
+		var1.playRecord(null, var2, var3, var4, null);
+		if (var1.canDoClientAction()) {
+			var1.setBlockMetadataWithNotify(var2, var3, var4, 0);
+			int var6 = Item.record13.shiftedIndex + var5 - 1;
+			float var7 = 0.7F;
+			double var8 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.5D;
+			double var10 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.2D + 0.6D;
+			double var12 = (double)(var1.rand.nextFloat() * var7) + (double)(1.0F - var7) * 0.5D;
+			EntityItem var14 = new EntityItem(var1, (double)var2 + var8, (double)var3 + var10, (double)var4 + var12, new ItemStack(var6));
+			var14.delayBeforeCanPickup = 10;
+			var1.spawnEntityInWorld(var14);
+		}
 	}
 
 	public void dropBlockAsItemWithChance(World var1, int var2, int var3, int var4, int var5, float var6) {
-		if(!var1.multiplayerWorld) {
-			if(var5 > 0) {
-				this.ejectRecord(var1, var2, var3, var4, var5);
-			}
-
-			super.dropBlockAsItemWithChance(var1, var2, var3, var4, var5, var6);
-		}
+		this.ejectRecord(var1, var2, var3, var4, var5);
+		super.dropBlockAsItemWithChance(var1, var2, var3, var4, 0, var6);
 	}
 }
--- net/minecraft/src/Packet21PickupSpawn.java
+++ net/minecraft/src/Packet21PickupSpawn.java
@@ -13,7 +13,10 @@
 	public byte pitch;
 	public byte roll;
 	public int itemID;
+	public int itemMetadata;
+	public int itemDamage;
 	public int count;
+	public NBTTagCompound storage;
 
 	public Packet21PickupSpawn() {
 	}
@@ -21,6 +24,8 @@
 	public Packet21PickupSpawn(EntityItem var1) {
 		this.entityId = var1.entityID;
 		this.itemID = var1.item.itemID;
+		this.itemMetadata = var1.item.itemMetadata;
+		this.itemDamage = var1.item.itemDmg;
 		this.count = var1.item.stackSize;
 		this.xPosition = MathHelper.floor_double(var1.posX * 32.0D);
 		this.yPosition = MathHelper.floor_double(var1.posY * 32.0D);
@@ -28,11 +33,14 @@
 		this.rotation = (byte)((int)(var1.motionX * 128.0D));
 		this.pitch = (byte)((int)(var1.motionY * 128.0D));
 		this.roll = (byte)((int)(var1.motionZ * 128.0D));
+		this.storage = var1.item.storage;
 	}
 
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.entityId = var1.readInt();
 		this.itemID = var1.readShort();
+		this.itemMetadata = var1.readByte();
+		this.itemDamage = var1.readShort();
 		this.count = var1.readByte();
 		this.xPosition = var1.readInt();
 		this.yPosition = var1.readInt();
@@ -40,11 +48,14 @@
 		this.rotation = var1.readByte();
 		this.pitch = var1.readByte();
 		this.roll = var1.readByte();
+		this.storage = Packet.readNBT(var1);
 	}
 
 	public void writePacket(DataOutputStream var1) throws IOException {
 		var1.writeInt(this.entityId);
 		var1.writeShort(this.itemID);
+		var1.writeByte(this.itemMetadata);
+		var1.writeShort(this.itemDamage);
 		var1.writeByte(this.count);
 		var1.writeInt(this.xPosition);
 		var1.writeInt(this.yPosition);
@@ -52,6 +63,7 @@
 		var1.writeByte(this.rotation);
 		var1.writeByte(this.pitch);
 		var1.writeByte(this.roll);
+		Packet.writeNBT(this.storage, var1);
 	}
 
 	public void processPacket(NetHandler var1) {
@@ -59,6 +71,6 @@
 	}
 
 	public int getPacketSize() {
-		return 22;
+		return 26;
 	}
 }
--- net/minecraft/src/NetworkManager.java
+++ net/minecraft/src/NetworkManager.java
@@ -13,7 +13,7 @@
 	public static final Object threadSyncObject = new Object();
 	public static int numReadThreads;
 	public static int numWriteThreads;
-	private Object sendQueueLock = new Object();
+	private final Object sendQueueLock = new Object();
 	private Socket networkSocket;
 	private DataInputStream socketInputStream;
 	private DataOutputStream socketOutputStream;
@@ -46,7 +46,7 @@
 	public void addToSendQueue(Packet var1) {
 		if(!this.isServerTerminating) {
 			Object var2 = this.sendQueueLock;
-			synchronized(var2) {
+			synchronized(this.sendQueueLock) {
 				this.sendQueueByteLength += var1.getPacketSize() + 1;
 				if(var1.isChunkDataPacket) {
 					this.chunkDataPackets.add(var1);
@@ -62,11 +62,9 @@
 		try {
 			boolean var1 = true;
 			Packet var2;
-			Object var3;
 			if(!this.dataPackets.isEmpty()) {
 				var1 = false;
-				var3 = this.sendQueueLock;
-				synchronized(var3) {
+				synchronized(this.sendQueueLock) {
 					var2 = (Packet)this.dataPackets.remove(0);
 					this.sendQueueByteLength -= var2.getPacketSize() + 1;
 				}
@@ -76,8 +74,7 @@
 
 			if((var1 || this.chunkDataSendCounter-- <= 0) && !this.chunkDataPackets.isEmpty()) {
 				var1 = false;
-				var3 = this.sendQueueLock;
-				synchronized(var3) {
+				synchronized(this.sendQueueLock) {
 					var2 = (Packet)this.chunkDataPackets.remove(0);
 					this.sendQueueByteLength -= var2.getPacketSize() + 1;
 				}
@@ -184,27 +181,27 @@
 		return this.chunkDataPackets.size();
 	}
 
-	static boolean isRunning(NetworkManager var0) {
+	public static boolean isRunning(NetworkManager var0) {
 		return var0.isRunning;
 	}
 
-	static boolean isServerTerminating(NetworkManager var0) {
+	public static boolean isServerTerminating(NetworkManager var0) {
 		return var0.isServerTerminating;
 	}
 
-	static void readNetworkPacket(NetworkManager var0) {
+	public static void readNetworkPacket(NetworkManager var0) {
 		var0.readPacket();
 	}
 
-	static void sendNetworkPacket(NetworkManager var0) {
+	public static void sendNetworkPacket(NetworkManager var0) {
 		var0.sendPacket();
 	}
 
-	static Thread getReadThread(NetworkManager var0) {
+	public static Thread getReadThread(NetworkManager var0) {
 		return var0.readThread;
 	}
 
-	static Thread getWriteThread(NetworkManager var0) {
+	public static Thread getWriteThread(NetworkManager var0) {
 		return var0.writeThread;
 	}
 
--- net/minecraft/src/EntityFallingSand.java
+++ net/minecraft/src/EntityFallingSand.java
@@ -1,27 +1,46 @@
 package net.minecraft.src;
 
 public class EntityFallingSand extends Entity {
-	public int blockID;
 	public int fallTime = 0;
+	public boolean breakOnFall = false;
 
 	public EntityFallingSand(World var1) {
 		super(var1);
+		this.dataWatcher.addObject(16, (short)0);
+		this.dataWatcher.addObject(17, (byte)0);
 	}
 
-	public EntityFallingSand(World var1, float var2, float var3, float var4, int var5) {
+	public EntityFallingSand(World var1, double var2, double var3, double var4, int var5) {
 		super(var1);
-		this.blockID = var5;
+		this.dataWatcher.addObject(16, (short)var5);
+		this.dataWatcher.addObject(17, (byte)0);
 		this.preventEntitySpawning = true;
 		this.setSize(0.98F, 0.98F);
 		this.yOffset = this.height / 2.0F;
-		this.setPosition((double)var2, (double)var3, (double)var4);
+		this.setPosition(var2, var3, var4);
 		this.motionX = 0.0D;
 		this.motionY = 0.0D;
 		this.motionZ = 0.0D;
 		this.canTriggerWalking = false;
-		this.prevPosX = (double)var2;
-		this.prevPosY = (double)var3;
-		this.prevPosZ = (double)var4;
+		this.lastTickPosX = this.prevPosX = this.posX = var2;
+		this.lastTickPosY = this.prevPosY = this.posY = var3;
+		this.lastTickPosZ = this.prevPosZ = this.posZ = var4;
+	}
+
+	public short getBlockID() {
+		return this.dataWatcher.getWatchableObjectShort(16);
+	}
+
+	public byte getBlockMetadata() {
+		return this.dataWatcher.getWatchableObjectByte(17);
+	}
+
+	public void setBlockID(int id) {
+		this.dataWatcher.updateObject(16, (short)id);
+	}
+
+	public void setBlockMetadata(int data) {
+		this.dataWatcher.updateObject(17, (byte)data);
 	}
 
 	public boolean canBeCollidedWith() {
@@ -29,7 +48,9 @@
 	}
 
 	public void onUpdate() {
-		if(this.blockID == 0) {
+		int blockID = this.getBlockID();
+		int blockMetadata = this.getBlockMetadata();
+		if(blockID == 0) {
 			this.setEntityDead();
 		} else {
 			this.prevPosX = this.posX;
@@ -44,7 +65,7 @@
 			int var1 = MathHelper.floor_double(this.posX);
 			int var2 = MathHelper.floor_double(this.posY);
 			int var3 = MathHelper.floor_double(this.posZ);
-			if(this.worldObj.getBlockId(var1, var2, var3) == this.blockID) {
+			if(this.worldObj.getBlockId(var1, var2, var3) == blockID) {
 				this.worldObj.setBlockWithNotify(var1, var2, var3, 0);
 			}
 
@@ -53,11 +74,15 @@
 				this.motionZ *= (double)0.7F;
 				this.motionY *= -0.5D;
 				this.setEntityDead();
-				if(!this.worldObj.canBlockBePlacedAt(this.blockID, var1, var2, var3, true) || !this.worldObj.setBlockWithNotify(var1, var2, var3, this.blockID)) {
-					this.dropItem(this.blockID, 1);
+				if(this.worldObj.canDoClientAction()
+						&& (this.breakOnFall
+						|| !this.worldObj.canBlockBePlacedAt(blockID, var1, var2, var3, true)
+						|| !this.worldObj.setBlockWithNotify(var1, var2, var3, blockID))) {
+					Block.blocksList[blockID].dropBlockAsItem(this.worldObj, var1, var2, var3, blockMetadata);
 				}
 			} else if(this.fallTime > 100) {
-				this.dropItem(this.blockID, 1);
+				if (this.worldObj.canDoClientAction())
+					Block.blocksList[blockID].dropBlockAsItem(this.worldObj, var1, var2, var3, blockMetadata);
 				this.setEntityDead();
 			}
 
@@ -65,11 +90,15 @@
 	}
 
 	protected void writeEntityToNBT(NBTTagCompound var1) {
-		var1.setByte("Tile", (byte)this.blockID);
+		var1.setShort("Tile", this.getBlockID());
+		var1.setByte("Metadata", this.getBlockMetadata());
+		var1.setBoolean("BreakOnFall", this.breakOnFall);
 	}
 
 	protected void readEntityFromNBT(NBTTagCompound var1) {
-		this.blockID = var1.getByte("Tile") & 255;
+		this.setBlockID(var1.getType("Tile") == 1 ? var1.getByte("Tile") : var1.getShort("Tile"));
+		this.setBlockMetadata(var1.getByte("Metadata"));
+		this.breakOnFall = var1.getBoolean("BreakOnFall");
 	}
 
 	public float getShadowSize() {
--- /dev/null
+++ net/minecraft/src/SpeleothemShape.java
@@ -1,0 +1,18 @@
+package net.minecraft.src;
+
+public enum SpeleothemShape {
+	STALAGMITE_TIP(false),
+	STALAGMITE_ANCHOR(false),
+	STALACTITE_ANCHOR(true),
+	STALACTITE_TIP(true);
+
+	public final boolean ceiling;
+
+	SpeleothemShape(boolean ceiling) {
+		this.ceiling = ceiling;
+	}
+
+	public String toString() {
+		return super.toString().toLowerCase();
+	}
+}
--- net/minecraft/src/WorldGenCactus.java
+++ net/minecraft/src/WorldGenCactus.java
@@ -3,13 +3,21 @@
 import java.util.Random;
 
 public class WorldGenCactus extends WorldGenerator {
+	private int height = 3;
+	private int minHeight = 1;
+
+	public void setScale(double var1, double var3, double var5) {
+		height = (int)var1;
+		minHeight = (int)var3;
+	}
+
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
 		for(int var6 = 0; var6 < 10; ++var6) {
 			int var7 = var3 + var2.nextInt(8) - var2.nextInt(8);
 			int var8 = var4 + var2.nextInt(4) - var2.nextInt(4);
 			int var9 = var5 + var2.nextInt(8) - var2.nextInt(8);
 			if(var1.getBlockId(var7, var8, var9) == 0) {
-				int var10 = 1 + var2.nextInt(var2.nextInt(3) + 1);
+				int var10 = 1 + var2.nextInt(var2.nextInt(height) + minHeight);
 
 				for(int var11 = 0; var11 < var10; ++var11) {
 					if(Block.cactus.canBlockStay(var1, var7, var8 + var11, var9)) {
--- net/minecraft/src/EntitySpider.java
+++ net/minecraft/src/EntitySpider.java
@@ -1,9 +1,8 @@
 package net.minecraft.src;
 
-public class EntitySpider extends EntityMob {
+public class EntitySpider extends EntityLeveledMob {
 	public EntitySpider(World var1) {
-		super(var1);
-		this.texture = "/mob/spider.png";
+		super(var1, "/mob/spider");
 		this.setSize(1.4F, 0.9F);
 		this.moveSpeed = 0.8F;
 	}
@@ -15,13 +14,20 @@
 	protected Entity findPlayerToAttack() {
 		float var1 = this.getBrightness(1.0F);
 		if(var1 < 0.5F) {
-			double var2 = 16.0D;
+			double var2 = 16.0D + this.getLevel() * 8.0D;
 			return this.worldObj.getClosestPlayerToEntity(this, var2);
 		} else {
 			return null;
 		}
 	}
 
+	public void setLevel(int level) {
+		super.setLevel(level);
+		this.moveSpeed = 0.8F + this.getLevel() * 0.4F;
+		this.attackStrength = 2 + this.getLevel() * 2;
+		this.heartsHalvesLife = 20 + level * 5;
+	}
+
 	protected String getLivingSound() {
 		return "mob.spider";
 	}
@@ -34,18 +40,24 @@
 		return "mob.spiderdeath";
 	}
 
+	protected float getSoundPitch() {
+		return 1.0F + this.getLevel() * 0.5F;
+	}
+
 	protected void attackEntity(Entity var1, float var2) {
 		float var3 = this.getBrightness(1.0F);
 		if(var3 > 0.5F && this.rand.nextInt(100) == 0) {
 			this.entityToAttack = null;
 		} else {
-			if(var2 > 2.0F && var2 < 6.0F && this.rand.nextInt(10) == 0) {
+			if(var2 > 2.0F && var2 < 6.0F && this.rand.nextInt(10 - this.getLevel() * 4) == 0) {
 				if(this.onGround) {
 					double var4 = var1.posX - this.posX;
 					double var6 = var1.posZ - this.posZ;
 					float var8 = MathHelper.sqrt_double(var4 * var4 + var6 * var6);
 					this.motionX = var4 / (double)var8 * 0.5D * (double)0.8F + this.motionX * (double)0.2F;
 					this.motionZ = var6 / (double)var8 * 0.5D * (double)0.8F + this.motionZ * (double)0.2F;
+					this.motionX *= 1.0D + this.getLevel() * 0.5D;
+					this.motionZ *= 1.0D + this.getLevel() * 0.5D;
 					this.motionY = (double)0.4F;
 				}
 			} else {
--- net/minecraft/src/WorldGenerator.java
+++ net/minecraft/src/WorldGenerator.java
@@ -7,4 +7,9 @@
 
 	public void setScale(double var1, double var3, double var5) {
 	}
+
+	public final WorldGenerator withScale(double var1, double var3, double var5) {
+		setScale(var1, var3, var5);
+		return this;
+	}
 }
--- net/minecraft/src/BlockClay.java
+++ net/minecraft/src/BlockClay.java
@@ -14,4 +14,12 @@
 	public int quantityDropped(Random var1) {
 		return 4;
 	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return 1;
+	}
 }
--- net/minecraft/src/CraftingManager.java
+++ net/minecraft/src/CraftingManager.java
@@ -8,6 +8,7 @@
 public class CraftingManager {
 	private static final CraftingManager instance = new CraftingManager();
 	private List recipes = new ArrayList();
+	private List guideRecipes = new ArrayList();
 
 	public static final CraftingManager getInstance() {
 		return instance;
@@ -20,49 +21,68 @@
 		(new RecipesFood()).addRecipes(this);
 		(new RecipesCrafting()).addRecipes(this);
 		(new RecipesArmor()).addRecipes(this);
-		this.addRecipe(new ItemStack(Item.paper, 3), new Object[]{"###", Character.valueOf('#'), Item.reed});
-		this.addRecipe(new ItemStack(Item.book, 1), new Object[]{"#", "#", "#", Character.valueOf('#'), Item.paper});
-		this.addRecipe(new ItemStack(Block.fence, 2), new Object[]{"###", "###", Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Block.jukebox, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Item.diamond});
-		this.addRecipe(new ItemStack(Block.bookshelf, 1), new Object[]{"###", "XXX", "###", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Item.book});
-		this.addRecipe(new ItemStack(Block.blockSnow, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.snowball});
-		this.addRecipe(new ItemStack(Block.blockClay, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.clay});
-		this.addRecipe(new ItemStack(Block.brick, 1), new Object[]{"##", "##", Character.valueOf('#'), Item.brick});
-		this.addRecipe(new ItemStack(Block.cloth, 1), new Object[]{"###", "###", "###", Character.valueOf('#'), Item.silk});
-		this.addRecipe(new ItemStack(Block.tnt, 1), new Object[]{"X#X", "#X#", "X#X", Character.valueOf('X'), Item.gunpowder, Character.valueOf('#'), Block.sand});
-		this.addRecipe(new ItemStack(Block.stairSingle, 3), new Object[]{"###", Character.valueOf('#'), Block.cobblestone});
-		this.addRecipe(new ItemStack(Block.ladder, 1), new Object[]{"# #", "###", "# #", Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Item.doorWood, 1), new Object[]{"##", "##", "##", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Item.doorSteel, 1), new Object[]{"##", "##", "##", Character.valueOf('#'), Item.ingotIron});
-		this.addRecipe(new ItemStack(Item.sign, 1), new Object[]{"###", "###", " X ", Character.valueOf('#'), Block.planks, Character.valueOf('X'), Item.stick});
-		this.addRecipe(new ItemStack(Block.planks, 4), new Object[]{"#", Character.valueOf('#'), Block.wood});
-		this.addRecipe(new ItemStack(Item.stick, 4), new Object[]{"#", "#", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.torch, 4), new Object[]{"X", "#", Character.valueOf('X'), Item.coal, Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Item.bowlEmpty, 4), new Object[]{"# #", " # ", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Block.minecartTrack, 16), new Object[]{"X X", "X#X", "X X", Character.valueOf('X'), Item.ingotIron, Character.valueOf('#'), Item.stick});
-		this.addRecipe(new ItemStack(Item.minecartEmpty, 1), new Object[]{"# #", "###", Character.valueOf('#'), Item.ingotIron});
-		this.addRecipe(new ItemStack(Item.minecartBox, 1), new Object[]{"A", "B", Character.valueOf('A'), Block.chest, Character.valueOf('B'), Item.minecartEmpty});
-		this.addRecipe(new ItemStack(Item.minecartEngine, 1), new Object[]{"A", "B", Character.valueOf('A'), Block.stoneOvenIdle, Character.valueOf('B'), Item.minecartEmpty});
-		this.addRecipe(new ItemStack(Item.boat, 1), new Object[]{"# #", "###", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Item.bucketEmpty, 1), new Object[]{"# #", " # ", Character.valueOf('#'), Item.ingotIron});
-		this.addRecipe(new ItemStack(Item.striker, 1), new Object[]{"A ", " B", Character.valueOf('A'), Item.ingotIron, Character.valueOf('B'), Item.flint});
-		this.addRecipe(new ItemStack(Item.bread, 1), new Object[]{"###", Character.valueOf('#'), Item.wheat});
-		this.addRecipe(new ItemStack(Block.stairCompactWood, 4), new Object[]{"#  ", "## ", "###", Character.valueOf('#'), Block.planks});
-		this.addRecipe(new ItemStack(Item.fishingRod, 1), new Object[]{"  #", " #X", "# X", Character.valueOf('#'), Item.stick, Character.valueOf('X'), Item.silk});
-		this.addRecipe(new ItemStack(Block.stairCompactStone, 4), new Object[]{"#  ", "## ", "###", Character.valueOf('#'), Block.cobblestone});
-		this.addRecipe(new ItemStack(Item.painting, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Item.stick, Character.valueOf('X'), Block.cloth});
-		this.addRecipe(new ItemStack(Item.appleGold, 1), new Object[]{"###", "#X#", "###", Character.valueOf('#'), Block.blockGold, Character.valueOf('X'), Item.appleRed});
-		this.addRecipe(new ItemStack(Block.lever, 1), new Object[]{"X", "#", Character.valueOf('#'), Block.cobblestone, Character.valueOf('X'), Item.stick});
-		this.addRecipe(new ItemStack(Block.torchRedstoneActive, 1), new Object[]{"X", "#", Character.valueOf('#'), Item.stick, Character.valueOf('X'), Item.redstone});
-		this.addRecipe(new ItemStack(Item.compass, 1), new Object[]{" # ", "#X#", " # ", Character.valueOf('#'), Item.ingotIron, Character.valueOf('X'), Item.redstone});
-		this.addRecipe(new ItemStack(Block.button, 1), new Object[]{"#", "#", Character.valueOf('#'), Block.stone});
-		this.addRecipe(new ItemStack(Block.pressurePlateStone, 1), new Object[]{"###", Character.valueOf('#'), Block.stone});
-		this.addRecipe(new ItemStack(Block.pressurePlateWood, 1), new Object[]{"###", Character.valueOf('#'), Block.planks});
+		(new RecipesBlocks()).addRecipes(this);
+		this.addRecipe(new ItemStack(Block.glass), "##", "##", '#', Item.shardGlass);
+		this.addRecipe(new ItemStack(Block.ice), "##", "##", '#', Item.shardIce);
+		this.addRecipe(new ItemStack(Block.gravel, 2), "#x", "x#", '#', Block.cobblestone, 'x', Item.flint);
+		this.addRecipe(new ItemStack(Block.snow, 2), "##", '#', Item.snowball);
+		this.addRecipe(new ItemStack(Item.paper, 3), "###", '#', Item.reed);
+		this.addRecipe(new ItemStack(Item.book), "#", "#", "#", '#', Item.paper);
+		this.addRecipe(new ItemStack(Block.jukebox), "###", "#X#", "###", '#', Block.planks, 'X', Item.diamond);
+		this.addRecipe(new ItemStack(Block.bookshelf), "###", "XXX", "###", '#', Block.planks, 'X', Item.book);
+		this.addRecipe(new ItemStack(Block.blockSnow), "##", "##", '#', Item.snowball);
+		this.addRecipe(new ItemStack(Block.blockClay), "##", "##", '#', Item.clay);
+		this.addRecipe(new ItemStack(Block.brick), "##", "##", '#', Item.brick);
+		this.addRecipe(new ItemStack(Block.cloth), "###", "###", "###", '#', Item.silk);
+		this.addRecipe(new ItemStack(Block.tnt), "X#X", "#X#", "X#X", 'X', Item.gunpowder, '#', Block.sand);
+		this.addRecipe(new ItemStack(Block.ladder), "# #", "###", "# #", '#', Item.stick);
+		this.addRecipe(new ItemStack(Item.doorWood), "##", "##", "##", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.doorSteel), "##", "##", "##", '#', Item.ingotIron);
+		this.addRecipe(new ItemStack(Item.sign), "###", "###", " X ", '#', Block.planks, 'X', Item.stick);
+		this.addRecipe(new ItemStack(Item.stick, 4), "#", "#", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.torch, 4), "X", "#", 'X', Item.coal, '#', Item.stick);
+		this.addRecipe(new ItemStack(Item.bowlEmpty, 4), "# #", " # ", '#', Block.planks);
+		this.addRecipe(new ItemStack(Block.minecartTrack, 16), "X X", "X#X", "X X", 'X', Item.ingotIron, '#', Item.stick);
+		this.addRecipe(new ItemStack(Block.boosterTrack, 4), "X-X", "X#X", "X-X", 'X', Item.ingotIron, '-', Item.stick, '#', Item.ruby);
+		this.addRecipe(new ItemStack(Item.minecartEmpty), "# #", "###", '#', Item.ingotIron);
+		this.addRecipe(new ItemStack(Item.minecartBox), "A", "B", 'A', Block.chest, 'B', Item.minecartEmpty);
+		this.addRecipe(new ItemStack(Item.minecartEngine), "A", "B", 'A', Block.stoneOvenIdle, 'B', Item.minecartEmpty);
+		this.addRecipe(new ItemStack(Item.boat), "# #", "###", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.bucketEmpty), "# #", " # ", '#', Item.ingotIron);
+		this.addRecipe(new ItemStack(Item.striker), "A ", " B", 'A', Item.ingotIron, 'B', Item.flint);
+		this.addRecipe(new ItemStack(Item.bread), "###", '#', Item.wheat);
+		this.addRecipe(new ItemStack(Item.fishingRod), "  #", " #X", "# X", '#', Item.stick, 'X', Item.silk);
+		this.addRecipe(new ItemStack(Block.stairCompactCobblestone, 8), "#  ", "## ", "###", '#', Block.cobblestone);
+		this.addRecipe(new ItemStack(Item.painting), "###", "#X#", "###", '#', Item.stick, 'X', Block.cloth);
+		this.addRecipe(new ItemStack(Item.appleGold), "###", "#X#", "###", '#', Block.blockGold, 'X', Item.appleRed);
+		this.addRecipe(new ItemStack(Block.lever), "X", "#", '#', Block.cobblestone, 'X', Item.stick);
+		this.addRecipe(new ItemStack(Block.torchRedstoneActive), "X", "#", '#', Item.stick, 'X', Item.redstone);
+		this.addRecipe(new ItemStack(Item.compass), " # ", "#X#", " # ", '#', Item.ingotIron, 'X', Item.redstone);
+		this.addRecipe(new ItemStack(Block.button), "#", "#", '#', Block.stone);
+		this.addRecipe(new ItemStack(Block.pressurePlateStone), "##", '#', Block.stone);
+		this.addRecipe(new ItemStack(Block.pressurePlateWood), "##", '#', Block.planks);
+		this.addRecipe(new ItemStack(Item.quiver), "##/", "##/", "## ", '#', Item.leather, '/', Item.stick);
+		this.addRecipe(new ItemStack(Item.wardingRing), " o ", "X X", " X ", 'o', Item.ruby, 'X', Item.sapphire);
+		this.addRecipe(new ItemStack(Item.repairKit), "=o=", "###", '=', Block.stone, 'o', Item.sapphire, '#', Item.ingotIron);
+		this.addRecipe(new ItemStack(Item.slimeShoes), "# #", "# #", '#', Item.slimeBall);
+		this.addRecipe(new ItemStack(Item.nimbleBoots), "f f", "x x", "# #", 'f', Item.feather, 'x', Item.sapphire, '#', Block.cloth);
+		this.addRecipe(new ItemStack(Item.wings), "#o#", "#-#", "# #", '#', Item.feather, 'o', Item.sapphire, '-', Item.silk);
+		this.addRecipe(new ItemStack(Item.starNecklace), " s ", "- -", " * ", 's', Item.sapphire, '-', Item.silk, '*', Item.starChunk);
+		this.addRecipe(new ItemStack(Item.sugar), "#", '#', Item.reed);
+		this.addRecipe(new ItemStack(Item.shieldIron), "XXX", "#X#", " # ", '#', Block.planks, 'X', Item.ingotIron);
+		this.addRecipe(new ItemStack(Item.shieldGold), "XXX", "#X#", " # ", '#', Block.planks, 'X', Item.ingotGold);
+		this.addRecipe(new ItemStack(Item.shieldDiamond), "XXX", "#X#", " # ", '#', Block.planks, 'X', Item.diamond);
+		this.addRecipe(new ItemStack(Item.shieldRuby), "XXX", "#X#", " # ", '#', Block.planks, 'X', Item.ruby);
+		this.addRecipe(new ItemStack(Item.shieldSapphire), "XXX", "#X#", " # ", '#', Block.planks, 'X', Item.sapphire);
+		this.addRecipe(new ItemStack(Item.furyTrinket), ".o.", "oWo", ".o.", '.', Item.ruby, 'o', Item.voidEssence, 'W', Block.umbrashardCrystal);
+		this.addRecipe(new ItemStack(Item.salvationTrinket), ".o.", "oWo", ".o.", '.', Item.sapphire, 'o', Item.voidEssence, 'W', Block.umbrashardCrystal);
+		this.addRecipe(new ItemStack(Item.hasteTrinket), ".o.", "oWo", ".o.", '.', Item.starDust, 'o', Item.voidEssence, 'W', Block.umbrashardCrystal);
+		(new RecipesDyes()).addRecipes(this);
+		(new RecipesVanity()).addRecipes(this);
 		Collections.sort(this.recipes, new RecipeSorter(this));
-		System.out.println(this.recipes.size() + " recipes");
 	}
 
-	void addRecipe(ItemStack var1, Object... var2) {
+	private CraftingRecipe getRecipe(ItemStack var1, Object... var2) {
 		String var3 = "";
 		int var4 = 0;
 		int var5 = 0;
@@ -85,39 +105,93 @@
 			}
 		}
 
-		HashMap var12;
-		int var15;
-		for(var12 = new HashMap(); var4 < var2.length; var4 += 2) {
-			Character var13 = (Character)var2[var4];
-			var15 = 0;
-			if(var2[var4 + 1] instanceof Item) {
-				var15 = ((Item)var2[var4 + 1]).shiftedIndex;
-			} else if(var2[var4 + 1] instanceof Block) {
-				var15 = ((Block)var2[var4 + 1]).blockID;
+		HashMap hashMap12;
+		Pair<Integer, Integer> var15;
+
+		for(hashMap12 = new HashMap(); var4 < var2.length; var4 += 2) {
+			Object value = var2[var4 + 1];
+			Character character13 = (Character)var2[var4];
+
+			var15 = new Pair<>(-1, -1);
+			if(value instanceof Pair && ((Pair<?, ?>) value).var1 instanceof Integer) {
+				if(((Pair<?, ?>) value).var0 instanceof Integer) {
+					var15 = (Pair<Integer, Integer>)value;
+				} else if(((Pair<?, ?>) value).var0 instanceof Item) {
+					Pair<Item, Integer> item = (Pair<Item, Integer>) value;
+					var15 = new Pair<>(item.var0.shiftedIndex, item.var1);
+				} else if(((Pair<?, ?>) value).var0 instanceof Block) {
+					Pair<Block, Integer> item = (Pair<Block, Integer>) value;
+					var15 = new Pair<>(item.var0.blockID, item.var1);
+				}
+			} else if(value instanceof Item) {
+				var15 = new Pair<>(((Item)var2[var4 + 1]).shiftedIndex, -1);
+			} else if(value instanceof Block) {
+				var15 = new Pair<>(((Block)var2[var4 + 1]).blockID, -1);
 			}
 
-			var12.put(var13, Integer.valueOf(var15));
+			hashMap12.put(character13, var15);
 		}
 
 		int[] var14 = new int[var5 * var6];
+		int[] metadata = new int[var5 * var6];
 
-		for(var15 = 0; var15 < var5 * var6; ++var15) {
-			char var10 = var3.charAt(var15);
-			if(var12.containsKey(Character.valueOf(var10))) {
-				var14[var15] = ((Integer)var12.get(Character.valueOf(var10))).intValue();
+		for(int var16 = 0; var16 < var5 * var6; ++var16) {
+			char c10 = var3.charAt(var16);
+			if(hashMap12.containsKey(c10)) {
+				var14[var16] = ((Pair<Integer, Integer>) hashMap12.get(c10)).var0;
+				metadata[var16] = ((Pair<Integer, Integer>) hashMap12.get(c10)).var1;
 			} else {
-				var14[var15] = -1;
-			}
-		}
-
-		this.recipes.add(new CraftingRecipe(var5, var6, var14, var1));
-	}
-
-	public ItemStack findMatchingRecipe(int[] var1) {
+				var14[var16] = -1;
+				metadata[var16] = -1;
+			}
+		}
+
+		return new CraftingRecipe(var5, var6, var14, metadata, var1);
+	}
+
+	public void addRecipe(ItemStack var1, Object... var2) {
+		CraftingRecipe recipe = getRecipe(var1, var2);
+		this.recipes.add(recipe);
+		this.guideRecipes.add(recipe);
+	}
+
+	public void addRecipeNoGuide(ItemStack var1, Object... var2) {
+		CraftingRecipe recipe = getRecipe(var1, var2);
+		this.recipes.add(recipe);
+	}
+
+	public ItemStack findMatchingRecipe(int[] var1, int[] metadata) {
+		for(int var2 = 0; var2 < this.recipes.size(); ++var2) {
+			CraftingRecipe craftingRecipe3 = (CraftingRecipe)this.recipes.get(var2);
+			if(craftingRecipe3.matches(var1, metadata)) {
+				return craftingRecipe3.getCraftingResult();
+			}
+		}
+
+		return null;
+	}
+
+	public ItemStack[] getRecipeAsItems(int i) {
+		CraftingRecipe recipe = (CraftingRecipe)guideRecipes.get(i);
+		if (recipe == null) {
+			return null;
+		}
+		return recipe.asItemStacks();
+	}
+
+	public int count() {
+		return this.recipes.size();
+	}
+
+	public int guideCount() {
+		return this.guideRecipes.size();
+	}
+
+	public ItemStack craft(int[] var1, int[] meta) {
 		for(int var2 = 0; var2 < this.recipes.size(); ++var2) {
 			CraftingRecipe var3 = (CraftingRecipe)this.recipes.get(var2);
-			if(var3.matches(var1)) {
-				return var3.getCraftingResult(var1);
+			if(var3.matches(var1, meta)) {
+				return var3.getCraftingResult();
 			}
 		}
 
--- net/minecraft/src/BlockIce.java
+++ net/minecraft/src/BlockIce.java
@@ -5,6 +5,7 @@
 public class BlockIce extends BlockBreakable {
 	public BlockIce(int var1, int var2) {
 		super(var1, var2, Material.ice, false);
+		canBlockGrass[var1] = true;
 		this.slipperiness = 0.98F;
 		this.setTickOnLoad(true);
 	}
@@ -17,22 +18,33 @@
 		return super.shouldSideBeRendered(var1, var2, var3, var4, 1 - var5);
 	}
 
-	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
-		Material var5 = var1.getBlockMaterial(var2, var3 - 1, var4);
-		if(var5.getIsSolid() || var5.getIsLiquid()) {
+	public void harvestBlock(World var1, int var2, int var3, int var4, int var5) {
+		super.harvestBlock(var1, var2, var3, var4, var5);
+		Material var6 = var1.getBlockMaterial(var2, var3 - 1, var4);
+		if(var6.getIsSolid() || var6.getIsLiquid()) {
 			var1.setBlockWithNotify(var2, var3, var4, Block.waterMoving.blockID);
 		}
-
 	}
 
 	public int quantityDropped(Random var1) {
-		return 0;
+		return var1.nextInt(3) + 1;
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.shardIce.shiftedIndex;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return 1;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
 	}
 
 	public void updateTick(World var1, int var2, int var3, int var4, Random var5) {
 		if(var1.getSavedLightValue(EnumSkyBlock.Block, var2, var3, var4) > 11 - Block.lightOpacity[this.blockID]) {
-			this.dropBlockAsItem(var1, var2, var3, var4, var1.getBlockMetadata(var2, var3, var4));
-			var1.setBlockWithNotify(var2, var3, var4, Block.waterStill.blockID);
+			var1.setBlockWithNotify(var2, var3, var4, Block.waterMoving.blockID);
 		}
 
 	}
--- /dev/null
+++ net/minecraft/src/Packet130UpdateSign.java
@@ -1,0 +1,61 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet130UpdateSign extends Packet {
+	public int xPosition;
+	public int yPosition;
+	public int zPosition;
+	public String[] signLines;
+
+	public Packet130UpdateSign() {
+		this.isChunkDataPacket = true;
+	}
+
+	public Packet130UpdateSign(int var1, int var2, int var3, String[] var4) {
+		this.isChunkDataPacket = true;
+		this.xPosition = var1;
+		this.yPosition = var2;
+		this.zPosition = var3;
+		this.signLines = var4;
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.xPosition = var1.readInt();
+		this.yPosition = var1.readShort();
+		this.zPosition = var1.readInt();
+		this.signLines = new String[4];
+
+		for(int var2 = 0; var2 < 4; ++var2) {
+			this.signLines[var2] = var1.readUTF();
+		}
+
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeInt(this.xPosition);
+		var1.writeShort(this.yPosition);
+		var1.writeInt(this.zPosition);
+
+		for(int var2 = 0; var2 < 4; ++var2) {
+			var1.writeUTF(this.signLines[var2]);
+		}
+
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleUpdateSign(this);
+	}
+
+	public int getPacketSize() {
+		int var1 = 0;
+
+		for(int var2 = 0; var2 < 4; ++var2) {
+			var1 += this.signLines[var2].length();
+		}
+
+		return var1;
+	}
+}
--- /dev/null
+++ net/minecraft/src/DataWatcher.java
@@ -1,0 +1,201 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class DataWatcher {
+	private static final HashMap dataTypes = new HashMap();
+	private final Map watchedObjects = new HashMap();
+	private boolean objectChanged;
+
+	public void addObject(int var1, Object var2) {
+		Integer var3 = (Integer)dataTypes.get(var2.getClass());
+		if(var3 == null) {
+			throw new IllegalArgumentException("Unknown data type: " + var2.getClass());
+		} else if(var1 > 31) {
+			throw new IllegalArgumentException("Data value id is too big with " + var1 + "! (Max is " + 31 + ")");
+		} else if(this.watchedObjects.containsKey(Integer.valueOf(var1))) {
+			throw new IllegalArgumentException("Duplicate id value for " + var1 + "!");
+		} else {
+			WatchableObject var4 = new WatchableObject(var3.intValue(), var1, var2);
+			this.watchedObjects.put(Integer.valueOf(var1), var4);
+		}
+	}
+
+	public byte getWatchableObjectByte(int var1) {
+		return ((Byte)((WatchableObject)this.watchedObjects.get(Integer.valueOf(var1))).getObject()).byteValue();
+	}
+
+	public short getWatchableObjectShort(int var1) {
+		return ((Short)((WatchableObject)this.watchedObjects.get(Integer.valueOf(var1))).getObject()).shortValue();
+	}
+
+	public int getWatchableObjectInt(int var1) {
+		return ((Integer)((WatchableObject)this.watchedObjects.get(Integer.valueOf(var1))).getObject()).intValue();
+	}
+
+	public String getWatchableObjectString(int var1) {
+		return (String)((WatchableObject)this.watchedObjects.get(Integer.valueOf(var1))).getObject();
+	}
+
+	public void updateObject(int var1, Object var2) {
+		WatchableObject var3 = (WatchableObject)this.watchedObjects.get(Integer.valueOf(var1));
+		if(!var2.equals(var3.getObject())) {
+			var3.setObject(var2);
+			var3.setWatching(true);
+			this.objectChanged = true;
+		}
+	}
+
+	public boolean hasObjectChanged() {
+		return this.objectChanged;
+	}
+
+	public ArrayList getChangedObjects() {
+		ArrayList var1 = null;
+		if(this.objectChanged) {
+			Iterator var2 = this.watchedObjects.values().iterator();
+
+			while(var2.hasNext()) {
+				WatchableObject var3 = (WatchableObject)var2.next();
+				if(var3.getWatching()) {
+					var3.setWatching(false);
+					if(var1 == null) {
+						var1 = new ArrayList();
+					}
+
+					var1.add(var3);
+				}
+			}
+		}
+
+		this.objectChanged = false;
+		return var1;
+	}
+
+	public static void writeObjectsInListToStream(List var0, DataOutputStream var1) throws IOException {
+		if(var0 != null) {
+			Iterator var2 = var0.iterator();
+
+			while(var2.hasNext()) {
+				WatchableObject var3 = (WatchableObject)var2.next();
+				writeWatchableObject(var1, var3);
+			}
+		}
+
+		var1.writeByte(127);
+	}
+
+	public void writeWatchableObjects(DataOutputStream var1) throws IOException {
+		Iterator var2 = this.watchedObjects.values().iterator();
+
+		while(var2.hasNext()) {
+			WatchableObject var3 = (WatchableObject)var2.next();
+			writeWatchableObject(var1, var3);
+		}
+
+		var1.writeByte(127);
+	}
+
+	private static void writeWatchableObject(DataOutputStream var0, WatchableObject var1) throws IOException {
+		int var2 = (var1.getObjectType() << 5 | var1.getDataValueId() & 31) & 255;
+		var0.writeByte(var2);
+		switch(var1.getObjectType()) {
+		case 0:
+			var0.writeByte(((Byte)var1.getObject()).byteValue());
+			break;
+		case 1:
+			var0.writeShort(((Short)var1.getObject()).shortValue());
+			break;
+		case 2:
+			var0.writeInt(((Integer)var1.getObject()).intValue());
+			break;
+		case 3:
+			var0.writeFloat(((Float)var1.getObject()).floatValue());
+			break;
+		case 4:
+			Packet.writeString((String)var1.getObject(), var0);
+			break;
+		case 5:
+			ItemStack var4 = (ItemStack)var1.getObject();
+			var0.writeShort(var4.getItem().shiftedIndex);
+			var0.writeByte(var4.stackSize);
+			var0.writeShort(var4.itemDmg);
+			var0.writeByte(var4.itemMetadata);
+			Packet.writeNBT(var4.storage, var0);
+			break;
+		}
+
+	}
+
+	public static List readWatchableObjects(DataInputStream var0) throws IOException {
+		ArrayList var1 = null;
+
+		for(byte var2 = var0.readByte(); var2 != 127; var2 = var0.readByte()) {
+			if(var1 == null) {
+				var1 = new ArrayList();
+			}
+
+			int var3 = (var2 & 224) >> 5;
+			int var4 = var2 & 31;
+			WatchableObject var5 = null;
+			switch(var3) {
+			case 0:
+				var5 = new WatchableObject(var3, var4, Byte.valueOf(var0.readByte()));
+				break;
+			case 1:
+				var5 = new WatchableObject(var3, var4, Short.valueOf(var0.readShort()));
+				break;
+			case 2:
+				var5 = new WatchableObject(var3, var4, Integer.valueOf(var0.readInt()));
+				break;
+			case 3:
+				var5 = new WatchableObject(var3, var4, Float.valueOf(var0.readFloat()));
+				break;
+			case 4:
+				var5 = new WatchableObject(var3, var4, Packet.readString(var0, 64));
+				break;
+			case 5:
+				short var9 = var0.readShort();
+				byte var10 = var0.readByte();
+				short var11 = var0.readShort();
+				byte var12 = var0.readByte();
+				NBTTagCompound var13 = Packet.readNBT(var0);
+				var5 = new WatchableObject(var3, var4, new ItemStack(var9, var10, var11, var12).withStorage(var13));
+				break;
+			}
+
+			var1.add(var5);
+		}
+
+		return var1;
+	}
+
+	public void updateWatchedObjectsFromList(List var1) {
+		Iterator var2 = var1.iterator();
+
+		while(var2.hasNext()) {
+			WatchableObject var3 = (WatchableObject)var2.next();
+			WatchableObject var4 = (WatchableObject)this.watchedObjects.get(Integer.valueOf(var3.getDataValueId()));
+			if(var4 != null) {
+				var4.setObject(var3.getObject());
+			}
+		}
+
+	}
+
+	static {
+		dataTypes.put(Byte.class, 0);
+		dataTypes.put(Short.class, 1);
+		dataTypes.put(Integer.class, 2);
+		dataTypes.put(Float.class, 3);
+		dataTypes.put(String.class, 4);
+		dataTypes.put(ItemStack.class, 5);
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiModConflict.java
@@ -1,0 +1,71 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class GuiModConflict extends GuiScreen {
+	protected final GuiScreen parentScreen;
+	private final String world;
+	private final String title;
+	private final List<String> lines = new ArrayList<>();
+
+	public GuiModConflict(GuiScreen parentScreen, String world, String displayName, NBTTagList mods) {
+		this.parentScreen = parentScreen;
+		this.world = world;
+		this.title = "\"" + displayName + "\" was last played with different mods:";
+
+		for (int i = 0; i < mods.tagCount(); i++) {
+			if (i >= 10) {
+				lines.add("...and " + (mods.tagCount() - i) + " more");
+				break;
+			}
+
+			NBTTagCompound mod = (NBTTagCompound)mods.tagAt(i);
+			lines.add(mod.getString("Name")
+					+ " "
+					+ mod.getString("Version")
+					+ " by "
+					+ mod.getString("Author"));
+		}
+
+		if (lines.size() == 0) {
+			lines.add("No mods");
+		}
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiSmallButton(0, this.width / 2 - 155, this.height - 24, "Yes"));
+		this.controlList.add(new GuiSmallButton(1, this.width / 2 + 5, this.height - 24, "No"));
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		switch (var1.id) {
+			case 0:
+				this.mc.playerController = new PlayerControllerSP(this.mc);
+				this.mc.startWorld(world);
+				this.mc.displayGuiScreen(null);
+				break;
+
+			case 1:
+				this.mc.displayGuiScreen(this.parentScreen);
+				break;
+		}
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		double time = (System.currentTimeMillis() / 1000.0D) % 1.0D;
+		int tint = (int)(128 * time) + 127;
+		this.drawBackground(0, (255 / 2 + tint / 2) << 16 | tint << 8 | tint, var3);
+
+		this.drawCenteredString(this.fontRenderer, this.title, this.width / 2, 10, 0xFFFFFF);
+		this.drawCenteredString(this.fontRenderer, "Are you sure you want to play on this world?", this.width / 2, this.height - 42, 0xFFFFFF);
+
+		int lineSpacing = 10;
+		int yOffset = (this.lines.size() + 1) * lineSpacing / 2;
+		for (int i = 0; i < this.lines.size(); i++) {
+			this.drawCenteredString(this.fontRenderer, this.lines.get(i), this.width / 2, this.height / 2 - yOffset + i * lineSpacing, 0xFFFFFF);
+		}
+
+		super.drawScreen(var1, var2, var3);
+	}
+}
--- /dev/null
+++ net/minecraft/src/Packet60Explosion.java
@@ -1,0 +1,73 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+public class Packet60Explosion extends Packet {
+	public double explosionX;
+	public double explosionY;
+	public double explosionZ;
+	public float explosionSize;
+	public Set destroyedBlockPositions;
+
+	public Packet60Explosion() {
+	}
+
+	public Packet60Explosion(double var1, double var3, double var5, float var7, Set var8) {
+		this.explosionX = var1;
+		this.explosionY = var3;
+		this.explosionZ = var5;
+		this.explosionSize = var7;
+		this.destroyedBlockPositions = new HashSet(var8);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.explosionX = var1.readDouble();
+		this.explosionY = var1.readDouble();
+		this.explosionZ = var1.readDouble();
+		this.explosionSize = var1.readFloat();
+		int var2 = var1.readInt();
+		this.destroyedBlockPositions = new HashSet();
+		int var3 = (int)this.explosionX;
+		int var4 = (int)this.explosionY;
+		int var5 = (int)this.explosionZ;
+
+		for(int var6 = 0; var6 < var2; ++var6) {
+			int var7 = var1.readByte() + var3;
+			int var8 = var1.readByte() + var4;
+			int var9 = var1.readByte() + var5;
+			this.destroyedBlockPositions.add(new ChunkPosition(var7, var8, var9));
+		}
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeDouble(this.explosionX);
+		var1.writeDouble(this.explosionY);
+		var1.writeDouble(this.explosionZ);
+		var1.writeFloat(this.explosionSize);
+		var1.writeInt(this.destroyedBlockPositions.size());
+		int var2 = (int)this.explosionX;
+		int var3 = (int)this.explosionY;
+		int var4 = (int)this.explosionZ;
+
+		for(Object var6 : this.destroyedBlockPositions) {
+			int var7 = ((ChunkPosition)var6).x - var2;
+			int var8 = ((ChunkPosition)var6).y - var3;
+			int var9 = ((ChunkPosition)var6).z - var4;
+			var1.writeByte(var7);
+			var1.writeByte(var8);
+			var1.writeByte(var9);
+		}
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleExplosion(this);
+	}
+
+	public int getPacketSize() {
+		return 32 + this.destroyedBlockPositions.size() * 3;
+	}
+}
--- net/minecraft/src/EntityExplodeFX.java
+++ net/minecraft/src/EntityExplodeFX.java
@@ -11,10 +11,6 @@
 		this.particleMaxAge = (int)(16.0D / ((double)this.rand.nextFloat() * 0.8D + 0.2D)) + 2;
 	}
 
-	public void renderParticle(Tessellator var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-		super.renderParticle(var1, var2, var3, var4, var5, var6, var7);
-	}
-
 	public void onUpdate() {
 		this.prevPosX = this.posX;
 		this.prevPosY = this.posY;
--- net/minecraft/src/IBlockAccess.java
+++ net/minecraft/src/IBlockAccess.java
@@ -12,4 +12,8 @@
 	Material getBlockMaterial(int var1, int var2, int var3);
 
 	boolean isBlockNormalCube(int var1, int var2, int var3);
+
+	default Block getBlock(int var1, int var2, int var3) {
+		return Block.blocksList[this.getBlockId(var1, var2, var3)];
+	}
 }
--- /dev/null
+++ net/minecraft/src/IListenToMyCommands.java
@@ -1,0 +1,7 @@
+package net.minecraft.src;
+
+public interface IListenToMyCommands {
+	void addHelpCommandMessage(String var1);
+
+	String getUsername();
+}
--- net/minecraft/src/TileEntity.java
+++ net/minecraft/src/TileEntity.java
@@ -10,6 +10,7 @@
 	public int xCoord;
 	public int yCoord;
 	public int zCoord;
+	public boolean hadChunkUpdate;
 
 	private static void addMapping(Class var0, String var1) {
 		if(classToNameMap.containsKey(var1)) {
@@ -54,6 +55,7 @@
 		}
 
 		if(var1 != null) {
+			var1.onSpawn();
 			var1.readFromNBT(var0);
 		} else {
 			System.out.println("Skipping TileEntity with id " + var0.getString("id"));
@@ -66,8 +68,10 @@
 		return this.worldObj.getBlockMetadata(this.xCoord, this.yCoord, this.zCoord);
 	}
 
-	public void onInventoryChanged() {
-		this.worldObj.updateTileEntityChunkAndDoNothing(this.xCoord, this.yCoord, this.zCoord, this);
+	public void onInventoryChange() {
+		if (this.worldObj != null) {
+			this.worldObj.updateTileEntityChunkAndDoNothing(this.xCoord, this.yCoord, this.zCoord, this);
+		}
 	}
 
 	public double getDistanceFrom(double var1, double var3, double var5) {
@@ -81,10 +85,19 @@
 		return Block.blocksList[this.worldObj.getBlockId(this.xCoord, this.yCoord, this.zCoord)];
 	}
 
+	public void onSpawn() {
+	}
+
+	public Packet getPacket() {
+		return null;
+	}
+
 	static {
 		addMapping(TileEntityFurnace.class, "Furnace");
 		addMapping(TileEntityChest.class, "Chest");
 		addMapping(TileEntitySign.class, "Sign");
 		addMapping(TileEntityMobSpawner.class, "MobSpawner");
+		addMapping(TileEntityRefabricator.class, "Refabricator");
+		addMapping(TileEntityCrate.class, "Crate");
 	}
 }
--- /dev/null
+++ net/minecraft/src/CreativeInventoryBuilder.java
@@ -1,0 +1,44 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class CreativeInventoryBuilder {
+	private final List<ItemStack> items = new ArrayList<>();
+	private final Map<Integer, String> labels = new HashMap<>();
+
+	public void addLabel(String label) {
+		this.lineBreak();
+		this.newLine();
+		this.labels.put(this.items.size() / 8, label);
+	}
+
+	public void lineBreak() {
+		if (this.items.size() % 8 != 0)
+			newLine();
+	}
+
+	public void newLine() {
+		int emptyItems = 8 - (this.items.size() % 8);
+		for (int i = 0; i < emptyItems; i++) {
+			this.items.add(null);
+		}
+	}
+
+	public void addItem(int id, int meta) {
+		if (id <= 0 || meta < 0) {
+			this.items.add(null);
+			return;
+		}
+
+		ItemStack item = new ItemStack(id, 1, -1, meta);
+		if (Item.itemsList[id] == null) item = null;
+		this.items.add(item);
+	}
+
+	public InventoryReadonly toInventory() {
+		return new InventoryReadonly(items.toArray(new ItemStack[0]), true, labels);
+	}
+}
--- net/minecraft/src/OSMap.java
+++ /dev/null
@@ -1,28 +1,0 @@
-package net.minecraft.src;
-
-public class OSMap {
-	public static final int[] osValues = new int[EnumOS.values().length];
-
-	static {
-		try {
-			osValues[EnumOS.linux.ordinal()] = 1;
-		} catch (NoSuchFieldError var4) {
-		}
-
-		try {
-			osValues[EnumOS.solaris.ordinal()] = 2;
-		} catch (NoSuchFieldError var3) {
-		}
-
-		try {
-			osValues[EnumOS.windows.ordinal()] = 3;
-		} catch (NoSuchFieldError var2) {
-		}
-
-		try {
-			osValues[EnumOS.macos.ordinal()] = 4;
-		} catch (NoSuchFieldError var1) {
-		}
-
-	}
-}
--- net/minecraft/src/ItemReed.java
+++ net/minecraft/src/ItemReed.java
@@ -3,12 +3,12 @@
 public class ItemReed extends Item {
 	private int spawnID;
 
-	public ItemReed(int var1, Block var2) {
+	public ItemReed(int var1, int var2) {
 		super(var1);
-		this.spawnID = var2.blockID;
+		this.spawnID = var2;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var3.getBlockId(var4, var5, var6) == Block.snow.blockID) {
 			var7 = 0;
 		} else {
@@ -43,7 +43,6 @@
 			if(var3.canBlockBePlacedAt(this.spawnID, var4, var5, var6, false)) {
 				Block var8 = Block.blocksList[this.spawnID];
 				if(var3.setBlockWithNotify(var4, var5, var6, this.spawnID)) {
-					Block.blocksList[this.spawnID].onBlockPlaced(var3, var4, var5, var6, var7);
 					var3.playSoundEffect((double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), var8.stepSound.getStepSound(), (var8.stepSound.getVolume() + 1.0F) / 2.0F, var8.stepSound.getPitch() * 0.8F);
 					--var1.stackSize;
 				}
--- net/minecraft/src/MinecartTrackLogic.java
+++ net/minecraft/src/MinecartTrackLogic.java
@@ -3,14 +3,23 @@
 import java.util.ArrayList;
 import java.util.List;
 
-class MinecartTrackLogic {
+public class MinecartTrackLogic {
 	private World worldObj;
 	private int trackX;
 	private int trackY;
 	private int trackZ;
 	private int trackMetadata;
 	private List connectedTracks;
-	final BlockMinecartTrack minecartTrack;
+	public final BlockMinecartTrack minecartTrack;
+
+	public static boolean isBlockMinecartTrack(World var1, int var2, int var3, int var4) {
+		int blockId = var1.getBlockId(var2, var3, var4);
+		return blockId == Block.minecartTrack.blockID || blockId == Block.boosterTrack.blockID;
+	}
+
+	private boolean isBlockMinecartTrack(int var1, int var2, int var3) {
+		return isBlockMinecartTrack(this.worldObj, var1, var2, var3);
+	}
 
 	public MinecartTrackLogic(BlockMinecartTrack var1, World var2, int var3, int var4, int var5) {
 		this.minecartTrack = var1;
@@ -72,11 +81,11 @@
 	}
 
 	private boolean isMinecartTrack(int var1, int var2, int var3) {
-		return this.worldObj.getBlockId(var1, var2, var3) == this.minecartTrack.blockID ? true : (this.worldObj.getBlockId(var1, var2 + 1, var3) == this.minecartTrack.blockID ? true : this.worldObj.getBlockId(var1, var2 - 1, var3) == this.minecartTrack.blockID);
+		return isBlockMinecartTrack(var1, var2, var3) ? true : (isBlockMinecartTrack(var1, var2 + 1, var3) ? true : isBlockMinecartTrack(var1, var2 - 1, var3));
 	}
 
 	private MinecartTrackLogic getMinecartTrackLogic(ChunkPosition var1) {
-		return this.worldObj.getBlockId(var1.x, var1.y, var1.z) == this.minecartTrack.blockID ? new MinecartTrackLogic(this.minecartTrack, this.worldObj, var1.x, var1.y, var1.z) : (this.worldObj.getBlockId(var1.x, var1.y + 1, var1.z) == this.minecartTrack.blockID ? new MinecartTrackLogic(this.minecartTrack, this.worldObj, var1.x, var1.y + 1, var1.z) : (this.worldObj.getBlockId(var1.x, var1.y - 1, var1.z) == this.minecartTrack.blockID ? new MinecartTrackLogic(this.minecartTrack, this.worldObj, var1.x, var1.y - 1, var1.z) : null));
+		return isBlockMinecartTrack(var1.x, var1.y, var1.z) ? new MinecartTrackLogic(this.minecartTrack, this.worldObj, var1.x, var1.y, var1.z) : (isBlockMinecartTrack(var1.x, var1.y + 1, var1.z) ? new MinecartTrackLogic(this.minecartTrack, this.worldObj, var1.x, var1.y + 1, var1.z) : (isBlockMinecartTrack(var1.x, var1.y - 1, var1.z) ? new MinecartTrackLogic(this.minecartTrack, this.worldObj, var1.x, var1.y - 1, var1.z) : null));
 	}
 
 	private boolean isConnectedTo(MinecartTrackLogic var1) {
@@ -167,21 +176,21 @@
 		}
 
 		if(var6 == 0) {
-			if(this.worldObj.getBlockId(this.trackX, this.trackY + 1, this.trackZ - 1) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX, this.trackY + 1, this.trackZ - 1)) {
 				var6 = 4;
 			}
 
-			if(this.worldObj.getBlockId(this.trackX, this.trackY + 1, this.trackZ + 1) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX, this.trackY + 1, this.trackZ + 1)) {
 				var6 = 5;
 			}
 		}
 
 		if(var6 == 1) {
-			if(this.worldObj.getBlockId(this.trackX + 1, this.trackY + 1, this.trackZ) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX + 1, this.trackY + 1, this.trackZ)) {
 				var6 = 2;
 			}
 
-			if(this.worldObj.getBlockId(this.trackX - 1, this.trackY + 1, this.trackZ) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX - 1, this.trackY + 1, this.trackZ)) {
 				var6 = 3;
 			}
 		}
@@ -278,21 +287,21 @@
 		}
 
 		if(var6 == 0) {
-			if(this.worldObj.getBlockId(this.trackX, this.trackY + 1, this.trackZ - 1) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX, this.trackY + 1, this.trackZ - 1)) {
 				var6 = 4;
 			}
 
-			if(this.worldObj.getBlockId(this.trackX, this.trackY + 1, this.trackZ + 1) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX, this.trackY + 1, this.trackZ + 1)) {
 				var6 = 5;
 			}
 		}
 
 		if(var6 == 1) {
-			if(this.worldObj.getBlockId(this.trackX + 1, this.trackY + 1, this.trackZ) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX + 1, this.trackY + 1, this.trackZ)) {
 				var6 = 2;
 			}
 
-			if(this.worldObj.getBlockId(this.trackX - 1, this.trackY + 1, this.trackZ) == this.minecartTrack.blockID) {
+			if(isBlockMinecartTrack(this.trackX - 1, this.trackY + 1, this.trackZ)) {
 				var6 = 3;
 			}
 		}
@@ -317,7 +326,7 @@
 
 	}
 
-	static int getNAdjacentTracks(MinecartTrackLogic var0) {
+	public static int getNAdjacentTracks(MinecartTrackLogic var0) {
 		return var0.getAdjacentTracks();
 	}
 }
--- net/minecraft/src/ItemBucket.java
+++ net/minecraft/src/ItemBucket.java
@@ -6,7 +6,6 @@
 	public ItemBucket(int var1, int var2) {
 		super(var1);
 		this.maxStackSize = 1;
-		this.maxDamage = 64;
 		this.isFull = var2;
 	}
 
@@ -15,7 +14,7 @@
 		float var5 = var3.prevRotationPitch + (var3.rotationPitch - var3.prevRotationPitch) * var4;
 		float var6 = var3.prevRotationYaw + (var3.rotationYaw - var3.prevRotationYaw) * var4;
 		double var7 = var3.prevPosX + (var3.posX - var3.prevPosX) * (double)var4;
-		double var9 = var3.prevPosY + (var3.posY - var3.prevPosY) * (double)var4;
+		double var9 = var3.prevPosY + (var3.posY - var3.prevPosY) * (double)var4 + 1.62D - (double)var3.yOffset;
 		double var11 = var3.prevPosZ + (var3.posZ - var3.prevPosZ) * (double)var4;
 		Vec3D var13 = Vec3D.createVector(var7, var9, var11);
 		float var14 = MathHelper.cos(-var6 * ((float)Math.PI / 180.0F) - (float)Math.PI);
@@ -26,7 +25,7 @@
 		float var20 = var14 * var16;
 		double var21 = 5.0D;
 		Vec3D var23 = var13.addVector((double)var18 * var21, (double)var17 * var21, (double)var20 * var21);
-		MovingObjectPosition var24 = var2.rayTraceBlocks_do(var13, var23, this.isFull == 0);
+		MovingObjectPosition var24 = var2.rayTraceBlocks(var13, var23, this.isFull == 0);
 		if(var24 == null) {
 			return var1;
 		} else {
--- /dev/null
+++ net/minecraft/src/Direction.java
@@ -1,0 +1,112 @@
+package net.minecraft.src;
+
+public enum Direction {
+	EAST(1, 0, 0.5F, 0.0F),
+	WEST(-1, 0, 0.0F, 0.5F),
+	SOUTH(0, 1, 0.5F, 0.5F),
+	NORTH(0, -1, 0.0F, 0.0F);
+
+	private final int frontX, frontZ;
+	private final float stairMinX, stairMinZ;
+	private final boolean zDir;
+	private Direction perpLeft, perpRight;
+
+	Direction(int backX, int backZ, float stairMinX, float stairMinZ) {
+		this.frontX = -backX;
+		this.frontZ = -backZ;
+		this.stairMinX = stairMinX;
+		this.stairMinZ = stairMinZ;
+		this.zDir = backZ != 0;
+	}
+
+	public int getFrontX() {
+		return this.frontX;
+	}
+
+	public int getFrontZ() {
+		return this.frontZ;
+	}
+
+	public int getBackX() {
+		return -this.frontX;
+	}
+
+	public int getBackZ() {
+		return -this.frontZ;
+	}
+
+	public int getLeftX() {
+		return this.frontZ;
+	}
+
+	public int getLeftZ() {
+		return this.frontX;
+	}
+
+	public int getRightX() {
+		return -this.frontZ;
+	}
+
+	public int getRightZ() {
+		return -this.frontX;
+	}
+
+	public float getStairMinX() {
+		return !isZ() ? stairMinX : 0.0F;
+	}
+
+	public float getStairMinZ() {
+		return isZ() ? stairMinZ : 0.0F;
+	}
+
+	public float getStairMaxX() {
+		return getStairMinX() + (isZ() ? 1.0F : 0.5F);
+	}
+
+	public float getStairMaxZ() {
+		return getStairMinZ() + (isZ() ? 0.5F : 1.0F);
+	}
+
+	public float getInnerStairMinX() {
+		return stairMinX;
+	}
+
+	public float getInnerStairMinZ() {
+		return stairMinZ;
+	}
+
+	public float getInnerStairMaxX() {
+		return stairMinX + 0.5F;
+	}
+
+	public float getInnerStairMaxZ() {
+		return stairMinZ + 0.5F;
+	}
+
+	public boolean isZ() {
+		return zDir;
+	}
+
+	public Direction getPerpLeft() {
+		return perpLeft;
+	}
+
+	public Direction getPerpRight() {
+		return perpRight;
+	}
+
+	public Direction getBehind() {
+		return perpRight.perpRight;
+	}
+
+	public String toString() {
+		return super.toString().toLowerCase();
+	}
+
+	static {
+		EAST.perpLeft = WEST.perpRight = NORTH;
+		EAST.perpRight = WEST.perpLeft = SOUTH;
+		NORTH.perpLeft = SOUTH.perpRight = WEST;
+		NORTH.perpRight = SOUTH.perpLeft = EAST;
+	}
+}
--- net/minecraft/src/PanelCrashReport.java
+++ net/minecraft/src/PanelCrashReport.java
@@ -9,10 +9,58 @@
 import java.io.StringWriter;
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.Random;
+
+import net.minecraft.client.Minecraft;
 import org.lwjgl.Sys;
 import org.lwjgl.opengl.GL11;
 
 public class PanelCrashReport extends Panel {
+	private static final String[] wittyComments = new String[] {
+			"Who set us up the TNT?",
+			"Everything's going to plan. No, really, that was supposed to happen.",
+			"Uh... Did I do that?",
+			"Oops.",
+			"Why did you do that?",
+			"I feel sad now :(",
+			"My bad.",
+			"I'm sorry, Dave.",
+			"I let you down. Sorry :(",
+			"On the bright side, I bought you a teddy bear!",
+			"Daisy, daisy...",
+			"Oh - I know what I did wrong!",
+			"Hey, that tickles! Hehehe!",
+			"I blame Dinnerbone.",
+			"You should try our sister game, Minceraft!",
+			"Don't be sad. I'll do better next time, I promise!",
+			"Don't be sad, have a hug! <3",
+			"I just don't know what went wrong :(",
+			"Shall we play a game?",
+			"Quite honestly, I wouldn't worry myself about that.",
+			"I bet Cylons wouldn't have this problem.",
+			"Sorry :(",
+			"Surprise! Haha. Well, this is awkward.",
+			"Would you like a cupcake?",
+			"Hi. I'm Minecraft, and I'm a crashaholic.",
+			"Ooh. Shiny.",
+			"This doesn't make any sense!",
+			"Why is it breaking :(",
+			"Don't do that.",
+			"Ouch. That hurt :(",
+			"You're mean.",
+			"This is a token for 1 free hug. Redeem at your nearest Mojangsta: [~~HUG~~]",
+			"There are four lights!",
+			"But it works on my machine.",
+			"Witty comment unavailable :(",
+			"You can go outside now.",
+			"Have you tried downloading more RAM?",
+			"Package protected is the worst Java feature.",
+			"RetroMCP-Java messed up the obfuscation!",
+			"So... what now?",
+			"Sorry, time's up, you're dead!",
+			"Bruh moment."
+	};
+
 	public PanelCrashReport(UnexpectedThrowable var1) {
 		this.setBackground(new Color(3028036));
 		this.setLayout(new BorderLayout());
@@ -25,7 +73,7 @@
 		try {
 			var5 = var5 + "Generated " + (new SimpleDateFormat()).format(new Date()) + "\n";
 			var5 = var5 + "\n";
-			var5 = var5 + "Minecraft: Minecraft Alpha v1.1.2_01\n";
+			var5 = var5 + "Minecraft: " + Minecraft.version + "\n";
 			var5 = var5 + "OS: " + System.getProperty("os.name") + " (" + System.getProperty("os.arch") + ") version " + System.getProperty("os.version") + "\n";
 			var5 = var5 + "Java: " + System.getProperty("java.version") + ", " + System.getProperty("java.vendor") + "\n";
 			var5 = var5 + "VM: " + System.getProperty("java.vm.name") + " (" + System.getProperty("java.vm.info") + "), " + System.getProperty("java.vm.vendor") + "\n";
@@ -67,7 +115,7 @@
 		}
 
 		var6 = var6 + "\n";
-		var6 = var6 + "\n";
+		var6 = var6 + "// " + wittyComments[new Random().nextInt(wittyComments.length)];
 		var6 = var6 + "\n";
 		var6 = var6 + "--- BEGIN ERROR REPORT " + Integer.toHexString(var6.hashCode()) + " --------\n";
 		var6 = var6 + var5;
--- /dev/null
+++ net/minecraft/src/ConvertProgressUpdater.java
@@ -1,0 +1,19 @@
+package net.minecraft.src;
+
+import net.minecraft.server.MinecraftServer;
+public class ConvertProgressUpdater implements IProgressUpdate {
+	private long lastTimeMillis = System.currentTimeMillis();
+
+	public void displayProgressMessage(String var1) {
+	}
+
+	public void displayLoadingString(String var1) {
+	}
+
+	public void setLoadingProgress(int var1) {
+		if(System.currentTimeMillis() - this.lastTimeMillis >= 1000L) {
+			this.lastTimeMillis = System.currentTimeMillis();
+			MinecraftServer.logger.info("Converting... " + var1 + "%");
+		}
+	}
+}
--- net/minecraft/src/BlockChest.java
+++ net/minecraft/src/BlockChest.java
@@ -3,11 +3,11 @@
 import java.util.Random;
 
 public class BlockChest extends BlockContainer {
-	private Random random = new Random();
+	private final Random random = new Random();
 
-	protected BlockChest(int var1) {
+	public BlockChest(int var1) {
 		super(var1, Material.wood);
-		this.blockIndexInTexture = 26;
+		this.blockIndexInTexture = textureXY(28, 3);
 	}
 
 	public int getBlockTexture(IBlockAccess var1, int var2, int var3, int var4, int var5) {
@@ -65,7 +65,7 @@
 						var13 = 2;
 					}
 
-					return (var5 == var13 ? this.blockIndexInTexture + 16 : this.blockIndexInTexture + 32) + var10;
+					return (var5 == var13 ? this.blockIndexInTexture + 32 : this.blockIndexInTexture + 64) + var10;
 				} else {
 					return this.blockIndexInTexture;
 				}
@@ -90,7 +90,7 @@
 					var13 = 4;
 				}
 
-				return (var5 == var13 ? this.blockIndexInTexture + 16 : this.blockIndexInTexture + 32) + var10;
+				return (var5 == var13 ? this.blockIndexInTexture + 32 : this.blockIndexInTexture + 64) + var10;
 			} else {
 				return this.blockIndexInTexture;
 			}
@@ -127,10 +127,11 @@
 	}
 
 	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
+		if (!var1.canDoClientAction()) return;
 		TileEntityChest var5 = (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4);
 
-		for(int var6 = 0; var6 < var5.getSizeInventory(); ++var6) {
-			ItemStack var7 = var5.getStackInSlot(var6);
+		for(int var6 = 0; var6 < var5.getInventorySize(); ++var6) {
+			ItemStack var7 = var5.getStack(var6);
 			if(var7 != null) {
 				float var8 = this.random.nextFloat() * 0.8F + 0.1F;
 				float var9 = this.random.nextFloat() * 0.8F + 0.1F;
@@ -143,7 +144,9 @@
 					}
 
 					var7.stackSize -= var11;
-					EntityItem var12 = new EntityItem(var1, (double)((float)var2 + var8), (double)((float)var3 + var9), (double)((float)var4 + var10), new ItemStack(var7.itemID, var11, var7.itemDmg));
+					ItemStack dropped = var7.copy();
+					dropped.stackSize = var11;
+					EntityItem var12 = new EntityItem(var1, (double)((float)var2 + var8), (double)((float)var3 + var9), (double)((float)var4 + var10), dropped);
 					float var13 = 0.05F;
 					var12.motionX = (double)((float)this.random.nextGaussian() * var13);
 					var12.motionY = (double)((float)this.random.nextGaussian() * var13 + 0.2F);
@@ -157,7 +160,7 @@
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
-		Object var6 = (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4);
+		IInventory var6 = (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4);
 		if(var1.isBlockNormalCube(var2, var3 + 1, var4)) {
 			return true;
 		} else if(var1.getBlockId(var2 - 1, var3, var4) == this.blockID && var1.isBlockNormalCube(var2 - 1, var3 + 1, var4)) {
@@ -170,22 +173,23 @@
 			return true;
 		} else {
 			if(var1.getBlockId(var2 - 1, var3, var4) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (TileEntityChest)var1.getBlockTileEntity(var2 - 1, var3, var4), (IInventory)var6);
+				var6 = new InventoryLargeChest("Large chest", (TileEntityChest) var1.getBlockTileEntity(var2 - 1, var3, var4), var6);
 			}
 
 			if(var1.getBlockId(var2 + 1, var3, var4) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (IInventory)var6, (TileEntityChest)var1.getBlockTileEntity(var2 + 1, var3, var4));
+				var6 = new InventoryLargeChest("Large chest", var6, (TileEntityChest) var1.getBlockTileEntity(var2 + 1, var3, var4));
 			}
 
 			if(var1.getBlockId(var2, var3, var4 - 1) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4 - 1), (IInventory)var6);
+				var6 = new InventoryLargeChest("Large chest", (TileEntityChest) var1.getBlockTileEntity(var2, var3, var4 - 1), var6);
 			}
 
 			if(var1.getBlockId(var2, var3, var4 + 1) == this.blockID) {
-				var6 = new InventoryLargeChest("Large chest", (IInventory)var6, (TileEntityChest)var1.getBlockTileEntity(var2, var3, var4 + 1));
+				var6 = new InventoryLargeChest("Large chest", var6, (TileEntityChest) var1.getBlockTileEntity(var2, var3, var4 + 1));
 			}
 
-			var5.displayGUIChest((IInventory)var6);
+			var5.displayGUIChest(var6);
+			var1.performAction(var5, 1003, var2, var3, var4, 0);
 			return true;
 		}
 	}
--- net/minecraft/src/PlayerManager.java
+++ net/minecraft/src/PlayerManager.java
@@ -3,16 +3,25 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+
 import net.minecraft.server.MinecraftServer;
-
 public class PlayerManager {
 	private List players = new ArrayList();
-	private MCHashTable2 playerInstances = new MCHashTable2();
+	private MCHashTableLong playerInstances = new MCHashTableLong();
 	private List playerInstancesToUpdate = new ArrayList();
 	private MinecraftServer mcServer;
-
-	public PlayerManager(MinecraftServer var1) {
-		this.mcServer = var1;
+	private final int playerViewRadius;
+	private final int maxChunkLoad;
+	private final int[][] xzDirectionsConst = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
+
+	public PlayerManager(MinecraftServer mcServer, int var2, int var3) {
+		if (var2 > 24) throw new IllegalArgumentException("Too big view radius!");
+		if (var2 < 2) throw new IllegalArgumentException("Too small view radius!");
+		if (var3 < 1) var3 = 1;
+
+		this.mcServer = mcServer;
+		this.playerViewRadius = var2;
+		this.maxChunkLoad = var3;
 	}
 
 	public void updatePlayerInstances() throws IOException {
@@ -39,7 +48,7 @@
 		int var6 = var4 >> 4;
 		PlayerInstance var7 = this.getPlayerInstance(var5, var6, false);
 		if(var7 != null) {
-			var7.sendTileEntity(var1);
+			var7.sendPacketToPlayersInInstance(var1);
 		}
 
 	}
@@ -55,23 +64,41 @@
 	}
 
 	public void addPlayer(EntityPlayerMP var1) {
-		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("\u00a7e" + var1.username + " joined the game."));
 		int var2 = (int)var1.posX >> 4;
 		int var3 = (int)var1.posZ >> 4;
 		var1.managedPosX = var1.posX;
 		var1.managedPosZ = var1.posZ;
-
-		for(int var4 = var2 - 10; var4 <= var2 + 10; ++var4) {
-			for(int var5 = var3 - 10; var5 <= var3 + 10; ++var5) {
-				this.getPlayerInstance(var4, var5, true).addPlayer(var1);
+		int var4 = 0;
+		int var5 = this.playerViewRadius;
+		int var6 = 0;
+		int var7 = 0;
+		this.getPlayerInstance(var2, var3, true).addPlayer(var1);
+
+		int var8;
+		for(var8 = 1; var8 <= var5 * 2; ++var8) {
+			for(int var9 = 0; var9 < 2; ++var9) {
+				int[] var10 = this.xzDirectionsConst[var4++ % 4];
+
+				for(int var11 = 0; var11 < var8; ++var11) {
+					var6 += var10[0];
+					var7 += var10[1];
+					this.getPlayerInstance(var2 + var6, var3 + var7, true).addPlayer(var1);
+				}
 			}
+		}
+
+		var4 %= 4;
+
+		for(var8 = 0; var8 < var5 * 2; ++var8) {
+			var6 += this.xzDirectionsConst[var4][0];
+			var7 += this.xzDirectionsConst[var4][1];
+			this.getPlayerInstance(var2 + var6, var3 + var7, true).addPlayer(var1);
 		}
 
 		this.players.add(var1);
 	}
 
 	public void removePlayer(EntityPlayerMP var1) {
-		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("\u00a7e" + var1.username + " left the game."));
 		int var2 = (int)var1.posX >> 4;
 		int var3 = (int)var1.posZ >> 4;
 
@@ -87,10 +114,10 @@
 		this.players.remove(var1);
 	}
 
-	private boolean a(int var1, int var2, int var3, int var4) {
+	private boolean isOutsidePlayerViewRadius(int var1, int var2, int var3, int var4) {
 		int var5 = var1 - var3;
 		int var6 = var2 - var4;
-		return var5 >= -10 && var5 <= 10 ? var6 >= -10 && var6 <= 10 : false;
+		return var5 >= -this.playerViewRadius && var5 <= this.playerViewRadius ? var6 >= -this.playerViewRadius && var6 <= this.playerViewRadius : false;
 	}
 
 	public void updateMountedMovingPlayer(EntityPlayerMP var1) {
@@ -105,13 +132,17 @@
 			int var12 = var2 - var10;
 			int var13 = var3 - var11;
 			if(var12 != 0 || var13 != 0) {
-				for(int var14 = var2 - 10; var14 <= var2 + 10; ++var14) {
-					for(int var15 = var3 - 10; var15 <= var3 + 10; ++var15) {
-						if(!this.a(var14, var15, var10, var11)) {
+				for(int var14 = var2 - this.playerViewRadius; var14 <= var2 + this.playerViewRadius; ++var14) {
+					for(int var15 = var3 - this.playerViewRadius; var15 <= var3 + this.playerViewRadius; ++var15) {
+						if (this.mcServer.worldMngr.lazyLoading && !this.mcServer.worldMngr.doChunksNearChunkExist(var14, 0, var15, 1)) {
+							continue;
+						}
+
+						if(!this.isOutsidePlayerViewRadius(var14, var15, var10, var11)) {
 							this.getPlayerInstance(var14, var15, true).addPlayer(var1);
 						}
 
-						if(!this.a(var14 - var12, var15 - var13, var2, var3)) {
+						if(!this.isOutsidePlayerViewRadius(var14 - var12, var15 - var13, var2, var3)) {
 							PlayerInstance var16 = this.getPlayerInstance(var14 - var12, var15 - var13, false);
 							if(var16 != null) {
 								var16.removePlayer(var1);
@@ -126,19 +157,50 @@
 		}
 	}
 
+	public void loadChunks(EntityPlayerMP var1) {
+		if (!this.mcServer.worldMngr.lazyLoading) {
+			return;
+		}
+
+		int var2 = (int)var1.posX >> 4;
+		int var3 = (int)var1.posZ >> 4;
+		int var10 = (int)var1.managedPosX >> 4;
+		int var11 = (int)var1.managedPosZ >> 4;
+		int var12 = var2 - var10;
+		int var13 = var3 - var11;
+		for(int var14 = var2 - this.playerViewRadius; var14 <= var2 + this.playerViewRadius; ++var14) {
+			for(int var15 = var3 - this.playerViewRadius; var15 <= var3 + this.playerViewRadius; ++var15) {
+				if (!this.mcServer.worldMngr.doChunksNearChunkExist(var14, 0, var15, 1)) {
+					continue;
+				}
+
+				if(!this.isOutsidePlayerViewRadius(var14, var15, var10, var11)) {
+					this.getPlayerInstance(var14, var15, true).addPlayer(var1);
+				}
+
+				if(!this.isOutsidePlayerViewRadius(var14 - var12, var15 - var13, var2, var3)) {
+					PlayerInstance var16 = this.getPlayerInstance(var14 - var12, var15 - var13, false);
+					if(var16 != null) {
+						var16.removePlayer(var1);
+					}
+				}
+			}
+		}
+	}
+
 	public int getMaxTrackingDistance() {
-		return 144;
+		return this.playerViewRadius * 16 - 16;
 	}
 
-	static MinecraftServer getMinecraftServer(PlayerManager var0) {
+	public static MinecraftServer getMinecraftServer(PlayerManager var0) {
 		return var0.mcServer;
 	}
 
-	static MCHashTable2 getPlayerInstances(PlayerManager var0) {
+	public static MCHashTableLong getPlayerInstances(PlayerManager var0) {
 		return var0.playerInstances;
 	}
 
-	static List getPlayerInstancesToUpdate(PlayerManager var0) {
+	public static List getPlayerInstancesToUpdate(PlayerManager var0) {
 		return var0.playerInstancesToUpdate;
 	}
 }
--- net/minecraft/src/MCHashTable.java
+++ /dev/null
@@ -1,151 +1,0 @@
-package net.minecraft.src;
-
-public class MCHashTable {
-	private transient MCHashEntry[] slots = new MCHashEntry[16];
-	private transient int count;
-	private int threshold = 12;
-	private final float growFactor = 12.0F / 16.0F;
-	private transient volatile int versionStamp;
-
-	private static int computeHash(int var0) {
-		var0 ^= var0 >>> 20 ^ var0 >>> 12;
-		return var0 ^ var0 >>> 7 ^ var0 >>> 4;
-	}
-
-	private static int getSlotIndex(int var0, int var1) {
-		return var0 & var1 - 1;
-	}
-
-	public Object lookup(int var1) {
-		int var2 = computeHash(var1);
-
-		for(MCHashEntry var3 = this.slots[getSlotIndex(var2, this.slots.length)]; var3 != null; var3 = var3.nextEntry) {
-			if(var3.hashEntry == var1) {
-				return var3.valueEntry;
-			}
-		}
-
-		return null;
-	}
-
-	public boolean containsItem(int var1) {
-		return this.lookupEntry(var1) != null;
-	}
-
-	final MCHashEntry lookupEntry(int var1) {
-		int var2 = computeHash(var1);
-
-		for(MCHashEntry var3 = this.slots[getSlotIndex(var2, this.slots.length)]; var3 != null; var3 = var3.nextEntry) {
-			if(var3.hashEntry == var1) {
-				return var3;
-			}
-		}
-
-		return null;
-	}
-
-	public void addKey(int var1, Object var2) {
-		int var3 = computeHash(var1);
-		int var4 = getSlotIndex(var3, this.slots.length);
-
-		for(MCHashEntry var5 = this.slots[var4]; var5 != null; var5 = var5.nextEntry) {
-			if(var5.hashEntry == var1) {
-				var5.valueEntry = var2;
-			}
-		}
-
-		++this.versionStamp;
-		this.insert(var3, var1, var2, var4);
-	}
-
-	private void grow(int var1) {
-		MCHashEntry[] var2 = this.slots;
-		int var3 = var2.length;
-		if(var3 == 1073741824) {
-			this.threshold = Integer.MAX_VALUE;
-		} else {
-			MCHashEntry[] var4 = new MCHashEntry[var1];
-			this.copyTo(var4);
-			this.slots = var4;
-			this.threshold = (int)((float)var1 * this.growFactor);
-		}
-	}
-
-	private void copyTo(MCHashEntry[] var1) {
-		MCHashEntry[] var2 = this.slots;
-		int var3 = var1.length;
-
-		for(int var4 = 0; var4 < var2.length; ++var4) {
-			MCHashEntry var5 = var2[var4];
-			if(var5 != null) {
-				var2[var4] = null;
-
-				MCHashEntry var6;
-				do {
-					var6 = var5.nextEntry;
-					int var7 = getSlotIndex(var5.slotHash, var3);
-					var5.nextEntry = var1[var7];
-					var1[var7] = var5;
-					var5 = var6;
-				} while(var6 != null);
-			}
-		}
-
-	}
-
-	public Object removeObject(int var1) {
-		MCHashEntry var2 = this.removeEntry(var1);
-		return var2 == null ? null : var2.valueEntry;
-	}
-
-	final MCHashEntry removeEntry(int var1) {
-		int var2 = computeHash(var1);
-		int var3 = getSlotIndex(var2, this.slots.length);
-		MCHashEntry var4 = this.slots[var3];
-
-		MCHashEntry var5;
-		MCHashEntry var6;
-		for(var5 = var4; var5 != null; var5 = var6) {
-			var6 = var5.nextEntry;
-			if(var5.hashEntry == var1) {
-				++this.versionStamp;
-				--this.count;
-				if(var4 == var5) {
-					this.slots[var3] = var6;
-				} else {
-					var4.nextEntry = var6;
-				}
-
-				return var5;
-			}
-
-			var4 = var5;
-		}
-
-		return var5;
-	}
-
-	public void clearMap() {
-		++this.versionStamp;
-		MCHashEntry[] var1 = this.slots;
-
-		for(int var2 = 0; var2 < var1.length; ++var2) {
-			var1[var2] = null;
-		}
-
-		this.count = 0;
-	}
-
-	private void insert(int var1, int var2, Object var3, int var4) {
-		MCHashEntry var5 = this.slots[var4];
-		this.slots[var4] = new MCHashEntry(var1, var2, var3, var5);
-		if(this.count++ >= this.threshold) {
-			this.grow(2 * this.slots.length);
-		}
-
-	}
-
-	static int getHash(int var0) {
-		return computeHash(var0);
-	}
-}
--- net/minecraft/src/ChunkCoordIntPair.java
+++ net/minecraft/src/ChunkCoordIntPair.java
@@ -9,8 +9,15 @@
 		this.chunkZPos = var2;
 	}
 
+	public static long chunkXZ2Int(int i0, int i1) {
+		return (long)i0 & 4294967295L | ((long)i1 & 4294967295L) << 32;
+	}
+
 	public int hashCode() {
-		return this.chunkXPos << 8 | this.chunkZPos;
+		long j1 = chunkXZ2Int(this.chunkXPos, this.chunkZPos);
+		int i3 = (int)j1;
+		int i4 = (int)(j1 >> 32);
+		return i3 ^ i4;
 	}
 
 	public boolean equals(Object var1) {
@@ -18,7 +25,7 @@
 		return var2.chunkXPos == this.chunkXPos && var2.chunkZPos == this.chunkZPos;
 	}
 
-	public double a(Entity var1) {
+	public double distanceFrom(Entity var1) {
 		double var2 = (double)(this.chunkXPos * 16 + 8);
 		double var4 = (double)(this.chunkZPos * 16 + 8);
 		double var6 = var2 - var1.posX;
--- net/minecraft/src/BlockMobSpawner.java
+++ net/minecraft/src/BlockMobSpawner.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockMobSpawner extends BlockContainer {
-	protected BlockMobSpawner(int var1, int var2) {
+	public BlockMobSpawner(int var1, int var2) {
 		super(var1, var2, Material.rock);
 	}
 
--- net/minecraft/src/EntityDiggingFX.java
+++ net/minecraft/src/EntityDiggingFX.java
@@ -1,9 +1,9 @@
 package net.minecraft.src;
 
 public class EntityDiggingFX extends EntityFX {
-	public EntityDiggingFX(World var1, double var2, double var4, double var6, double var8, double var10, double var12, Block var14) {
+	public EntityDiggingFX(World var1, double var2, double var4, double var6, double var8, double var10, double var12, Block var14, int metadata) {
 		super(var1, var2, var4, var6, var8, var10, var12);
-		this.particleTextureIndex = var14.blockIndexInTexture;
+		this.particleTextureIndex = var14.getBlockTextureFromSideAndMetadata(0, metadata);
 		this.particleGravity = var14.blockParticleGravity;
 		this.particleRed = this.particleGreen = this.particleBlue = 0.6F;
 		this.particleScale /= 2.0F;
@@ -14,10 +14,10 @@
 	}
 
 	public void renderParticle(Tessellator var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-		float var8 = ((float)(this.particleTextureIndex % 16) + this.particleTextureJitterX / 4.0F) / 16.0F;
-		float var9 = var8 + 0.999F / 64.0F;
-		float var10 = ((float)(this.particleTextureIndex / 16) + this.particleTextureJitterY / 4.0F) / 16.0F;
-		float var11 = var10 + 0.999F / 64.0F;
+		float var8 = ((float)(this.particleTextureIndex % 32) + this.particleTextureJitterX / 4.0F) / 32.0F;
+		float var9 = var8 + 0.999F / 128.0F;
+		float var10 = ((float)(this.particleTextureIndex / 32) + this.particleTextureJitterY / 4.0F) / 32.0F;
+		float var11 = var10 + 0.999F / 128.0F;
 		float var12 = 0.1F * this.particleScale;
 		float var13 = (float)(this.prevPosX + (this.posX - this.prevPosX) * (double)var2 - interpPosX);
 		float var14 = (float)(this.prevPosY + (this.posY - this.prevPosY) * (double)var2 - interpPosY);
--- /dev/null
+++ net/minecraft/src/Packet106Transaction.java
@@ -1,0 +1,40 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet106Transaction extends Packet {
+	public int windowId;
+	public short mysteryShort;
+	public boolean mysteryBoolean;
+
+	public Packet106Transaction() {
+	}
+
+	public Packet106Transaction(int var1, short var2, boolean var3) {
+		this.windowId = var1;
+		this.mysteryShort = var2;
+		this.mysteryBoolean = var3;
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleTransaction(this);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.windowId = var1.readByte();
+		this.mysteryShort = var1.readShort();
+		this.mysteryBoolean = var1.readByte() != 0;
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeByte(this.windowId);
+		var1.writeShort(this.mysteryShort);
+		var1.writeByte(this.mysteryBoolean ? 1 : 0);
+	}
+
+	public int getPacketSize() {
+		return 4;
+	}
+}
--- net/minecraft/src/GuiYesNo.java
+++ net/minecraft/src/GuiYesNo.java
@@ -23,7 +23,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.message1, this.width / 2, 70, 16777215);
 		this.drawCenteredString(this.fontRenderer, this.message2, this.width / 2, 90, 16777215);
 		super.drawScreen(var1, var2, var3);
--- net/minecraft/src/TileEntityMobSpawner.java
+++ net/minecraft/src/TileEntityMobSpawner.java
@@ -54,6 +54,12 @@
 						double var15 = (double)this.zCoord + (this.worldObj.rand.nextDouble() - this.worldObj.rand.nextDouble()) * 4.0D;
 						var9.setLocationAndAngles(var11, var13, var15, this.worldObj.rand.nextFloat() * 360.0F, 0.0F);
 						if(var9.getCanSpawnHere()) {
+							if(var9 instanceof EntityLeveledMob) {
+								if (var13 <= 88) {
+									((EntityLeveledMob) var9).setLevel(1);
+								}
+							}
+
 							this.worldObj.spawnEntityInWorld(var9);
 
 							for(int var17 = 0; var17 < 20; ++var17) {
--- /dev/null
+++ net/minecraft/src/Packet101CloseWindow.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet101CloseWindow extends Packet {
+	public int windowId;
+
+	public Packet101CloseWindow() {
+	}
+
+	public Packet101CloseWindow(int var1) {
+		this.windowId = var1;
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleCloseWindow(this);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.windowId = var1.readByte();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeByte(this.windowId);
+	}
+
+	public int getPacketSize() {
+		return 1;
+	}
+}
--- /dev/null
+++ net/minecraft/src/BooleanHookRenderBlock.java
@@ -1,0 +1,5 @@
+package net.minecraft.src;
+
+public interface BooleanHookRenderBlock {
+	boolean call(BaseMod mod, IBlockAccess blockAccess, Block block, int x, int y, int z, int type);
+}
--- net/minecraft/src/Chunk.java
+++ net/minecraft/src/Chunk.java
@@ -1,36 +1,56 @@
 package net.minecraft.src;
 
+import java.nio.ByteBuffer;
+import java.nio.ShortBuffer;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 
+import static net.minecraft.src.Constants.CHUNK_BIT_OFFSET;
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 public class Chunk {
+	public static final int
+			CHUNK_VERSION_0_1 = 0,
+			CHUNK_VERSION_0_2 = 1,
+			CHUNK_VERSION_0_3 = 2,
+			CHUNK_VERSION_0_3_1 = 3;
+	public static final int CHUNK_VERSION_CURRENT = CHUNK_VERSION_0_3_1;
+
 	public static boolean isLit;
-	public byte[] blocks;
+	public short[] blocks;
+	public byte[] biomes;
 	public boolean isChunkLoaded;
 	public World worldObj;
-	public NibbleArray data;
+	public byte[] data;
 	public NibbleArray skylightMap;
 	public NibbleArray blocklightMap;
-	public byte[] heightMap;
+	public int[] heightMap;
 	public int height;
 	public final int xPosition;
 	public final int zPosition;
 	public Map chunkTileEntityMap;
 	public List[] entities;
 	public boolean isTerrainPopulated;
+	public boolean isUnderworldPopulated;
+    public boolean isLightPopulated;
 	public boolean isModified;
 	public boolean neverSave;
 	public boolean isChunkRendered;
 	public boolean hasEntities;
 	public long lastSaveTime;
+	public boolean[] updateSkylightColumns;
+	public boolean isGapLightingUpdated;
+	private int queuedLightChecks;
+	public int heightMapMinimum;
 
 	public Chunk(World var1, int var2, int var3) {
 		this.chunkTileEntityMap = new HashMap();
-		this.entities = new List[8];
+		this.entities = new List[CHUNK_HEIGHT / 16];
 		this.isTerrainPopulated = false;
+		this.isUnderworldPopulated = false;
 		this.isModified = false;
 		this.isChunkRendered = false;
 		this.hasEntities = false;
@@ -38,7 +58,11 @@
 		this.worldObj = var1;
 		this.xPosition = var2;
 		this.zPosition = var3;
-		this.heightMap = new byte[256];
+		this.queuedLightChecks = 4096;
+		this.heightMap = new int[256];
+		this.biomes = new byte[256];
+		this.updateSkylightColumns = new boolean[256];
+		this.isGapLightingUpdated = false;
 
 		for(int var4 = 0; var4 < this.entities.length; ++var4) {
 			this.entities[var4] = new ArrayList();
@@ -46,10 +70,10 @@
 
 	}
 
-	public Chunk(World var1, byte[] var2, int var3, int var4) {
+	public Chunk(World var1, short[] var2, int var3, int var4) {
 		this(var1, var3, var4);
 		this.blocks = var2;
-		this.data = new NibbleArray(var2.length);
+		this.data = new byte[var2.length];
 		this.skylightMap = new NibbleArray(var2.length);
 		this.blocklightMap = new NibbleArray(var2.length);
 	}
@@ -58,186 +82,298 @@
 		return var1 == this.xPosition && var2 == this.zPosition;
 	}
 
+	public void generateBiomes(World worldObj) {
+		Profiler.startSection("biomes");
+		for (int x = 0; x < 16; x++) {
+			for (int z = 0; z < 16; z++) {
+				this.biomes[z << 4 | x] = worldObj.generateBiome((this.xPosition << 4) + x, (this.zPosition << 4) + z).id;
+			}
+		}
+		Profiler.endSection();
+	}
+
+	public Biome getBiome(int x, int z) {
+		if (this.biomes == null) {
+			return Biome.forest;
+		}
+		Biome biome = Biome.biomesList[this.biomes[z << 4 | x]];
+		return biome == null ? Biome.forest : biome;
+	}
+
 	public int getHeightValue(int var1, int var2) {
-		return this.heightMap[var2 << 4 | var1] & 255;
+		return this.heightMap[var2 << 4 | var1];
 	}
 
 	public void doNothing() {
 	}
 
 	public void generateHeightMap() {
-		int var1 = 127;
+		this.heightMapMinimum = Integer.MAX_VALUE;
+
+		for (int var2 = 0; var2 < 16; ++var2) {
+			int var3 = 0;
+			while (var3 < 16) {
+				int var4 = CHUNK_HEIGHT - 1;
+				while (true) {
+					if (var4 > 0) {
+						int var5 = this.blocks[var2 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET | var4];
+
+						if (Block.lightOpacity[var5] == 0) {
+							--var4;
+							continue;
+						}
+
+						this.heightMap[var3 << 4 | var2] = var4;
+						if (var4 < this.heightMapMinimum) {
+							this.heightMapMinimum = var4;
+						}
+					}
+					++var3;
+					break;
+				}
+			}
+		}
+
+		this.isModified = true;
+	}
+
+	public void generateSkylightMap() {
+		this.heightMapMinimum = Integer.MAX_VALUE;
+
+        for (int var2 = 0; var2 < 16; ++var2) {
+            int var3 = 0;
+            while (var3 < 16) {
+                int var4 = CHUNK_HEIGHT - 1;
+
+                while (true) {
+                    if (var4 > 0) {
+                        if (this.getBlockLightOpacity(var2, var4 - 1, var3) == 0) {
+                            --var4;
+                            continue;
+                        }
+
+                        this.heightMap[var3 << 4 | var2] = var4;
+
+                        if (var4 < this.heightMapMinimum) {
+                            this.heightMapMinimum = var4;
+                        }
+                    }
+
+                    var4 = 15;
+                    int var5 = CHUNK_HEIGHT - 1;
+
+                    do {
+                        int var6 = this.getBlockLightOpacity(var2, var5, var3);
+
+                        if (var6 == 0 && var4 != 15) {
+                            var6 = 1;
+                        }
+
+                        var4 -= var6;
+
+                        if (var4 > 0) {
+                            this.skylightMap.set(var2, var5, var3, var4);
+                            this.worldObj.markBlockNeedsRenderUpdate((this.xPosition << 4) + var2, var5, (this.zPosition << 4) + var3);
+                        }
+
+                        --var5;
+                    } while (var5 > 0 && var4 > 0);
+
+                    ++var3;
+                    break;
+                }
+            }
+        }
 
 		for(int var2 = 0; var2 < 16; ++var2) {
 			for(int var3 = 0; var3 < 16; ++var3) {
-				int var4 = 127;
-
-				for(int var5 = var2 << 11 | var3 << 7; var4 > 0 && Block.lightOpacity[this.blocks[var5 + var4 - 1]] == 0; --var4) {
-				}
-
-				this.heightMap[var3 << 4 | var2] = (byte)var4;
-				if(var4 < var1) {
-					var1 = var4;
-				}
-			}
-		}
-
-		this.height = var1;
-		this.isModified = true;
-	}
-
-	public void generateSkylightMap() {
-		int var1 = 127;
-
-		int var2;
-		int var3;
-		for(var2 = 0; var2 < 16; ++var2) {
-			for(var3 = 0; var3 < 16; ++var3) {
-				this.heightMap[var3 << 4 | var2] = -128;
-				this.relightBlock(var2, 127, var3);
-				if((this.heightMap[var3 << 4 | var2] & 255) < var1) {
-					var1 = this.heightMap[var3 << 4 | var2] & 255;
-				}
-			}
-		}
-
-		this.height = var1;
-
-		for(var2 = 0; var2 < 16; ++var2) {
-			for(var3 = 0; var3 < 16; ++var3) {
-				this.updateSkylight_do(var2, var3);
-			}
-		}
-
-		this.isModified = true;
-	}
-
-	private void updateSkylight_do(int var1, int var2) {
-		int var3 = this.getHeightValue(var1, var2);
-		int var4 = this.xPosition * 16 + var1;
-		int var5 = this.zPosition * 16 + var2;
-		this.checkSkylightNeighborUpdate(var4 - 1, var5, var3);
-		this.checkSkylightNeighborUpdate(var4 + 1, var5, var3);
-		this.checkSkylightNeighborUpdate(var4, var5 - 1, var3);
-		this.checkSkylightNeighborUpdate(var4, var5 + 1, var3);
-	}
-
-	private void checkSkylightNeighborUpdate(int var1, int var2, int var3) {
+				this.propagateSkylightOcclusion(var2, var3);
+			}
+		}
+
+		this.isModified = true;
+	}
+
+	public int getBlockLightOpacity(int var1, int var2, int var3) {
+		return Block.lightOpacity[this.getBlockID(var1, var2, var3)];
+	}
+
+	private void updateSkylight_do() {
+		Profiler.startSection("recheckGaps");
+		if(this.worldObj.doChunksNearChunkExist(this.xPosition * 16 + 8, 0, this.zPosition * 16 + 8, 16)) {
+			for(int var1 = 0; var1 < 16; ++var1) {
+				for(int var2 = 0; var2 < 16; ++var2) {
+					if(this.updateSkylightColumns[var1 + var2 * 16]) {
+						this.updateSkylightColumns[var1 + var2 * 16] = false;
+						int var3 = this.getHeightValue(var1, var2);
+						int var4 = this.xPosition * 16 + var1;
+						int var5 = this.zPosition * 16 + var2;
+						int var6 = this.worldObj.getChunkHeightMapMinimum(var4 - 1, var5);
+						int var7 = this.worldObj.getChunkHeightMapMinimum(var4 + 1, var5);
+						int var8 = this.worldObj.getChunkHeightMapMinimum(var4, var5 - 1);
+						int var9 = this.worldObj.getChunkHeightMapMinimum(var4, var5 + 1);
+						if(var7 < var6) {
+							var6 = var7;
+						}
+
+						if(var8 < var6) {
+							var6 = var8;
+						}
+
+						if(var9 < var6) {
+							var6 = var9;
+						}
+
+						this.checkSkylightNeighborUpdate(var4, var5, var6);
+						this.checkSkylightNeighborUpdate(var4 - 1, var5, var3);
+						this.checkSkylightNeighborUpdate(var4 + 1, var5, var3);
+						this.checkSkylightNeighborUpdate(var4, var5 - 1, var3);
+						this.checkSkylightNeighborUpdate(var4, var5 + 1, var3);
+					}
+				}
+			}
+
+			this.isGapLightingUpdated = false;
+		}
+
+		Profiler.endSection();
+	}
+
+	private void propagateSkylightOcclusion(int var1, int var2) {
+		this.updateSkylightColumns[var1 + var2 * 16] = true;
+		this.isGapLightingUpdated = true;
+	}
+
+	private void scheduleSkylightNeighborUpdate(int var1, int var2, int var3) {
 		int var4 = this.worldObj.getHeightValue(var1, var2);
 		if(var4 > var3) {
 			this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var3, var2, var1, var4, var2);
+			this.isModified = true;
 		} else if(var4 < var3) {
 			this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Sky, var1, var4, var2, var1, var3, var2);
-		}
-
-		this.isModified = true;
+			this.isModified = true;
+		}
+	}
+
+	private void checkSkylightNeighborUpdate(int var1, int var2, int var3) {
+		int var4 = this.worldObj.getHeightValue(var1, var2);
+		if(var4 > var3) {
+			this.updateSkylightNeighborHeight(var1, var2, var3, var4 + 1);
+		} else if(var4 < var3) {
+			this.updateSkylightNeighborHeight(var1, var2, var4, var3 + 1);
+		}
+	}
+
+	private void updateSkylightNeighborHeight(int var1, int var2, int var3, int var4) {
+		if(var4 > var3 && this.worldObj.doChunksNearChunkExist(var1, 0, var2, 16)) {
+			for(int var5 = var3; var5 < var4; ++var5) {
+				this.worldObj.updateLightByType(EnumSkyBlock.Sky, var1, var5, var2);
+			}
+
+			this.isModified = true;
+		}
 	}
 
 	private void relightBlock(int var1, int var2, int var3) {
-		int var4 = this.heightMap[var3 << 4 | var1] & 255;
+		int var4 = getHeightValue(var1, var3);
 		int var5 = var4;
 		if(var2 > var4) {
 			var5 = var2;
 		}
 
-		for(int var6 = var1 << 11 | var3 << 7; var5 > 0 && Block.lightOpacity[this.blocks[var6 + var5 - 1]] == 0; --var5) {
+		for(int var6 = var1 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET; var5 > 0 && Block.lightOpacity[this.blocks[var6 + var5 - 1]] == 0; --var5) {
 		}
 
 		if(var5 != var4) {
 			this.worldObj.markBlocksDirtyVertical(var1, var3, var5, var4);
-			this.heightMap[var3 << 4 | var1] = (byte)var5;
+			this.heightMap[var3 << 4 | var1] = var5;
 			int var7;
 			int var8;
 			int var9;
-			if(var5 < this.height) {
-				this.height = var5;
-			} else {
-				var7 = 127;
-
-				for(var8 = 0; var8 < 16; ++var8) {
-					for(var9 = 0; var9 < 16; ++var9) {
-						if((this.heightMap[var9 << 4 | var8] & 255) < var7) {
-							var7 = this.heightMap[var9 << 4 | var8] & 255;
-						}
-					}
-				}
-
-				this.height = var7;
-			}
 
 			var7 = this.xPosition * 16 + var1;
 			var8 = this.zPosition * 16 + var3;
 			if(var5 < var4) {
 				for(var9 = var5; var9 < var4; ++var9) {
 					this.skylightMap.set(var1, var9, var3, 15);
+					this.worldObj.markBlockNeedsRenderUpdate((this.xPosition << 4) + var1, var9, (this.zPosition << 4) + var3);
 				}
 			} else {
-				this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Sky, var7, var4, var8, var7, var5, var8);
-
 				for(var9 = var4; var9 < var5; ++var9) {
 					this.skylightMap.set(var1, var9, var3, 0);
+					this.worldObj.markBlockNeedsRenderUpdate((this.xPosition << 4) + var1, var9, (this.zPosition << 4) + var3);
 				}
 			}
 
 			var9 = 15;
 
-			int var10;
-			for(var10 = var5; var5 > 0 && var9 > 0; this.skylightMap.set(var1, var5, var3, var9)) {
+			while (var5 > 0 && var9 > 0) {
 				--var5;
-				int var11 = Block.lightOpacity[this.getBlockID(var1, var5, var3)];
-				if(var11 == 0) {
-					var11 = 1;
+				int var10 = Block.lightOpacity[this.getBlockID(var1, var5, var3)];
+				if (var10 == 0) {
+					var10 = 1;
 				}
-
-				var9 -= var11;
-				if(var9 < 0) {
+				var9 -= var10;
+				if (var9 < 0) {
 					var9 = 0;
 				}
-			}
-
-			while(var5 > 0 && Block.lightOpacity[this.getBlockID(var1, var5 - 1, var3)] == 0) {
-				--var5;
-			}
-
-			if(var5 != var10) {
-				this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Sky, var7 - 1, var5, var8 - 1, var7 + 1, var10, var8 + 1);
-			}
+				this.skylightMap.set(var1, var5, var3, var9);
+			}
+
+			var9 = this.heightMap[var3 << 4 | var1];
+			int var12 = var4;
+			int var13 = var9;
+
+			if (var9 < var4) {
+				var12 = var9;
+				var13 = var4;
+			}
+
+			if (var9 < this.heightMapMinimum) {
+				this.heightMapMinimum = var9;
+			}
+
+			this.updateSkylightNeighborHeight(var7 - 1, var8, var12, var13);
+			this.updateSkylightNeighborHeight(var7 + 1, var8, var12, var13);
+			this.updateSkylightNeighborHeight(var7, var8 - 1, var12, var13);
+			this.updateSkylightNeighborHeight(var7, var8 + 1, var12, var13);
+			this.updateSkylightNeighborHeight(var7, var8, var12, var13);
 
 			this.isModified = true;
 		}
 	}
 
 	public int getBlockID(int var1, int var2, int var3) {
-		return this.blocks[var1 << 11 | var3 << 7 | var2];
+		return this.blocks[var1 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET | var2];
 	}
 
 	public boolean setBlockIDWithMetadata(int var1, int var2, int var3, int var4, int var5) {
-		byte var6 = (byte)var4;
-		int var7 = this.heightMap[var3 << 4 | var1] & 255;
-		int var8 = this.blocks[var1 << 11 | var3 << 7 | var2] & 255;
-		if(var8 == var4 && this.data.get(var1, var2, var3) == var5) {
+		int offset = var1 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET | var2;
+		short var6 = (short)var4;
+		int var7 = this.getHeightValue(var1, var3);
+		int var8 = this.blocks[offset];
+		if(var8 == var4 && this.data[offset] == (byte)var5) {
 			return false;
 		} else {
 			int var9 = this.xPosition * 16 + var1;
 			int var10 = this.zPosition * 16 + var3;
-			this.blocks[var1 << 11 | var3 << 7 | var2] = var6;
-			if(var8 != 0 && !this.worldObj.multiplayerWorld) {
+			if(var8 != 0 && this.worldObj.canDoClientAction()) {
 				Block.blocksList[var8].onBlockRemoval(this.worldObj, var9, var2, var10);
 			}
+			this.blocks[offset] = var6;
+			this.data[offset] = (byte)var5;
 
-			this.data.set(var1, var2, var3, var5);
-			if(Block.lightOpacity[var6] != 0) {
-				if(var2 >= var7) {
+			if (Block.lightOpacity[var6] != 0) {
+				if (var2 >= var7) {
 					this.relightBlock(var1, var2 + 1, var3);
 				}
-			} else if(var2 == var7 - 1) {
+			} else if (var2 == var7 - 1) {
 				this.relightBlock(var1, var2, var3);
 			}
 
-			this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Sky, var9, var2, var10, var9, var2, var10);
-			this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Block, var9, var2, var10, var9, var2, var10);
-			this.updateSkylight_do(var1, var3);
-			if(var4 != 0) {
+			this.propagateSkylightOcclusion(var1, var3);
+
+			if(var4 != 0 && this.worldObj.canDoClientAction()) {
 				Block.blocksList[var4].onBlockAdded(this.worldObj, var9, var2, var10);
 			}
 
@@ -247,47 +383,16 @@
 	}
 
 	public boolean setBlockID(int var1, int var2, int var3, int var4) {
-		byte var5 = (byte)var4;
-		int var6 = this.heightMap[var3 << 4 | var1] & 255;
-		int var7 = this.blocks[var1 << 11 | var3 << 7 | var2] & 255;
-		if(var7 == var4) {
-			return false;
-		} else {
-			int var8 = this.xPosition * 16 + var1;
-			int var9 = this.zPosition * 16 + var3;
-			this.blocks[var1 << 11 | var3 << 7 | var2] = var5;
-			if(var7 != 0) {
-				Block.blocksList[var7].onBlockRemoval(this.worldObj, var8, var2, var9);
-			}
-
-			this.data.set(var1, var2, var3, 0);
-			if(Block.lightOpacity[var5] != 0) {
-				if(var2 >= var6) {
-					this.relightBlock(var1, var2 + 1, var3);
-				}
-			} else if(var2 == var6 - 1) {
-				this.relightBlock(var1, var2, var3);
-			}
-
-			this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Sky, var8, var2, var9, var8, var2, var9);
-			this.worldObj.scheduleLightingUpdate(EnumSkyBlock.Block, var8, var2, var9, var8, var2, var9);
-			this.updateSkylight_do(var1, var3);
-			if(var4 != 0 && !this.worldObj.multiplayerWorld) {
-				Block.blocksList[var4].onBlockAdded(this.worldObj, var8, var2, var9);
-			}
-
-			this.isModified = true;
-			return true;
-		}
+		return this.setBlockIDWithMetadata(var1, var2, var3, var4, 0);
 	}
 
 	public int getBlockMetadata(int var1, int var2, int var3) {
-		return this.data.get(var1, var2, var3);
+		return this.data[var1 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET | var2] & 0xFF;
 	}
 
 	public void setBlockMetadata(int var1, int var2, int var3, int var4) {
 		this.isModified = true;
-		this.data.set(var1, var2, var3, var4);
+		this.data[var1 << CHUNK_BIT_OFFSET + 4 | var3 << CHUNK_BIT_OFFSET | var2] = (byte)var4;
 	}
 
 	public int getSavedLightValue(EnumSkyBlock var1, int var2, int var3, int var4) {
@@ -366,7 +471,7 @@
 	}
 
 	public boolean canBlockSeeTheSky(int var1, int var2, int var3) {
-		return var2 >= (this.heightMap[var3 << 4 | var1] & 255);
+		return var2 >= this.getHeightValue(var1, var3);
 	}
 
 	public TileEntity getChunkBlockTileEntity(int var1, int var2, int var3) {
@@ -412,6 +517,7 @@
 		} else {
 			System.out.println("Attempted to place a tile entity where there was no entity tile!");
 		}
+		var4.onSpawn();
 	}
 
 	public void removeChunkBlockTileEntity(int var1, int var2, int var3) {
@@ -499,43 +605,43 @@
 	}
 
 	public int getChunkData(byte[] var1, int var2, int var3, int var4, int var5, int var6, int var7, int var8) {
+		int height = var6 - var3;
+
+		ByteBuffer byteBuffer = ByteBuffer.allocate(this.blocks.length * 2);
+		byteBuffer.asShortBuffer().put(this.blocks);
+
 		int var9;
 		int var10;
 		int var11;
-		int var12;
-		for(var9 = var2; var9 < var5; ++var9) {
-			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = var9 << 11 | var10 << 7 | var3;
-				var12 = var6 - var3;
-				System.arraycopy(this.blocks, var11, var1, var8, var12);
-				var8 += var12;
-			}
-		}
-
-		for(var9 = var2; var9 < var5; ++var9) {
-			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = (var9 << 11 | var10 << 7 | var3) >> 1;
-				var12 = (var6 - var3) / 2;
-				System.arraycopy(this.data.data, var11, var1, var8, var12);
-				var8 += var12;
-			}
-		}
-
-		for(var9 = var2; var9 < var5; ++var9) {
-			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = (var9 << 11 | var10 << 7 | var3) >> 1;
-				var12 = (var6 - var3) / 2;
-				System.arraycopy(this.blocklightMap.data, var11, var1, var8, var12);
-				var8 += var12;
-			}
-		}
-
-		for(var9 = var2; var9 < var5; ++var9) {
-			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = (var9 << 11 | var10 << 7 | var3) >> 1;
-				var12 = (var6 - var3) / 2;
-				System.arraycopy(this.skylightMap.data, var11, var1, var8, var12);
-				var8 += var12;
+		for(var9 = var2; var9 < var5; ++var9) {
+			for(var10 = var4; var10 < var7; ++var10) {
+				var11 = var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3;
+				System.arraycopy(byteBuffer.array(), var11 * 2, var1, var8, height * 2);
+				var8 += height * 2;
+			}
+		}
+
+		for(var9 = var2; var9 < var5; ++var9) {
+			for(var10 = var4; var10 < var7; ++var10) {
+				var11 = var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3;
+				System.arraycopy(this.data, var11, var1, var8, height);
+				var8 += height;
+			}
+		}
+
+		for(var9 = var2; var9 < var5; ++var9) {
+			for(var10 = var4; var10 < var7; ++var10) {
+				var11 = (var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3) >> 1;
+				System.arraycopy(this.blocklightMap.data, var11, var1, var8, height / 2);
+				var8 += height / 2;
+			}
+		}
+
+		for(var9 = var2; var9 < var5; ++var9) {
+			for(var10 = var4; var10 < var7; ++var10) {
+				var11 = (var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3) >> 1;
+				System.arraycopy(this.skylightMap.data, var11, var1, var8, height / 2);
+				var8 += height / 2;
 			}
 		}
 
@@ -543,33 +649,37 @@
 	}
 
 	public int setChunkData(byte[] var1, int var2, int var3, int var4, int var5, int var6, int var7, int var8) {
+		ByteBuffer byteBuffer = ByteBuffer.allocate(this.blocks.length * 2);
+		byteBuffer.asShortBuffer().put(this.blocks);
+
 		int var9;
 		int var10;
 		int var11;
 		int var12;
 		for(var9 = var2; var9 < var5; ++var9) {
 			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = var9 << 11 | var10 << 7 | var3;
+				var11 = var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3;
 				var12 = var6 - var3;
-				System.arraycopy(var1, var8, this.blocks, var11, var12);
-				var8 += var12;
+				System.arraycopy(var1, var8, byteBuffer.array(), var11 * 2, var12 * 2);
+				var8 += var12 * 2;
 			}
 		}
 
+		ShortBuffer.wrap(this.blocks).put(byteBuffer.asShortBuffer());
 		this.generateHeightMap();
 
 		for(var9 = var2; var9 < var5; ++var9) {
 			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = (var9 << 11 | var10 << 7 | var3) >> 1;
-				var12 = (var6 - var3) / 2;
-				System.arraycopy(var1, var8, this.data.data, var11, var12);
+				var11 = var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3;
+				var12 = var6 - var3;
+				System.arraycopy(var1, var8, this.data, var11, var12);
 				var8 += var12;
 			}
 		}
 
 		for(var9 = var2; var9 < var5; ++var9) {
 			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = (var9 << 11 | var10 << 7 | var3) >> 1;
+				var11 = (var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3) >> 1;
 				var12 = (var6 - var3) / 2;
 				System.arraycopy(var1, var8, this.blocklightMap.data, var11, var12);
 				var8 += var12;
@@ -578,17 +688,207 @@
 
 		for(var9 = var2; var9 < var5; ++var9) {
 			for(var10 = var4; var10 < var7; ++var10) {
-				var11 = (var9 << 11 | var10 << 7 | var3) >> 1;
+				var11 = (var9 << CHUNK_BIT_OFFSET + 4 | var10 << CHUNK_BIT_OFFSET | var3) >> 1;
 				var12 = (var6 - var3) / 2;
 				System.arraycopy(var1, var8, this.skylightMap.data, var11, var12);
 				var8 += var12;
 			}
 		}
 
+		this.isLightPopulated = true;
+		this.isTerrainPopulated = true;
+
 		return var8;
 	}
 
 	public Random getRandomWithSeed(long var1) {
 		return new Random(this.worldObj.randomSeed + (long)(this.xPosition * this.xPosition * 4987142) + (long)(this.xPosition * 5947611) + (long)(this.zPosition * this.zPosition) * 4392871L + (long)(this.zPosition * 389711) ^ var1);
+	}
+
+	public void updateSkylight() {
+		if (this.isGapLightingUpdated) {
+			this.updateSkylight_do();
+		}
+
+		if (!this.worldObj.fastLighting && !this.isLightPopulated && this.isTerrainPopulated) {
+			 this.populateLightNeighbors();
+		}
+	}
+
+	public void populateLightNeighbors() {
+		Profiler.startSection("populateLightNeighbors");
+        this.isTerrainPopulated = true;
+        this.isLightPopulated = true;
+
+        if (this.worldObj.checkChunksExist(this.xPosition * 16 - 1, 0, this.zPosition * 16 - 1,
+                this.xPosition * 16 + 1, 127, this.zPosition * 16 + 1)) {
+			Profiler.startSection("populateLight");
+            for (int var1 = 0; var1 < 16; ++var1) {
+                for (int var2 = 0; var2 < 16; ++var2) {
+                    if (!this.populateLight(var1, var2)) {
+                        this.isLightPopulated = false;
+                        break;
+                    }
+                }
+            }
+
+            if (this.isLightPopulated) {
+				Profiler.endStartSection("postPopulateLight");
+                Chunk var3 = this.worldObj.getChunkFromBlockCoords(this.xPosition * 16 - 1, this.zPosition * 16);
+                var3.populateNeighborLight(3);
+                var3 = this.worldObj.getChunkFromBlockCoords(this.xPosition * 16 + 16, this.zPosition * 16);
+                var3.populateNeighborLight(1);
+                var3 = this.worldObj.getChunkFromBlockCoords(this.xPosition * 16, this.zPosition * 16 - 1);
+                var3.populateNeighborLight(0);
+                var3 = this.worldObj.getChunkFromBlockCoords(this.xPosition * 16, this.zPosition * 16 + 16);
+                var3.populateNeighborLight(2);
+            }
+
+			Profiler.endSection();
+        } else {
+            this.isLightPopulated = false;
+        }
+		Profiler.endSection();
+    }
+
+	private void populateNeighborLight(int var1) {
+        if (this.isTerrainPopulated) {
+			Profiler.startSection("populateLight");
+            int var2;
+
+            if (var1 == 3) {
+                for (var2 = 0; var2 < 16; ++var2) {
+                    this.populateLight(15, var2);
+                }
+            } else if (var1 == 1) {
+                for (var2 = 0; var2 < 16; ++var2) {
+                    this.populateLight(0, var2);
+                }
+            } else if (var1 == 0) {
+                for (var2 = 0; var2 < 16; ++var2) {
+                    this.populateLight(var2, 15);
+                }
+            } else if (var1 == 2) {
+                for (var2 = 0; var2 < 16; ++var2) {
+                    this.populateLight(var2, 0);
+                }
+            }
+			Profiler.endSection();
+        }
+    }
+
+	private boolean populateLight(int x, int y) {
+        int var3 = CHUNK_HEIGHT - 1;
+        boolean var4 = false;
+        boolean var5 = false;
+        int var6;
+
+        for (var6 = var3; var6 > 127 || var6 > 0 && !var5; --var6) {
+            int var7 = this.getBlockLightOpacity(x, var6, y);
+
+            if (var7 == 255 && var6 < 127) {
+                var5 = true;
+            }
+
+            if (!var4 && var7 > 0) {
+                var4 = true;
+            } else if (var4 && var7 == 0 && !this.worldObj.updateAllLightTypes(this.xPosition * 16 + x, var6,
+                    this.zPosition * 16 + y)) {
+                return false;
+            }
+        }
+
+        for (; var6 > 0; --var6) {
+            if (Block.lightValue[this.getBlockID(x, var6, y)] > 0) {
+                this.worldObj.updateAllLightTypes(this.xPosition * 16 + x, var6, this.zPosition * 16 + y);
+            }
+        }
+
+        return true;
+    }
+
+	public void resetRelightChecks() {
+		this.queuedLightChecks = 0;
+	}
+
+	public void enqueueRelightChecks() {
+		for(int var1 = 0; var1 < 8; ++var1) {
+			if(this.queuedLightChecks >= 4096) {
+				return;
+			}
+
+			int var2 = this.queuedLightChecks % 16;
+			int var3 = this.queuedLightChecks / 16 % 16;
+			int var4 = this.queuedLightChecks / 256;
+			++this.queuedLightChecks;
+			int var5 = (this.xPosition << 4) + var3;
+			int var6 = (this.zPosition << 4) + var4;
+
+			for(int var7 = 0; var7 < 16; ++var7) {
+				int var8 = (var2 << 4) + var7;
+				if((var7 == 0 || var7 == 15 || var3 == 0 || var3 == 15 || var4 == 0 || var4 == 15) && this.getBlockID(var3, var7, var4) == 0) {
+					if(Block.lightValue[this.worldObj.getBlockId(var5, var8 - 1, var6)] > 0) {
+						this.worldObj.updateAllLightTypes(var5, var8 - 1, var6);
+					}
+
+					if(Block.lightValue[this.worldObj.getBlockId(var5, var8 + 1, var6)] > 0) {
+						this.worldObj.updateAllLightTypes(var5, var8 + 1, var6);
+					}
+
+					if(Block.lightValue[this.worldObj.getBlockId(var5 - 1, var8, var6)] > 0) {
+						this.worldObj.updateAllLightTypes(var5 - 1, var8, var6);
+					}
+
+					if(Block.lightValue[this.worldObj.getBlockId(var5 + 1, var8, var6)] > 0) {
+						this.worldObj.updateAllLightTypes(var5 + 1, var8, var6);
+					}
+
+					if(Block.lightValue[this.worldObj.getBlockId(var5, var8, var6 - 1)] > 0) {
+						this.worldObj.updateAllLightTypes(var5, var8, var6 - 1);
+					}
+
+					if(Block.lightValue[this.worldObj.getBlockId(var5, var8, var6 + 1)] > 0) {
+						this.worldObj.updateAllLightTypes(var5, var8, var6 + 1);
+					}
+
+					this.worldObj.updateAllLightTypes(var5, var8, var6);
+				}
+			}
+		}
+	}
+
+	public void populateChunk(IChunkProvider var1, IChunkProvider var2, int var3, int var4) {
+		if(!this.isTerrainPopulated && var1.chunkExists(var3 + 1, var4 + 1) && var1.chunkExists(var3, var4 + 1) && var1.chunkExists(var3 + 1, var4)) {
+			var1.populate(var2, var3, var4);
+		}
+
+		if(var1.chunkExists(var3 - 1, var4) && !var1.provideChunk(var3 - 1, var4).isTerrainPopulated && var1.chunkExists(var3 - 1, var4 + 1) && var1.chunkExists(var3, var4 + 1) && var1.chunkExists(var3 - 1, var4 + 1)) {
+			var1.populate(var2, var3 - 1, var4);
+		}
+
+		if(var1.chunkExists(var3, var4 - 1) && !var1.provideChunk(var3, var4 - 1).isTerrainPopulated && var1.chunkExists(var3 + 1, var4 - 1) && var1.chunkExists(var3 + 1, var4 - 1) && var1.chunkExists(var3 + 1, var4)) {
+			var1.populate(var2, var3, var4 - 1);
+		}
+
+		if(var1.chunkExists(var3 - 1, var4 - 1) && !var1.provideChunk(var3 - 1, var4 - 1).isTerrainPopulated && var1.chunkExists(var3, var4 - 1) && var1.chunkExists(var3 - 1, var4)) {
+			var1.populate(var2, var3 - 1, var4 - 1);
+		}
+
+		if(!this.isUnderworldPopulated && var1.chunkExists(var3 + 1, var4 + 1) && var1.chunkExists(var3, var4 + 1) && var1.chunkExists(var3 + 1, var4)) {
+			var1.populateUnderworld(var2, var3, var4);
+		}
+
+		if(var1.chunkExists(var3 - 1, var4) && !var1.provideChunk(var3 - 1, var4).isUnderworldPopulated && var1.chunkExists(var3 - 1, var4 + 1) && var1.chunkExists(var3, var4 + 1) && var1.chunkExists(var3 - 1, var4 + 1)) {
+			var1.populateUnderworld(var2, var3 - 1, var4);
+		}
+
+		if(var1.chunkExists(var3, var4 - 1) && !var1.provideChunk(var3, var4 - 1).isUnderworldPopulated && var1.chunkExists(var3 + 1, var4 - 1) && var1.chunkExists(var3 + 1, var4 - 1) && var1.chunkExists(var3 + 1, var4)) {
+			var1.populateUnderworld(var2, var3, var4 - 1);
+		}
+
+		if(var1.chunkExists(var3 - 1, var4 - 1) && !var1.provideChunk(var3 - 1, var4 - 1).isUnderworldPopulated && var1.chunkExists(var3, var4 - 1) && var1.chunkExists(var3 - 1, var4)) {
+			var1.populateUnderworld(var2, var3 - 1, var4 - 1);
+		}
+
 	}
 }
--- /dev/null
+++ net/minecraft/src/TreePopulator.java
@@ -1,0 +1,105 @@
+package net.minecraft.src;
+
+public class TreePopulator {
+	private WorldGenerator tree = new WorldGenTrees();
+
+	private WorldGenerator bigTree = null;
+	private int bigTreeDamp;
+	private int bigTreeMax;
+
+	private WorldGenerator highTree = null;
+	private int highTreeMinY;
+	private int highTreeMaxY;
+
+	private WorldGenerator shrub = null;
+	private int shrubRarity;
+
+	private double densityDamp = 8.0D;
+	private double densityRange = 8.0D;
+	private double densityDamp2 = 3.0D;
+	private double densityBoost = 0.0D;
+	private double densityDist = 100.0D;
+
+	public void populate(PopulatorHost host) {
+		double treeDensity =
+				((host.noise != null
+						? host.noise.generateNoiseOctaves(host.x / densityDist, host.z / densityDist)
+						: SimplexNoise.noise2(host.worldObj.randomSeed, host.x / densityDist, host.z / densityDist))
+				/ densityDamp + host.rand.nextDouble() * densityRange + densityRange) / densityDamp2 + densityBoost;
+		if (Double.isInfinite(treeDensity)) {
+			treeDensity = 10.0D;
+		}
+		int densityInt = (int)treeDensity;
+		if(densityInt < 0) {
+			densityInt = 0;
+		}
+
+		if(host.rand.nextInt(10) == 0) {
+			++densityInt;
+		}
+
+		WorldGenerator placedTree = tree;
+		if(bigTree != null && (densityInt >= bigTreeMax / bigTreeDamp
+				|| host.rand.nextInt(Math.max((bigTreeMax - densityInt) / bigTreeDamp, 1)) == 0)) {
+			placedTree = bigTree;
+		} else if (densityInt > 0) {
+			int s = host.rand.nextInt(densityInt);
+			placedTree.setScale(s / 3.0 - 1, s / 2.0, s / 3.0);
+		}
+
+		for(int count = 0; count < Math.min(densityInt, 8); ++count) {
+			int x = host.x + host.rand.nextInt(16) + 8;
+			int z = host.z + host.rand.nextInt(16) + 8;
+			int y = host.worldObj.getHeightValue(x, z);
+
+			if (highTree != null && y > host.rand.nextInt(highTreeMaxY - highTreeMinY) + highTreeMinY)
+				highTree.generate(host.worldObj, host.rand, x, y, z);
+			else
+				placedTree.generate(host.worldObj, host.rand, x, y, z);
+		}
+
+		if (shrub != null && host.rand.nextInt(Math.max(densityInt + shrubRarity, 1)) == 0) {
+			int x = host.x + host.rand.nextInt(16) + 8;
+			int z = host.z + host.rand.nextInt(16) + 8;
+			shrub.generate(host.worldObj, host.rand, x, host.worldObj.getHeightValue(x, z), z);
+		}
+	}
+
+	public TreePopulator withTree(WorldGenerator tree) {
+		this.tree = tree;
+		return this;
+	}
+
+	public TreePopulator withBigTree(WorldGenerator bigTree, int bigTreeMax, int bigTreeDamp) {
+		this.bigTree = bigTree;
+		this.bigTreeMax = bigTreeMax;
+		this.bigTreeDamp = bigTreeDamp;
+		return this;
+	}
+
+	public TreePopulator withDensity(double densityDamp, double densityRange, double densityDamp2) {
+		return this.withDensity(densityDamp, densityRange, densityDamp2, 0.0D, 0.0D);
+	}
+
+	public TreePopulator withDensity(double densityDamp, double densityRange, double densityDamp2, double densityBoost, double densityDist) {
+		this.densityDamp = densityDamp;
+		this.densityRange = densityRange;
+		this.densityDamp2 = densityDamp2;
+		this.densityBoost = densityBoost;
+		this.densityDist = densityDist;
+		return this;
+	}
+
+	public TreePopulator withShrub(WorldGenerator shrub, int shrubRarity) {
+		this.shrub = shrub;
+		this.shrubRarity = shrubRarity;
+		return this;
+	}
+
+	public TreePopulator withHighTree(WorldGenerator highTree, int highTreeMinY, int highTreeMaxY) {
+		this.highTree = highTree;
+		this.highTreeMinY = highTreeMinY;
+		this.highTreeMaxY = highTreeMaxY;
+		return this;
+	}
+}
--- net/minecraft/src/ItemRecord.java
+++ net/minecraft/src/ItemRecord.java
@@ -1,22 +1,28 @@
 package net.minecraft.src;
 
 public class ItemRecord extends Item {
-	private String recordName;
+	private final String recordName;
+	private final String recordTitle;
 
-	protected ItemRecord(int var1, String var2) {
+	public ItemRecord(int var1, String var2, String title) {
 		super(var1);
 		this.recordName = var2;
+		this.recordTitle = title;
 		this.maxStackSize = 1;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var3.getBlockId(var4, var5, var6) == Block.jukebox.blockID && var3.getBlockMetadata(var4, var5, var6) == 0) {
 			var3.setBlockMetadataWithNotify(var4, var5, var6, this.shiftedIndex - Item.record13.shiftedIndex + 1);
-			var3.playRecord(this.recordName, var4, var5, var6);
+			var3.playRecord(this.recordName, var4, var5, var6, this.recordTitle);
 			--var1.stackSize;
 			return true;
 		} else {
 			return false;
 		}
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] { this.recordTitle, ItemTooltip.DESCRIPTION_COL };
 	}
 }
--- net/minecraft/src/AxisAlignedBB.java
+++ net/minecraft/src/AxisAlignedBB.java
@@ -191,6 +191,16 @@
 		return this;
 	}
 
+	public AxisAlignedBB contract(double var1, double var3, double var5) {
+		double var7 = this.minX + var1;
+		double var9 = this.minY + var3;
+		double var11 = this.minZ + var5;
+		double var13 = this.maxX - var1;
+		double var15 = this.maxY - var3;
+		double var17 = this.maxZ - var5;
+		return getBoundingBoxFromPool(var7, var9, var11, var13, var15, var17);
+	}
+
 	public AxisAlignedBB removeCoord(double var1, double var3, double var5) {
 		double var7 = this.minX;
 		double var9 = this.minY;
@@ -343,5 +353,9 @@
 		this.maxX = var1.maxX;
 		this.maxY = var1.maxY;
 		this.maxZ = var1.maxZ;
+	}
+
+	public boolean isVecInside(Vec3D var1) {
+		return var1.xCoord > this.minX && var1.xCoord < this.maxX ? (var1.yCoord > this.minY && var1.yCoord < this.maxY ? var1.zCoord > this.minZ && var1.zCoord < this.maxZ : false) : false;
 	}
 }
--- net/minecraft/client/Minecraft.java
+++ net/minecraft/client/Minecraft.java
@@ -8,61 +8,69 @@
 import java.awt.Frame;
 import java.awt.Graphics;
 import java.io.File;
-import net.minecraft.src.AxisAlignedBB;
-import net.minecraft.src.Block;
-import net.minecraft.src.EffectRenderer;
-import net.minecraft.src.EntityPlayerSP;
-import net.minecraft.src.EntityRenderer;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.text.DecimalFormat;
+import java.util.List;
+import java.util.Random;
+
 import net.minecraft.src.EnumOS;
-import net.minecraft.src.FontRenderer;
-import net.minecraft.src.GLAllocation;
+import net.minecraft.src.GameAchievements;
 import net.minecraft.src.GameSettings;
-import net.minecraft.src.GameWindowListener;
-import net.minecraft.src.GuiChat;
+import net.minecraft.src.MinecraftImpl;
+import net.minecraft.src.MouseHelper;
+import net.minecraft.src.Session;
+import net.minecraft.src.Timer;
+import net.minecraft.src.MovementInputFromOptions;
+import net.minecraft.src.PlayerController;
 import net.minecraft.src.GuiConflictWarning;
-import net.minecraft.src.GuiConnecting;
+import net.minecraft.src.GuiDevelopmentWarning;
 import net.minecraft.src.GuiErrorScreen;
 import net.minecraft.src.GuiGameOver;
 import net.minecraft.src.GuiIngame;
 import net.minecraft.src.GuiIngameMenu;
-import net.minecraft.src.GuiInventory;
 import net.minecraft.src.GuiMainMenu;
 import net.minecraft.src.GuiScreen;
-import net.minecraft.src.ItemRenderer;
-import net.minecraft.src.ItemStack;
-import net.minecraft.src.LoadingScreenRenderer;
-import net.minecraft.src.MathHelper;
-import net.minecraft.src.MinecraftError;
-import net.minecraft.src.MinecraftException;
-import net.minecraft.src.MinecraftImpl;
+import net.minecraft.src.GuiTextureViewer;
+import net.minecraft.src.GuiInventory;
+import net.minecraft.src.GuiChat;
+import net.minecraft.src.GuiConnecting;
+import net.minecraft.src.*;
+import net.minecraft.src.EffectRenderer;
 import net.minecraft.src.ModelBiped;
-import net.minecraft.src.MouseHelper;
-import net.minecraft.src.MovementInputFromOptions;
-import net.minecraft.src.MovingObjectPosition;
-import net.minecraft.src.OSMap;
-import net.minecraft.src.OpenGlCapsChecker;
-import net.minecraft.src.PlayerController;
-import net.minecraft.src.PlayerControllerCreative;
-import net.minecraft.src.RenderEngine;
-import net.minecraft.src.RenderGlobal;
-import net.minecraft.src.RenderManager;
-import net.minecraft.src.ScaledResolution;
-import net.minecraft.src.Session;
-import net.minecraft.src.SoundManager;
-import net.minecraft.src.Tessellator;
+import net.minecraft.src.VanityModels;
 import net.minecraft.src.TextureCompassFX;
 import net.minecraft.src.TextureFlamesFX;
 import net.minecraft.src.TextureLavaFX;
 import net.minecraft.src.TextureLavaFlowFX;
 import net.minecraft.src.TextureWaterFX;
 import net.minecraft.src.TextureWaterFlowFX;
+import net.minecraft.src.SoundManager;
 import net.minecraft.src.ThreadDownloadResources;
-import net.minecraft.src.ThreadSleepForever;
-import net.minecraft.src.Timer;
+import net.minecraft.src.GameWindowListener;
+import net.minecraft.src.MinecraftError;
+import net.minecraft.src.MinecraftException;
 import net.minecraft.src.UnexpectedThrowable;
+import net.minecraft.src.ModLoader;
+import net.minecraft.src.NetClientHandler;
+import net.minecraft.src.ThreadSleepForever;
+import net.minecraft.src.BenchmarkTimer;
+import net.minecraft.src.MathHelper;
+import net.minecraft.src.Profiler;
+import net.minecraft.src.ProfilerResult;
+import net.minecraft.src.AxisAlignedBB;
+import net.minecraft.src.MovingObjectPosition;
 import net.minecraft.src.Vec3D;
+import net.minecraft.src.CreateWorldInfo;
 import net.minecraft.src.World;
-import net.minecraft.src.WorldRenderer;
+import net.minecraft.src.Block;
+import net.minecraft.src.RegionFileCache;
+import net.minecraft.src.RegionTool;
+import net.minecraft.src.EntityClientPlayerMP;
+import net.minecraft.src.EntityPlayerSP;
+import net.minecraft.src.SimplexOctaves;
+import net.minecraft.src.ItemStack;
+
 import org.lwjgl.LWJGLException;
 import org.lwjgl.input.Controllers;
 import org.lwjgl.input.Keyboard;
@@ -70,9 +78,16 @@
 import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.DisplayMode;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.PixelFormat;
 import org.lwjgl.util.glu.GLU;
 
 public abstract class Minecraft implements Runnable {
+	public static final String version = "Minecraft Diverge " + World.VERSION_NAMES[World.CURRENT_VERSION];
+	public static final boolean developmentVersion = false;
+	public static final boolean panoramaMode = false;
+	public static final Proxy betacraftProxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("betacraft.uk", 11705));
+	private static Minecraft instance;
+
 	public PlayerController playerController;
 	private boolean fullscreen = false;
 	public int displayWidth;
@@ -104,12 +119,15 @@
 	public boolean skipRenderWorld = false;
 	public ModelBiped playerModelBiped = new ModelBiped(0.0F);
 	public MovingObjectPosition objectMouseOver = null;
+	public MovingObjectPosition lastObjectMouseOver = null;
 	public GameSettings options;
+	public GameAchievements achievements;
 	protected MinecraftApplet mcApplet;
 	public SoundManager sndManager = new SoundManager();
 	public MouseHelper mouseHelper;
 	public File mcDataDir;
 	public static long[] frameTimes = new long[512];
+	public static long[] tickTimes = new long[512];
 	public static int numRecordedFrameTimes = 0;
 	private String serverName;
 	private int serverPort;
@@ -118,26 +136,38 @@
 	private static File minecraftDir = null;
 	public volatile boolean running = true;
 	public String debug = "";
+	boolean isTakingScreenshot = false;
 	long prevFrameTime = -1L;
 	public boolean inGameHasFocus = false;
 	private int mouseTicksRan = 0;
 	public boolean isRaining = false;
 	long systemTime = System.currentTimeMillis();
 	private int joinPlayerCounter = 0;
+	public boolean creativeDebugEnabled = false;
+	public boolean showHud = true;
+	private int guiCloseTimer = 0;
+	private boolean guiLeftClick;
+	private String debugProfilerName = "root";
+	private int panoramaTick = 0;
 
-	public Minecraft(Component var1, Canvas var2, MinecraftApplet var3, int var4, int var5, boolean var6) {
-		this.tempDisplayWidth = var4;
-		this.tempDisplayHeight = var5;
-		this.fullscreen = var6;
-		this.mcApplet = var3;
+	public Minecraft(Component component, Canvas canvas, MinecraftApplet mcApplet, int width, int height, boolean fullscreen) {
+		Minecraft.instance = this;
+		this.tempDisplayWidth = width;
+		this.tempDisplayHeight = height;
+		this.fullscreen = fullscreen;
+		this.mcApplet = mcApplet;
 		new ThreadSleepForever(this, "Timer hack thread");
-		this.mcCanvas = var2;
-		this.displayWidth = var4;
-		this.displayHeight = var5;
-		this.fullscreen = var6;
-	}
-
-	public abstract void displayUnexpectedThrowable(UnexpectedThrowable var1);
+		this.mcCanvas = canvas;
+		this.displayWidth = width;
+		this.displayHeight = height;
+		this.fullscreen = fullscreen;
+	}
+
+	public static Minecraft getInstance() {
+		return Minecraft.instance;
+	}
+
+	public abstract void displayUnexpectedThrowable(UnexpectedThrowable unexpectedThrowable1);
 
 	public void setServer(String var1, int var2) {
 		this.serverName = var1;
@@ -145,6 +175,8 @@
 	}
 
 	public void startGame() throws LWJGLException {
+		System.setProperty("java.util.Arrays.useLegacyMergeSort", "true");
+
 		if(this.mcCanvas != null) {
 			Graphics var1 = this.mcCanvas.getGraphics();
 			if(var1 != null) {
@@ -169,35 +201,39 @@
 			Display.setDisplayMode(new DisplayMode(this.displayWidth, this.displayHeight));
 		}
 
-		Display.setTitle("Minecraft Minecraft Alpha v1.1.2_01");
+		Display.setTitle("Minecraft " + Minecraft.version);
 
 		try {
-			Display.create();
-		} catch (LWJGLException var6) {
-			var6.printStackTrace();
+			Display.create(new PixelFormat()
+					.withDepthBits(24));
+		} catch (LWJGLException lWJGLException6) {
+			lWJGLException6.printStackTrace();
 
 			try {
 				Thread.sleep(1000L);
-			} catch (InterruptedException var5) {
+			} catch (InterruptedException interruptedException5) {
 			}
 
-			Display.create();
+			Display.create(new PixelFormat()
+					.withDepthBits(24));
 		}
 
 		RenderManager.instance.itemRenderer = new ItemRenderer(this);
 		this.mcDataDir = getMinecraftDir();
 		this.options = new GameSettings(this, this.mcDataDir);
+		this.achievements = new GameAchievements(this, this.mcDataDir);
 		this.renderEngine = new RenderEngine(this.options);
 		this.fontRenderer = new FontRenderer(this.options, "/default.png", this.renderEngine);
 		this.loadScreen();
 		Keyboard.create();
 		Mouse.create();
 		this.mouseHelper = new MouseHelper(this.mcCanvas);
+		Display.setVSyncEnabled(this.options.maxFps <= 0);
 
 		try {
 			Controllers.create();
-		} catch (Exception var4) {
-			var4.printStackTrace();
+		} catch (Exception exception4) {
+			exception4.printStackTrace();
 		}
 
 		this.checkGLError("Pre startup");
@@ -229,7 +265,14 @@
 		try {
 			this.downloadResourcesThread = new ThreadDownloadResources(this.mcDataDir, this);
 			this.downloadResourcesThread.start();
-		} catch (Exception var3) {
+		} catch (Exception exception3) {
+		}
+
+		GuiScreen.setBgType(new Random().nextInt(3));
+
+		try {
+			Thread.sleep(1000L);
+		} catch (InterruptedException e) {
 		}
 
 		this.checkGLError("Post startup");
@@ -237,16 +280,15 @@
 		if(this.serverName != null) {
 			this.displayGuiScreen(new GuiConnecting(this, this.serverName, this.serverPort));
 		} else {
-			this.displayGuiScreen(new GuiMainMenu());
+			this.displayGuiScreen(Minecraft.developmentVersion ? new GuiDevelopmentWarning(this) : new GuiMainMenu());
 		}
-
 	}
 
 	private void loadScreen() throws LWJGLException {
-		ScaledResolution var1 = new ScaledResolution(this.displayWidth, this.displayHeight);
-		int var2 = var1.getScaledWidth();
-		int var3 = var1.getScaledHeight();
-		GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT | GL11.GL_COLOR_BUFFER_BIT);
+		ScaledResolution scaledResolution1 = new ScaledResolution(this.displayWidth, this.displayHeight, 0);
+		int var2 = scaledResolution1.getScaledWidth();
+		int var3 = scaledResolution1.getScaledHeight();
+		GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
 		GL11.glMatrixMode(GL11.GL_PROJECTION);
 		GL11.glLoadIdentity();
 		GL11.glOrtho(0.0D, (double)var2, (double)var3, 0.0D, 1000.0D, 3000.0D);
@@ -255,23 +297,23 @@
 		GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
 		GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
 		GL11.glClearColor(0.0F, 0.0F, 0.0F, 0.0F);
-		Tessellator var4 = Tessellator.instance;
+		Tessellator tessellator4 = Tessellator.instance;
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
 		GL11.glDisable(GL11.GL_FOG);
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/title/mojang.png"));
-		var4.startDrawingQuads();
-		var4.setColorOpaque_I(16777215);
-		var4.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
-		var4.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
-		var4.addVertexWithUV((double)this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
-		var4.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
-		var4.draw();
-		short var5 = 256;
-		short var6 = 256;
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/title/mojang" + (new Random().nextInt(1000) == 0 ? "-alt.png" : ".png")));
+		tessellator4.startDrawingQuads();
+		tessellator4.setColorOpaque_I(0xFFFFFF);
+		tessellator4.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 2.0D);
+		tessellator4.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 2.0D);
+		tessellator4.addVertexWithUV((double)this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
+		tessellator4.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+		tessellator4.draw();
+		short s5 = 256;
+		short s6 = 256;
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-		var4.setColorOpaque_I(16777215);
-		this.scaledTessellator((this.displayWidth / 2 - var5) / 2, (this.displayHeight / 2 - var6) / 2, 0, 0, var5, var6);
+		tessellator4.setColorOpaque_I(0xFFFFFF);
+		this.scaledTessellator((this.displayWidth / 2 - s5) / 2, (this.displayHeight / 2 - s6) / 2, 0, 0, s5, s6);
 		GL11.glDisable(GL11.GL_LIGHTING);
 		GL11.glDisable(GL11.GL_FOG);
 		GL11.glEnable(GL11.GL_ALPHA_TEST);
@@ -282,13 +324,13 @@
 	public void scaledTessellator(int var1, int var2, int var3, int var4, int var5, int var6) {
 		float var7 = 0.00390625F;
 		float var8 = 0.00390625F;
-		Tessellator var9 = Tessellator.instance;
-		var9.startDrawingQuads();
-		var9.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), 0.0D, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + var6) * var8));
-		var9.addVertexWithUV((double)(var1 + var5), (double)(var2 + var6), 0.0D, (double)((float)(var3 + var5) * var7), (double)((float)(var4 + var6) * var8));
-		var9.addVertexWithUV((double)(var1 + var5), (double)(var2 + 0), 0.0D, (double)((float)(var3 + var5) * var7), (double)((float)(var4 + 0) * var8));
-		var9.addVertexWithUV((double)(var1 + 0), (double)(var2 + 0), 0.0D, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + 0) * var8));
-		var9.draw();
+		Tessellator tessellator9 = Tessellator.instance;
+		tessellator9.startDrawingQuads();
+		tessellator9.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), 0.0D, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + var6) * var8));
+		tessellator9.addVertexWithUV((double)(var1 + var5), (double)(var2 + var6), 0.0D, (double)((float)(var3 + var5) * var7), (double)((float)(var4 + var6) * var8));
+		tessellator9.addVertexWithUV((double)(var1 + var5), (double)(var2 + 0), 0.0D, (double)((float)(var3 + var5) * var7), (double)((float)(var4 + 0) * var8));
+		tessellator9.addVertexWithUV((double)(var1 + 0), (double)(var2 + 0), 0.0D, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + 0) * var8));
+		tessellator9.draw();
 	}
 
 	public static File getMinecraftDir() {
@@ -301,31 +343,31 @@
 
 	public static File getAppDir(String var0) {
 		String var1 = System.getProperty("user.home", ".");
-		File var2;
-		switch(OSMap.osValues[getOs().ordinal()]) {
-		case 1:
-		case 2:
-			var2 = new File(var1, '.' + var0 + '/');
-			break;
-		case 3:
-			String var3 = System.getenv("APPDATA");
-			if(var3 != null) {
-				var2 = new File(var3, "." + var0 + '/');
-			} else {
-				var2 = new File(var1, '.' + var0 + '/');
-			}
-			break;
-		case 4:
-			var2 = new File(var1, "Library/Application Support/" + var0);
-			break;
-		default:
-			var2 = new File(var1, var0 + '/');
+		File file2;
+		switch (getOs()) {
+			case linux:
+			case solaris:
+				file2 = new File(var1, '.' + var0 + '/');
+				break;
+			case windows:
+				String var3 = System.getenv("APPDATA");
+				if(var3 != null) {
+					file2 = new File(var3, "." + var0 + '/');
+				} else {
+					file2 = new File(var1, '.' + var0 + '/');
+				}
+				break;
+			case macos:
+				file2 = new File(var1, "Library/Application Support/" + var0);
+				break;
+			default:
+				file2 = new File(var1, var0 + '/');
 		}
 
-		if(!var2.exists() && !var2.mkdirs()) {
-			throw new RuntimeException("The working directory could not be created: " + var2);
+		if(!file2.exists() && !file2.mkdirs()) {
+			throw new RuntimeException("The working directory could not be created: " + file2);
 		} else {
-			return var2;
+			return file2;
 		}
 	}
 
@@ -334,25 +376,25 @@
 		return var0.contains("win") ? EnumOS.windows : (var0.contains("mac") ? EnumOS.macos : (var0.contains("solaris") ? EnumOS.solaris : (var0.contains("sunos") ? EnumOS.solaris : (var0.contains("linux") ? EnumOS.linux : (var0.contains("unix") ? EnumOS.linux : EnumOS.unknown)))));
 	}
 
-	public void displayGuiScreen(GuiScreen var1) {
+	public void displayGuiScreen(GuiScreen guiScreen1) {
 		if(!(this.currentScreen instanceof GuiErrorScreen)) {
 			if(this.currentScreen != null) {
 				this.currentScreen.onGuiClosed();
 			}
 
-			if(var1 == null && this.theWorld == null) {
-				var1 = new GuiMainMenu();
-			} else if(var1 == null && this.thePlayer.health <= 0) {
-				var1 = new GuiGameOver();
+			if(guiScreen1 == null && this.theWorld == null) {
+				guiScreen1 = new GuiMainMenu();
+			} else if(guiScreen1 == null && this.thePlayer.health <= 0) {
+				guiScreen1 = new GuiGameOver();
 			}
 
-			this.currentScreen = (GuiScreen)var1;
-			if(var1 != null) {
+			this.currentScreen = (GuiScreen)guiScreen1;
+			if(guiScreen1 != null) {
 				this.setIngameNotInFocus();
-				ScaledResolution var2 = new ScaledResolution(this.displayWidth, this.displayHeight);
-				int var3 = var2.getScaledWidth();
-				int var4 = var2.getScaledHeight();
-				((GuiScreen)var1).setWorldAndResolution(this, var3, var4);
+				ScaledResolution scaledResolution2 = new ScaledResolution(this.displayWidth, this.displayHeight, this.options.guiScale);
+				int var3 = scaledResolution2.getScaledWidth();
+				int var4 = scaledResolution2.getScaledHeight();
+				((GuiScreen)guiScreen1).setWorldAndResolution(this, var3, var4);
 				this.skipRenderWorld = false;
 			} else {
 				this.setIngameFocus();
@@ -382,7 +424,7 @@
 			if(this.downloadResourcesThread != null) {
 				this.downloadResourcesThread.closeMinecraft();
 			}
-		} catch (Exception var8) {
+		} catch (Exception exception8) {
 		}
 
 		try {
@@ -391,7 +433,7 @@
 
 			try {
 				GLAllocation.deleteTexturesAndDisplayLists();
-			} catch (Exception var6) {
+			} catch (Exception exception6) {
 			}
 
 			this.sndManager.closeMinecraft();
@@ -409,9 +451,17 @@
 
 		try {
 			this.startGame();
-		} catch (Exception var13) {
-			var13.printStackTrace();
-			this.displayUnexpectedThrowable(new UnexpectedThrowable("Failed to start game", var13));
+		} catch (Exception exception13) {
+			exception13.printStackTrace();
+			this.displayUnexpectedThrowable(new UnexpectedThrowable("Failed to start game", exception13));
+			return;
+		}
+
+		try {
+			ModLoader.init(Minecraft.getMinecraftDir(), System.out::println, this);
+		} catch (Exception e) {
+			e.printStackTrace();
+			this.displayUnexpectedThrowable(new UnexpectedThrowable("Failed to load mods", e));
 			return;
 		}
 
@@ -423,6 +473,7 @@
 				while(this.running && (this.mcApplet == null || this.mcApplet.isActive())) {
 					AxisAlignedBB.clearBoundingBoxPool();
 					Vec3D.initialize();
+					Profiler.startSection("root");
 					if(this.mcCanvas == null && Display.isCloseRequested()) {
 						this.shutdown();
 					}
@@ -435,50 +486,74 @@
 						this.timer.updateTimer();
 					}
 
+					long var6 = System.nanoTime();
+
+					Profiler.startSection("loadChunks");
+					if (this.theWorld != null && this.thePlayer != null) {
+						this.renderGlobal.updateRenderers(this.thePlayer, false);
+					}
+
+					Profiler.startSection("tick");
 					for(int var17 = 0; var17 < this.timer.elapsedTicks; ++var17) {
 						++this.ticksRan;
 
 						try {
 							this.runTick();
-						} catch (MinecraftException var12) {
+						} catch (MinecraftException minecraftException12) {
 							this.theWorld = null;
 							this.changeWorld1((World)null);
 							this.displayGuiScreen(new GuiConflictWarning());
 						}
 					}
 
+					Profiler.endSection();
+					long var7 = System.nanoTime() - var6;
+
 					this.checkGLError("Pre render");
+					Profiler.startSection("sound");
 					this.sndManager.setListener(this.thePlayer, this.timer.renderPartialTicks);
+
+					Profiler.endStartSection("render");
+
+					Profiler.startSection("display");
 					GL11.glEnable(GL11.GL_TEXTURE_2D);
-					if(this.theWorld != null) {
-						while(this.theWorld.updatingLighting()) {
-						}
-					}
+					Display.update();
+					Profiler.endSection();
 
 					if(!this.skipRenderWorld) {
+						Profiler.startSection("gameMode");
 						if(this.playerController != null) {
 							this.playerController.setPartialTime(this.timer.renderPartialTicks);
 						}
-
+						Profiler.endStartSection("gameRenderer");
 						this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
-					}
-
-					if(!Display.isActive()) {
-						if(this.fullscreen) {
-							this.toggleFullscreen();
+						Profiler.endSection();
+					}
+
+					Profiler.endSection();
+
+					if(!Display.isActive() && this.fullscreen) {
+						this.toggleFullscreen();
+					}
+
+					Profiler.endSection();
+
+					if(this.options.lagometer) {
+						if(!Profiler.profilingEnabled) {
+							Profiler.clearProfiling();
 						}
 
-						Thread.sleep(10L);
-					}
-
-					if(Keyboard.isKeyDown(Keyboard.KEY_F6)) {
-						this.displayDebugInfo();
+						Profiler.profilingEnabled = true;
+						this.displayDebugInfo(var7);
 					} else {
+						Profiler.profilingEnabled = false;
 						this.prevFrameTime = System.nanoTime();
 					}
 
+					Profiler.startSection("root");
 					Thread.yield();
-					Display.update();
+
+					this.screenshotListener();
 					if(this.mcCanvas != null && !this.fullscreen && (this.mcCanvas.getWidth() != this.displayWidth || this.mcCanvas.getHeight() != this.displayHeight)) {
 						this.displayWidth = this.mcCanvas.getWidth();
 						this.displayHeight = this.mcCanvas.getHeight();
@@ -493,8 +568,8 @@
 						this.resize(this.displayWidth, this.displayHeight);
 					}
 
-					if(this.options.limitFramerate) {
-						Thread.sleep(5L);
+					if (this.options.maxFps > 0 && this.options.maxFps < 250) {
+						Display.sync(this.options.maxFps);
 					}
 
 					this.checkGLError("Post render");
@@ -505,8 +580,10 @@
 						WorldRenderer.chunksUpdated = 0;
 						var1 += 1000L;
 					}
+
+					Profiler.endSection();
 				}
-			} catch (MinecraftError var14) {
+			} catch (MinecraftError minecraftError14) {
 			} catch (Throwable var15) {
 				this.theWorld = null;
 				var15.printStackTrace();
@@ -514,19 +591,50 @@
 			}
 
 		} finally {
-		}
-	}
-
-	private void displayDebugInfo() {
+			BenchmarkTimer.printResults();
+		}
+	}
+
+	private void updateDebugProfilerName(int var1) {
+		List var2 = Profiler.getProfilingData(this.debugProfilerName);
+		if(var2 != null && var2.size() != 0) {
+			ProfilerResult var3 = (ProfilerResult)var2.remove(0);
+			if(var1 == 0) {
+				if(var3.name.length() > 0) {
+					int var4 = this.debugProfilerName.lastIndexOf(".");
+					if(var4 >= 0) {
+						this.debugProfilerName = this.debugProfilerName.substring(0, var4);
+					}
+				}
+			} else {
+				--var1;
+				if(var1 < var2.size() && !((ProfilerResult)var2.get(var1)).name.equals("unspecified")) {
+					if(this.debugProfilerName.length() > 0) {
+						this.debugProfilerName = this.debugProfilerName + ".";
+					}
+
+					this.debugProfilerName = this.debugProfilerName + ((ProfilerResult)var2.get(var1)).name;
+				}
+			}
+
+		}
+	}
+
+	private void displayDebugInfo(long var1) {
+		List var3 = Profiler.getProfilingData(this.debugProfilerName);
+		ProfilerResult var4 = (ProfilerResult)var3.remove(0);
+		long var5 = 16666666L;
 		if(this.prevFrameTime == -1L) {
 			this.prevFrameTime = System.nanoTime();
 		}
 
-		long var1 = System.nanoTime();
-		frameTimes[numRecordedFrameTimes++ & frameTimes.length - 1] = var1 - this.prevFrameTime;
-		this.prevFrameTime = var1;
+		long var7 = System.nanoTime();
+		tickTimes[numRecordedFrameTimes & frameTimes.length - 1] = var1;
+		frameTimes[numRecordedFrameTimes++ & frameTimes.length - 1] = var7 - this.prevFrameTime;
+		this.prevFrameTime = var7;
 		GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
 		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glEnable(GL11.GL_COLOR_MATERIAL);
 		GL11.glLoadIdentity();
 		GL11.glOrtho(0.0D, (double)this.displayWidth, (double)this.displayHeight, 0.0D, 1000.0D, 3000.0D);
 		GL11.glMatrixMode(GL11.GL_MODELVIEW);
@@ -534,45 +642,148 @@
 		GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
 		GL11.glLineWidth(1.0F);
 		GL11.glDisable(GL11.GL_TEXTURE_2D);
-		Tessellator var3 = Tessellator.instance;
-		var3.startDrawing(7);
-		var3.setColorOpaque_I(538968064);
-		var3.addVertex(0.0D, (double)(this.displayHeight - 100), 0.0D);
-		var3.addVertex(0.0D, (double)this.displayHeight, 0.0D);
-		var3.addVertex((double)frameTimes.length, (double)this.displayHeight, 0.0D);
-		var3.addVertex((double)frameTimes.length, (double)(this.displayHeight - 100), 0.0D);
-		var3.draw();
-		long var4 = 0L;
-
-		int var6;
-		for(var6 = 0; var6 < frameTimes.length; ++var6) {
-			var4 += frameTimes[var6];
-		}
-
-		var6 = (int)(var4 / 200000L / (long)frameTimes.length);
-		var3.startDrawing(7);
-		var3.setColorOpaque_I(541065216);
-		var3.addVertex(0.0D, (double)(this.displayHeight - var6), 0.0D);
-		var3.addVertex(0.0D, (double)this.displayHeight, 0.0D);
-		var3.addVertex((double)frameTimes.length, (double)this.displayHeight, 0.0D);
-		var3.addVertex((double)frameTimes.length, (double)(this.displayHeight - var6), 0.0D);
-		var3.draw();
-		var3.startDrawing(1);
-
-		for(int var7 = 0; var7 < frameTimes.length; ++var7) {
-			int var8 = (var7 - numRecordedFrameTimes & frameTimes.length - 1) * 255 / frameTimes.length;
-			int var9 = var8 * var8 / 255;
-			var9 = var9 * var9 / 255;
-			int var10 = var9 * var9 / 255;
-			var10 = var10 * var10 / 255;
-			var3.setColorOpaque_I(-16777216 + var10 + var9 * 256 + var8 * 65536);
-			long var11 = frameTimes[var7] / 200000L;
-			var3.addVertex((double)((float)var7 + 0.5F), (double)((float)((long)this.displayHeight - var11) + 0.5F), 0.0D);
-			var3.addVertex((double)((float)var7 + 0.5F), (double)((float)this.displayHeight + 0.5F), 0.0D);
-		}
-
-		var3.draw();
+		Tessellator var9 = Tessellator.instance;
+		var9.startDrawing(7);
+		int var10 = (int)(var5 / 200000L);
+		var9.setColorOpaque_I(536870912);
+		var9.addVertex(0.0D, (double)(this.displayHeight - var10), 0.0D);
+		var9.addVertex(0.0D, (double)this.displayHeight, 0.0D);
+		var9.addVertex((double)frameTimes.length, (double)this.displayHeight, 0.0D);
+		var9.addVertex((double)frameTimes.length, (double)(this.displayHeight - var10), 0.0D);
+		var9.setColorOpaque_I(538968064);
+		var9.addVertex(0.0D, (double)(this.displayHeight - var10 * 2), 0.0D);
+		var9.addVertex(0.0D, (double)(this.displayHeight - var10), 0.0D);
+		var9.addVertex((double)frameTimes.length, (double)(this.displayHeight - var10), 0.0D);
+		var9.addVertex((double)frameTimes.length, (double)(this.displayHeight - var10 * 2), 0.0D);
+		var9.draw();
+		long var11 = 0L;
+
+		int var13;
+		for(var13 = 0; var13 < frameTimes.length; ++var13) {
+			var11 += frameTimes[var13];
+		}
+
+		var13 = (int)(var11 / 200000L / (long)frameTimes.length);
+		var9.startDrawing(7);
+		var9.setColorOpaque_I(541065216);
+		var9.addVertex(0.0D, (double)(this.displayHeight - var13), 0.0D);
+		var9.addVertex(0.0D, (double)this.displayHeight, 0.0D);
+		var9.addVertex((double)frameTimes.length, (double)this.displayHeight, 0.0D);
+		var9.addVertex((double)frameTimes.length, (double)(this.displayHeight - var13), 0.0D);
+		var9.draw();
+		var9.startDrawing(1);
+
+		int var15;
+		int var16;
+		for(int var14 = 0; var14 < frameTimes.length; ++var14) {
+			var15 = (var14 - numRecordedFrameTimes & frameTimes.length - 1) * 255 / frameTimes.length;
+			var16 = var15 * var15 / 255;
+			var16 = var16 * var16 / 255;
+			int var17 = var16 * var16 / 255;
+			var17 = var17 * var17 / 255;
+			if(frameTimes[var14] > var5) {
+				var9.setColorOpaque_I(-16777216 + var16 * 65536);
+			} else {
+				var9.setColorOpaque_I(-16777216 + var16 * 256);
+			}
+
+			long var18 = frameTimes[var14] / 200000L;
+			long var20 = tickTimes[var14] / 200000L;
+			var9.addVertex((double)((float)var14 + 0.5F), (double)((float)((long)this.displayHeight - var18) + 0.5F), 0.0D);
+			var9.addVertex((double)((float)var14 + 0.5F), (double)((float)this.displayHeight + 0.5F), 0.0D);
+			var9.setColorOpaque_I(-16777216 + var16 * 65536 + var16 * 256 + var16 * 1);
+			var9.addVertex((double)((float)var14 + 0.5F), (double)((float)((long)this.displayHeight - var18) + 0.5F), 0.0D);
+			var9.addVertex((double)((float)var14 + 0.5F), (double)((float)((long)this.displayHeight - (var18 - var20)) + 0.5F), 0.0D);
+		}
+
+		var9.draw();
+		short var26 = 160;
+		var15 = this.displayWidth - var26 - 10;
+		var16 = this.displayHeight - var26 * 2;
+		GL11.glEnable(GL11.GL_BLEND);
+		var9.startDrawingQuads();
+		var9.setColorRGBA(0, 0, 0, 200);
+		var9.addVertex((double)((float)var15 - (float)var26 * 1.1F), (double)((float)var16 - (float)var26 * 0.6F - 16.0F), 0.0D);
+		var9.addVertex((double)((float)var15 - (float)var26 * 1.1F), (double)(var16 + var26 * 2), 0.0D);
+		var9.addVertex((double)((float)var15 + (float)var26 * 1.1F), (double)(var16 + var26 * 2), 0.0D);
+		var9.addVertex((double)((float)var15 + (float)var26 * 1.1F), (double)((float)var16 - (float)var26 * 0.6F - 16.0F), 0.0D);
+		var9.draw();
+		GL11.glDisable(GL11.GL_BLEND);
+		double var27 = 0.0D;
+
+		int var21;
+		for(int var19 = 0; var19 < var3.size(); ++var19) {
+			ProfilerResult var29 = (ProfilerResult)var3.get(var19);
+			var21 = MathHelper.floor_double(var29.sectionPercentage / 4.0D) + 1;
+			var9.startDrawing(6);
+			var9.setColorOpaque_I(var29.getDisplayColor());
+			var9.addVertex((double)var15, (double)var16, 0.0D);
+
+			int var22;
+			float var23;
+			float var24;
+			float var25;
+			for(var22 = var21; var22 >= 0; --var22) {
+				var23 = (float)((var27 + var29.sectionPercentage * (double)var22 / (double)var21) * (double)((float)Math.PI) * 2.0D / 100.0D);
+				var24 = MathHelper.sin(var23) * (float)var26;
+				var25 = MathHelper.cos(var23) * (float)var26 * 0.5F;
+				var9.addVertex((double)((float)var15 + var24), (double)((float)var16 - var25), 0.0D);
+			}
+
+			var9.draw();
+			var9.startDrawing(5);
+			var9.setColorOpaque_I((var29.getDisplayColor() & 16711422) >> 1);
+
+			for(var22 = var21; var22 >= 0; --var22) {
+				var23 = (float)((var27 + var29.sectionPercentage * (double)var22 / (double)var21) * (double)((float)Math.PI) * 2.0D / 100.0D);
+				var24 = MathHelper.sin(var23) * (float)var26;
+				var25 = MathHelper.cos(var23) * (float)var26 * 0.5F;
+				var9.addVertex((double)((float)var15 + var24), (double)((float)var16 - var25), 0.0D);
+				var9.addVertex((double)((float)var15 + var24), (double)((float)var16 - var25 + 10.0F), 0.0D);
+			}
+
+			var9.draw();
+			var27 += var29.sectionPercentage;
+		}
+
+		DecimalFormat var28 = new DecimalFormat("##0.00");
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
+		String var30 = "";
+		if(!var4.name.equals("unspecified")) {
+			var30 = var30 + "[0] ";
+		}
+
+		if(var4.name.length() == 0) {
+			var30 = var30 + "ROOT ";
+		} else {
+			var30 = var30 + var4.name + " ";
+		}
+
+		var21 = 16777215;
+		this.fontRenderer.drawStringWithShadow(var30, var15 - var26, var16 - var26 / 2 - 16, var21);
+		FontRenderer var10000 = this.fontRenderer;
+		var30 = var28.format(var4.globalPercentage) + "%";
+		var10000.drawStringWithShadow(var30, var15 + var26 - this.fontRenderer.getStringWidth(var30), var16 - var26 / 2 - 16, var21);
+
+		for(int var32 = 0; var32 < var3.size(); ++var32) {
+			ProfilerResult var31 = (ProfilerResult)var3.get(var32);
+			String var33 = "";
+			if(!var31.name.equals("unspecified")) {
+				var33 = var33 + "[" + (var32 + 1) + "] ";
+			} else {
+				var33 = var33 + "[?] ";
+			}
+
+			var33 = var33 + var31.name;
+			this.fontRenderer.drawStringWithShadow(var33, var15 - var26, var16 + var26 / 2 + var32 * 8 + 20, var31.getDisplayColor());
+			var10000 = this.fontRenderer;
+			var33 = var28.format(var31.sectionPercentage) + "%";
+			var10000.drawStringWithShadow(var33, var15 + var26 - 50 - this.fontRenderer.getStringWidth(var33), var16 + var26 / 2 + var32 * 8 + 20, var31.getDisplayColor());
+			var10000 = this.fontRenderer;
+			var33 = var28.format(var31.globalPercentage) + "%";
+			var10000.drawStringWithShadow(var33, var15 + var26 - this.fontRenderer.getStringWidth(var33), var16 + var26 / 2 + var32 * 8 + 20, var31.getDisplayColor());
+		}
+
 	}
 
 	public void shutdown() {
@@ -586,6 +797,7 @@
 				this.mouseHelper.grabMouseCursor();
 				this.displayGuiScreen((GuiScreen)null);
 				this.mouseTicksRan = this.ticksRan + 10000;
+				this.leftClickCounter = 5;
 			}
 		}
 	}
@@ -604,13 +816,24 @@
 	public void displayInGameMenu() {
 		if(this.currentScreen == null) {
 			this.displayGuiScreen(new GuiIngameMenu());
+
+			if (panoramaMode) {
+				this.thePlayer.rotationYaw = -90.0F;
+				this.thePlayer.rotationPitch = 0.0F;
+
+				if (this.panoramaTick < 4) this.thePlayer.rotationYaw += this.panoramaTick * 90;
+				if (this.panoramaTick == 4) this.thePlayer.rotationPitch = -90.0F;
+				if (this.panoramaTick == 5) this.thePlayer.rotationPitch = 90.0F;
+
+				this.panoramaTick = (this.panoramaTick + 1) % 6;
+			}
 		}
 	}
 
-	private void sendClickBlockToController(int var1, boolean var2) {
+	private void sendClickBlockToController(int button, boolean clicked) {
 		if(!this.playerController.isInTestMode) {
-			if(var1 != 0 || this.leftClickCounter <= 0) {
-				if(var2 && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == 0 && var1 == 0) {
+			if(button != 0 || this.leftClickCounter <= 0) {
+				if(clicked && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == 0 && button == 0) {
 					int var3 = this.objectMouseOver.blockX;
 					int var4 = this.objectMouseOver.blockY;
 					int var5 = this.objectMouseOver.blockZ;
@@ -620,28 +843,31 @@
 					this.playerController.resetBlockRemoving();
 				}
 
+				if(!clicked) {
+					this.playerController.stopBlockRemoving();
+				}
 			}
 		}
 	}
 
-	private void clickMouse(int var1) {
-		if(var1 != 0 || this.leftClickCounter <= 0) {
-			if(var1 == 0) {
+	private void clickMouse(int button) {
+		if(button != 0 || this.leftClickCounter <= 0) {
+			if(button == 0) {
 				this.thePlayer.swingItem();
 			}
 
 			int var3;
 			if(this.objectMouseOver == null) {
-				if(var1 == 0 && !(this.playerController instanceof PlayerControllerCreative)) {
-					this.leftClickCounter = 10;
+				if(button == 0 && !this.thePlayer.creative) {
+//					this.leftClickCounter = 10;
 				}
 			} else if(this.objectMouseOver.typeOfHit == 1) {
-				if(var1 == 0) {
-					this.thePlayer.attackEntity(this.objectMouseOver.entityHit);
+				if(button == 0) {
+					this.playerController.attackEntity(this.thePlayer, this.objectMouseOver.entityHit);
 				}
 
-				if(var1 == 1) {
-					this.thePlayer.interactWithEntity(this.objectMouseOver.entityHit);
+				if(button == 1) {
+					this.playerController.interactWithEntity(this.thePlayer, this.objectMouseOver.entityHit);
 				}
 			} else if(this.objectMouseOver.typeOfHit == 0) {
 				int var2 = this.objectMouseOver.blockX;
@@ -649,15 +875,15 @@
 				int var4 = this.objectMouseOver.blockZ;
 				int var5 = this.objectMouseOver.sideHit;
 				Block var6 = Block.blocksList[this.theWorld.getBlockId(var2, var3, var4)];
-				if(var1 == 0) {
+				if(button == 0) {
 					this.theWorld.extinguishFire(var2, var3, var4, this.objectMouseOver.sideHit);
-					if(var6 != Block.bedrock || this.thePlayer.unusedMiningCooldown >= 100) {
+					if(var6 != Block.bedrock || this.thePlayer.unusedMiningCooldown >= 100 || this.thePlayer.creative) {
 						this.playerController.clickBlock(var2, var3, var4, this.objectMouseOver.sideHit);
 					}
 				} else {
 					ItemStack var7 = this.thePlayer.inventory.getCurrentItem();
 					int var8 = var7 != null ? var7.stackSize : 0;
-					if(this.playerController.onPlayerRightClick(this.thePlayer, this.theWorld, var7, var2, var3, var4, var5)) {
+					if(this.playerController.sendPlaceBlock(this.thePlayer, this.theWorld, var7, var2, var3, var4, var5, this.objectMouseOver.hitVec)) {
 						this.thePlayer.swingItem();
 					}
 
@@ -673,22 +899,23 @@
 				}
 			}
 
-			if(var1 == 1) {
+			if(button == 1) {
 				ItemStack var9 = this.thePlayer.inventory.getCurrentItem();
-				if(var9 != null) {
-					var3 = var9.stackSize;
-					ItemStack var10 = var9.useItemRightClick(this.theWorld, this.thePlayer);
-					if(var10 != var9 || var10 != null && var10.stackSize != var3) {
-						this.thePlayer.inventory.mainInventory[this.thePlayer.inventory.currentItem] = var10;
-						this.entityRenderer.itemRenderer.resetEquippedProgress2();
-						if(var10.stackSize == 0) {
-							this.thePlayer.inventory.mainInventory[this.thePlayer.inventory.currentItem] = null;
-						}
-					}
+				if(var9 != null && this.playerController.sendUseItem(this.thePlayer, this.theWorld, var9)) {
+					this.entityRenderer.itemRenderer.resetEquippedProgress2();
 				}
 			}
 
 		}
+	}
+
+	private boolean repeatClick() {
+		return this.thePlayer != null
+				&& this.thePlayer.flying
+				&& this.thePlayer.isRunning()
+				&& (MathHelper.floor_double(this.thePlayer.posX) != MathHelper.floor_double(this.thePlayer.lastTickPosX)
+						|| MathHelper.floor_double(this.thePlayer.posY) != MathHelper.floor_double(this.thePlayer.lastTickPosY)
+						|| MathHelper.floor_double(this.thePlayer.posZ) != MathHelper.floor_double(this.thePlayer.lastTickPosZ));
 	}
 
 	public void toggleFullscreen() {
@@ -740,48 +967,55 @@
 			}
 
 			System.out.println("Size: " + this.displayWidth + ", " + this.displayHeight);
-		} catch (Exception var2) {
-			var2.printStackTrace();
+		} catch (Exception exception2) {
+			exception2.printStackTrace();
 		}
 
 	}
 
-	private void resize(int var1, int var2) {
-		if(var1 <= 0) {
-			var1 = 1;
-		}
-
-		if(var2 <= 0) {
-			var2 = 1;
-		}
-
-		this.displayWidth = var1;
-		this.displayHeight = var2;
+	private void resize(int width, int height) {
+		if(width <= 0) {
+			width = 1;
+		}
+
+		if(height <= 0) {
+			height = 1;
+		}
+
+		this.displayWidth = width;
+		this.displayHeight = height;
 		if(this.currentScreen != null) {
-			ScaledResolution var3 = new ScaledResolution(var1, var2);
-			int var4 = var3.getScaledWidth();
-			int var5 = var3.getScaledHeight();
+			ScaledResolution scaledResolution3 = new ScaledResolution(width, height, this.options.guiScale);
+			int var4 = scaledResolution3.getScaledWidth();
+			int var5 = scaledResolution3.getScaledHeight();
 			this.currentScreen.setWorldAndResolution(this, var4, var5);
 		}
 
 	}
 
 	private void clickMiddleMouseButton() {
-		if(this.objectMouseOver != null) {
+		if(this.objectMouseOver != null && this.objectMouseOver.typeOfHit == 0) {
 			int var1 = this.theWorld.getBlockId(this.objectMouseOver.blockX, this.objectMouseOver.blockY, this.objectMouseOver.blockZ);
-			if(var1 == Block.grass.blockID) {
-				var1 = Block.dirt.blockID;
-			}
-
-			if(var1 == Block.stairDouble.blockID) {
-				var1 = Block.stairSingle.blockID;
-			}
-
-			if(var1 == Block.bedrock.blockID) {
-				var1 = Block.stone.blockID;
-			}
-
-			this.thePlayer.inventory.setCurrentItem(var1, this.playerController instanceof PlayerControllerCreative);
+			if (!this.thePlayer.creative) {
+				if(var1 == Block.grass.blockID) {
+					var1 = Block.dirt.blockID;
+				}
+
+				if(var1 == Block.stairDouble.blockID) {
+					var1 = Block.stairSingle.blockID;
+				}
+
+				if(var1 == Block.bedrock.blockID) {
+					var1 = Block.stone.blockID;
+				}
+			}
+			int var2 = this.theWorld.getBlockMetadata(this.objectMouseOver.blockX, this.objectMouseOver.blockY, this.objectMouseOver.blockZ);
+
+			Block block = Block.blocksList[var1];
+			int id = block.idDroppedSilk(var2, this.theWorld.rand);
+			int meta = block.metadataDroppedSilk(var2, id, this.theWorld.rand);
+
+			this.thePlayer.inventory.setCurrentItem(id, meta, this.thePlayer.creative);
 		}
 
 	}
@@ -789,9 +1023,6 @@
 	public void runTick() {
 		this.ingameGUI.updateTick();
 		this.entityRenderer.getMouseOver(1.0F);
-		if(this.thePlayer != null) {
-			this.thePlayer.onPlayerUpdate();
-		}
 
 		if(!this.isGamePaused && this.theWorld != null) {
 			this.playerController.onUpdate();
@@ -813,6 +1044,7 @@
 		if(this.currentScreen != null) {
 			this.currentScreen.handleInput();
 			if(this.currentScreen != null) {
+				GuiScreen.panoramaCounter++;
 				this.currentScreen.updateScreen();
 			}
 		}
@@ -822,7 +1054,9 @@
 			while(true) {
 				while(true) {
 					while(true) {
+						if (this.guiCloseTimer > 0) this.guiCloseTimer--;
 						long var1;
+
 						do {
 							if(!Mouse.next()) {
 								if(this.leftClickCounter > 0) {
@@ -833,19 +1067,23 @@
 									while(true) {
 										do {
 											if(!Keyboard.next()) {
+												if(Mouse.getEventButtonState() && Mouse.getEventButton() == 0) {
+													this.guiLeftClick = !this.inGameHasFocus;
+												}
+
 												if(this.currentScreen == null) {
-													if(Mouse.isButtonDown(0) && (float)(this.ticksRan - this.mouseTicksRan) >= this.timer.ticksPerSecond / 4.0F && this.inGameHasFocus) {
+													if(Mouse.isButtonDown(0) && ((float)(this.ticksRan - this.mouseTicksRan) >= this.timer.ticksPerSecond / 4.0F || this.repeatClick()) && this.inGameHasFocus) {
 														this.clickMouse(0);
 														this.mouseTicksRan = this.ticksRan;
 													}
 
-													if(Mouse.isButtonDown(1) && (float)(this.ticksRan - this.mouseTicksRan) >= this.timer.ticksPerSecond / 4.0F && this.inGameHasFocus) {
+													if(Mouse.isButtonDown(1) && ((float)(this.ticksRan - this.mouseTicksRan) >= this.timer.ticksPerSecond / 4.0F || this.repeatClick()) && this.inGameHasFocus) {
 														this.clickMouse(1);
 														this.mouseTicksRan = this.ticksRan;
 													}
 												}
 
-												this.sendClickBlockToController(0, this.currentScreen == null && Mouse.isButtonDown(0) && this.inGameHasFocus);
+												this.sendClickBlockToController(0, this.currentScreen == null && Mouse.isButtonDown(0) && this.inGameHasFocus && !this.guiLeftClick);
 												break label234;
 											}
 
@@ -866,22 +1104,51 @@
 													this.forceReload();
 												}
 
-												if(Keyboard.getEventKey() == Keyboard.KEY_F5) {
-													this.options.thirdPersonView = !this.options.thirdPersonView;
+												if(Keyboard.getEventKey() == this.options.keyBindThirdPerson.keyCode) {
+													this.options.thirdPersonView = (this.options.thirdPersonView + 1) % 3;
+												}
+
+												if(Keyboard.getEventKey() == Keyboard.KEY_F3) {
+													this.options.debugMenu = !this.options.debugMenu;
+												}
+
+												if(Keyboard.getEventKey() == Keyboard.KEY_F6) {
+													this.options.lagometer = !this.options.lagometer;
 												}
 
 												if(Keyboard.getEventKey() == this.options.keyBindInventory.keyCode) {
-													this.displayGuiScreen(new GuiInventory(this.thePlayer.inventory, this.thePlayer.inventory.craftingInventory));
+													this.displayGuiScreen(new GuiInventory(this.thePlayer));
 												}
 
 												if(Keyboard.getEventKey() == this.options.keyBindDrop.keyCode) {
-													this.thePlayer.dropPlayerItemWithRandomChoice(this.thePlayer.inventory.decrStackSize(this.thePlayer.inventory.currentItem, 1), false);
+													this.thePlayer.dropOneItem();
+												}
+
+												if(Keyboard.getEventKey() == this.options.keyBindHideHud.keyCode) {
+													this.showHud = !this.showHud;
 												}
 
 												if(this.isMultiplayerWorld() && Keyboard.getEventKey() == this.options.keyBindChat.keyCode) {
 													this.displayGuiScreen(new GuiChat());
 												}
-											}
+
+												if(Keyboard.getEventKey() == this.options.keyBindCreative.keyCode) {
+													this.playerController.displayGuiCreative();
+												}
+
+												if(Keyboard.getEventKey() == Keyboard.KEY_F10 && this.options.creativeDebug) {
+													this.displayGuiScreen(new GuiTextureViewer());
+												}
+
+												if(Keyboard.isKeyDown(Keyboard.KEY_F3)) {
+													if (Keyboard.getEventKey() == Keyboard.KEY_T) {
+														this.renderEngine.refreshTextures();
+														this.renderGlobal.loadRenderers();
+														RenderManager.instance.refresh();
+														VanityModels.refresh();
+													}
+												}
+ 											}
 
 											for(int var4 = 0; var4 < 9; ++var4) {
 												if(Keyboard.getEventKey() == Keyboard.KEY_1 + var4) {
@@ -889,8 +1156,16 @@
 												}
 											}
 
-											if(Keyboard.getEventKey() == this.options.keyBindToggleFog.keyCode) {
-												this.options.setOptionValue(4, !Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) && !Keyboard.isKeyDown(Keyboard.KEY_RSHIFT) ? 1 : -1);
+											if(this.options.lagometer) {
+												if(Keyboard.getEventKey() == Keyboard.KEY_0) {
+													this.updateDebugProfilerName(0);
+												}
+
+												for(int i = 0; i < 9; ++i) {
+													if(Keyboard.getEventKey() == Keyboard.KEY_1 + i) {
+														this.updateDebugProfilerName(i + 1);
+													}
+												}
 											}
 										}
 									}
@@ -908,7 +1183,9 @@
 						if(this.currentScreen == null) {
 							if(!this.inGameHasFocus && Mouse.getEventButtonState()) {
 								this.setIngameFocus();
-							} else {
+								if (this.thePlayer.creative)
+									this.guiCloseTimer = 10;
+							} else if (this.guiCloseTimer <= 0) {
 								if(Mouse.getEventButton() == 0 && Mouse.getEventButtonState()) {
 									this.clickMouse(0);
 									this.mouseTicksRan = this.ticksRan;
@@ -924,6 +1201,9 @@
 								}
 							}
 						} else if(this.currentScreen != null) {
+							if(Mouse.getEventButtonState() && Mouse.getEventButton() == 0) {
+								this.guiLeftClick = true;
+							}
 							this.currentScreen.handleMouseInput();
 						}
 					}
@@ -941,29 +1221,44 @@
 			}
 
 			this.theWorld.difficultySetting = this.options.difficulty;
+
+			Profiler.startSection("gameRenderer");
 			if(!this.isGamePaused) {
 				this.entityRenderer.updateRenderer();
 			}
 
+			Profiler.endStartSection("levelRenderer");
 			if(!this.isGamePaused) {
 				this.renderGlobal.updateClouds();
 			}
 
+			Profiler.endStartSection("level");
 			if(!this.isGamePaused) {
 				this.theWorld.updateEntities();
 			}
 
 			if(!this.isGamePaused || this.isMultiplayerWorld()) {
+				if (!this.options.caveSounds) {
+					this.theWorld.soundCounter = 0xDEAD;
+				}
+				this.theWorld.simulationDistance = Math.min(this.options.simulationDistance, this.options.renderDistance);
+				this.theWorld.fastLighting = this.options.fastLighting;
+				this.theWorld.lazyLoading = this.options.lazyLoading;
+				this.theWorld.autosavePeriod = this.options.autosaveInterval * 20;
 				this.theWorld.tick();
 			}
 
+			Profiler.endStartSection("animateTick");
 			if(!this.isGamePaused && this.theWorld != null) {
 				this.theWorld.randomDisplayUpdates(MathHelper.floor_double(this.thePlayer.posX), MathHelper.floor_double(this.thePlayer.posY), MathHelper.floor_double(this.thePlayer.posZ));
 			}
 
+			Profiler.endStartSection("particles");
 			if(!this.isGamePaused) {
 				this.effectRenderer.updateEffects();
 			}
+
+			Profiler.endSection();
 		}
 
 		this.systemTime = System.currentTimeMillis();
@@ -980,82 +1275,106 @@
 		return this.theWorld != null && this.theWorld.multiplayerWorld;
 	}
 
-	public void startWorld(String var1) {
+	public void startWorld(String worldName) {
+		startWorld(worldName, null);
+	}
+
+	public void startWorld(String worldName, CreateWorldInfo info) {
+		this.sndManager.fadeOutTitleMusic();
 		this.changeWorld1((World)null);
 		System.gc();
-		World var2 = new World(new File(getMinecraftDir(), "saves"), var1);
-		if(var2.isNewWorld) {
-			this.changeWorld(var2, "Generating level");
+		this.loadingScreen.resetProgressAndMessage("");
+		this.loadingScreen.displayLoadingString("Finding spawn");
+		World var2 = new World(new File(getMinecraftDir(), "saves"), worldName, info == null ? 0 : info.seed, info, this.achievements);
+		int i2 = World.requiresConversion(new File(getMinecraftDir(), "saves"), worldName);
+
+		if(i2 > 0) {
+			this.convertMapFormat(worldName);
 		} else {
-			this.changeWorld(var2, "Loading level");
+			if (var2.isNewWorld) {
+				this.changeWorld(var2, "Generating level");
+			} else {
+				this.changeWorld(var2, "Loading level");
+			}
 		}
-
-	}
-
-	public void changeWorld1(World var1) {
-		this.changeWorld(var1, "");
-	}
-
-	public void changeWorld(World var1, String var2) {
-		this.sndManager.playStreaming((String)null, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F);
+	}
+
+	public void changeWorld1(World world) {
+		this.changeWorld(world, "");
+	}
+
+	public void changeWorld(World world, String title) {
+		this.sndManager.playStreaming(null, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F);
 		if(this.theWorld != null) {
 			this.theWorld.saveWorldIndirectly(this.loadingScreen);
 		}
 
-		this.theWorld = var1;
-		if(var1 != null) {
-			this.playerController.onWorldChange(var1);
-			var1.fontRenderer = this.fontRenderer;
+		this.theWorld = world;
+		if(world != null) {
+			this.playerController.onWorldChange(world);
+			world.fontRenderer = this.fontRenderer;
 			if(!this.isMultiplayerWorld()) {
-				this.thePlayer = (EntityPlayerSP)var1.createDebugPlayer(EntityPlayerSP.class);
+				this.thePlayer = (EntityPlayerSP)world.createDebugPlayer(EntityPlayerSP.class);
 			} else if(this.thePlayer != null) {
 				this.thePlayer.preparePlayerToSpawn();
-				if(var1 != null) {
-					var1.spawnEntityInWorld(this.thePlayer);
+				if(world != null) {
+					world.spawnEntityInWorld(this.thePlayer);
 				}
 			}
 
-			if(!var1.multiplayerWorld) {
-				this.preloadWorld(var2);
+			if(!world.multiplayerWorld) {
+				this.preloadWorld(title);
 			}
 
 			if(this.thePlayer == null) {
-				this.thePlayer = (EntityPlayerSP)this.playerController.createPlayer(var1);
+				this.thePlayer = (EntityPlayerSP)this.playerController.createPlayer(world);
 				this.thePlayer.preparePlayerToSpawn();
 				this.playerController.flipPlayer(this.thePlayer);
 			}
 
 			this.thePlayer.movementInput = new MovementInputFromOptions(this.options);
 			if(this.renderGlobal != null) {
-				this.renderGlobal.changeWorld(var1);
+				this.renderGlobal.changeWorld(world);
 			}
 
 			if(this.effectRenderer != null) {
-				this.effectRenderer.clearEffects(var1);
+				this.effectRenderer.clearEffects(world);
 			}
 
 			this.playerController.onRespawn(this.thePlayer);
-			var1.spawnPlayerWithLoadedChunks(this.thePlayer);
-			if(var1.isNewWorld) {
-				var1.saveWorldIndirectly(this.loadingScreen);
+			world.spawnPlayerWithLoadedChunks(this.thePlayer);
+			if(world.isNewWorld) {
+				world.saveWorldIndirectly(this.loadingScreen);
 			}
 		} else {
+			this.sndManager.fadeOutBackgroundMusic();
 			this.thePlayer = null;
+			RegionFileCache.clear();
 		}
 
 		System.gc();
 		this.systemTime = 0L;
 	}
 
-	private void preloadWorld(String var1) {
-		this.loadingScreen.resetProgressAndMessage(var1);
+	private void convertMapFormat(String worldName) {
+		this.loadingScreen.resetProgressAndMessage("Converting world to Extended McRegion");
+		this.loadingScreen.displayLoadingString("This may take a while :)");
+		this.loadingScreen.beHereForAWhile(true);
+		File worldDir = new File(new File(getMinecraftDir(), "saves"), worldName);
+		RegionTool.pack(worldDir, worldDir, this.loadingScreen);
+		this.loadingScreen.beHereForAWhile(false);
+		startWorld(worldName);
+	}
+
+	private void preloadWorld(String title) {
+		this.loadingScreen.resetProgressAndMessage(title);
 		this.loadingScreen.displayLoadingString("Building terrain");
-		short var2 = 128;
+		short s2 = 128;
 		int var3 = 0;
-		int var4 = var2 * 2 / 16 + 1;
+		int var4 = s2 * 2 / 16 + 1;
 		var4 *= var4;
 
-		for(int var5 = -var2; var5 <= var2; var5 += 16) {
+		for(int var5 = -s2; var5 <= s2; var5 += 16) {
 			int var6 = this.theWorld.spawnX;
 			int var7 = this.theWorld.spawnZ;
 			if(this.thePlayer != null) {
@@ -1063,7 +1382,7 @@
 				var7 = (int)this.thePlayer.posZ;
 			}
 
-			for(int var8 = -var2; var8 <= var2; var8 += 16) {
+			for(int var8 = -s2; var8 <= s2; var8 += 16) {
 				this.loadingScreen.setLoadingProgress(var3++ * 100 / var4);
 				this.theWorld.getBlockId(var6 + var5, 64, var7 + var8);
 
@@ -1077,20 +1396,31 @@
 		this.theWorld.dropOldChunks();
 	}
 
-	public void installResource(String var1, File var2) {
-		int var3 = var1.indexOf("/");
-		String var4 = var1.substring(0, var3);
-		var1 = var1.substring(var3 + 1);
+	public void installResource(String name, File file) {
+		int var3 = name.indexOf("/");
+		String var4 = name.substring(0, var3);
+		name = name.substring(var3 + 1);
 		if(var4.equalsIgnoreCase("sound")) {
-			this.sndManager.addSound(var1, var2);
+			this.sndManager.addSound(name, file);
 		} else if(var4.equalsIgnoreCase("newsound")) {
-			this.sndManager.addSound(var1, var2);
+			this.sndManager.addSound(name, file);
 		} else if(var4.equalsIgnoreCase("streaming")) {
-			this.sndManager.addStreaming(var1, var2);
-		} else if(var4.equalsIgnoreCase("music")) {
-			this.sndManager.addMusic(var1, var2);
+			this.sndManager.addStreaming(name, file);
 		} else if(var4.equalsIgnoreCase("newmusic")) {
-			this.sndManager.addMusic(var1, var2);
+			if (name.contains("cave")) {
+				this.sndManager.addCaveMusic(name, file);
+			} else if (name.contains("title")) {
+				this.sndManager.addTitleMusic(name, file);
+			} else if (name.contains("underworld")) {
+				this.sndManager.addUnderworldMusic(name, file);
+			} else if (name.contains("calm")
+					|| name.contains("piano")
+					|| name.contains("hal")
+					|| name.contains("nuance")) {
+				this.sndManager.addMusic(name, file);
+			}
+		} else if(var4.equalsIgnoreCase("music")) {
+			this.sndManager.addMusic(name, file);
 		}
 
 	}
@@ -1099,6 +1429,12 @@
 		return this.glCapabilities;
 	}
 
+	public String debugInfoLocation() {
+		return "X: " + MathHelper.formatDouble(this.thePlayer.posX)
+			   + ", Y: " + MathHelper.formatDouble(this.thePlayer.boundingBox.minY)
+			   + ", Z: " + MathHelper.formatDouble(this.thePlayer.posZ);
+	}
+
 	public String debugInfoRenders() {
 		return this.renderGlobal.getDebugInfoRenders();
 	}
@@ -1111,66 +1447,119 @@
 		return "P: " + this.effectRenderer.getStatistics() + ". T: " + this.theWorld.getDebugLoadedEntities();
 	}
 
+	public String debugInfoSeed() {
+		return "Seed: " + this.theWorld.randomSeed;
+	}
+
+	public String debugInfoWorld() {
+		return "Type: " + this.theWorld.worldType.getName()
+				   + ", Biome: " + (this.theWorld.getBiome(MathHelper.floor_double(this.thePlayer.posX), MathHelper.floor_double(this.thePlayer.posZ)).name);
+	}
+
+	public String debugInfoClimate() {
+		int x = MathHelper.floor_double(this.thePlayer.posX);
+		int z = MathHelper.floor_double(this.thePlayer.posZ);
+
+		double biomeSize = 0.0005D;
+
+		float temperature = MathHelper.clamp(SimplexOctaves.noise3_ImproveXY(this.theWorld.randomSeed,
+				x * biomeSize, z * biomeSize, 1000, 2) / 1.5F + 0.5F, 0.0F, 1.0F);
+		float humidity = MathHelper.clamp(SimplexOctaves.noise3_ImproveXY(this.theWorld.randomSeed,
+				x * biomeSize, z * biomeSize, -1000, 2) / 1.5F + 0.5F, 0.0F, 1.0F);
+
+		return "T: " + MathHelper.formatFloat(temperature)
+				+ ". H: " + MathHelper.formatFloat(humidity);
+	}
+
 	public void respawn() {
 		this.theWorld.setSpawnLocation();
 		if(this.thePlayer != null) {
 			this.theWorld.setEntityDead(this.thePlayer);
 		}
 
+		int var8 = 0;
+		if(this.thePlayer != null) {
+			var8 = this.thePlayer.entityID;
+			this.theWorld.setEntityDead(this.thePlayer);
+		}
+
 		this.thePlayer = (EntityPlayerSP)this.playerController.createPlayer(this.theWorld);
 		this.thePlayer.preparePlayerToSpawn();
 		this.playerController.flipPlayer(this.thePlayer);
 		this.theWorld.spawnPlayerWithLoadedChunks(this.thePlayer);
 		this.thePlayer.movementInput = new MovementInputFromOptions(this.options);
+		this.thePlayer.entityID = var8;
 		this.playerController.onRespawn(this.thePlayer);
 		this.preloadWorld("Respawning");
 	}
 
-	public static void startMainThread(String var0, String var1) {
-		startMainThread(var0, var1, (String)null);
+	public static void startMainThread(String username, String sessionId) {
+		startMainThread(username, sessionId, null);
 	}
 
-	public static void startMainThread(String var0, String var1, String var2) {
+	public static void startMainThread(String username, String sessionId, String server) {
+		int windowWidth = panoramaMode ? 256 : 854;
+		int windowHeight = panoramaMode ? 256 : 480;
 		boolean var3 = false;
-		Frame var5 = new Frame("Minecraft");
-		Canvas var6 = new Canvas();
-		var5.setLayout(new BorderLayout());
-		var5.add(var6, "Center");
-		var6.setPreferredSize(new Dimension(854, 480));
-		var5.pack();
-		var5.setLocationRelativeTo((Component)null);
-		MinecraftImpl var7 = new MinecraftImpl(var5, var6, (MinecraftApplet)null, 854, 480, var3, var5);
-		Thread var8 = new Thread(var7, "Minecraft main thread");
-		var8.setPriority(10);
-		var7.appletMode = false;
-		var7.minecraftUri = "www.minecraft.net";
-		if(var0 != null && var1 != null) {
-			var7.session = new Session(var0, var1);
+		Frame frame5 = new Frame("Minecraft");
+		Canvas canvas6 = new Canvas();
+		frame5.setLayout(new BorderLayout());
+		frame5.add(canvas6, "Center");
+		canvas6.setPreferredSize(new Dimension(windowWidth, windowHeight));
+		frame5.pack();
+		frame5.setLocationRelativeTo(null);
+		MinecraftImpl minecraftImpl7 = new MinecraftImpl(frame5, canvas6, null, windowWidth, windowHeight, var3, frame5);
+		Thread thread8 = new Thread(minecraftImpl7, "Minecraft main thread");
+		thread8.setPriority(10);
+		minecraftImpl7.appletMode = false;
+		minecraftImpl7.minecraftUri = "www.minecraft.net";
+		if(username != null && sessionId != null) {
+			minecraftImpl7.session = new Session(username, sessionId);
 		} else {
-			var7.session = new Session("Player" + System.currentTimeMillis() % 1000L, "");
-		}
-
-		if(var2 != null) {
-			String[] var9 = var2.split(":");
-			var7.setServer(var9[0], Integer.parseInt(var9[1]));
-		}
-
-		var5.setVisible(true);
-		var5.addWindowListener(new GameWindowListener(var7, var8));
-		var8.start();
+			minecraftImpl7.session = new Session("Player" + System.currentTimeMillis() % 1000L, "");
+		}
+
+		if(server != null) {
+			String[] var9 = server.split(":");
+			minecraftImpl7.setServer(var9[0], Integer.parseInt(var9[1]));
+		}
+
+		frame5.setVisible(true);
+		frame5.addWindowListener(new GameWindowListener(minecraftImpl7, thread8));
+		thread8.start();
 	}
 
-	public static void main(String[] var0) {
+	public static void main(String[] args) {
 		String var1 = "Player" + System.currentTimeMillis() % 1000L;
-		if(var0.length > 0) {
-			var1 = var0[0];
+		if(args.length > 0) {
+			var1 = args[0];
 		}
 
 		String var2 = "-";
-		if(var0.length > 1) {
-			var2 = var0[1];
+		if(args.length > 1) {
+			var2 = args[1];
 		}
 
 		startMainThread(var1, var2);
+	}
+
+	public NetClientHandler getSendQueue() {
+		return this.thePlayer instanceof EntityClientPlayerMP ? ((EntityClientPlayerMP)this.thePlayer).sendQueue : null;
+	}
+
+	private void screenshotListener() {
+		if(Keyboard.isKeyDown(this.options.keyBindScreenshot.keyCode)) {
+			if(!this.isTakingScreenshot) {
+				this.isTakingScreenshot = true;
+				this.ingameGUI.addChatMessage(ScreenShotHelper.saveScreenshot(minecraftDir, this.displayWidth, this.displayHeight));
+			}
+		} else {
+			this.isTakingScreenshot = false;
+		}
+
+	}
+
+	public static boolean fastRender() {
+		return getInstance() != null && getInstance().options.fastRender;
 	}
 }
--- /dev/null
+++ net/minecraft/src/Profiler.java
@@ -1,0 +1,118 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class Profiler {
+	public static boolean profilingEnabled = false;
+	private static List sectionList = new ArrayList();
+	private static List timestampList = new ArrayList();
+	private static String profilingSection = "";
+	private static Map profilingMap = new HashMap();
+
+	public static void clearProfiling() {
+		profilingMap.clear();
+	}
+
+	public static void startSection(String var0) {
+		if(profilingEnabled) {
+			if(profilingSection.length() > 0) {
+				profilingSection = profilingSection + ".";
+			}
+
+			profilingSection = profilingSection + var0;
+			sectionList.add(profilingSection);
+			timestampList.add(Long.valueOf(System.nanoTime()));
+		}
+	}
+
+	public static void endSection() {
+		if(profilingEnabled) {
+			long var0 = System.nanoTime();
+			long var2 = ((Long)timestampList.remove(timestampList.size() - 1)).longValue();
+			sectionList.remove(sectionList.size() - 1);
+			long var4 = var0 - var2;
+			if(profilingMap.containsKey(profilingSection)) {
+				profilingMap.put(profilingSection, Long.valueOf(((Long)profilingMap.get(profilingSection)).longValue() + var4));
+			} else {
+				profilingMap.put(profilingSection, Long.valueOf(var4));
+			}
+
+			profilingSection = sectionList.size() > 0 ? (String)sectionList.get(sectionList.size() - 1) : "";
+			if(var4 > 100000000L) {
+				System.out.println(profilingSection + " " + var4);
+			}
+
+		}
+	}
+
+	public static List getProfilingData(String var0) {
+		if(!profilingEnabled) {
+			return null;
+		} else {
+			long var2 = profilingMap.containsKey("root") ? ((Long)profilingMap.get("root")).longValue() : 0L;
+			long var4 = profilingMap.containsKey(var0) ? ((Long)profilingMap.get(var0)).longValue() : -1L;
+			ArrayList var6 = new ArrayList();
+			if(var0.length() > 0) {
+				var0 = var0 + ".";
+			}
+
+			long var7 = 0L;
+			Iterator var9 = profilingMap.keySet().iterator();
+
+			while(var9.hasNext()) {
+				String var10 = (String)var9.next();
+				if(var10.length() > var0.length() && var10.startsWith(var0) && var10.indexOf(".", var0.length() + 1) < 0) {
+					var7 += ((Long)profilingMap.get(var10)).longValue();
+				}
+			}
+
+			float var19 = (float)var7;
+			if(var7 < var4) {
+				var7 = var4;
+			}
+
+			if(var2 < var7) {
+				var2 = var7;
+			}
+
+			Iterator var20 = profilingMap.keySet().iterator();
+
+			String var11;
+			while(var20.hasNext()) {
+				var11 = (String)var20.next();
+				if(var11.length() > var0.length() && var11.startsWith(var0) && var11.indexOf(".", var0.length() + 1) < 0) {
+					long var12 = ((Long)profilingMap.get(var11)).longValue();
+					double var14 = (double)var12 * 100.0D / (double)var7;
+					double var16 = (double)var12 * 100.0D / (double)var2;
+					String var18 = var11.substring(var0.length());
+					var6.add(new ProfilerResult(var18, var14, var16));
+				}
+			}
+
+			var20 = profilingMap.keySet().iterator();
+
+			while(var20.hasNext()) {
+				var11 = (String)var20.next();
+				profilingMap.put(var11, Long.valueOf(((Long)profilingMap.get(var11)).longValue() * 999L / 1000L));
+			}
+
+			if((float)var7 > var19) {
+				var6.add(new ProfilerResult("unspecified", (double)((float)var7 - var19) * 100.0D / (double)var7, (double)((float)var7 - var19) * 100.0D / (double)var2));
+			}
+
+			Collections.sort(var6);
+			var6.add(0, new ProfilerResult(var0, 100.0D, (double)var7 * 100.0D / (double)var2));
+			return var6;
+		}
+	}
+
+	public static void endStartSection(String var0) {
+		endSection();
+		startSection(var0);
+	}
+}
--- net/minecraft/src/EntityPickupFX.java
+++ net/minecraft/src/EntityPickupFX.java
@@ -32,7 +32,7 @@
 		int var27 = MathHelper.floor_double(var21);
 		int var28 = MathHelper.floor_double(var23 + (double)(this.yOffset / 2.0F));
 		int var29 = MathHelper.floor_double(var25);
-		float var30 = this.worldObj.getBrightness(var27, var28, var29);
+		float var30 = this.worldObj.getBrightness(var27, var28, var29) * (1 - RenderGlobal.globalBrightness) + RenderGlobal.globalBrightness;
 		var21 -= interpPosX;
 		var23 -= interpPosY;
 		var25 -= interpPosZ;
--- net/minecraft/src/Session.java
+++ net/minecraft/src/Session.java
@@ -2,6 +2,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Random;
 
 public class Session {
 	public static List registeredBlocksList = new ArrayList();
@@ -12,37 +13,9 @@
 	public Session(String var1, String var2) {
 		this.username = var1;
 		this.sessionId = var2;
-	}
 
-	static {
-		registeredBlocksList.add(Block.stone);
-		registeredBlocksList.add(Block.cobblestone);
-		registeredBlocksList.add(Block.brick);
-		registeredBlocksList.add(Block.dirt);
-		registeredBlocksList.add(Block.planks);
-		registeredBlocksList.add(Block.wood);
-		registeredBlocksList.add(Block.leaves);
-		registeredBlocksList.add(Block.torch);
-		registeredBlocksList.add(Block.stairSingle);
-		registeredBlocksList.add(Block.glass);
-		registeredBlocksList.add(Block.cobblestoneMossy);
-		registeredBlocksList.add(Block.sapling);
-		registeredBlocksList.add(Block.plantYellow);
-		registeredBlocksList.add(Block.plantRed);
-		registeredBlocksList.add(Block.mushroomBrown);
-		registeredBlocksList.add(Block.mushroomRed);
-		registeredBlocksList.add(Block.sand);
-		registeredBlocksList.add(Block.gravel);
-		registeredBlocksList.add(Block.sponge);
-		registeredBlocksList.add(Block.cloth);
-		registeredBlocksList.add(Block.oreCoal);
-		registeredBlocksList.add(Block.oreIron);
-		registeredBlocksList.add(Block.oreGold);
-		registeredBlocksList.add(Block.blockSteel);
-		registeredBlocksList.add(Block.blockGold);
-		registeredBlocksList.add(Block.bookshelf);
-		registeredBlocksList.add(Block.tnt);
-		registeredBlocksList.add(Block.obsidian);
-		System.out.println(registeredBlocksList.size());
+		if (this.username.equals("Player")) {
+			this.username = "Player" + new Random().nextInt(1000);
+		}
 	}
 }
--- net/minecraft/src/InventoryPlayer.java
+++ net/minecraft/src/InventoryPlayer.java
@@ -1,12 +1,11 @@
 package net.minecraft.src;
 
 public class InventoryPlayer implements IInventory {
-	public ItemStack[] mainInventory = new ItemStack[37];
-	public ItemStack[] armorInventory = new ItemStack[4];
-	public ItemStack[] craftingInventory = new ItemStack[4];
+	public ItemStack[] mainInventory = new ItemStack[36];
+	public ItemStack[] armorInventory = new ItemStack[11];
 	public int currentItem = 0;
 	private EntityPlayer player;
-	public ItemStack draggedItemStack;
+	private ItemStack draggedItemStack;
 	public boolean inventoryChanged = false;
 
 	public InventoryPlayer(EntityPlayer var1) {
@@ -17,19 +16,29 @@
 		return this.mainInventory[this.currentItem];
 	}
 
-	private int getInventorySlotContainItem(int var1) {
-		for(int var2 = 0; var2 < this.mainInventory.length; ++var2) {
-			if(this.mainInventory[var2] != null && this.mainInventory[var2].itemID == var1) {
-				return var2;
+	private int getInventorySlotContainItem(int var1, int var2) {
+		for(int var3 = 0; var3 < this.mainInventory.length; ++var3) {
+			if (var1 == 0 && this.mainInventory[var3] == null) {
+				return var3;
+			}
+
+			if(this.mainInventory[var3] != null
+					&& this.mainInventory[var3].itemID == var1
+					&& (var2 < 0 || this.mainInventory[var3].itemMetadata == var2)) {
+				return var3;
 			}
 		}
 
 		return -1;
 	}
 
-	private int storeItemStack(int var1) {
+	private int storeItemStack(int var1, int metadata) {
 		for(int var2 = 0; var2 < this.mainInventory.length; ++var2) {
-			if(this.mainInventory[var2] != null && this.mainInventory[var2].itemID == var1 && this.mainInventory[var2].stackSize < this.mainInventory[var2].getMaxStackSize() && this.mainInventory[var2].stackSize < this.getInventoryStackLimit()) {
+			if(this.mainInventory[var2] != null
+				&& this.mainInventory[var2].itemID == var1
+				&& this.mainInventory[var2].itemMetadata == metadata
+				&& this.mainInventory[var2].stackSize < this.mainInventory[var2].getMaxStackSize()
+				&& this.mainInventory[var2].stackSize < this.getStackLimit()) {
 				return var2;
 			}
 		}
@@ -47,10 +56,17 @@
 		return -1;
 	}
 
-	public void setCurrentItem(int var1, boolean var2) {
-		int var3 = this.getInventorySlotContainItem(var1);
-		if(var3 >= 0 && var3 < 9) {
-			this.currentItem = var3;
+	public void setCurrentItem(int var1, int var2, boolean var3) {
+		int var4 = this.getInventorySlotContainItem(var1, var2);
+		if(var4 >= 0 && var4 < 9) {
+			this.currentItem = var4;
+		} else if (var3) {
+			var4 = this.getInventorySlotContainItem(0, 0);
+			if (var4 >= 0 && var4 < 9) {
+				this.currentItem = var4;
+			}
+
+			this.setInventorySlotItem(this.currentItem, new ItemStack(var1, 1, 0, var2));
 		}
 	}
 
@@ -72,8 +88,8 @@
 
 	}
 
-	private int storePartialItemStack(int var1, int var2) {
-		int var3 = this.storeItemStack(var1);
+	private int storePartialItemStack(int var1, int var2, int metadata, NBTTagCompound storage) {
+		int var3 = this.storeItemStack(var1, metadata);
 		if(var3 < 0) {
 			var3 = this.getFirstEmptyStack();
 		}
@@ -82,7 +98,10 @@
 			return var2;
 		} else {
 			if(this.mainInventory[var3] == null) {
-				this.mainInventory[var3] = new ItemStack(var1, 0);
+				this.mainInventory[var3] = new ItemStack(var1, 0, -1, metadata);
+				if (storage != null) {
+					this.mainInventory[var3].withStorage(storage.copy());
+				}
 			}
 
 			int var4 = var2;
@@ -90,8 +109,8 @@
 				var4 = this.mainInventory[var3].getMaxStackSize() - this.mainInventory[var3].stackSize;
 			}
 
-			if(var4 > this.getInventoryStackLimit() - this.mainInventory[var3].stackSize) {
-				var4 = this.getInventoryStackLimit() - this.mainInventory[var3].stackSize;
+			if(var4 > this.getStackLimit() - this.mainInventory[var3].stackSize) {
+				var4 = this.getStackLimit() - this.mainInventory[var3].stackSize;
 			}
 
 			if(var4 == 0) {
@@ -115,7 +134,7 @@
 	}
 
 	public boolean consumeInventoryItem(int var1) {
-		int var2 = this.getInventorySlotContainItem(var1);
+		int var2 = this.getInventorySlotContainItem(var1, -1);
 		if(var2 < 0) {
 			return false;
 		} else {
@@ -129,7 +148,7 @@
 
 	public boolean addItemStackToInventory(ItemStack var1) {
 		if(var1.itemDmg == 0) {
-			var1.stackSize = this.storePartialItemStack(var1.itemID, var1.stackSize);
+			var1.stackSize = this.storePartialItemStack(var1.itemID, var1.stackSize, var1.itemMetadata, var1.storage);
 			if(var1.stackSize == 0) {
 				return true;
 			}
@@ -145,7 +164,7 @@
 		}
 	}
 
-	public ItemStack decrStackSize(int var1, int var2) {
+	public ItemStack decrStack(int var1, int var2) {
 		ItemStack[] var3 = this.mainInventory;
 		if(var1 >= this.mainInventory.length) {
 			var3 = this.armorInventory;
@@ -171,16 +190,11 @@
 		}
 	}
 
-	public void setInventorySlotContents(int var1, ItemStack var2) {
+	public void setInventorySlotItem(int var1, ItemStack var2) {
 		ItemStack[] var3 = this.mainInventory;
 		if(var1 >= var3.length) {
 			var1 -= var3.length;
 			var3 = this.armorInventory;
-		}
-
-		if(var1 >= var3.length) {
-			var1 -= var3.length;
-			var3 = this.craftingInventory;
 		}
 
 		var3[var1] = var2;
@@ -188,10 +202,15 @@
 
 	public float getStrVsBlock(Block var1) {
 		float var2 = 1.0F;
-		if(this.mainInventory[this.currentItem] != null) {
-			var2 *= this.mainInventory[this.currentItem].getStrVsBlock(var1);
+		ItemStack currentItem = this.getCurrentItem();
+		if(currentItem != null) {
+			var2 *= currentItem.getStrVsBlock(var1);
+			if (currentItem.getItem() instanceof ItemAxe
+					&& this.player.isSneaking()
+					&& var1 instanceof BlockLog) {
+				var2 /= 10.0F;
+			}
 		}
-
 		return var2;
 	}
 
@@ -216,70 +235,64 @@
 			}
 		}
 
-		for(var2 = 0; var2 < this.craftingInventory.length; ++var2) {
-			if(this.craftingInventory[var2] != null) {
-				var3 = new NBTTagCompound();
-				var3.setByte("Slot", (byte)(var2 + 80));
-				this.craftingInventory[var2].writeToNBT(var3);
-				var1.setTag(var3);
-			}
-		}
-
 		return var1;
 	}
 
-	public void readFromNBT(NBTTagList var1) {
+	public void readFromNBT(NBTTagList var1, int chunkVersion) {
 		this.mainInventory = new ItemStack[36];
-		this.armorInventory = new ItemStack[4];
-		this.craftingInventory = new ItemStack[4];
+		this.armorInventory = new ItemStack[11];
 
 		for(int var2 = 0; var2 < var1.tagCount(); ++var2) {
 			NBTTagCompound var3 = (NBTTagCompound)var1.tagAt(var2);
 			int var4 = var3.getByte("Slot") & 255;
-			if(var4 >= 0 && var4 < this.mainInventory.length) {
-				this.mainInventory[var4] = new ItemStack(var3);
-			}
-
-			if(var4 >= 80 && var4 < this.craftingInventory.length + 80) {
-				this.craftingInventory[var4 - 80] = new ItemStack(var3);
-			}
-
-			if(var4 >= 100 && var4 < this.armorInventory.length + 100) {
-				this.armorInventory[var4 - 100] = new ItemStack(var3);
+			ItemStack var5 = new ItemStack(var3);
+			if (chunkVersion < Chunk.CHUNK_VERSION_CURRENT) {
+				var5.onChunkUpdate(chunkVersion);
+
+				if (chunkVersion < Chunk.CHUNK_VERSION_0_3) {
+					if (var4 == 104) {
+						var4 = 108;
+					}
+				}
+			}
+			var5.checkMissing();
+
+			if(var5.getItem() != null) {
+				if(var4 >= 0 && var4 < this.mainInventory.length) {
+					this.mainInventory[var4] = var5;
+				}
+
+				if(var4 >= 100 && var4 < this.armorInventory.length + 100) {
+					this.armorInventory[var4 - 100] = var5;
+				}
 			}
 		}
-
-	}
-
-	public int getSizeInventory() {
-		return this.mainInventory.length + 4;
-	}
-
-	public ItemStack getStackInSlot(int var1) {
+	}
+
+	public int getInventorySize() {
+		return this.mainInventory.length + 11;
+	}
+
+	public ItemStack getStack(int var1) {
 		ItemStack[] var2 = this.mainInventory;
 		if(var1 >= var2.length) {
 			var1 -= var2.length;
 			var2 = this.armorInventory;
 		}
 
-		if(var1 >= var2.length) {
-			var1 -= var2.length;
-			var2 = this.craftingInventory;
-		}
-
 		return var2[var1];
 	}
 
-	public String getInvName() {
+	public String getInventoryName() {
 		return "Inventory";
 	}
 
-	public int getInventoryStackLimit() {
+	public int getStackLimit() {
 		return 64;
 	}
 
 	public int getDamageVsEntity(Entity var1) {
-		ItemStack var2 = this.getStackInSlot(this.currentItem);
+		ItemStack var2 = this.getStack(this.currentItem);
 		return var2 != null ? var2.getDamageVsEntity(var1) : 1;
 	}
 
@@ -287,7 +300,7 @@
 		if(var1.material != Material.rock && var1.material != Material.iron && var1.material != Material.craftedSnow && var1.material != Material.snow) {
 			return true;
 		} else {
-			ItemStack var2 = this.getStackInSlot(this.currentItem);
+			ItemStack var2 = this.getStack(this.currentItem);
 			return var2 != null ? var2.canHarvestBlock(var1) : false;
 		}
 	}
@@ -298,32 +311,18 @@
 
 	public int getTotalArmorValue() {
 		int var1 = 0;
-		int var2 = 0;
-		int var3 = 0;
-
-		for(int var4 = 0; var4 < this.armorInventory.length; ++var4) {
-			if(this.armorInventory[var4] != null && this.armorInventory[var4].getItem() instanceof ItemArmor) {
-				int var5 = this.armorInventory[var4].getMaxDamage();
-				int var6 = this.armorInventory[var4].itemDmg;
-				int var7 = var5 - var6;
-				var2 += var7;
-				var3 += var5;
-				int var8 = ((ItemArmor)this.armorInventory[var4].getItem()).damageReduceAmount;
-				var1 += var8;
+		for (int var4 = 0; var4 < 4; ++var4) {
+			if (this.armorInventory[var4] != null && this.armorInventory[var4].getItem() instanceof ItemArmor) {
+				var1 += ((ItemArmor) this.armorInventory[var4].getItem()).defense;
 			}
 		}
-
-		if(var3 == 0) {
-			return 0;
-		} else {
-			return (var1 - 1) * var2 / var3 + 1;
-		}
+		return var1;
 	}
 
 	public void damageArmor(int var1) {
-		for(int var2 = 0; var2 < this.armorInventory.length; ++var2) {
+		for(int var2 = 0; var2 < 4; ++var2) {
 			if(this.armorInventory[var2] != null && this.armorInventory[var2].getItem() instanceof ItemArmor) {
-				this.armorInventory[var2].damageItem(var1);
+				this.armorInventory[var2].damageItem(1);
 				if(this.armorInventory[var2].stackSize == 0) {
 					this.armorInventory[var2].onItemDestroyedByUse(this.player);
 					this.armorInventory[var2] = null;
@@ -351,53 +350,103 @@
 
 	}
 
-	public void onInventoryChanged() {
+	public void onInventoryChange() {
 		this.inventoryChanged = true;
 	}
 
-	public boolean getInventoryEqual(InventoryPlayer var1) {
-		int var2;
-		for(var2 = 0; var2 < this.mainInventory.length; ++var2) {
-			if(!this.getItemStacksEqual(var1.mainInventory[var2], this.mainInventory[var2])) {
-				return false;
-			}
-		}
-
-		for(var2 = 0; var2 < this.armorInventory.length; ++var2) {
-			if(!this.getItemStacksEqual(var1.armorInventory[var2], this.armorInventory[var2])) {
-				return false;
-			}
-		}
-
-		for(var2 = 0; var2 < this.craftingInventory.length; ++var2) {
-			if(!this.getItemStacksEqual(var1.craftingInventory[var2], this.craftingInventory[var2])) {
-				return false;
-			}
-		}
-
-		return true;
-	}
-
-	private boolean getItemStacksEqual(ItemStack var1, ItemStack var2) {
-		return var1 == null && var2 == null ? true : (var1 != null && var2 != null ? var1.itemID == var2.itemID && var1.stackSize == var2.stackSize && var1.itemDmg == var2.itemDmg : false);
-	}
-
-	public InventoryPlayer copyInventory() {
-		InventoryPlayer var1 = new InventoryPlayer((EntityPlayer)null);
-
-		int var2;
-		for(var2 = 0; var2 < this.mainInventory.length; ++var2) {
-			var1.mainInventory[var2] = this.mainInventory[var2] != null ? this.mainInventory[var2].copy() : null;
-		}
-
-		for(var2 = 0; var2 < this.armorInventory.length; ++var2) {
-			var1.armorInventory[var2] = this.armorInventory[var2] != null ? this.armorInventory[var2].copy() : null;
-		}
-
-		for(var2 = 0; var2 < this.craftingInventory.length; ++var2) {
-			var1.craftingInventory[var2] = this.craftingInventory[var2] != null ? this.craftingInventory[var2].copy() : null;
-		}
-
-		return var1;
+	public void setDraggedItemStack(ItemStack var1) {
+		this.draggedItemStack = var1;
+	}
+
+	public ItemStack getDraggedItemStack() {
+		return this.draggedItemStack;
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return this.player.isDead ? false : var1.getDistanceSqToEntity(this.player) <= 64.0D;
+	}
+
+	public void updateAchievementProgress(GameAchievements achievements) {
+		for (ItemStack stack : this.mainInventory)
+			updateItemAchievementProgress(achievements, stack, false);
+		for (ItemStack stack : this.armorInventory)
+			updateItemAchievementProgress(achievements, stack, true);
+		updateItemAchievementProgress(achievements, this.draggedItemStack, false);
+
+		// FURSUITER
+
+		boolean fluffyEars = false;
+		boolean fluffySnout = false;
+		boolean fluffyTail = false;
+		boolean fluffyPaws = false;
+		for (ItemStack item : this.armorInventory) {
+			if (item == null) continue;
+
+			if (item.itemID == Item.fluffyEars.shiftedIndex) fluffyEars = true;
+			if (item.itemID == Item.fluffySnout.shiftedIndex) fluffySnout = true;
+			if (item.itemID == Item.fluffyTail.shiftedIndex) fluffyTail = true;
+			if (item.itemID == Item.fluffyPaws.shiftedIndex) fluffyPaws = true;
+			if (item.itemID == Item.longFluffySnout.shiftedIndex) fluffySnout = true;
+		}
+
+		int fluffyness = 0;
+		if (fluffyEars) fluffyness++;
+		if (fluffySnout) fluffyness++;
+		if (fluffyTail) fluffyness++;
+		if (fluffyPaws) fluffyness++;
+
+		if (Achievement.FURSUITER.progress < fluffyness) {
+			achievements.updateProgress(Achievement.FURSUITER, fluffyness);
+		}
+
+		// TRINKET ME THIS
+
+		for (ItemStack item : this.mainInventory) {
+			if (item != null && item.getTrinket() != null) {
+				achievements.updateProgress(Achievement.TRINKET_ME_THIS, 1);
+				break;
+			}
+		}
+	}
+
+	public void updateItemAchievementProgress(GameAchievements achievements, ItemStack itemStack, boolean armor) {
+		if (itemStack == null) return;
+		Item item = itemStack.getItem();
+		if (item == null) return;
+
+		if (item.shiftedIndex == Block.workbench.blockID)
+			achievements.updateProgress(Achievement.CRAFTING_TIME, 1);
+
+		if (item.shiftedIndex == Item.starChunk.shiftedIndex)
+			achievements.updateProgress(Achievement.WISH_GRANTED, 1);
+
+		if (item.shiftedIndex == Block.refabricator.blockID)
+			achievements.updateProgress(Achievement.REFABRICATING_TIME, 1);
+
+		if (item.shiftedIndex == Block.oreDiamond.blockID
+				|| item.shiftedIndex == Block.blockDiamond.blockID
+				|| item.shiftedIndex == Item.diamond.shiftedIndex)
+			achievements.updateProgress(Achievement.OOH_SHINY, 1);
+
+		if (item.shiftedIndex == Block.oreRuby.blockID
+				|| item.shiftedIndex == Block.blockRuby.blockID
+				|| item.shiftedIndex == Item.ruby.shiftedIndex
+				|| item.shiftedIndex == Block.oreSapphire.blockID
+				|| item.shiftedIndex == Block.blockSapphire.blockID
+				|| item.shiftedIndex == Item.sapphire.shiftedIndex)
+			achievements.updateProgress(Achievement.OOH_EXTRA_SHINY, 1);
+
+		if (item.shiftedIndex == Block.umbrashardCrystal.blockID
+				|| item.shiftedIndex == Item.umbrashard.shiftedIndex)
+			achievements.updateProgress(Achievement.OOH_TOO_SHINY, 1);
+
+		if (item instanceof ItemVanity && armor)
+			achievements.updateProgress(Achievement.DRESS_TO_IMPRESS, 1);
+
+		if (item instanceof ItemStaff)
+			achievements.updateProgress(Achievement.ALAKAZAM, 1);
+
+		if (item instanceof ItemCharm && armor)
+			achievements.updateProgress(Achievement.CHARMING_UPGRADE, 1);
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet39AttachEntity.java
@@ -1,0 +1,36 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet39AttachEntity extends Packet {
+	public int passenger;
+	public int vehicle;
+
+	public Packet39AttachEntity() {
+	}
+
+	public Packet39AttachEntity(Entity var1, Entity var2) {
+		this.passenger = var1.entityID;
+		this.vehicle = var2 != null ? var2.entityID : -1;
+	}
+
+	public int getPacketSize() {
+		return 8;
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.passenger = var1.readInt();
+		this.vehicle = var1.readInt();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeInt(this.passenger);
+		var1.writeInt(this.vehicle);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleAttachEntity(this);
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemStaff.java
@@ -1,0 +1,35 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+public class ItemStaff extends ItemMagic {
+	public final EntitySnowballType type;
+
+	public ItemStaff(int var1, float var2, int maxDmg, EntitySnowballType type) {
+		super(var1, var2);
+		this.maxStackSize = 1;
+		this.maxDamage = maxDmg;
+		this.type = type;
+	}
+
+	public ItemStack onMagicItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
+		var2.playSoundAtEntity(var3, "random.wand", 1.0F, rand.nextFloat() * 0.2F + 0.9F);
+		if (var2.canDoClientAction()) {
+			var2.spawnEntityInWorld(new EntitySnowball(var2, var3, type));
+			var1.damageItem(1);
+		}
+
+		return var1;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				this.type.damage + " attack damage", INFO_COL,
+				"Uses " + formatFloat(this.useMana) + " points of mana", INFO_COL
+		};
+	}
+
+	public boolean isFull3D() {
+		return true;
+	}
+}
--- net/minecraft/src/Packet52MultiBlockChange.java
+++ net/minecraft/src/Packet52MultiBlockChange.java
@@ -8,7 +8,7 @@
 	public int xPosition;
 	public int zPosition;
 	public short[] coordinateArray;
-	public byte[] typeArray;
+	public short[] typeArray;
 	public byte[] metadataArray;
 	public int size;
 
@@ -21,14 +21,17 @@
 		this.zPosition = var1.readInt();
 		this.size = var1.readShort() & '\uffff';
 		this.coordinateArray = new short[this.size];
-		this.typeArray = new byte[this.size];
+		this.typeArray = new short[this.size];
 		this.metadataArray = new byte[this.size];
 
 		for(int var2 = 0; var2 < this.size; ++var2) {
 			this.coordinateArray[var2] = var1.readShort();
 		}
 
-		var1.readFully(this.typeArray);
+		for(int var2 = 0; var2 < this.size; ++var2) {
+			this.typeArray[var2] = var1.readShort();
+		}
+
 		var1.readFully(this.metadataArray);
 	}
 
@@ -41,7 +44,10 @@
 			var1.writeShort(this.coordinateArray[var2]);
 		}
 
-		var1.write(this.typeArray);
+		for(int var2 = 0; var2 < this.size; ++var2) {
+			var1.writeShort(this.typeArray[var2]);
+		}
+
 		var1.write(this.metadataArray);
 	}
 
@@ -59,7 +65,7 @@
 		this.zPosition = var2;
 		this.size = var4;
 		this.coordinateArray = new short[var4];
-		this.typeArray = new byte[var4];
+		this.typeArray = new short[var4];
 		this.metadataArray = new byte[var4];
 		Chunk var6 = var5.getChunkFromChunkCoords(var1, var2);
 
@@ -68,7 +74,7 @@
 			int var9 = var3[var7] >> 8 & 15;
 			int var10 = var3[var7] & 255;
 			this.coordinateArray[var7] = var3[var7];
-			this.typeArray[var7] = (byte)var6.getBlockID(var8, var10, var9);
+			this.typeArray[var7] = (short)var6.getBlockID(var8, var10, var9);
 			this.metadataArray[var7] = (byte)var6.getBlockMetadata(var8, var10, var9);
 		}
 
--- /dev/null
+++ net/minecraft/src/BlockSmoothStone.java
@@ -1,0 +1,21 @@
+package net.minecraft.src;
+
+import java.util.Random;
+
+public class BlockSmoothStone extends BlockStone {
+	public BlockSmoothStone(int var1, int var2) {
+		super(var1, var2, 4);
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
+	}
+
+	public int metadataDroppedSilk(int var1, int var2, Random var3) {
+		return var1;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return 1;
+	}
+}
--- /dev/null
+++ net/minecraft/src/Packet42RemoveEffect.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet42RemoveEffect extends Packet {
+	public int type;
+
+	public Packet42RemoveEffect() {
+	}
+
+	public Packet42RemoveEffect(int type) {
+		this.type = type;
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.type = var1.read();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.write(this.type);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleRemoveEffect(this);
+	}
+
+	public int getPacketSize() {
+		return 1;
+	}
+}
--- net/minecraft/src/ThreadServerApplication.java
+++ net/minecraft/src/ThreadServerApplication.java
@@ -3,7 +3,7 @@
 import net.minecraft.server.MinecraftServer;
 
 public final class ThreadServerApplication extends Thread {
-	final MinecraftServer mcServer;
+	public final MinecraftServer mcServer;
 
 	public ThreadServerApplication(String var1, MinecraftServer var2) {
 		super(var1);
--- /dev/null
+++ net/minecraft/src/Hook2.java
@@ -1,0 +1,9 @@
+package net.minecraft.src;
+
+public interface Hook2<T1, T2> {
+	void call(BaseMod mod, T1 t1, T2 t2);
+
+	default Hook bind(T1 t1, T2 t2) {
+		return (BaseMod mod) -> call(mod, t1, t2);
+	}
+}
--- /dev/null
+++ net/minecraft/src/IBitField.java
@@ -1,0 +1,8 @@
+package net.minecraft.src;
+
+public interface IBitField {
+	int BITS = 8;
+
+	String getName();
+	String getString(int number);
+}
--- net/minecraft/src/EntityPlayer.java
+++ net/minecraft/src/EntityPlayer.java
@@ -1,9 +1,14 @@
 package net.minecraft.src;
 
+import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
 
-public class EntityPlayer extends EntityLiving {
+public abstract class EntityPlayer extends EntityLiving {
 	public InventoryPlayer inventory = new InventoryPlayer(this);
+	public Container inventorySlots;
+	public Container craftingInventory;
 	public byte unusedMiningCooldown = 0;
 	public int score = 0;
 	public float prevCameraYaw;
@@ -12,9 +17,33 @@
 	public int swingProgressInt = 0;
 	public String username;
 	private int damageRemainder = 0;
+	public float energy = 20.0F;
+	public float energyBoost = 0.0F;
+	public boolean energyRegen;
+	public boolean tired = false;
+	public float mana = 20.0F;
+	public boolean showMana = false;
+	public boolean creative;
+	private int slowHealTick = 0;
+	public boolean slowHealing = false;
+	public float bounce = 0.0F;
+	private float bounceHeight = 0.0F;
+	protected boolean justJumped = false;
+	protected boolean wasSneaking = false;
+	protected int flyToggleTimer;
+	public boolean blueStaggo;
+	public List<Effect> effects = new ArrayList<>();
+	public double aPosX;
+	public double aPosY;
+	public double aPosZ;
+	public double bPosX;
+	public double bPosY;
+	public double bPosZ;
 
 	public EntityPlayer(World var1) {
 		super(var1);
+		this.inventorySlots = new ContainerPlayer(this.inventory, var1.canDoClientAction());
+		this.craftingInventory = this.inventorySlots;
 		this.yOffset = 1.62F;
 		this.setLocationAndAngles((double)var1.spawnX + 0.5D, (double)(var1.spawnY + 1), (double)var1.spawnZ + 0.5D, 0.0F, 0.0F);
 		this.health = 20;
@@ -22,6 +51,62 @@
 		this.unusedRotation = 180.0F;
 		this.fireResistance = 20;
 		this.texture = "/char.png";
+		this.creative = var1.creative;
+	}
+
+	public void onUpdate() {
+		super.onUpdate();
+		if(this.worldObj.canDoClientAction() && this.craftingInventory != null && !this.craftingInventory.stayOpen(this)) {
+			this.closeCurrentInventory();
+			this.craftingInventory = this.inventorySlots;
+		}
+
+		this.aPosX = this.bPosX;
+		this.aPosY = this.bPosY;
+		this.aPosZ = this.bPosZ;
+		double var1 = this.posX - this.bPosX;
+		double var3 = this.posY - this.bPosY;
+		double var5 = this.posZ - this.bPosZ;
+		double var7 = 10.0D;
+		if(var1 > var7) {
+			this.aPosX = this.bPosX = this.posX;
+		}
+
+		if(var5 > var7) {
+			this.aPosZ = this.bPosZ = this.posZ;
+		}
+
+		if(var3 > var7) {
+			this.aPosY = this.bPosY = this.posY;
+		}
+
+		if(var1 < -var7) {
+			this.aPosX = this.bPosX = this.posX;
+		}
+
+		if(var5 < -var7) {
+			this.aPosZ = this.bPosZ = this.posZ;
+		}
+
+		if(var3 < -var7) {
+			this.aPosY = this.bPosY = this.posY;
+		}
+
+		this.bPosX += var1 * 0.25D;
+		this.bPosZ += var5 * 0.25D;
+		this.bPosY += var3 * 0.25D;
+	}
+
+	public boolean justJumped() {
+		return this.justJumped;
+	}
+
+	public void midairJump() {
+		this.motionY = this.isSneaking() ? 0.25D : 0.6D;
+		this.motionX *= 1.5D;
+		this.motionZ *= 1.5D;
+		this.fallDistance = -1.0F;
+		this.playSound("random.wings", 1.0F, 1.0F);
 	}
 
 	public void updateRidden() {
@@ -53,13 +138,122 @@
 	}
 
 	public void onLivingUpdate() {
-		if(this.worldObj.difficultySetting == 0 && this.health < 20 && this.ticksExisted % 20 * 4 == 0) {
+		this.preUpdate();
+
+		ItemStack[] armorInventory = this.inventory.armorInventory;
+		for (int i = 0; i < armorInventory.length; i++) {
+			ItemStack armor = armorInventory[i];
+			if (armor == null) continue;
+			Item item = Item.itemsList[armor.itemID];
+			if (item instanceof ItemCharm) {
+				((ItemCharm) item).updateCharm(this, armor);
+				if (armor.itemID == Item.slimeShoes.shiftedIndex && this.bounceHeight > 0.0F) {
+					this.worldObj.playSoundAtEntity(this, "mob.slime", this.getSoundVolume(), ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F) * 0.8F);
+					this.motionX *= 2.0;
+					this.motionZ *= 2.0;
+					this.motionY = Math.sqrt(2 * 0.08 * this.bounceHeight); // Thanks https://qr.ae/prhm4v
+					this.bounceHeight = 0.0F;
+
+					armor.damageItem(1);
+				}
+
+				if (armor.stackSize == 0) {
+					armor.onItemDestroyedByUse(this);
+					this.inventory.armorInventory[i] = null;
+				}
+			}
+		}
+
+		for (Effect effect : this.effects) {
+			effect.doEffect(this);
+		}
+
+		this.effects = this.effects.stream().filter(e -> e.duration >= 0).collect(Collectors.toList());
+
+		if(this.flyToggleTimer > 0) {
+			--this.flyToggleTimer;
+		}
+
+		if((this.worldObj.difficultySetting == 0 && this.health < 20 && this.ticksExisted % 20 * 4 == 0)
+			|| this.ticksExisted % 5 == 0 && this.healthRegen > 0) {
 			this.heal(1);
-		}
-
+			this.healthRegen--;
+		}
+
+		if (this.slowHealing && this.health < 20) {
+			if (--this.slowHealTick <= 0) {
+				this.heal(1);
+				this.slowHealTick = 1200;
+			}
+		} else {
+			this.slowHealTick = 1200;
+		}
+
+		ItemStack currentItem = this.inventory.getCurrentItem();
+		this.showMana = (currentItem != null && Item.itemsList[currentItem.itemID].isMagic()) || this.mana < 20;
+
+		if (this.worldObj.canDoClientAction() && this.creative) {
+			if (currentItem != null) {
+				currentItem.itemDmg = 0;
+			}
+			for (int i = 0; i < armorInventory.length; i++) {
+				currentItem = this.inventory.armorItemInSlot(i);
+				if (currentItem != null) {
+					currentItem.itemDmg = 0;
+				}
+			}
+		}
+
+		this.mana += (this.mana / 100.0F) + 0.05F;
+		this.mana = MathHelper.clamp(this.mana, 0.0F, 20.0F);
+
+		ModLoader.callHook(BaseMod::onPlayerPreUpdate, this);
 		this.inventory.decrementAnimations();
 		this.prevCameraYaw = this.cameraYaw;
 		super.onLivingUpdate();
+		ModLoader.callHook(BaseMod::onPlayerUpdate, this);
+
+		if (this.creative && this.posY > -64) {
+			this.health = 20;
+			this.energy = 20.0F;
+			this.mana = 20.0F;
+			this.hurtTime = 0;
+			if (this.fire > 0) {
+				this.fire = 1;
+			}
+		}
+
+		if (this.noClip || this.flying) {
+			this.flying |= this.noClip;
+			this.onGround = this.noClip;
+			if (this.noClip) {
+				if (this.moveForward != 0 || this.moveStrafing != 0) {
+					this.motionX *= 1.8F;
+					this.motionZ *= 1.8F;
+				} else {
+					this.motionX = 0;
+					this.motionZ = 0;
+				}
+			}
+
+			if (this.isSneaking() && this.isJumping) {
+				this.motionY = 0.0D;
+			} else if (this.isJumping) {
+				this.motionY = this.noClip ? 1.0D : 0.4D;
+			} else if (this.isSneaking()) {
+				this.motionY = this.noClip ? -1.0D : -0.4D;
+			} else {
+				this.motionY *= 0.5D;
+//				this.motionY += 0.08D;
+			}
+//			this.motionY = (this.isSneaking() ? -1 : this.isJumping ? 1 : 0) * (this.noClip ? 1.0D : 0.4D);
+
+			if (this.noClip) {
+				this.health = 20;
+				this.energy = 20;
+			}
+		}
+
 		float var1 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
 		float var2 = (float)Math.atan(-this.motionY * (double)0.2F) * 15.0F;
 		if(var1 > 0.1F) {
@@ -85,6 +279,47 @@
 			}
 		}
 
+		if (this.isRunning()) {
+			this.energy -= 0.1F;
+		} else {
+			this.energy += 0.1F;
+		}
+		this.energy += this.energyBoost;
+		this.energy = MathHelper.clamp(this.energy, 0.0F, 20.0F);
+		this.tired = this.energyRegen || this.energy < 5.0F;
+		this.energyRegen =
+				this.energyRegen ? this.energy < 10.0F
+				: !this.isRunning() ? this.tired
+				: this.energy <= 0.0F;
+
+		ModLoader.callHook(BaseMod::onPlayerPostUpdate, this);
+
+		this.wasSneaking = this.isSneaking();
+	}
+
+	public void preUpdate() {
+		this.slowHealing = false;
+		this.bounce = 0.0F;
+		this.runSpeed = (1.4F + this.energy / 100.0F) * (1.0F + energyBoost);
+		this.energyBoost = 0.0F;
+	}
+
+	protected void jump() {
+		super.jump();
+		if (this.isRunning() && (this.energy -= 1.0F) < 0.0F) {
+			this.energy = 0.0F;
+		}
+
+		this.justJumped = false;
+	}
+
+	protected void fall(float var1) {
+		if (this.bounce > 0.0F && var1 > 1.5F) {
+			this.bounceHeight = var1 * this.bounce;
+			super.fall(var1 * (1.0F - this.bounce));
+		} else {
+			super.fall(var1);
+		}
 	}
 
 	private void collideWithPlayer(Entity var1) {
@@ -96,12 +331,17 @@
 	}
 
 	public void onDeath(Entity var1) {
+		ModLoader.callHook(BaseMod::onEntityDeath, this.getClass(), this, var1);
+
 		this.setSize(0.2F, 0.2F);
 		this.setPosition(this.posX, this.posY, this.posZ);
 		this.motionY = (double)0.1F;
 		if(this.username.equals("Notch")) {
 			this.dropPlayerItemWithRandomChoice(new ItemStack(Item.appleRed, 1), true);
 		}
+		if(this.username.equals("BlueStag256")) {
+			this.dropPlayerItemWithRandomChoice(new ItemStack(Item.cookie, 1), true);
+		}
 
 		this.inventory.dropAllItems();
 		if(var1 != null) {
@@ -118,6 +358,10 @@
 		this.score += var2;
 	}
 
+	public void dropOneItem() {
+		this.dropPlayerItemWithRandomChoice(this.inventory.decrStack(this.inventory.currentItem, 1), false);
+	}
+
 	public void dropPlayerItem(ItemStack var1) {
 		this.dropPlayerItemWithRandomChoice(var1, false);
 	}
@@ -169,24 +413,56 @@
 	}
 
 	public boolean canHarvestBlock(Block var1) {
-		return this.inventory.canHarvestBlock(var1);
+		return this.inventory.canHarvestBlock(var1) && !this.creative;
 	}
 
 	public void readEntityFromNBT(NBTTagCompound var1) {
 		super.readEntityFromNBT(var1);
 		NBTTagList var2 = var1.getTagList("Inventory");
-		this.inventory.readFromNBT(var2);
+		this.inventory.readFromNBT(var2, var1.getInteger("ChunkVersion"));
+		this.energy = var1.hasKey("Energy") ? var1.getFloat("Energy") : 20.0F;
+		this.energyBoost = var1.getFloat("EnergyBoost");
+		this.energyRegen = var1.getBoolean("RegeneratingEnergy");
+		this.noClip = var1.getBoolean("NoClip");
+		this.mana = var1.hasKey("Mana") ? var1.getFloat("Mana") : 20.0F;
+		this.flying = var1.getBoolean("Flying");
+
+		NBTTagList var3 = var1.getTagList("Effects");
+		this.effects.clear();
+		for (int i = 0; i < var3.tagCount(); i++) {
+			Effect effect = new Effect();
+			effect.readFromNBT((NBTTagCompound) var3.tagAt(i));
+			this.effects.add(effect);
+		}
 	}
 
 	public void writeEntityToNBT(NBTTagCompound var1) {
 		super.writeEntityToNBT(var1);
 		var1.setTag("Inventory", this.inventory.writeToNBT(new NBTTagList()));
+		var1.setFloat("Energy", this.energy);
+		var1.setFloat("EnergyBoost", this.energyBoost);
+		var1.setBoolean("RegeneratingEnergy", this.energyRegen);
+		var1.setBoolean("NoClip", this.noClip);
+		var1.setFloat("Mana", this.mana);
+		var1.setBoolean("Flying", this.flying);
+		var1.setInteger("ChunkVersion", Chunk.CHUNK_VERSION_CURRENT);
+
+		NBTTagList effectList = new NBTTagList();
+		for (Effect effect : this.effects) {
+			NBTTagCompound effectTag = new NBTTagCompound();
+			effect.writeToNBT(effectTag);
+			effectList.setTag(effectTag);
+		}
+		var1.setTag("Effects", effectList);
 	}
 
 	public void displayGUIChest(IInventory var1) {
 	}
 
-	public void displayWorkbenchGUI() {
+	public void displayGUICrate(IInventory var1) {
+	}
+
+	public void displayWorkbenchGUI(int var1, int var2, int var3) {
 	}
 
 	public void onItemPickup(Entity var1, int var2) {
@@ -198,9 +474,7 @@
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
 		this.entityAge = 0;
-		if(this.health <= 0) {
-			return false;
-		} else if((float)this.heartsLife > (float)this.heartsHalvesLife / 2.0F) {
+		if((this.creative && this.posY > -64) || this.health <= 0 || (float)this.heartsLife > (float)this.heartsHalvesLife / 2.0F) {
 			return false;
 		} else {
 			if(var1 instanceof EntityMob || var1 instanceof EntityArrow) {
@@ -217,12 +491,7 @@
 				}
 			}
 
-			int var3 = 25 - this.inventory.getTotalArmorValue();
-			int var4 = var2 * var3 + this.damageRemainder;
-			this.inventory.damageArmor(var2);
-			var2 = var4 / 25;
-			this.damageRemainder = var4 % 25;
-			return var2 == 0 ? false : super.attackEntityFrom(var1, var2);
+			return var2 != 0 && super.attackEntityFrom(var1, var2);
 		}
 	}
 
@@ -232,7 +501,27 @@
 	public void displayGUIEditSign(TileEntitySign var1) {
 	}
 
+	public void displayGUIRefabricator(TileEntityRefabricator var1) {
+	}
+
+	public void displayGUIRecipeGuide(ItemStack var1) {
+	}
+
+	public void displayGUICreative() {
+	}
+
 	public void interactWithEntity(Entity var1) {
+		if(!var1.interact(this)) {
+			ItemStack var2 = this.getCurrentEquippedItem();
+			if(var2 != null && var1 instanceof EntityLiving) {
+				var2.useItemOnEntity((EntityLiving)var1);
+				if(var2.stackSize <= 0) {
+					var2.onItemDestroyedByUse(this);
+					this.destroyCurrentEquippedItem();
+				}
+			}
+
+		}
 	}
 
 	public ItemStack getCurrentEquippedItem() {
@@ -240,7 +529,7 @@
 	}
 
 	public void destroyCurrentEquippedItem() {
-		this.inventory.setInventorySlotContents(this.inventory.currentItem, (ItemStack)null);
+		this.inventory.setInventorySlotItem(this.inventory.currentItem, (ItemStack)null);
 	}
 
 	public double getYOffset() {
@@ -250,5 +539,150 @@
 	public void swingItem() {
 		this.swingProgressInt = -1;
 		this.isSwinging = true;
+	}
+
+	public boolean useMana(float var1) {
+		if (this.mana >= var1) {
+			this.mana -= var1;
+			return true;
+		}
+		return false;
+	}
+
+	public void attackEntity(Entity var1) {
+		int var2 = this.inventory.getDamageVsEntity(var1);
+		if(var2 > 0) {
+			ItemTrinket trinket = null;
+			if (this.inventory.getCurrentItem() != null) {
+				trinket = this.inventory.getCurrentItem().getTrinket();
+			}
+
+			var1.attackEntityFrom(this, var2);
+			if (var1 instanceof EntityLiving && var1.heartsLife == ((EntityLiving)var1).heartsHalvesLife && trinket != null) {
+				int heartsLife = trinket.modifyHeartsLife(var1.heartsLife);
+				((EntityLiving)var1).hurtTime = heartsLife / 2;
+				((EntityLiving)var1).maxHurtTime = heartsLife / 2;
+				var1.heartsLife = heartsLife;
+			}
+
+			ItemStack var3 = this.getCurrentEquippedItem();
+			if(var3 != null && var1 instanceof EntityLiving) {
+				var3.hitEntity((EntityLiving)var1);
+				if(var3.stackSize <= 0) {
+					var3.onItemDestroyedByUse(this);
+					this.destroyCurrentEquippedItem();
+				}
+			}
+		}
+	}
+
+	protected void damageEntity(int var1) {
+		float var1f = var1;
+		for (int i = 0; i < 4; i++) {
+			ItemStack armor = this.inventory.armorInventory[i];
+			if (armor != null && armor.getTrinket() != null) {
+				var1f = armor.getTrinket().modifyDamageTaken(var1f);
+			}
+		}
+
+		if (var1 > 0) {
+			var1 = (int)Math.max(var1f, 1);
+		}
+
+		int var2 = 25 - this.inventory.getTotalArmorValue();
+		int var3 = var1 * var2 + this.damageRemainder;
+		this.inventory.damageArmor(var1);
+		var1 = var3 / 25;
+		this.damageRemainder = var3 % 25;
+
+		if (!this.hasEffect(EffectType.shieldDelay) && this.isSneaking()) {
+			for (int i = 0; i < 3; i++) {
+				ItemStack charmStack = this.inventory.armorItemInSlot(i + 8);
+				if (charmStack == null) continue;
+
+				Item item = charmStack.getItem();
+				if (item instanceof ItemShield) {
+					ItemShield shield = (ItemShield)item;
+					var1 = (int)(var1 * (1.0F - shield.blockAmount));
+
+					this.addEffect(EffectType.shieldDelay, shield.blockDelay);
+					this.playSound("random.richochet", 1.0F, rand.nextFloat() * 0.2F + 0.9F);
+				}
+			}
+		}
+
+		super.damageEntity(var1);
+	}
+
+	public void respawnPlayer() {
+	}
+
+	public void closeCurrentInventory() {
+		this.craftingInventory = this.inventorySlots;
+	}
+
+	public void setEntityDead() {
+		super.setEntityDead();
+		this.inventorySlots.onCraftGuiClosed(this);
+		if (this.craftingInventory != null) {
+			this.craftingInventory.onCraftGuiClosed(this);
+		}
+	}
+
+	public void handleHealthUpdate(byte var1) {
+		if(var1 == 2) {
+			this.limbYaw = 1.5F;
+			this.heartsLife = this.heartsHalvesLife;
+			this.hurtTime = this.maxHurtTime = this.heartsHalvesLife / 2;
+			this.attackedAtYaw = 0.0F;
+			this.attackEntityFrom(null, 0);
+		} else if(var1 == 3) {
+			this.health = 0;
+			this.onDeath(null);
+		}
+	}
+
+	public Effect addEffect(EffectType type, int duration) {
+		return this.addEffect(type, duration, 0);
+	}
+
+	public Effect addEffect(EffectType type, int duration, int metadata) {
+		for (Effect effect : this.effects) {
+			if (effect.type == type && effect.duration < duration) {
+				effect.duration = effect.maxDuration = duration;
+				effect.metadata = metadata;
+				return effect;
+			}
+		}
+
+		Effect effect = new Effect(type, duration, duration, metadata);
+		this.effects.add(effect);
+		return effect;
+	}
+
+	public void removeEffect(EffectType type) {
+		this.effects = this.effects.stream().filter(e -> e.type != type).collect(Collectors.toList());
+	}
+
+	public boolean hasEffect(EffectType effect) {
+		return this.effects.stream().anyMatch(e -> e.type == effect);
+	}
+
+	public int getEffectMetadata(EffectType effect) {
+		return this.effects.stream().filter(ee -> ee.type == effect).findAny().map(value -> value.metadata).orElse(0);
+	}
+
+	public boolean justSneaked() {
+		return this.isSneaking() && !this.wasSneaking;
+	}
+
+	public void onMainModelOverride(String texture) {
+		this.skinUrl = null;
+		this.texture = texture;
+	}
+
+	public void onMainModelUnoverride(String skinUrl, String texture) {
+		this.skinUrl = skinUrl;
+		this.texture = texture;
 	}
 }
--- net/minecraft/src/BlockPressurePlate.java
+++ net/minecraft/src/BlockPressurePlate.java
@@ -6,12 +6,12 @@
 public class BlockPressurePlate extends Block {
 	private EnumMobType triggerMobType;
 
-	protected BlockPressurePlate(int var1, int var2, EnumMobType var3) {
+	public BlockPressurePlate(int var1, int var2, EnumMobType var3) {
 		super(var1, var2, Material.rock);
 		this.triggerMobType = var3;
 		this.setTickOnLoad(true);
 		float var4 = 1.0F / 16.0F;
-		this.setBlockBounds(var4, 0.0F, var4, 1.0F - var4, 0.03125F, 1.0F - var4);
+		this.setBlockBounds(var4, 0.0F, var4, 1.0F - var4, 1.0F / 32.0F, 1.0F - var4);
 	}
 
 	public int tickRate() {
@@ -119,7 +119,7 @@
 		boolean var5 = var1.getBlockMetadata(var2, var3, var4) == 1;
 		float var6 = 1.0F / 16.0F;
 		if(var5) {
-			this.setBlockBounds(var6, 0.0F, var6, 1.0F - var6, 0.03125F, 1.0F - var6);
+			this.setBlockBounds(var6, 0.0F, var6, 1.0F - var6, 1.0F / 32.0F, 1.0F - var6);
 		} else {
 			this.setBlockBounds(var6, 0.0F, var6, 1.0F - var6, 1.0F / 16.0F, 1.0F - var6);
 		}
--- /dev/null
+++ net/minecraft/src/ItemNimbleBoots.java
@@ -1,0 +1,14 @@
+package net.minecraft.src;
+
+public class ItemNimbleBoots extends ItemCharm {
+	public ItemNimbleBoots(int id) {
+		super(id, 2048, "nimbleboots");
+	}
+
+	public void updateCharm(EntityPlayer player, ItemStack stack) {
+		player.runSpeed *= 1.2F;
+		if (player.isRunning() && player.ticksExisted % 10   == 0) {
+			stack.damageItem(1);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/Effect.java
@@ -1,0 +1,39 @@
+package net.minecraft.src;
+
+public class Effect {
+	public EffectType type;
+	public int maxDuration;
+	public int duration;
+	public int metadata;
+
+	public Effect() {
+	}
+
+	public Effect(EffectType type, int duration, int maxDuration, int metadata) {
+		this.type = type;
+		this.duration = duration;
+		this.maxDuration = maxDuration;
+		this.metadata = metadata;
+	}
+
+	public void readFromNBT(NBTTagCompound var1) {
+		this.type = EffectType.effectsList[var1.getByte("Type") & 0xFF];
+		this.duration = var1.getInteger("Duration");
+		this.maxDuration = var1.getInteger("MaxDuration");
+		this.metadata = var1.getInteger("Metadata");
+	}
+
+	public void writeToNBT(NBTTagCompound var1) {
+		var1.setByte("Type", (byte) this.type.id);
+		var1.setInteger("Duration", this.duration);
+		var1.setInteger("MaxDuration", this.maxDuration);
+		var1.setInteger("Metadata", this.metadata);
+	}
+
+	public void doEffect(EntityPlayer player) {
+		if (this.type != null) {
+			this.type.doEffect(player, this);
+		}
+		this.duration--;
+	}
+}
--- net/minecraft/src/Packet.java
+++ net/minecraft/src/Packet.java
@@ -7,11 +7,11 @@
 import java.util.Map;
 
 public abstract class Packet {
-	private static Map packetIdToClassMap = new HashMap();
-	private static Map packetClassToIdMap = new HashMap();
+	private static final Map packetIdToClassMap = new HashMap();
+	private static final Map packetClassToIdMap = new HashMap();
 	public boolean isChunkDataPacket = false;
 
-	static void addIdClassMapping(int var0, Class var1) {
+	public static void addIdClassMapping(int var0, Class var1) {
 		if(packetIdToClassMap.containsKey(Integer.valueOf(var0))) {
 			throw new IllegalArgumentException("Duplicate packet id:" + var0);
 		} else if(packetClassToIdMap.containsKey(var1)) {
@@ -24,7 +24,7 @@
 
 	public static Packet getNewPacket(int var0) {
 		try {
-			Class var1 = (Class)packetIdToClassMap.get(Integer.valueOf(var0));
+			Class var1 = (Class)packetIdToClassMap.get(var0);
 			return var1 == null ? null : (Packet)var1.newInstance();
 		} catch (Exception var2) {
 			var2.printStackTrace();
@@ -41,15 +41,15 @@
 		int var1 = var0.read();
 		if(var1 == -1) {
 			return null;
-		} else {
-			Packet var2 = getNewPacket(var1);
-			if(var2 == null) {
-				throw new IOException("Bad packet id " + var1);
-			} else {
-				var2.readPacketData(var0);
-				return var2;
-			}
-		}
+		}
+
+		Packet var2 = getNewPacket(var1);
+		if(var2 == null) {
+			throw new IOException("Bad packet id " + var1);
+		}
+
+		var2.readPacketData(var0);
+		return var2;
 	}
 
 	public static void writePacket(Packet var0, DataOutputStream var1) throws IOException {
@@ -57,6 +57,48 @@
 		var0.writePacket(var1);
 	}
 
+	public static void writeString(String var0, DataOutputStream var1) throws IOException {
+		if(var0.length() > Short.MAX_VALUE) {
+			throw new IOException("String too big");
+		} else {
+			var1.writeShort(var0.length());
+			var1.writeChars(var0);
+		}
+	}
+
+	public static String readString(DataInputStream var0, int var1) throws IOException {
+		short var2 = var0.readShort();
+		if(var2 > var1) {
+			throw new IOException("Received string length longer than maximum allowed (" + var2 + " > " + var1 + ")");
+		} else if(var2 < 0) {
+			throw new IOException("Received string length is less than zero! Weird string!");
+		} else {
+			StringBuilder var3 = new StringBuilder();
+
+			for(int var4 = 0; var4 < var2; ++var4) {
+				var3.append(var0.readChar());
+			}
+
+			return var3.toString();
+		}
+	}
+
+	public static NBTTagCompound readNBT(DataInputStream var0) throws IOException {
+		NBTBase storage = NBTBase.readNamedTag(var0);
+		if (storage instanceof NBTTagCompound) {
+			return (NBTTagCompound)storage;
+		}
+		return null;
+	}
+
+	public static void writeNBT(NBTTagCompound var0, DataOutputStream var1) throws IOException {
+		if (var0 == null) {
+			var1.writeByte(0);
+		} else {
+			NBTBase.writeNamedTag(var0, var1);
+		}
+	}
+
 	public abstract void readPacketData(DataInputStream var1) throws IOException;
 
 	public abstract void writePacket(DataOutputStream var1) throws IOException;
@@ -73,6 +115,9 @@
 		addIdClassMapping(4, Packet4UpdateTime.class);
 		addIdClassMapping(5, Packet5PlayerInventory.class);
 		addIdClassMapping(6, Packet6SpawnPosition.class);
+		addIdClassMapping(7, Packet7UseEntity.class);
+		addIdClassMapping(8, Packet8UpdateHealth.class);
+		addIdClassMapping(9, Packet9Respawn.class);
 		addIdClassMapping(10, Packet10Flying.class);
 		addIdClassMapping(11, Packet11PlayerPosition.class);
 		addIdClassMapping(12, Packet12PlayerLook.class);
@@ -80,24 +125,42 @@
 		addIdClassMapping(14, Packet14BlockDig.class);
 		addIdClassMapping(15, Packet15Place.class);
 		addIdClassMapping(16, Packet16BlockItemSwitch.class);
-		addIdClassMapping(17, Packet17AddToInventory.class);
 		addIdClassMapping(18, Packet18ArmAnimation.class);
+		addIdClassMapping(19, Packet19EntityAction.class);
 		addIdClassMapping(20, Packet20NamedEntitySpawn.class);
 		addIdClassMapping(21, Packet21PickupSpawn.class);
 		addIdClassMapping(22, Packet22Collect.class);
 		addIdClassMapping(23, Packet23VehicleSpawn.class);
 		addIdClassMapping(24, Packet24MobSpawn.class);
+		addIdClassMapping(25, Packet25EntityPainting.class);
+		addIdClassMapping(28, Packet28EntityVelocity.class);
 		addIdClassMapping(29, Packet29DestroyEntity.class);
 		addIdClassMapping(30, Packet30Entity.class);
 		addIdClassMapping(31, Packet31RelEntityMove.class);
 		addIdClassMapping(32, Packet32EntityLook.class);
 		addIdClassMapping(33, Packet33RelEntityMoveLook.class);
 		addIdClassMapping(34, Packet34EntityTeleport.class);
+		addIdClassMapping(38, Packet38EntityStatus.class);
+		addIdClassMapping(39, Packet39AttachEntity.class);
+		addIdClassMapping(40, Packet40EntityMetadata.class);
+		addIdClassMapping(41, Packet41AddEffect.class);
+		addIdClassMapping(42, Packet42RemoveEffect.class);
 		addIdClassMapping(50, Packet50PreChunk.class);
 		addIdClassMapping(51, Packet51MapChunk.class);
 		addIdClassMapping(52, Packet52MultiBlockChange.class);
 		addIdClassMapping(53, Packet53BlockChange.class);
-		addIdClassMapping(59, Packet59ComplexEntity.class);
+		addIdClassMapping(54, Packet54LoadChunks.class);
+		addIdClassMapping(60, Packet60Explosion.class);
+		addIdClassMapping(61, Packet61DoorChange.class);
+		addIdClassMapping(70, Packet70WorldType.class);
+		addIdClassMapping(100, Packet100OpenWindow.class);
+		addIdClassMapping(101, Packet101CloseWindow.class);
+		addIdClassMapping(102, Packet102WindowClick.class);
+		addIdClassMapping(103, Packet103SetSlot.class);
+		addIdClassMapping(104, Packet104WindowItems.class);
+		addIdClassMapping(105, Packet105UpgradeProgressbar.class);
+		addIdClassMapping(106, Packet106Transaction.class);
+		addIdClassMapping(130, Packet130UpdateSign.class);
 		addIdClassMapping(255, Packet255KickDisconnect.class);
 	}
 }
--- net/minecraft/src/GameWindowListener.java
+++ net/minecraft/src/GameWindowListener.java
@@ -5,8 +5,8 @@
 import net.minecraft.client.Minecraft;
 
 public final class GameWindowListener extends WindowAdapter {
-	final Minecraft mc;
-	final Thread thread;
+	public final Minecraft mc;
+	public final Thread thread;
 
 	public GameWindowListener(Minecraft var1, Thread var2) {
 		this.mc = var1;
--- net/minecraft/src/ItemSeeds.java
+++ net/minecraft/src/ItemSeeds.java
@@ -8,7 +8,7 @@
 		this.blockType = var2;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		if(var7 != 1) {
 			return false;
 		} else {
--- net/minecraft/src/RenderGlobal.java
+++ net/minecraft/src/RenderGlobal.java
@@ -1,17 +1,23 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 import java.nio.IntBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
+
 import net.minecraft.client.Minecraft;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.ARBOcclusionQuery;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL15;
 
 public class RenderGlobal implements IWorldAccess {
+	private long lastMovedTime = System.currentTimeMillis();
 	public List tileEntities = new ArrayList();
 	private World theWorld;
 	private RenderEngine renderEngine;
@@ -36,7 +42,7 @@
 	private int maxBlockX;
 	private int maxBlockY;
 	private int maxBlockZ;
-	private int renderDistance = -1;
+	public int renderDistance = -1;
 	private int renderEntitiesStartupCounter = 2;
 	private int countEntitiesTotal;
 	private int countEntitiesRendered;
@@ -50,6 +56,7 @@
 	private int renderersSkippingRenderPass;
 	private List glRenderLists = new ArrayList();
 	private RenderList[] allRenderLists = new RenderList[]{new RenderList(), new RenderList(), new RenderList(), new RenderList()};
+	private IntBuffer field_22019_aY = BufferUtils.createIntBuffer(65536);
 	int dummyRenderInt = 0;
 	int unusedGLCallList = GLAllocation.generateDisplayLists(1);
 	double prevSortX = -9999.0D;
@@ -57,6 +64,8 @@
 	double prevSortZ = -9999.0D;
 	public float damagePartialTime;
 	int frustumCheckOffset = 0;
+	private int worldRenderersCheckIndex;
+	public static float globalBrightness = 0.0F;
 
 	public RenderGlobal(Minecraft var1, RenderEngine var2) {
 		this.mc = var1;
@@ -184,7 +193,7 @@
 	}
 
 	public void loadRenderers() {
-		Block.leaves.setGraphicsLevel(this.mc.options.fancyGraphics);
+		Block.leaves.setGraphicsLevel(this.mc.options.fancyGraphics > 0);
 		this.renderDistance = this.mc.options.renderDistance;
 		int var1;
 		if(this.worldRenderers != null) {
@@ -193,13 +202,10 @@
 			}
 		}
 
-		var1 = 64 << 3 - this.renderDistance;
-		if(var1 > 400) {
-			var1 = 400;
-		}
+		var1 = 32 * this.renderDistance;
 
 		this.renderChunksWide = var1 / 16 + 1;
-		this.renderChunksTall = 8;
+		this.renderChunksTall = CHUNK_HEIGHT / 16;
 		this.renderChunksDeep = var1 / 16 + 1;
 		this.worldRenderers = new WorldRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
 		this.sortedWorldRenderers = new WorldRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
@@ -214,7 +220,10 @@
 
 		int var4;
 		for(var4 = 0; var4 < this.worldRenderersToUpdate.size(); ++var4) {
-			((WorldRenderer)this.worldRenderersToUpdate.get(var4)).needsUpdate = false;
+			WorldRenderer wr = (WorldRenderer)this.worldRenderersToUpdate.get(var4);
+			if (wr != null) {
+				wr.needsUpdate = false;
+			}
 		}
 
 		this.worldRenderersToUpdate.clear();
@@ -242,8 +251,10 @@
 
 		if(this.theWorld != null) {
 			EntityPlayerSP var7 = this.mc.thePlayer;
-			this.markRenderersForNewPosition(MathHelper.floor_double(var7.posX), MathHelper.floor_double(var7.posY), MathHelper.floor_double(var7.posZ));
-			Arrays.sort(this.sortedWorldRenderers, new EntitySorter(var7));
+			if (var7 != null) {
+				this.markRenderersForNewPosition(MathHelper.floor_double(var7.posX), MathHelper.floor_double(var7.posY), MathHelper.floor_double(var7.posZ));
+				Arrays.sort(this.sortedWorldRenderers, new EntitySorter(var7));
+			}
 		}
 
 		this.renderEntitiesStartupCounter = 2;
@@ -271,7 +282,7 @@
 			int var6;
 			for(var6 = 0; var6 < var5.size(); ++var6) {
 				Entity var7 = (Entity)var5.get(var6);
-				if(var7.isInRangeToRenderVec3D(var1) && var2.isBoundingBoxInFrustum(var7.boundingBox) && (var7 != this.mc.thePlayer || this.mc.options.thirdPersonView)) {
+				if(var7.isInRangeToRenderVec3D(var1) && var2.isBoundingBoxInFrustum(var7.boundingBox) && (var7 != this.mc.thePlayer || this.mc.options.thirdPersonView > 0)) {
 					++this.countEntitiesRendered;
 					RenderManager.instance.renderEntity(var7, var3);
 				}
@@ -362,6 +373,19 @@
 	}
 
 	public int sortAndRender(EntityPlayer var1, int var2, double var3) {
+		Profiler.startSection("sortChunks");
+		if(this.worldRenderersToUpdate.size() < 10) {
+			byte partialX = 10;
+
+			for(int i = 0; i < partialX; ++i) {
+				this.worldRenderersCheckIndex = (this.worldRenderersCheckIndex + 1) % this.worldRenderers.length;
+				WorldRenderer partialY = this.worldRenderers[this.worldRenderersCheckIndex];
+				if(partialY.needsUpdate && !this.worldRenderersToUpdate.contains(partialY)) {
+					this.worldRenderersToUpdate.add(partialY);
+				}
+			}
+		}
+
 		if(this.mc.options.renderDistance != this.renderDistance) {
 			this.loadRenderers();
 		}
@@ -386,26 +410,52 @@
 			this.prevSortZ = var1.posZ;
 			this.markRenderersForNewPosition(MathHelper.floor_double(var1.posX), MathHelper.floor_double(var1.posY), MathHelper.floor_double(var1.posZ));
 			Arrays.sort(this.sortedWorldRenderers, new EntitySorter(var1));
+			int sumTX = (int)var1.posX;
+			int sumTY = (int)var1.posZ;
+			short sumTZ = 2000;
+			if(Math.abs(sumTX - WorldRenderer.globalChunkOffsetX) > sumTZ || Math.abs(sumTY - WorldRenderer.globalChunkOffsetZ) > sumTZ) {
+				WorldRenderer.globalChunkOffsetX = sumTX;
+				WorldRenderer.globalChunkOffsetZ = sumTY;
+				this.loadRenderers();
+			}
 		}
 
 		byte var17 = 0;
 		int var33;
-		if(this.occlusionEnabled && !this.mc.options.anaglyph && var2 == 0) {
-			byte var18 = 0;
-			int var19 = 16;
-			this.checkOcclusionQueryResult(var18, var19);
+		int var42 = 0;
+		if(this.occlusionEnabled && this.mc.options.advancedOpengl && !this.mc.options.anaglyph && var2 == 0) {
+			byte firstIndex = 0;
+			byte var43 = 20;
+			this.checkOcclusionQueryResult(firstIndex, var43, var1.posX, var1.posY, var1.posZ);
 
-			for(int var20 = var18; var20 < var19; ++var20) {
-				this.sortedWorldRenderers[var20].isVisible = true;
+			int endIndex;
+			for(endIndex = firstIndex; endIndex < var43; ++endIndex) {
+				this.sortedWorldRenderers[endIndex].isVisible = true;
 			}
 
-			var33 = var17 + this.renderSortedRenderers(var18, var19, var2, var3);
-
-			do {
-				int var34 = var19;
-				var19 *= 2;
-				if(var19 > this.sortedWorldRenderers.length) {
-					var19 = this.sortedWorldRenderers.length;
+			Profiler.endStartSection("render");
+			var33 = this.renderSortedRenderers(firstIndex, var43, var2, var3);
+			endIndex = var43;
+			int var44 = 0;
+			byte step = 30;
+
+			int startIndex;
+			for(int var45 = this.renderChunksWide / 2; endIndex < this.sortedWorldRenderers.length; var33 += this.renderSortedRenderers(startIndex, endIndex, var2, var3)) {
+				Profiler.endStartSection("occ");
+				startIndex = endIndex;
+				if(var44 < var45) {
+					++var44;
+				} else {
+					--var44;
+				}
+
+				endIndex += var44 * step;
+				if(endIndex <= startIndex) {
+					endIndex = startIndex + 10;
+				}
+
+				if(endIndex > this.sortedWorldRenderers.length) {
+					endIndex = this.sortedWorldRenderers.length;
 				}
 
 				GL11.glDisable(GL11.GL_TEXTURE_2D);
@@ -414,43 +464,59 @@
 				GL11.glDisable(GL11.GL_FOG);
 				GL11.glColorMask(false, false, false, false);
 				GL11.glDepthMask(false);
-				this.checkOcclusionQueryResult(var34, var19);
+				Profiler.startSection("check");
+				this.checkOcclusionQueryResult(startIndex, endIndex, var1.posX, var1.posY, var1.posZ);
+				Profiler.endSection();
 				GL11.glPushMatrix();
-				float var35 = 0.0F;
-				float var21 = 0.0F;
-				float var22 = 0.0F;
-
-				for(int var23 = var34; var23 < var19; ++var23) {
-					if(this.sortedWorldRenderers[var23].skipAllRenderPasses()) {
-						this.sortedWorldRenderers[var23].isInFrustum = false;
-					} else {
-						if(!this.sortedWorldRenderers[var23].isInFrustum) {
-							this.sortedWorldRenderers[var23].isVisible = true;
-						}
-
-						if(this.sortedWorldRenderers[var23].isInFrustum && !this.sortedWorldRenderers[var23].isWaitingOnOcclusionQuery) {
-							float var24 = MathHelper.sqrt_float(this.sortedWorldRenderers[var23].distanceToEntitySquared(var1));
-							int var25 = (int)(1.0F + var24 / 128.0F);
-							if(this.cloudTickCounter % var25 == var23 % var25) {
-								WorldRenderer var26 = this.sortedWorldRenderers[var23];
-								float var27 = (float)((double)var26.posXMinus - var5);
-								float var28 = (float)((double)var26.posYMinus - var7);
-								float var29 = (float)((double)var26.posZMinus - var9);
-								float var30 = var27 - var35;
-								float var31 = var28 - var21;
-								float var32 = var29 - var22;
-								if(var30 != 0.0F || var31 != 0.0F || var32 != 0.0F) {
-									GL11.glTranslatef(var30, var31, var32);
-									var35 += var30;
-									var21 += var31;
-									var22 += var32;
+				float sumTX = 0.0F;
+				float sumTY = 0.0F;
+				float sumTZ = 0.0F;
+
+				for(int k = startIndex; k < endIndex; ++k) {
+					WorldRenderer wr = this.sortedWorldRenderers[k];
+					if(wr.skipAllRenderPasses()) {
+						wr.isInFrustum = false;
+					} else if(wr.isInFrustum) {
+						if(this.mc.options.occlusionFancy && !wr.isInFrustumFully) {
+							wr.isVisible = true;
+						} else if(wr.isInFrustum && !wr.isWaitingOnOcclusionQuery) {
+							float bbX;
+							float bbY;
+							float bbZ;
+							float tX;
+							if(wr.isVisibleFromPosition) {
+								bbX = Math.abs((float)(wr.visibleFromX - var1.posX));
+								bbY = Math.abs((float)(wr.visibleFromY - var1.posY));
+								bbZ = Math.abs((float)(wr.visibleFromZ - var1.posZ));
+								tX = bbX + bbY + bbZ;
+								if((double)tX < 10.0D + (double)k / 1000.0D) {
+									wr.isVisible = true;
+									continue;
 								}
 
-								ARBOcclusionQuery.glBeginQueryARB(GL15.GL_SAMPLES_PASSED, this.sortedWorldRenderers[var23].glOcclusionQuery);
-								this.sortedWorldRenderers[var23].callOcclusionQueryList();
-								ARBOcclusionQuery.glEndQueryARB(GL15.GL_SAMPLES_PASSED);
-								this.sortedWorldRenderers[var23].isWaitingOnOcclusionQuery = true;
-							}
+								wr.isVisibleFromPosition = false;
+							}
+
+							bbX = (float)((double)wr.posXMinus - var5);
+							bbY = (float)((double)wr.posYMinus - var7);
+							bbZ = (float)((double)wr.posZMinus - var9);
+							tX = bbX - sumTX;
+							float tY = bbY - sumTY;
+							float tZ = bbZ - sumTZ;
+							if(tX != 0.0F || tY != 0.0F || tZ != 0.0F) {
+								GL11.glTranslatef(tX, tY, tZ);
+								sumTX += tX;
+								sumTY += tY;
+								sumTZ += tZ;
+							}
+
+							Profiler.startSection("bb");
+							ARBOcclusionQuery.glBeginQueryARB(GL15.GL_SAMPLES_PASSED, wr.glOcclusionQuery);
+							wr.callOcclusionQueryList();
+							ARBOcclusionQuery.glEndQueryARB(GL15.GL_SAMPLES_PASSED);
+							Profiler.endSection();
+							wr.isWaitingOnOcclusionQuery = true;
+							++var42;
 						}
 					}
 				}
@@ -461,88 +527,117 @@
 				GL11.glEnable(GL11.GL_TEXTURE_2D);
 				GL11.glEnable(GL11.GL_ALPHA_TEST);
 				GL11.glEnable(GL11.GL_FOG);
-				var33 += this.renderSortedRenderers(var34, var19, var2, var3);
-			} while(var19 < this.sortedWorldRenderers.length);
+				Profiler.endStartSection("render");
+			}
 		} else {
+			Profiler.endStartSection("render");
 			var33 = var17 + this.renderSortedRenderers(0, this.sortedWorldRenderers.length, var2, var3);
 		}
 
+		Profiler.endSection();
 		return var33;
 	}
 
-	private void checkOcclusionQueryResult(int var1, int var2) {
-		for(int var3 = var1; var3 < var2; ++var3) {
-			if(this.sortedWorldRenderers[var3].isWaitingOnOcclusionQuery) {
-				this.occlusionResult.clear();
-				ARBOcclusionQuery.glGetQueryObjectuARB(this.sortedWorldRenderers[var3].glOcclusionQuery, GL15.GL_QUERY_RESULT_AVAILABLE, this.occlusionResult);
-				if(this.occlusionResult.get(0) != 0) {
-					this.sortedWorldRenderers[var3].isWaitingOnOcclusionQuery = false;
-					this.occlusionResult.clear();
-					ARBOcclusionQuery.glGetQueryObjectuARB(this.sortedWorldRenderers[var3].glOcclusionQuery, GL15.GL_QUERY_RESULT, this.occlusionResult);
-					this.sortedWorldRenderers[var3].isVisible = this.occlusionResult.get(0) != 0;
-				}
-			}
-		}
+	private void checkOcclusionQueryResult(int startIndex, int endIndex, double px, double py, double pz) {
+        for (int k = startIndex; k < endIndex; ++k) {
+            WorldRenderer wr = this.sortedWorldRenderers[k];
+            if (wr.isWaitingOnOcclusionQuery) {
+                this.occlusionResult.clear();
+                ARBOcclusionQuery.glGetQueryObjectuARB(wr.glOcclusionQuery, GL15.GL_QUERY_RESULT_AVAILABLE,
+                        this.occlusionResult);
+                if (this.occlusionResult.get(0) != 0) {
+                    wr.isWaitingOnOcclusionQuery = false;
+                    this.occlusionResult.clear();
+                    ARBOcclusionQuery.glGetQueryObjectuARB(wr.glOcclusionQuery, GL15.GL_QUERY_RESULT,
+                            this.occlusionResult);
+                    boolean wasVisible = wr.isVisible;
+                    wr.isVisible = this.occlusionResult.get(0) > 0;
+                    if (wasVisible && wr.isVisible) {
+                        wr.isVisibleFromPosition = true;
+                        wr.visibleFromX = px;
+                        wr.visibleFromY = py;
+                        wr.visibleFromZ = pz;
+                    }
+                }
+            }
+        }
 
-	}
+    }
 
 	private int renderSortedRenderers(int var1, int var2, int var3, double var4) {
 		this.glRenderLists.clear();
+		this.field_22019_aY.clear();
 		int var6 = 0;
 
 		for(int var7 = var1; var7 < var2; ++var7) {
+			WorldRenderer renderer = this.sortedWorldRenderers[var7];
 			if(var3 == 0) {
 				++this.renderersLoaded;
-				if(this.sortedWorldRenderers[var7].skipRenderPass[var3]) {
+				if(renderer.skipRenderPass[var3]) {
 					++this.renderersSkippingRenderPass;
-				} else if(!this.sortedWorldRenderers[var7].isInFrustum) {
+				} else if(!renderer.isInFrustum) {
 					++this.renderersBeingClipped;
-				} else if(this.occlusionEnabled && !this.sortedWorldRenderers[var7].isVisible) {
+				} else if(this.occlusionEnabled && !renderer.isVisible) {
 					++this.renderersBeingOccluded;
 				} else {
 					++this.renderersBeingRendered;
 				}
 			}
 
-			if(!this.sortedWorldRenderers[var7].skipRenderPass[var3] && this.sortedWorldRenderers[var7].isInFrustum && this.sortedWorldRenderers[var7].isVisible) {
-				int var8 = this.sortedWorldRenderers[var7].getGLCallListForPass(var3);
+			if(!renderer.skipRenderPass[var3] && renderer.isInFrustum && renderer.isVisible) {
+				int var8 = renderer.getGLCallListForPass(var3);
 				if(var8 >= 0) {
-					this.glRenderLists.add(this.sortedWorldRenderers[var7]);
+					if (Minecraft.fastRender()) {
+						this.field_22019_aY.put(var8);
+					} else {
+						this.glRenderLists.add(renderer);
+					}
 					++var6;
 				}
 			}
 		}
 
+		this.field_22019_aY.flip();
 		EntityPlayerSP var19 = this.mc.thePlayer;
 		double var20 = var19.lastTickPosX + (var19.posX - var19.lastTickPosX) * var4;
 		double var10 = var19.lastTickPosY + (var19.posY - var19.lastTickPosY) * var4;
 		double var12 = var19.lastTickPosZ + (var19.posZ - var19.lastTickPosZ) * var4;
+		if (Minecraft.fastRender()) {
+			var20 -= (double)WorldRenderer.globalChunkOffsetX;
+			var12 -= (double)WorldRenderer.globalChunkOffsetZ;
+			GL11.glTranslatef((float)-var20, (float)-var10, (float)-var12);
+			GL11.glCallLists(this.field_22019_aY);
+			GL11.glTranslatef((float)var20, (float)var10, (float)var12);
+		}
 		int var14 = 0;
 
-		int var15;
-		for(var15 = 0; var15 < this.allRenderLists.length; ++var15) {
-			this.allRenderLists[var15].reset();
-		}
-
-		for(var15 = 0; var15 < this.glRenderLists.size(); ++var15) {
-			WorldRenderer var16 = (WorldRenderer)this.glRenderLists.get(var15);
-			int var17 = -1;
-
-			for(int var18 = 0; var18 < var14; ++var18) {
-				if(this.allRenderLists[var18].isRenderedAt(var16.posXMinus, var16.posYMinus, var16.posZMinus)) {
-					var17 = var18;
-				}
-			}
-
-			if(var17 < 0) {
-				var17 = var14++;
-				this.allRenderLists[var17].setLocation(var16.posXMinus, var16.posYMinus, var16.posZMinus, var20, var10, var12);
-			}
-
-			this.allRenderLists[var17].render(var16.getGLCallListForPass(var3));
-		}
-
-		this.renderAllRenderLists(var3, var4);
+		if (!Minecraft.fastRender()) {
+			int var15;
+			for(var15 = 0; var15 < this.allRenderLists.length; ++var15) {
+				this.allRenderLists[var15].reset();
+			}
+
+			for(var15 = 0; var15 < this.glRenderLists.size(); ++var15) {
+				WorldRenderer var16 = (WorldRenderer)this.glRenderLists.get(var15);
+				int var17 = -1;
+
+				for(int var18 = 0; var18 < var14; ++var18) {
+					if(this.allRenderLists[var18].isRenderedAt(var16.posXMinus, var16.posYMinus, var16.posZMinus)) {
+						var17 = var18;
+					}
+				}
+
+				if(var17 < 0) {
+					var17 = var14++;
+					this.allRenderLists[var17].setLocation(var16.posXMinus, var16.posYMinus, var16.posZMinus, var20, var10, var12);
+				}
+
+				this.allRenderLists[var17].render(var16.getGLCallListForPass(var3));
+			}
+
+			this.renderAllRenderLists(var3, var4);
+		}
+
 		return var6;
 	}
 
@@ -553,16 +648,35 @@
 
 	}
 
+	public int renderAllSortedRenderers(int renderPass, double partialTicks) {
+		return this.renderSortedRenderers(0, this.sortedWorldRenderers.length, renderPass, partialTicks);
+	}
+
 	public void updateClouds() {
 		++this.cloudTickCounter;
 	}
 
 	public void renderSky(float var1) {
 		GL11.glDisable(GL11.GL_TEXTURE_2D);
-		Vec3D var2 = this.theWorld.getSkyColor(var1);
+		double posX = MathHelper.lerp(this.mc.thePlayer.lastTickPosX, this.mc.thePlayer.posX, var1);
+		double posY = MathHelper.lerp(this.mc.thePlayer.lastTickPosY, this.mc.thePlayer.posY, var1);
+		double posZ = MathHelper.lerp(this.mc.thePlayer.lastTickPosZ, this.mc.thePlayer.posZ, var1);
+		Vec3D var2 = this.theWorld.getSkyColor(var1, this.theWorld.getTemperature(posX, posZ), this.theWorld.getHumidity(posX, posZ));
 		float var3 = (float)var2.xCoord;
 		float var4 = (float)var2.yCoord;
 		float var5 = (float)var2.zCoord;
+		if (this.mc.theWorld.worldType != WorldType.SUPERFLAT) {
+			if (posY < 32.0D) {
+				var3 = 0.1F;
+				var4 = 0.0F;
+				var5 = 0.2F;
+			} else if (posY < 48.0D) {
+				float lerp = (float)((posY - 32.0D) / -16.0D + 1.0D);
+				var3 = MathHelper.lerp(var3, 0.1F, lerp);
+				var4 = MathHelper.lerp(var4, 0.0F, lerp);
+				var5 = MathHelper.lerp(var5, 0.2F, lerp);
+			}
+		}
 		float var7;
 		float var8;
 		if(this.mc.options.anaglyph) {
@@ -594,26 +708,48 @@
 		GL11.glRotatef(0.0F, 0.0F, 0.0F, 1.0F);
 		GL11.glRotatef(this.theWorld.getCelestialAngle(var1) * 360.0F, 1.0F, 0.0F, 0.0F);
 		float var10 = 30.0F;
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/terrain/sun.png"));
-		var12.startDrawingQuads();
-		var12.addVertexWithUV((double)(-var10), 100.0D, (double)(-var10), 0.0D, 0.0D);
-		var12.addVertexWithUV((double)var10, 100.0D, (double)(-var10), 1.0D, 0.0D);
-		var12.addVertexWithUV((double)var10, 100.0D, (double)var10, 1.0D, 1.0D);
-		var12.addVertexWithUV((double)(-var10), 100.0D, (double)var10, 0.0D, 1.0D);
-		var12.draw();
-		var10 = 20.0F;
-		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/terrain/moon.png"));
-		var12.startDrawingQuads();
-		var12.addVertexWithUV((double)(-var10), -100.0D, (double)var10, 1.0D, 1.0D);
-		var12.addVertexWithUV((double)var10, -100.0D, (double)var10, 0.0D, 1.0D);
-		var12.addVertexWithUV((double)var10, -100.0D, (double)(-var10), 0.0D, 0.0D);
-		var12.addVertexWithUV((double)(-var10), -100.0D, (double)(-var10), 1.0D, 0.0D);
-		var12.draw();
-		GL11.glDisable(GL11.GL_TEXTURE_2D);
-		float var11 = this.theWorld.getStarBrightness(var1);
-		if(var11 > 0.0F) {
-			GL11.glColor4f(var11, var11, var11, var11);
-			GL11.glCallList(this.starGLCallList);
+		if (this.theWorld.worldType == WorldType.ARID) {
+			var10 = 50.0F;
+		}
+		if (this.theWorld.worldType == WorldType.TROPICAL) {
+			var10 = 40.0F;
+		}
+		if (this.theWorld.worldType == WorldType.WINTER) {
+			var10 = 20.0F;
+		}
+		if (this.mc.thePlayer.posY > 48.0F || this.theWorld.worldType == WorldType.SUPERFLAT) {
+			if (this.mc.thePlayer.posY < 64.0F && this.theWorld.worldType != WorldType.SUPERFLAT) {
+				float lerp = (float)((this.mc.thePlayer.posY - 48.0D) / -16.0D + 1.0D);
+				var10 = MathHelper.lerp(var10, 0.0F, lerp);
+			}
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/terrain/sun.png"));
+			var12.startDrawingQuads();
+			var12.addVertexWithUV((double)(-var10), 100.0D, (double)(-var10), 0.0D, 0.0D);
+			var12.addVertexWithUV((double)var10, 100.0D, (double)(-var10), 1.0D, 0.0D);
+			var12.addVertexWithUV((double)var10, 100.0D, (double)var10, 1.0D, 1.0D);
+			var12.addVertexWithUV((double)(-var10), 100.0D, (double)var10, 0.0D, 1.0D);
+			var12.draw();
+			var10 = 20.0F;
+			if (this.theWorld.worldType == WorldType.WINTER) {
+				var10 = 30.0F;
+			}
+			if (this.mc.thePlayer.posY < 64.0F && this.theWorld.worldType != WorldType.SUPERFLAT) {
+				float lerp = (float)((this.mc.thePlayer.posY - 48.0D) / -16.0D + 1.0D);
+				var10 = MathHelper.lerp(var10, 0.0F, lerp);
+			}
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/terrain/moon.png"));
+			var12.startDrawingQuads();
+			var12.addVertexWithUV((double)(-var10), -100.0D, (double)var10, 1.0D, 1.0D);
+			var12.addVertexWithUV((double)var10, -100.0D, (double)var10, 0.0D, 1.0D);
+			var12.addVertexWithUV((double)var10, -100.0D, (double)(-var10), 0.0D, 0.0D);
+			var12.addVertexWithUV((double)(-var10), -100.0D, (double)(-var10), 1.0D, 0.0D);
+			var12.draw();
+			GL11.glDisable(GL11.GL_TEXTURE_2D);
+			float var11 = this.theWorld.getStarBrightness(var1);
+			if(var11 > 0.0F) {
+				GL11.glColor4f(var11, var11, var11, var11);
+				GL11.glCallList(this.starGLCallList);
+			}
 		}
 
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
@@ -623,13 +759,13 @@
 		GL11.glPopMatrix();
 		GL11.glColor3f(var3 * 0.2F + 0.04F, var4 * 0.2F + 0.04F, var5 * 0.6F + 0.1F);
 		GL11.glDisable(GL11.GL_TEXTURE_2D);
-		GL11.glCallList(this.glSkyList2);
+//		GL11.glCallList(this.glSkyList2);
 		GL11.glEnable(GL11.GL_TEXTURE_2D);
 		GL11.glDepthMask(true);
 	}
 
 	public void renderClouds(float var1) {
-		if(this.mc.options.fancyGraphics) {
+		if(this.mc.options.fancyGraphics > 0) {
 			this.renderCloudsFancy(var1);
 		} else {
 			GL11.glDisable(GL11.GL_CULL_FACE);
@@ -661,7 +797,7 @@
 			int var16 = MathHelper.floor_double(var13 / 2048.0D);
 			var22 -= (double)(var15 * 2048);
 			var13 -= (double)(var16 * 2048);
-			float var17 = 120.0F - var2 + 0.33F;
+			float var17 = 192.0F - var2 + 0.33F;
 			float var18 = (float)(var22 * (double)var10);
 			float var19 = (float)(var13 * (double)var10);
 			var5.startDrawingQuads();
@@ -684,6 +820,11 @@
 	}
 
 	public void renderCloudsFancy(float var1) {
+		if (Minecraft.panoramaMode) {
+			this.cloudTickCounter = -1;
+			var1 = 1.0F;
+		}
+
 		GL11.glDisable(GL11.GL_CULL_FACE);
 		float var2 = (float)(this.mc.thePlayer.lastTickPosY + (this.mc.thePlayer.posY - this.mc.thePlayer.lastTickPosY) * (double)var1);
 		Tessellator var3 = Tessellator.instance;
@@ -691,7 +832,7 @@
 		float var5 = 4.0F;
 		double var6 = (this.mc.thePlayer.prevPosX + (this.mc.thePlayer.posX - this.mc.thePlayer.prevPosX) * (double)var1 + (double)(((float)this.cloudTickCounter + var1) * 0.03F)) / (double)var4;
 		double var8 = (this.mc.thePlayer.prevPosZ + (this.mc.thePlayer.posZ - this.mc.thePlayer.prevPosZ) * (double)var1) / (double)var4 + (double)0.33F;
-		float var10 = 108.0F - var2 + 0.33F;
+		float var10 = 192.0F - var2 + 0.33F;
 		int var11 = MathHelper.floor_double(var6 / 2048.0D);
 		int var12 = MathHelper.floor_double(var8 / 2048.0D);
 		var6 -= (double)(var11 * 2048);
@@ -717,7 +858,7 @@
 
 		var17 = (float)(var6 * 0.0D);
 		var18 = (float)(var8 * 0.0D);
-		var19 = 0.00390625F;
+		var19 = 1.0F / 256.0F;
 		var17 = (float)MathHelper.floor_double(var6) * var19;
 		var18 = (float)MathHelper.floor_double(var8) * var19;
 		float var20 = (float)(var6 - (double)MathHelper.floor_double(var6));
@@ -817,32 +958,282 @@
 	}
 
 	public boolean updateRenderers(EntityPlayer var1, boolean var2) {
-		Collections.sort(this.worldRenderersToUpdate, new RenderSorter(var1));
-		int var3 = this.worldRenderersToUpdate.size() - 1;
-		int var4 = this.worldRenderersToUpdate.size();
+		int updateMethod = 2;
+		if (updateMethod == 0) {
+			this.worldRenderersToUpdate.sort(new RenderSorter(var1));
+			int var17 = this.worldRenderersToUpdate.size() - 1;
+			int var18 = this.worldRenderersToUpdate.size();
 
-		for(int var5 = 0; var5 < var4; ++var5) {
-			WorldRenderer var6 = (WorldRenderer)this.worldRenderersToUpdate.get(var3 - var5);
-			if(!var2) {
-				if(var6.distanceToEntitySquared(var1) > 1024.0F) {
-					if(var6.isInFrustum) {
-						if(var5 >= 3) {
+			for(int var19 = 0; var19 < var18; ++var19) {
+				WorldRenderer var20 = (WorldRenderer)this.worldRenderersToUpdate.get(var17 - var19);
+				if(var20.distanceToEntitySquared(var1) > 1024.0F) {
+					if(var20.isInFrustum) {
+						if(var19 >= 3) {
 							return false;
 						}
-					} else if(var5 >= 1) {
+					} else if(var19 >= 1) {
 						return false;
 					}
 				}
-			} else if(!var6.isInFrustum) {
-				continue;
-			}
-
-			var6.updateRenderer();
-			this.worldRenderersToUpdate.remove(var6);
-			var6.needsUpdate = false;
-		}
-
-		return this.worldRenderersToUpdate.size() == 0;
+
+				var20.updateRenderer();
+				this.worldRenderersToUpdate.remove(var20);
+				var20.needsUpdate = false;
+			}
+
+			return this.worldRenderersToUpdate.size() == 0;
+		} else if (updateMethod == 1) {
+			byte var4 = 2;
+			RenderSorter var5 = new RenderSorter(var1);
+			WorldRenderer[] var6 = new WorldRenderer[var4];
+			ArrayList var7 = null;
+			int var8 = this.worldRenderersToUpdate.size();
+			int var9 = 0;
+
+			int var10;
+			WorldRenderer var11;
+			int var12;
+			int var13;
+			label169:
+			for(var10 = 0; var10 < var8; ++var10) {
+				var11 = (WorldRenderer)this.worldRenderersToUpdate.get(var10);
+				if(var11.distanceToEntitySquared(var1) > 256.0F) {
+					for(var12 = 0; var12 < var4 && (var6[var12] == null || var5.doCompare(var6[var12], var11) <= 0); ++var12) {
+					}
+
+					--var12;
+					if(var12 <= 0) {
+						continue;
+					}
+
+					var13 = var12;
+
+					while(true) {
+						--var13;
+						if(var13 == 0) {
+							var6[var12] = var11;
+							continue label169;
+						}
+
+						var6[var13 - 1] = var6[var13];
+					}
+				}
+
+				if(var7 == null) {
+					var7 = new ArrayList();
+				}
+
+				++var9;
+				var7.add(var11);
+				this.worldRenderersToUpdate.set(var10, (Object)null);
+			}
+
+			if(var7 != null) {
+				if(var7.size() > 1) {
+					var7.sort(var5);
+				}
+
+				for(var10 = var7.size() - 1; var10 >= 0; --var10) {
+					var11 = (WorldRenderer)var7.get(var10);
+					var11.updateRenderer();
+					var11.needsUpdate = false;
+				}
+			}
+
+			var10 = 0;
+
+			int var21;
+			for(var21 = var4 - 1; var21 >= 0; --var21) {
+				WorldRenderer var22 = var6[var21];
+				if(var22 != null) {
+					if(!var22.isInFrustum && var21 != var4 - 1) {
+						var6[var21] = null;
+						var6[0] = null;
+						break;
+					}
+
+					var6[var21].updateRenderer();
+					var6[var21].needsUpdate = false;
+					++var10;
+				}
+			}
+
+			var21 = 0;
+			var12 = 0;
+
+			for(var13 = this.worldRenderersToUpdate.size(); var21 != var13; ++var21) {
+				WorldRenderer var14 = (WorldRenderer)this.worldRenderersToUpdate.get(var21);
+				if(var14 != null) {
+					boolean var15 = false;
+
+					for(int var16 = 0; var16 < var4 && !var15; ++var16) {
+						if(var14 == var6[var16]) {
+							var15 = true;
+						}
+					}
+
+					if(!var15) {
+						if(var12 != var21) {
+							this.worldRenderersToUpdate.set(var12, var14);
+						}
+
+						++var12;
+					}
+				}
+			}
+
+			while(true) {
+				--var21;
+				if(var21 < var12) {
+					return var8 == var9 + var10;
+				}
+
+				this.worldRenderersToUpdate.remove(var21);
+			}
+		} else if (updateMethod == 2) {
+			if(this.worldRenderersToUpdate.size() <= 0) {
+				return false;
+			} else {
+				int i1 = 0;
+				int i2 = this.mc.options.chunkUpdates;
+				if(this.mc.options.dynamicUpdates && !this.isMoving(var1)) {
+					i2 *= 5;
+				}
+
+				byte b3 = 4;
+				int i4 = 0;
+				WorldRenderer worldRenderer5 = null;
+				float f6 = Float.MAX_VALUE;
+				int i7 = -1;
+
+				int i8;
+				for(i8 = 0; i8 < this.worldRenderersToUpdate.size(); ++i8) {
+					WorldRenderer worldRenderer9 = (WorldRenderer)this.worldRenderersToUpdate.get(i8);
+					if(worldRenderer9 != null) {
+						++i4;
+						if(!worldRenderer9.needsUpdate) {
+							this.worldRenderersToUpdate.set(i8, (Object)null);
+						} else {
+							float wr = worldRenderer9.distanceToEntitySquared(var1);
+							if(wr <= 256.0F && (Mouse.isButtonDown(0) || Mouse.isButtonDown(1))) {
+								if (var2) {
+									worldRenderer9.updateRenderer();
+									worldRenderer9.needsUpdate = false;
+									this.worldRenderersToUpdate.set(i8, (Object)null);
+								} else {
+									worldRenderer9.loadChunks();
+								}
+								++i1;
+							} else {
+								if(wr > 256.0F && i1 >= i2) {
+									break;
+								}
+
+								if(!worldRenderer9.isInFrustum) {
+									wr *= (float)b3;
+									if (!var2) continue;
+								}
+
+								if(worldRenderer5 == null) {
+									worldRenderer5 = worldRenderer9;
+									f6 = wr;
+									i7 = i8;
+								} else if(wr < f6) {
+									worldRenderer5 = worldRenderer9;
+									f6 = wr;
+									i7 = i8;
+								}
+							}
+						}
+					}
+				}
+
+				int var16;
+				if(worldRenderer5 != null) {
+					if (var2) {
+						worldRenderer5.updateRenderer();
+						worldRenderer5.needsUpdate = false;
+						this.worldRenderersToUpdate.set(i7, (Object)null);
+					} else {
+						worldRenderer5.loadChunks();
+					}
+					++i1;
+					float var15 = f6 / 5.0F;
+
+					for(var16 = 0; var16 < this.worldRenderersToUpdate.size() && i1 < i2; ++var16) {
+						WorldRenderer var17 = (WorldRenderer)this.worldRenderersToUpdate.get(var16);
+						if(var17 != null) {
+							float f10 = var17.distanceToEntitySquared(var1);
+							if(!var17.isInFrustum) {
+								f10 *= (float)b3;
+								if (!var2) continue;
+							}
+
+							float f11 = Math.abs(f10 - f6);
+							if(f11 < var15) {
+								if (var2) {
+									var17.updateRenderer();
+									var17.needsUpdate = false;
+									this.worldRenderersToUpdate.set(var16, (Object)null);
+								} else {
+									var17.loadChunks();
+								}
+								++i1;
+							}
+						}
+					}
+				}
+
+				if(i4 == 0) {
+					this.worldRenderersToUpdate.clear();
+				}
+
+				if(this.worldRenderersToUpdate.size() > 100 && i4 < this.worldRenderersToUpdate.size() * 4 / 5) {
+					i8 = 0;
+
+					for(var16 = 0; var16 < this.worldRenderersToUpdate.size(); ++var16) {
+						Object var18 = this.worldRenderersToUpdate.get(var16);
+						if(var18 != null && var16 != i8) {
+							this.worldRenderersToUpdate.set(i8, var18);
+							++i8;
+						}
+					}
+
+					for(var16 = this.worldRenderersToUpdate.size() - 1; var16 >= i8; --var16) {
+						this.worldRenderersToUpdate.remove(var16);
+					}
+				}
+
+				return true;
+			}
+		}
+		return true;
+	}
+
+	private boolean isMoving(EntityLiving entityliving) {
+		boolean moving = this.isMovingNow(entityliving);
+		if(moving) {
+			this.lastMovedTime = System.currentTimeMillis();
+			return true;
+		} else {
+			return System.currentTimeMillis() - this.lastMovedTime < 2000L;
+		}
+	}
+
+	private boolean isMovingNow(EntityLiving entityliving) {
+		if (entityliving == null) {
+			return false;
+		}
+
+		double maxDiff = 0.001D;
+		return entityliving.isJumping
+				|| entityliving.isSneaking()
+				|| (double) entityliving.prevSwingProgress > maxDiff
+				|| this.mc.mouseHelper.deltaX != 0
+				|| this.mc.mouseHelper.deltaY != 0
+				|| Math.abs(entityliving.posX - entityliving.prevPosX) > maxDiff
+				|| Math.abs(entityliving.posY - entityliving.prevPosY) > maxDiff
+				|| Math.abs(entityliving.posZ - entityliving.prevPosZ) > maxDiff;
 	}
 
 	public void drawBlockBreaking(EntityPlayer var1, MovingObjectPosition var2, int var3, ItemStack var4, float var5) {
@@ -874,7 +1265,7 @@
 					var9 = Block.stone;
 				}
 
-				this.globalRenderBlocks.renderBlockUsingTexture(var9, var2.blockX, var2.blockY, var2.blockZ, 240 + (int)(this.damagePartialTime * 10.0F));
+				this.globalRenderBlocks.renderBlockUsingTexture(var9, var2.blockX, var2.blockY, var2.blockZ, 992 + (int)(this.damagePartialTime * 10.0F));
 				var6.draw();
 				var6.setTranslationD(0.0D, 0.0D, 0.0D);
 				GL11.glPolygonOffset(0.0F, 0.0F);
@@ -1004,9 +1395,8 @@
 					WorldRenderer var20 = this.worldRenderers[var19];
 					if(!var20.needsUpdate) {
 						this.worldRenderersToUpdate.add(var20);
+						var20.markDirty();
 					}
-
-					var20.markDirty();
 				}
 			}
 		}
@@ -1017,6 +1407,10 @@
 		this.markBlocksForUpdate(var1 - 1, var2 - 1, var3 - 1, var1 + 1, var2 + 1, var3 + 1);
 	}
 
+	public void markBlockNeedsRenderUpdate(int var1, int var2, int var3) {
+		this.markBlocksForUpdate(var1 - 1, var2 - 1, var3 - 1, var1 + 1, var2 + 1, var3 + 1);
+	}
+
 	public void markBlockRangeNeedsUpdate(int var1, int var2, int var3, int var4, int var5, int var6) {
 		this.markBlocksForUpdate(var1 - 1, var2 - 1, var3 - 1, var4 + 1, var5 + 1, var6 + 1);
 	}
@@ -1031,15 +1425,22 @@
 		++this.frustumCheckOffset;
 	}
 
-	public void playRecord(String var1, int var2, int var3, int var4) {
-		if(var1 != null) {
-			this.mc.ingameGUI.setRecordPlayingMessage("C418 - " + var1);
+	public void playRecord(String var1, int var2, int var3, int var4, String title) {
+		if(title != null) {
+			this.mc.ingameGUI.setRecordPlayingMessage(title);
 		}
 
 		this.mc.sndManager.playStreaming(var1, (float)var2, (float)var3, (float)var4, 1.0F, 1.0F);
 	}
 
 	public void playSound(String var1, double var2, double var4, double var6, float var8, float var9) {
+		if (var1.equals("ambient.cave.cave") && !this.mc.options.caveSounds) {
+			return;
+		}
+		if (var1.equals("ambient.cave.cave.forced")) {
+			var1 = "ambient.cave.cave";
+		}
+
 		float var10 = 16.0F;
 		if(var8 > 1.0F) {
 			var10 *= var8;
@@ -1056,25 +1457,25 @@
 		double var16 = this.mc.thePlayer.posY - var4;
 		double var18 = this.mc.thePlayer.posZ - var6;
 		if(var14 * var14 + var16 * var16 + var18 * var18 <= 256.0D) {
-			if(var1 == "bubble") {
+			if(var1.equals("bubble")) {
 				this.mc.effectRenderer.addEffect(new EntityBubbleFX(this.theWorld, var2, var4, var6, var8, var10, var12));
-			} else if(var1 == "smoke") {
+			} else if(var1.equals("smoke")) {
 				this.mc.effectRenderer.addEffect(new EntitySmokeFX(this.theWorld, var2, var4, var6));
-			} else if(var1 == "explode") {
+			} else if(var1.equals("explode")) {
 				this.mc.effectRenderer.addEffect(new EntityExplodeFX(this.theWorld, var2, var4, var6, var8, var10, var12));
-			} else if(var1 == "flame") {
+			} else if(var1.equals("flame")) {
 				this.mc.effectRenderer.addEffect(new EntityFlameFX(this.theWorld, var2, var4, var6, var8, var10, var12));
-			} else if(var1 == "lava") {
+			} else if(var1.equals("lava")) {
 				this.mc.effectRenderer.addEffect(new EntityLavaFX(this.theWorld, var2, var4, var6));
-			} else if(var1 == "splash") {
+			} else if(var1.equals("splash")) {
 				this.mc.effectRenderer.addEffect(new EntitySplashFX(this.theWorld, var2, var4, var6, var8, var10, var12));
-			} else if(var1 == "largesmoke") {
+			} else if(var1.equals("largesmoke")) {
 				this.mc.effectRenderer.addEffect(new EntitySmokeFX(this.theWorld, var2, var4, var6, 2.5F));
-			} else if(var1 == "reddust") {
+			} else if(var1.equals("reddust")) {
 				this.mc.effectRenderer.addEffect(new EntityReddustFX(this.theWorld, var2, var4, var6));
-			} else if(var1 == "snowballpoof") {
+			} else if(var1.equals("snowballpoof")) {
 				this.mc.effectRenderer.addEffect(new EntitySlimeFX(this.theWorld, var2, var4, var6, Item.snowball));
-			} else if(var1 == "slime") {
+			} else if(var1.equals("slime")) {
 				this.mc.effectRenderer.addEffect(new EntitySlimeFX(this.theWorld, var2, var4, var6, Item.slimeBall));
 			}
 
@@ -1109,5 +1510,48 @@
 	}
 
 	public void doNothingWithTileEntity(int var1, int var2, int var3, TileEntity var4) {
+	}
+
+	private boolean fullBright = false;
+
+	public void toggleFullbright() {
+		fullBright = !fullBright;
+		if (fullBright) {
+			RenderGlobal.globalBrightness = 1.0F;
+		} else {
+			RenderGlobal.globalBrightness = this.mc.options.brightness * 0.2F;
+		}
+		this.loadRenderers();
+	}
+
+	public void performAction(EntityPlayer var1, int var2, int var3, int var4, int var5, int var6) {
+		int var16;
+		switch (var2) {
+		case 1003:
+			if(Math.random() < 0.5D) {
+				this.theWorld.playSoundEffect((double)var3 + 0.5D, (double)var4 + 0.5D, (double)var5 + 0.5D, "random.door_open", 1.0F, this.theWorld.rand.nextFloat() * 0.1F + 0.9F);
+			} else {
+				this.theWorld.playSoundEffect((double)var3 + 0.5D, (double)var4 + 0.5D, (double)var5 + 0.5D, "random.door_close", 1.0F, this.theWorld.rand.nextFloat() * 0.1F + 0.9F);
+			}
+			break;
+
+		case 2001:
+			var16 = var6 & 65535;
+			if(var16 > 0) {
+				Block var17 = Block.blocksList[var16];
+				this.mc.sndManager.playSound(var17.stepSound.getBreakSound(), (float)var3 + 0.5F, (float)var4 + 0.5F, (float)var5 + 0.5F, (var17.stepSound.getVolume() + 1.0F) / 2.0F, var17.stepSound.getPitch() * 0.8F);
+			}
+
+			this.mc.effectRenderer.addBlockDestroyEffects(var3, var4, var5, var6 & 65535, var6 >> 16 & 255);
+			break;
+		}
+	}
+
+	public void setAllRenderersVisible() {
+		if (this.worldRenderers != null) {
+			for (WorldRenderer worldRenderer : this.worldRenderers) {
+				worldRenderer.isVisible = true;
+			}
+		}
 	}
 }
--- net/minecraft/src/BlockWorkbench.java
+++ net/minecraft/src/BlockWorkbench.java
@@ -1,17 +1,19 @@
 package net.minecraft.src;
 
 public class BlockWorkbench extends Block {
-	protected BlockWorkbench(int var1) {
+	public BlockWorkbench(int var1) {
 		super(var1, Material.wood);
-		this.blockIndexInTexture = 59;
+		this.blockIndexInTexture = textureXY(29, 5);
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.blockIndexInTexture - 16 : (var1 == 0 ? Block.planks.getBlockTextureFromSide(0) : (var1 != 2 && var1 != 4 ? this.blockIndexInTexture : this.blockIndexInTexture + 1));
+		return var1 == 1 ? this.blockIndexInTexture - 32 : (var1 == 0 ? Block.planks.getBlockTextureFromSide(0) : (var1 != 2 && var1 != 4 ? this.blockIndexInTexture : this.blockIndexInTexture + 1));
 	}
 
 	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
-		var5.displayWorkbenchGUI();
+		if (var1.canDoClientAction()) {
+			var5.displayWorkbenchGUI(var2, var3, var4);
+		}
 		return true;
 	}
 }
--- net/minecraft/src/IMobs.java
+++ net/minecraft/src/IMobs.java
@@ -1,4 +1,4 @@
 package net.minecraft.src;
 
-public interface IMobs extends IAnimals {
+public interface IMobs {
 }
--- net/minecraft/src/ChunkProviderClient.java
+++ net/minecraft/src/ChunkProviderClient.java
@@ -1,53 +1,45 @@
 package net.minecraft.src;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
 
 public class ChunkProviderClient implements IChunkProvider {
-	private Chunk blankChunk;
-	private Map chunkMapping = new HashMap();
-	private List chunkListing = new ArrayList();
+	private MCHashTableLong chunkMapping = new MCHashTableLong();
 	private World worldObj;
 
 	public ChunkProviderClient(World var1) {
-		this.blankChunk = new Chunk(var1, new byte[-Short.MIN_VALUE], 0, 0);
-		this.blankChunk.isChunkRendered = true;
-		this.blankChunk.neverSave = true;
 		this.worldObj = var1;
 	}
 
 	public boolean chunkExists(int var1, int var2) {
-		ChunkCoordinates var3 = new ChunkCoordinates(var1, var2);
-		return this.chunkMapping.containsKey(var3);
+		return this.chunkMapping.lookup(ChunkCoordIntPair.chunkXZ2Int(var1, var2)) != null;
 	}
 
 	public void unloadChunk(int var1, int var2) {
-		Chunk var3 = this.provideChunk(var1, var2);
-		if(!var3.isChunkRendered) {
-			var3.onChunkUnload();
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		Chunk var4 = this.provideChunk(var1, var2);
+		if(!var4.isChunkRendered) {
+			var4.onChunkUnload();
 		}
 
-		this.chunkMapping.remove(new ChunkCoordinates(var1, var2));
-		this.chunkListing.remove(var3);
+		this.chunkMapping.removeObject(var3);
 	}
 
 	public Chunk loadChunk(int var1, int var2) {
-		ChunkCoordinates var3 = new ChunkCoordinates(var1, var2);
-		byte[] var4 = new byte[-Short.MIN_VALUE];
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+
+		short[] var4 = new short[65536];
 		Chunk var5 = new Chunk(this.worldObj, var4, var1, var2);
 		Arrays.fill(var5.skylightMap.data, (byte)-1);
-		this.chunkMapping.put(var3, var5);
+
+		this.chunkMapping.addKey(var3, var5);
 		var5.isChunkLoaded = true;
 		return var5;
 	}
 
 	public Chunk provideChunk(int var1, int var2) {
-		ChunkCoordinates var3 = new ChunkCoordinates(var1, var2);
-		Chunk var4 = (Chunk)this.chunkMapping.get(var3);
-		return var4 == null ? this.blankChunk : var4;
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		Chunk var4 = (Chunk)this.chunkMapping.lookup(var3);
+		return var4 == null ? this.worldObj.blankChunk : var4;
 	}
 
 	public boolean saveChunks(boolean var1, IProgressUpdate var2) {
@@ -63,5 +55,11 @@
 	}
 
 	public void populate(IChunkProvider var1, int var2, int var3) {
+	}
+
+	public void populateUnderworld(IChunkProvider var1, int var2, int var3) {
+	}
+
+	public void upgradeHeight(IChunkProvider var1, Chunk var2, World var3) {
 	}
 }
--- /dev/null
+++ net/minecraft/src/ItemMagic.java
@@ -1,0 +1,25 @@
+package net.minecraft.src;
+
+public class ItemMagic extends Item {
+	public float useMana;
+
+	public ItemMagic(int var1, float var2) {
+		super(var1);
+		this.useMana = var2;
+	}
+
+	public ItemStack onMagicItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
+		return var1;
+	}
+
+	public ItemStack onItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
+		if (var3.useMana(this.useMana)) {
+			return this.onMagicItemRightClick(var1, var2, var3);
+		}
+		return var1;
+	}
+
+	public boolean isMagic() {
+		return true;
+	}
+}
--- net/minecraft/src/CanvasMinecraftApplet.java
+++ net/minecraft/src/CanvasMinecraftApplet.java
@@ -1,10 +1,11 @@
 package net.minecraft.src;
 
 import java.awt.Canvas;
+
 import net.minecraft.client.MinecraftApplet;
 
 public class CanvasMinecraftApplet extends Canvas {
-	final MinecraftApplet mcApplet;
+	public final MinecraftApplet mcApplet;
 
 	public CanvasMinecraftApplet(MinecraftApplet var1) {
 		this.mcApplet = var1;
--- net/minecraft/src/BlockSnowBlock.java
+++ net/minecraft/src/BlockSnowBlock.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockSnowBlock extends Block {
-	protected BlockSnowBlock(int var1, int var2) {
+	public BlockSnowBlock(int var1, int var2) {
 		super(var1, var2, Material.craftedSnow);
 		this.setTickOnLoad(true);
 	}
--- net/minecraft/src/RecipesTools.java
+++ net/minecraft/src/RecipesTools.java
@@ -2,15 +2,20 @@
 
 public class RecipesTools {
 	private String[][] recipePatterns = new String[][]{{"XXX", " # ", " # "}, {"X", "#", "#"}, {"XX", "X#", " #"}, {"XX", " #", " #"}};
-	private Object[][] recipeItems = new Object[][]{{Block.planks, Block.cobblestone, Item.ingotIron, Item.diamond, Item.ingotGold}, {Item.pickaxeWood, Item.pickaxeStone, Item.pickaxeSteel, Item.pickaxeDiamond, Item.pickaxeGold}, {Item.shovelWood, Item.shovelStone, Item.shovel, Item.shovelDiamond, Item.shovelGold}, {Item.axeWood, Item.axeStone, Item.axeSteel, Item.axeDiamond, Item.axeGold}, {Item.hoeWood, Item.hoeStone, Item.hoeSteel, Item.hoeDiamond, Item.hoeGold}};
+	private Object[][] recipeItems = new Object[][]{
+	{Block.planks, Block.cobblestone, Item.ingotIron, Item.diamond, Item.ingotGold},
+	{Item.pickaxeWood, Item.pickaxeStone, Item.pickaxeSteel, Item.pickaxeDiamond, Item.pickaxeGold},
+	{Item.shovelWood, Item.shovelStone, Item.shovel, Item.shovelDiamond, Item.shovelGold},
+	{Item.axeWood, Item.axeStone, Item.axeSteel, Item.axeDiamond, Item.axeGold},
+	{Item.hoeWood, Item.hoeStone, Item.hoeSteel, Item.hoeDiamond, Item.hoeGold}};
 
-	public void addRecipes(CraftingManager var1) {
+	public void addRecipes(CraftingManager craftingManager) {
 		for(int var2 = 0; var2 < this.recipeItems[0].length; ++var2) {
 			Object var3 = this.recipeItems[0][var2];
 
 			for(int var4 = 0; var4 < this.recipeItems.length - 1; ++var4) {
 				Item var5 = (Item)this.recipeItems[var4 + 1][var2];
-				var1.addRecipe(new ItemStack(var5), new Object[]{this.recipePatterns[var4], Character.valueOf('#'), Item.stick, Character.valueOf('X'), var3});
+				craftingManager.addRecipe(new ItemStack(var5), this.recipePatterns[var4], '#', Item.stick, 'X', var3);
 			}
 		}
 
--- net/minecraft/src/BlockStep.java
+++ net/minecraft/src/BlockStep.java
@@ -1,48 +1,89 @@
 package net.minecraft.src;
 
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Random;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 
 public class BlockStep extends Block {
-	private boolean blockType;
-
-	public BlockStep(int var1, boolean var2) {
-		super(var1, 6, Material.rock);
-		this.blockType = var2;
-		if(!var2) {
-			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
-		}
-
-		this.setLightOpacity(255);
-	}
-
-	public int getBlockTextureFromSide(int var1) {
-		return var1 <= 1 ? 6 : 5;
+	public final BitField fieldType;
+	public final BitFlag fieldHalf;
+
+	public final boolean blockType;
+	protected final BlockStepType[] slabTypes;
+
+	public BlockStep(int var1, Material var2, boolean var3, BlockStepType[] var4) {
+		super(var1, 6, var2);
+		if (var4.length > 128) {
+			throw new IllegalArgumentException("Too many slab types! 128 maximum!");
+		}
+
+		this.slabTypes = var4;
+		this.blockType = var3;
+		this.blockIndexInTexture = var4[0].topTexture;
+		if(!var3) {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+		}
+
+		this.fieldType = this.fields.addBitField("type", 7, Arrays.stream(var4)
+				.map(t -> t.name)
+				.collect(Collectors.toList()));
+		this.fieldHalf = this.fields.addBitFlag("half", "bottom", "top");
+	}
+
+	public void setBlockBoundsBasedOnState(IBlockAccess var1, int var2, int var3, int var4) {
+		if (this.blockType) {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else if (this.fieldHalf.get(var1.getBlockMetadata(var2, var3, var4))) {
+			this.setBlockBounds(0.0F, 0.5F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+		}
+	}
+
+	public void setBlockBoundsForItemRender() {
+		if (this.blockType) {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+		} else {
+			this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+		}
+	}
+
+	public void getCollidingBoundingBoxes(World var1, int var2, int var3, int var4, AxisAlignedBB var5, ArrayList var6) {
+		this.setBlockBoundsBasedOnState(var1, var2, var3, var4);
+		super.getCollidingBoundingBoxes(var1, var2, var3, var4, var5, var6);
+	}
+
+	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
+		int type = this.fieldType.get(var2);
+		if (type < slabTypes.length) {
+			return slabTypes[type].getTextureFromSide(var1);
+		}
+		return var1 <= 1 ? 14 : 13;
 	}
 
 	public boolean isOpaqueCube() {
 		return this.blockType;
 	}
 
-	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
-		if(this == Block.stairSingle) {
-		}
-	}
-
-	public void onBlockAdded(World var1, int var2, int var3, int var4) {
-		if(this != Block.stairSingle) {
-			super.onBlockAdded(var1, var2, var3, var4);
-		}
-
-		int var5 = var1.getBlockId(var2, var3 - 1, var4);
-		if(var5 == stairSingle.blockID) {
-			var1.setBlockWithNotify(var2, var3, var4, 0);
-			var1.setBlockWithNotify(var2, var3 - 1, var4, Block.stairDouble.blockID);
-		}
-
+	public int onBlockPlaced(World var1, int var2, int var3, int var4, int var5, float hitx, float hity, float hitz, int meta) {
+		if (!this.blockType && var5 != 1 && (var5 == 0 || hity >= 0.5F)) {
+			meta = this.fieldHalf.set(meta, true);
+		}
+		return meta;
 	}
 
 	public int idDropped(int var1, Random var2) {
-		return Block.stairSingle.blockID;
+		return this.blockType ? this.blockID + 1 : this.blockID;
+	}
+
+	public int quantityDropped(Random var1) {
+		return this.blockType ? 2 : 1;
+	}
+
+	public int metadataDropped(int var1, int var2, Random var3) {
+		return this.fieldType.get(var1);
 	}
 
 	public boolean renderAsNormalBlock() {
@@ -50,10 +91,28 @@
 	}
 
 	public boolean shouldSideBeRendered(IBlockAccess var1, int var2, int var3, int var4, int var5) {
-		if(this != Block.stairSingle) {
-			super.shouldSideBeRendered(var1, var2, var3, var4, var5);
-		}
+        if (this.blockType) {
+            return super.shouldSideBeRendered(var1, var2, var3, var4, var5);
+        } else if (var5 != 1 && var5 != 0 && !super.shouldSideBeRendered(var1, var2, var3, var4, var5)) {
+            return false;
+        } else {
+            int var6 = var2 + Facing.offsetsXForSide[Facing.oppositeSide[var5]];
+            int var7 = var3 + Facing.offsetsYForSide[Facing.oppositeSide[var5]];
+            int var8 = var4 + Facing.offsetsZForSide[Facing.oppositeSide[var5]];
+            boolean var9 = this.fieldHalf.get(var1.getBlockMetadata(var6, var7, var8));
+            return var9
+                    ? var5 == 0
+		                    || var5 == 1 && super.shouldSideBeRendered(var1, var2, var3, var4, var5)
+		                    || !(var1.getBlock(var2, var3, var4) instanceof BlockStep)
+		                    || !this.fieldHalf.get(var1.getBlockMetadata(var2, var3, var4))
+                    : var5 == 1
+		                    || var5 == 0 && super.shouldSideBeRendered(var1, var2, var3, var4, var5)
+		                    || !(var1.getBlock(var2, var3, var4) instanceof BlockStep)
+		                    || this.fieldHalf.get(var1.getBlockMetadata(var2, var3, var4));
+        }
+    }
 
-		return var5 == 1 ? true : (!super.shouldSideBeRendered(var1, var2, var3, var4, var5) ? false : (var5 == 0 ? true : var1.getBlockId(var2, var3, var4) != this.blockID));
+	public int[] availableMetadata() {
+		return IntStream.range(0, this.slabTypes.length).toArray();
 	}
 }
--- net/minecraft/src/MCHashTable2.java
+++ /dev/null
@@ -1,128 +1,0 @@
-package net.minecraft.src;
-
-public class MCHashTable2 {
-	private transient MCHashEntry2[] slots = new MCHashEntry2[16];
-	private transient int count;
-	private int threshold = 12;
-	private final float growFactor = 12.0F / 16.0F;
-	private transient volatile int versionStamp;
-
-	private static int computeHash(long var0) {
-		return computeHash((int)(var0 ^ var0 >>> 32));
-	}
-
-	private static int computeHash(int var0) {
-		var0 ^= var0 >>> 20 ^ var0 >>> 12;
-		return var0 ^ var0 >>> 7 ^ var0 >>> 4;
-	}
-
-	private static int getSlotIndex(int var0, int var1) {
-		return var0 & var1 - 1;
-	}
-
-	public Object lookup(long var1) {
-		int var3 = computeHash(var1);
-
-		for(MCHashEntry2 var4 = this.slots[getSlotIndex(var3, this.slots.length)]; var4 != null; var4 = var4.nextEntry) {
-			if(var4.hashEntry == var1) {
-				return var4.valueEntry;
-			}
-		}
-
-		return null;
-	}
-
-	public void addKey(long var1, Object var3) {
-		int var4 = computeHash(var1);
-		int var5 = getSlotIndex(var4, this.slots.length);
-
-		for(MCHashEntry2 var6 = this.slots[var5]; var6 != null; var6 = var6.nextEntry) {
-			if(var6.hashEntry == var1) {
-				var6.valueEntry = var3;
-			}
-		}
-
-		++this.versionStamp;
-		this.insert(var4, var1, var3, var5);
-	}
-
-	private void grow(int var1) {
-		MCHashEntry2[] var2 = this.slots;
-		int var3 = var2.length;
-		if(var3 == 1073741824) {
-			this.threshold = Integer.MAX_VALUE;
-		} else {
-			MCHashEntry2[] var4 = new MCHashEntry2[var1];
-			this.copyTo(var4);
-			this.slots = var4;
-			this.threshold = (int)((float)var1 * this.growFactor);
-		}
-	}
-
-	private void copyTo(MCHashEntry2[] var1) {
-		MCHashEntry2[] var2 = this.slots;
-		int var3 = var1.length;
-
-		for(int var4 = 0; var4 < var2.length; ++var4) {
-			MCHashEntry2 var5 = var2[var4];
-			if(var5 != null) {
-				var2[var4] = null;
-
-				MCHashEntry2 var6;
-				do {
-					var6 = var5.nextEntry;
-					int var7 = getSlotIndex(var5.slotHash, var3);
-					var5.nextEntry = var1[var7];
-					var1[var7] = var5;
-					var5 = var6;
-				} while(var6 != null);
-			}
-		}
-
-	}
-
-	public Object removeObject(long var1) {
-		MCHashEntry2 var3 = this.removeEntry(var1);
-		return var3 == null ? null : var3.valueEntry;
-	}
-
-	final MCHashEntry2 removeEntry(long var1) {
-		int var3 = computeHash(var1);
-		int var4 = getSlotIndex(var3, this.slots.length);
-		MCHashEntry2 var5 = this.slots[var4];
-
-		MCHashEntry2 var6;
-		MCHashEntry2 var7;
-		for(var6 = var5; var6 != null; var6 = var7) {
-			var7 = var6.nextEntry;
-			if(var6.hashEntry == var1) {
-				++this.versionStamp;
-				--this.count;
-				if(var5 == var6) {
-					this.slots[var4] = var7;
-				} else {
-					var5.nextEntry = var7;
-				}
-
-				return var6;
-			}
-
-			var5 = var6;
-		}
-
-		return var6;
-	}
-
-	private void insert(int var1, long var2, Object var4, int var5) {
-		MCHashEntry2 var6 = this.slots[var5];
-		this.slots[var5] = new MCHashEntry2(var1, var2, var4, var6);
-		if(this.count++ >= this.threshold) {
-			this.grow(2 * this.slots.length);
-		}
-
-	}
-
-	static int getHash(long var0) {
-		return computeHash(var0);
-	}
-}
--- /dev/null
+++ net/minecraft/src/ScreenShotHelper.java
@@ -1,0 +1,81 @@
+package net.minecraft.src;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.nio.ByteBuffer;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import javax.imageio.ImageIO;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.GL11;
+
+public class ScreenShotHelper {
+	private static DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss");
+	private static ByteBuffer buffer;
+	private static byte[] pixelData;
+	private static int[] imageData;
+
+	public static String saveScreenshot(File var0, int var1, int var2) {
+		return func_35879_a(var0, (String)null, var1, var2);
+	}
+
+	public static String func_35879_a(File var0, String var1, int var2, int var3) {
+		try {
+			File var4 = new File(var0, "screenshots");
+			var4.mkdir();
+			if(buffer == null || buffer.capacity() < var2 * var3 * 3) {
+				buffer = BufferUtils.createByteBuffer(var2 * var3 * 3);
+			}
+
+			if(imageData == null || imageData.length < var2 * var3 * 3) {
+				pixelData = new byte[var2 * var3 * 3];
+				imageData = new int[var2 * var3];
+			}
+
+			GL11.glPixelStorei(GL11.GL_PACK_ALIGNMENT, 1);
+			GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT, 1);
+			buffer.clear();
+			GL11.glReadPixels(0, 0, var2, var3, GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)buffer);
+			buffer.clear();
+			String var5 = "" + dateFormat.format(new Date());
+			File var6;
+			int var7;
+			if(var1 == null) {
+				var7 = 1;
+
+				while(true) {
+					var6 = new File(var4, var5 + (var7 == 1 ? "" : "_" + var7) + ".png");
+					if(!var6.exists()) {
+						break;
+					}
+
+					++var7;
+				}
+			} else {
+				var6 = new File(var4, var1);
+			}
+
+			buffer.get(pixelData);
+
+			for(var7 = 0; var7 < var2; ++var7) {
+				for(int var8 = 0; var8 < var3; ++var8) {
+					int var9 = var7 + (var3 - var8 - 1) * var2;
+					int var10 = pixelData[var9 * 3 + 0] & 255;
+					int var11 = pixelData[var9 * 3 + 1] & 255;
+					int var12 = pixelData[var9 * 3 + 2] & 255;
+					int var13 = -16777216 | var10 << 16 | var11 << 8 | var12;
+					imageData[var7 + var8 * var2] = var13;
+				}
+			}
+
+			BufferedImage var15 = new BufferedImage(var2, var3, 1);
+			var15.setRGB(0, 0, var2, var3, imageData, 0, var2);
+			ImageIO.write(var15, "png", var6);
+			return "Saved screenshot as " + var6.getName();
+		} catch (Exception var14) {
+			var14.printStackTrace();
+			return "Failed to save: " + var14;
+		}
+	}
+}
--- net/minecraft/src/IChunkProvider.java
+++ net/minecraft/src/IChunkProvider.java
@@ -7,9 +7,25 @@
 
 	void populate(IChunkProvider var1, int var2, int var3);
 
+	void populateUnderworld(IChunkProvider var1, int var2, int var3);
+
+	void upgradeHeight(IChunkProvider var1, Chunk var2, World var3);
+
 	boolean saveChunks(boolean var1, IProgressUpdate var2);
 
 	boolean unload100OldestChunks();
 
 	boolean canSave();
+
+	default String[] getDebugInfo(int x, int y, int z) {
+		return null;
+	}
+
+	default boolean isOcean(int x, int z) {
+		return false;
+	}
+
+	default boolean isRiver(int x, int z) {
+		return false;
+	}
 }
--- net/minecraft/src/BlockSign.java
+++ net/minecraft/src/BlockSign.java
@@ -6,10 +6,10 @@
 	private Class signEntityClass;
 	private boolean isFreestanding;
 
-	protected BlockSign(int var1, Class var2, boolean var3) {
+	public BlockSign(int var1, Class var2, boolean var3) {
 		super(var1, Material.wood);
 		this.isFreestanding = var3;
-		this.blockIndexInTexture = 4;
+		this.blockIndexInTexture = textureXY(2, 8);
 		this.signEntityClass = var2;
 		float var4 = 0.25F;
 		float var5 = 1.0F;
--- net/minecraft/src/GuiStatsComponent.java
+++ net/minecraft/src/GuiStatsComponent.java
@@ -5,6 +5,7 @@
 import java.awt.Graphics;
 import javax.swing.JComponent;
 
+import net.minecraft.server.MinecraftServer;
 public class GuiStatsComponent extends JComponent {
 	private int[] memoryUse = new int[256];
 	private int updateCounter = 0;
@@ -23,6 +24,7 @@
 		System.gc();
 		this.displayStrings[0] = "Memory use: " + var1 / 1024L / 1024L + " mb (" + Runtime.getRuntime().freeMemory() * 100L / Runtime.getRuntime().maxMemory() + "% free)";
 		this.displayStrings[1] = "Threads: " + NetworkManager.numReadThreads + " + " + NetworkManager.numWriteThreads;
+		this.displayStrings[2] = "Ticks behind: " + MinecraftServer.getInstance().getTicksBehind();
 		this.memoryUse[this.updateCounter++ & 255] = (int)(var1 * 100L / Runtime.getRuntime().maxMemory());
 		this.repaint();
 	}
@@ -49,7 +51,7 @@
 
 	}
 
-	static void update(GuiStatsComponent var0) {
+	public static void update(GuiStatsComponent var0) {
 		var0.update();
 	}
 }
--- /dev/null
+++ net/minecraft/src/InventoryBasic.java
@@ -1,0 +1,67 @@
+package net.minecraft.src;
+
+public class InventoryBasic implements IInventory {
+	private String field_20072_a;
+	private int field_20071_b;
+	private ItemStack[] field_20074_c;
+
+	public InventoryBasic(String var1, int var2) {
+		this.field_20072_a = var1;
+		this.field_20071_b = var2;
+		this.field_20074_c = new ItemStack[var2];
+	}
+
+	public ItemStack getStack(int var1) {
+		return this.field_20074_c[var1];
+	}
+
+	public ItemStack decrStack(int var1, int var2) {
+		if(this.field_20074_c[var1] != null) {
+			ItemStack var3;
+			if(this.field_20074_c[var1].stackSize <= var2) {
+				var3 = this.field_20074_c[var1];
+				this.field_20074_c[var1] = null;
+				this.onInventoryChange();
+				return var3;
+			} else {
+				var3 = this.field_20074_c[var1].splitStack(var2);
+				if(this.field_20074_c[var1].stackSize == 0) {
+					this.field_20074_c[var1] = null;
+				}
+
+				this.onInventoryChange();
+				return var3;
+			}
+		} else {
+			return null;
+		}
+	}
+
+	public void setInventorySlotItem(int var1, ItemStack var2) {
+		this.field_20074_c[var1] = var2;
+		if(var2 != null && var2.stackSize > this.getStackLimit()) {
+			var2.stackSize = this.getStackLimit();
+		}
+
+		this.onInventoryChange();
+	}
+
+	public void onInventoryChange() {
+	}
+
+	public int getInventorySize() {
+		return this.field_20071_b;
+	}
+
+	public String getInventoryName() {
+		return this.field_20072_a;
+	}
+
+	public int getStackLimit() {
+		return 64;
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return true;
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiAchievements.java
@@ -1,0 +1,81 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+public class GuiAchievements extends GuiScreen {
+	private final GuiScreen parentScreen;
+	private GuiSliderGeneric scrollbar;
+
+	public GuiAchievements(GuiScreen parentScreen) {
+		this.parentScreen = parentScreen;
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(0, this.width / 2 - 50, this.height - 24, 100, 20, "Exit"));
+
+		int rows = 0;
+		for (Achievement achievement : Achievement.list) {
+			if (!achievement.secret || achievement.getProgressFloat() >= 1.0F) {
+				rows++;
+			}
+		}
+
+		this.scrollbar = new GuiSliderGeneric(1, this.width - 18, 32, 18, this.height - 64, null, 0.0F,
+				Math.max((rows * 56) - this.height + 72, 0.0F));
+		this.scrollbar.vertical = true;
+		this.scrollbar.hideBg = true;
+		this.controlList.add(this.scrollbar);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1.id == 0) {
+			this.mc.displayGuiScreen(this.parentScreen);
+		}
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground(var3);
+		this.drawRect(this.width - 18, 32, this.width, this.height - 32, 0xFF202020);
+		int row = 0;
+		for (Achievement achievement : Achievement.list) {
+			if (!achievement.secret || achievement.getProgressFloat() >= 1.0F) {
+				this.drawAchievement(achievement, row++);
+			}
+		}
+
+		this.drawHeader("Achievements");
+		super.drawScreen(var1, var2, var3);
+	}
+
+	public void drawAchievement(Achievement achievement, int i) {
+		float progress = achievement.getProgressFloat();
+		boolean achieved = progress >= 1.0F;
+		boolean hidden = achievement.secret && !achieved;
+		int x = (this.width - 256) / 2;
+		int y = 40 + (int)(-this.scrollbar.sliderValue * this.scrollbar.multiplier) + i * 56;
+
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("@@/gui/panel.png"));
+		this.drawTexturedModalRect(x, y, 0, 0, 256, 48);
+		this.drawTexturedModalRect(x + 7, y + 7, 0, 48, 34, 34);
+		this.drawTexturedModalRect(x + 243, y + 7, 34, 48, 6, 34);
+
+		if (hidden) {
+			this.drawRect(x + 8, y + 8, x + 40, y + 40, 0xFF000000);
+		} else {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture(
+					"/achievement/" + achievement.id + (achieved ? ".png" : "_locked.png")));
+			this.drawTexturedModalRect(x + 8, y + 8, 0, 0, 32, 32, 32.0F);
+		}
+
+		this.drawRect(x + 244, y + 8 + (int)(32.0F - 32.0F * achievement.getProgressFloat()), x + 248, y + 40, 0xFF00FF00);
+
+		this.fontRenderer.drawBoldStringWithShadow(hidden ? "???" : achievement.title, x + 43, y + 7, achievement.secret ? 0xFF55FF : 0xFFFF55);
+		this.fontRenderer.drawStringWrapped(hidden ? "This is a secret achievement. Do something very special to unlock it!"
+				: achievement.description, x + 43, y + 16, 196, 0xFFFFFF);
+	}
+
+	protected void mouseScrolled(int delta) {
+		this.scrollbar.mouseScrolled(delta / 10.0F * this.scrollbar.multiplier);
+	}
+}
--- /dev/null
+++ net/minecraft/src/McRegionChunkLoader.java
@@ -1,0 +1,94 @@
+package net.minecraft.src;
+
+import java.io.*;
+
+public class McRegionChunkLoader implements IChunkLoader {
+	private File saveDir;
+
+	public McRegionChunkLoader(File saveDir) {
+		this.saveDir = saveDir;
+	}
+
+	private File chunkFileForXZ(int chunkX, int chunkZ) {
+		String fileName = "c." + Integer.toString(chunkX, 36) + "." + Integer.toString(chunkZ, 36) + ".dat";
+		String dir1 = Integer.toString(chunkX & 63, 36);
+		String dir2 = Integer.toString(chunkZ & 63, 36);
+		File file = new File(this.saveDir, dir1);
+		file = new File(file, dir2);
+		file = new File(file, fileName);
+		return file;
+	}
+
+	public Chunk loadChunk(World worldObj, int chunkX, int chunkZ) throws IOException {
+		DataInputStream regionChunkInputStream = RegionFileCache.getChunkDataInputStream(this.saveDir, chunkX, chunkZ);
+		File chunkFile = this.chunkFileForXZ(chunkX, chunkZ);
+		NBTTagCompound nbt;
+		if(regionChunkInputStream != null) {
+			nbt = CompressedStreamTools.read(regionChunkInputStream);
+		} else {
+			if(!chunkFile.exists()) {
+				return null;
+			}
+
+			try {
+				FileInputStream fileInputStream5 = new FileInputStream(chunkFile);
+				nbt = CompressedStreamTools.readCompressed(fileInputStream5);
+			} catch (Exception exception8) {
+				exception8.printStackTrace();
+				return null;
+			}
+		}
+
+		if(!nbt.hasKey("Level")) {
+			System.out.println("Chunk file at " + chunkX + "," + chunkZ + " is missing level data, skipping");
+			return null;
+		} else if(!nbt.getCompoundTag("Level").hasKey("Blocks")) {
+			System.out.println("Chunk file at " + chunkX + "," + chunkZ + " is missing block data, skipping");
+			return null;
+		} else {
+			Chunk chunk7 = ChunkLoader.loadChunkIntoWorldFromCompound(worldObj, nbt.getCompoundTag("Level"));
+			if(!chunk7.isAtLocation(chunkX, chunkZ)) {
+				System.out.println("Chunk file at " + chunkX + "," + chunkZ + " is in the wrong location; relocating. (Expected " + chunkX + ", " + chunkZ + ", got " + chunk7.xPosition + ", " + chunk7.zPosition + ")");
+				nbt.setInteger("xPos", chunkX);
+				nbt.setInteger("zPos", chunkZ);
+				chunk7 = ChunkLoader.loadChunkIntoWorldFromCompound(worldObj, nbt.getCompoundTag("Level"));
+			}
+
+			try {
+				if(regionChunkInputStream != null) {
+					regionChunkInputStream.close();
+				}
+			} catch (IOException iOException8) {
+			}
+
+			return chunk7;
+		}
+	}
+
+	public void saveChunk(World worldObj, Chunk chunk) throws IOException {
+		worldObj.checkSessionLock();
+
+		try {
+			DataOutputStream output = RegionFileCache.getChunkDataOutputStream(this.saveDir, chunk.xPosition, chunk.zPosition);
+			NBTTagCompound nBTTagCompound6 = new NBTTagCompound();
+			NBTTagCompound nBTTagCompound7 = new NBTTagCompound();
+			nBTTagCompound6.setTag("Level", nBTTagCompound7);
+			ChunkLoader.storeChunkInCompound(chunk, worldObj, nBTTagCompound7);
+			CompressedStreamTools.write(nBTTagCompound6, output);
+			output.close();
+			worldObj.sizeOnDisk += (long)RegionFileCache.getSizeDelta(this.saveDir, chunk.xPosition, chunk.zPosition);
+		} catch (Exception exception8) {
+			exception8.printStackTrace();
+		}
+
+	}
+
+	public void chunkTick() {
+	}
+
+	public void saveExtraData() {
+	}
+
+	public void saveExtraChunkData(World worldObj, Chunk chunk) {
+	}
+}
--- net/minecraft/src/EffectRenderer.java
+++ net/minecraft/src/EffectRenderer.java
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
+
 import org.lwjgl.opengl.GL11;
 
 public class EffectRenderer {
@@ -104,19 +105,18 @@
 
 	}
 
-	public void addBlockDestroyEffects(int var1, int var2, int var3) {
-		int var4 = this.worldObj.getBlockId(var1, var2, var3);
+	public void addBlockDestroyEffects(int var1, int var2, int var3, int var4, int var5) {
 		if(var4 != 0) {
-			Block var5 = Block.blocksList[var4];
-			byte var6 = 4;
+			Block var6 = Block.blocksList[var4];
+			byte var7 = 4;
 
-			for(int var7 = 0; var7 < var6; ++var7) {
-				for(int var8 = 0; var8 < var6; ++var8) {
-					for(int var9 = 0; var9 < var6; ++var9) {
-						double var10 = (double)var1 + ((double)var7 + 0.5D) / (double)var6;
-						double var12 = (double)var2 + ((double)var8 + 0.5D) / (double)var6;
-						double var14 = (double)var3 + ((double)var9 + 0.5D) / (double)var6;
-						this.addEffect(new EntityDiggingFX(this.worldObj, var10, var12, var14, var10 - (double)var1 - 0.5D, var12 - (double)var2 - 0.5D, var14 - (double)var3 - 0.5D, var5));
+			for(int var8 = 0; var8 < var7; ++var8) {
+				for(int var9 = 0; var9 < var7; ++var9) {
+					for(int var10 = 0; var10 < var7; ++var10) {
+						double var11 = (double)var1 + ((double)var8 + 0.5D) / (double)var7;
+						double var13 = (double)var2 + ((double)var9 + 0.5D) / (double)var7;
+						double var15 = (double)var3 + ((double)var10 + 0.5D) / (double)var7;
+						this.addEffect((new EntityDiggingFX(this.worldObj, var11, var13, var15, var11 - (double)var1 - 0.5D, var13 - (double)var2 - 0.5D, var15 - (double)var3 - 0.5D, var6, var5)));
 					}
 				}
 			}
@@ -156,7 +156,8 @@
 				var8 = (double)var1 + var6.maxX + (double)var7;
 			}
 
-			this.addEffect((new EntityDiggingFX(this.worldObj, var8, var10, var12, 0.0D, 0.0D, 0.0D, var6)).multiplyVelocity(0.2F).multipleParticleScaleBy(0.6F));
+			this.addEffect((new EntityDiggingFX(this.worldObj, var8, var10, var12, 0.0D, 0.0D, 0.0D, var6, this.worldObj.getBlockMetadata(var1, var2, var3)))
+					.multiplyVelocity(0.2F).multipleParticleScaleBy(0.6F));
 		}
 	}
 
--- /dev/null
+++ net/minecraft/src/FurnaceRecipe.java
@@ -1,0 +1,24 @@
+package net.minecraft.src;
+
+public class FurnaceRecipe {
+	private final ItemStack input, output;
+
+	public FurnaceRecipe(ItemStack input, ItemStack output) {
+		this.input = input;
+		this.output = output;
+	}
+
+	public ItemStack getInput() {
+		return input;
+	}
+
+	public ItemStack getOutput(ItemStack input) {
+		return output.itemMetadata == -1 ? output.copy().withMetadata(input.itemMetadata) : output;
+	}
+
+	public boolean canSmelt(ItemStack input) {
+		return this.input.itemID == input.itemID
+				&& (this.input.itemMetadata == -1
+					|| this.input.itemMetadata == input.itemMetadata);
+	}
+}
--- net/minecraft/src/GuiEditSign.java
+++ net/minecraft/src/GuiEditSign.java
@@ -21,6 +21,9 @@
 
 	public void onGuiClosed() {
 		Keyboard.enableRepeatEvents(false);
+		if (this.mc.theWorld.multiplayerWorld) {
+			this.mc.getSendQueue().addToSendQueue(new Packet130UpdateSign(this.entitySign.xCoord, this.entitySign.yCoord, this.entitySign.zCoord, this.entitySign.signText));
+		}
 	}
 
 	public void updateScreen() {
@@ -30,7 +33,7 @@
 	protected void actionPerformed(GuiButton var1) {
 		if(var1.enabled) {
 			if(var1.id == 0) {
-				this.entitySign.onInventoryChanged();
+				this.entitySign.onInventoryChange();
 				this.mc.displayGuiScreen((GuiScreen)null);
 			}
 
@@ -57,7 +60,7 @@
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 40, 16777215);
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)(this.width / 2), (float)(this.height / 2), 50.0F);
--- /dev/null
+++ net/minecraft/src/TileEntityRefabricator.java
@@ -1,0 +1,147 @@
+package net.minecraft.src;
+
+import java.util.Objects;
+
+public class TileEntityRefabricator extends TileEntity implements IInventory {
+	private ItemStack[] items = new ItemStack[2];
+	private EntityItem displayItem;
+	public int refabricationTime;
+
+	public void onSpawn() {
+		displayItem = new EntityItem(this.worldObj, this.xCoord + 0.5D, this.yCoord + 1.5D, this.zCoord + 0.5D, null);
+	}
+
+	public EntityItem getDisplayItem() {
+		return this.displayItem;
+	}
+
+	public int getInventorySize() {
+		return this.items.length;
+	}
+
+	public ItemStack getStack(int var1) {
+		return this.items[var1];
+	}
+
+	public ItemStack decrStack(int slot, int stackSize) {
+		if(this.items[slot] != null) {
+			ItemStack var3;
+			if(this.items[slot].stackSize <= stackSize) {
+				var3 = this.items[slot];
+				this.items[slot] = null;
+			} else {
+				var3 = this.items[slot].splitStack(stackSize);
+				if(this.items[slot].stackSize == 0) {
+					this.items[slot] = null;
+				}
+			}
+			return var3;
+		} else {
+			return null;
+		}
+	}
+
+	public void setInventorySlotItem(int slot, ItemStack itemStack) {
+		this.items[slot] = itemStack;
+		if(itemStack != null && itemStack.stackSize > this.getStackLimit()) {
+			itemStack.stackSize = this.getStackLimit();
+		}
+	}
+
+	public String getInventoryName() {
+		return "Refabricator";
+	}
+
+	public int getStackLimit() {
+		return 64;
+	}
+
+	public boolean canRefabricate() {
+		ItemStack input = this.items[0];
+		ItemStack fuel = this.items[1];
+
+		if (input == null || fuel == null) return false;
+
+		if (fuel.itemID == Item.starDust.shiftedIndex) {
+			return fuel.stackSize > 0 && input.itemDmg > 0 && Objects.requireNonNull(input.getItem()).allowRepair();
+		} else if (fuel.getItem() instanceof ItemTrinket) {
+			return input.getTrinket() == null && ((ItemTrinket)fuel.getItem()).isApplicable(input.getItem());
+		}
+
+		return false;
+	}
+
+	public void readFromNBT(NBTTagCompound var1) {
+		super.readFromNBT(var1);
+		NBTTagList nBTTagList2 = var1.getTagList("Items");
+		this.items = new ItemStack[this.getInventorySize()];
+
+		for(int var3 = 0; var3 < nBTTagList2.tagCount(); ++var3) {
+			NBTTagCompound nBTTagCompound4 = (NBTTagCompound)nBTTagList2.tagAt(var3);
+			byte var5 = nBTTagCompound4.getByte("Slot");
+			if(var5 >= 0 && var5 < this.items.length) {
+				this.items[var5] = new ItemStack(nBTTagCompound4);
+			}
+		}
+
+		this.refabricationTime = var1.getInteger("FabricationTime");
+	}
+
+	public void writeToNBT(NBTTagCompound var1) {
+		super.writeToNBT(var1);
+
+		NBTTagList nBTTagList2 = new NBTTagList();
+		for(int var3 = 0; var3 < this.items.length; ++var3) {
+			if(this.items[var3] != null) {
+				NBTTagCompound nBTTagCompound4 = new NBTTagCompound();
+				nBTTagCompound4.setByte("Slot", (byte)var3);
+				this.items[var3].writeToNBT(nBTTagCompound4);
+				nBTTagList2.setTag(nBTTagCompound4);
+			}
+		}
+		var1.setTag("Items", nBTTagList2);
+		var1.setInteger("FabricationTime", this.refabricationTime);
+	}
+
+	public int getProgressScaled(int scale) {
+		return this.refabricationTime * scale / 200;
+	}
+
+	public void updateEntity() {
+		this.displayItem.item = this.items[0];
+		this.displayItem.age++;
+		if (this.displayItem.age >= 6000) {
+			this.displayItem.age = 0;
+		}
+		this.displayItem.isDead = false;
+
+		if (!canRefabricate()) {
+			this.refabricationTime -= 10;
+			if (this.refabricationTime < 0) {
+				this.refabricationTime = 0;
+			}
+			return;
+		}
+
+		this.refabricationTime++;
+		if (this.refabricationTime >= 200) {
+			ItemStack input = this.items[0];
+			ItemStack fuel = this.items[1];
+
+			if (fuel.getItem() instanceof ItemTrinket) {
+				input.applyTrinket((ItemTrinket)fuel.getItem());
+			} else if (fuel.itemID == Item.starDust.shiftedIndex) {
+				input.itemDmg -= input.getItem().maxDamage / 4;
+				if (input.itemDmg < 0) input.itemDmg = 0;
+			}
+
+			this.decrStack(1, 1);
+			this.refabricationTime = 0;
+			this.displayItem.item = this.items[0];
+		}
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return this.worldObj.getBlockTileEntity(this.xCoord, this.yCoord, this.zCoord) == this && var1.getDistanceSq((double) this.xCoord + 0.5D, (double) this.yCoord + 0.5D, (double) this.zCoord + 0.5D) <= 64.0D;
+	}
+}
--- /dev/null
+++ net/minecraft/src/Hook1.java
@@ -1,0 +1,9 @@
+package net.minecraft.src;
+
+public interface Hook1<T1> {
+	void call(BaseMod mod, T1 t1);
+
+	default Hook bind(T1 t1) {
+		return (BaseMod mod) -> call(mod, t1);
+	}
+}
--- net/minecraft/src/TileEntityRenderer.java
+++ net/minecraft/src/TileEntityRenderer.java
@@ -3,6 +3,7 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+
 import org.lwjgl.opengl.GL11;
 
 public class TileEntityRenderer {
@@ -24,6 +25,7 @@
 	private TileEntityRenderer() {
 		this.specialRendererMap.put(TileEntitySign.class, new TileEntitySignRenderer());
 		this.specialRendererMap.put(TileEntityMobSpawner.class, new TileEntityMobSpawnerRenderer());
+		this.specialRendererMap.put(TileEntityRefabricator.class, new TileEntityRefabricatorRender());
 		Iterator var1 = this.specialRendererMap.values().iterator();
 
 		while(var1.hasNext()) {
--- /dev/null
+++ net/minecraft/src/ItemSalvationTrinket.java
@@ -1,0 +1,32 @@
+package net.minecraft.src;
+
+import java.util.stream.Stream;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+public class ItemSalvationTrinket extends ItemTrinket {
+	public final float damageReduction;
+
+	public ItemSalvationTrinket(int var1, String var2, float var3) {
+		super(var1, var2);
+		this.damageReduction = var3;
+	}
+
+	public int getColor() {
+		return 0x4444BB;
+	}
+
+	public boolean isApplicable(Item item) {
+		return item instanceof ItemArmor;
+	}
+
+	public float modifyDamageTaken(float damage) {
+		return damage * this.damageReduction;
+	}
+
+	public Object[] getTooltipInfo() {
+		return Stream.of(new Object[] {
+				"Reduces damage taken by " + formatFloat(this.damageReduction / 2.0F) + " hearts", DESCRIPTION_COL,
+		}, super.getTooltipInfo()).flatMap(Stream::of).toArray();
+	}
+}
--- /dev/null
+++ net/minecraft/src/ModelBaseballCap.java
@@ -1,0 +1,31 @@
+package net.minecraft.src;
+
+public class ModelBaseballCap extends ModelBiped {
+	public ModelRenderer bipedBrim;
+	public ModelRenderer bipedHat;
+
+	public ModelBaseballCap(float var1) {
+		super(var1);
+		this.bipedHat = new ModelRenderer(0, 0);
+		this.bipedHat.addBox(-4.0F, -8.0F, -4.0F, 8, 4, 8, var1);
+		this.bipedHat.setRotationPoint(0.0F, 0.0F, 0.0F);
+		this.bipedBrim = new ModelRenderer(4, 12);
+		this.bipedBrim.addBox(-4.0F, -5.0F, -8.0F, 8, 1, 4, var1);
+		this.bipedBrim.setRotationPoint(0.0F, 0.0F, 0.0F);
+	}
+
+	public void render(float var1, float var2, float var3, float var4, float var5, float var6) {
+		this.setRotationAngles(var1, var2, var3, var4, var5, var6);
+		this.bipedBrim.render(var6);
+		this.bipedHat.render(var6);
+	}
+
+	public void setRotationAngles(float var1, float var2, float var3, float var4, float var5, float var6) {
+		super.setRotationAngles(var1, var2, var3, var4, var5, var6);
+
+		this.bipedBrim.rotateAngleX = this.bipedHat.rotateAngleX = this.bipedHead.rotateAngleX;
+		this.bipedBrim.rotateAngleY = this.bipedHat.rotateAngleY = this.bipedHead.rotateAngleY;
+		this.bipedBrim.rotateAngleZ = this.bipedHat.rotateAngleZ = this.bipedHead.rotateAngleZ;
+		this.bipedBrim.rotationPointY = this.bipedHat.rotationPointY = this.bipedHead.rotationPointY;
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiSliderGeneric.java
@@ -1,0 +1,142 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+
+import org.lwjgl.opengl.GL11;
+
+public class GuiSliderGeneric extends GuiButton {
+	public final String label;
+	public float multiplier;
+	public float sliderValue;
+	public boolean round;
+	public boolean dragging;
+	public boolean vertical;
+	public boolean hideBg;
+
+	public GuiSliderGeneric(int id, int x, int y, int w, int h, String label, float defaultValue, float multiplier) {
+		super(id, x, y, w, h, label);
+		this.width = w;
+		this.height = h;
+		this.label = label;
+		this.multiplier = multiplier;
+		this.sliderValue = defaultValue;
+		this.displayString = this.getDisplayString();
+	}
+
+	protected int getHoverState(boolean var1) {
+		return 0;
+	}
+
+	public float getValue() {
+		float value = this.sliderValue * this.multiplier;
+		if (round) {
+			value = (int) value;
+		}
+		return value;
+	}
+
+	public String getDisplayString() {
+		if (this.label == null) {
+			return "";
+		}
+
+		float value = getValue();
+		if (round) {
+			if (this.multiplier == 1.0F) {
+				return this.label + ": " + (int) value;
+			} else {
+				return this.label + ": " + (int) value + " / " + (int)this.multiplier;
+			}
+		} else {
+			if (this.multiplier == 1.0F) {
+				return this.label + ": " + value;
+			} else {
+				return this.label + ": " + value + " / " + this.multiplier;
+			}
+		}
+	}
+
+	protected void mouseDragged(Minecraft var1, int var2, int var3) {
+		if(this.visible) {
+			if(this.dragging) {
+				this.sliderValue = this.vertical
+						? (float)(var3 - (this.yPosition + 4)) / (float)(this.height - 8)
+						: (float)(var2 - (this.xPosition + 4)) / (float)(this.width - 8);
+				if(this.sliderValue < 0.0F) {
+					this.sliderValue = 0.0F;
+				}
+
+				if(this.sliderValue > 1.0F) {
+					this.sliderValue = 1.0F;
+				}
+
+				this.displayString = this.getDisplayString();
+			}
+
+
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			if (this.vertical) {
+				this.drawTexturedModalRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.height - 8)), 18, 112, this.width, 4);
+				this.drawTexturedModalRect(this.xPosition, this.yPosition + (int)(this.sliderValue * (float)(this.height - 8)) + 4, 18, 252, this.width, 4);
+			} else {
+				this.drawTexturedModalRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)), this.yPosition, 0, 66, 4, this.height);
+				this.drawTexturedModalRect(this.xPosition + (int)(this.sliderValue * (float)(this.width - 8)) + 4, this.yPosition, 196, 66, 4, this.height);
+			}
+		}
+	}
+
+	public boolean mousePressed(Minecraft var1, int var2, int var3) {
+		if(super.mousePressed(var1, var2, var3)) {
+			this.sliderValue = this.vertical
+					? (float)(var2 - (this.yPosition + 4)) / (float)(this.height - 8)
+					: (float)(var2 - (this.xPosition + 4)) / (float)(this.width - 8);
+
+			if(this.sliderValue < 0.0F) {
+				this.sliderValue = 0.0F;
+			}
+
+			if(this.sliderValue > 1.0F) {
+				this.sliderValue = 1.0F;
+			}
+
+			this.dragging = true;
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public void mouseReleased(int var1, int var2) {
+		this.dragging = false;
+	}
+
+	public void mouseScrolled(float delta) {
+		if (this.multiplier == 0.0F) return;
+
+		this.sliderValue -= delta / 120.0F / this.multiplier;
+
+		if(this.sliderValue < 0.0F) {
+			this.sliderValue = 0.0F;
+		}
+
+		if(this.sliderValue > 1.0F) {
+			this.sliderValue = 1.0F;
+		}
+	}
+
+	public void drawButton(Minecraft var1, int var2, int var3) {
+		if (!this.vertical) {
+			super.drawButton(var1, var2, var3);
+		}
+
+		if (this.visible) {
+			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1.renderEngine.getTexture("@@/gui/gui.png"));
+			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+			if (!this.hideBg) {
+				this.drawTexturedModalRect(this.xPosition, this.yPosition, 0, 112, this.width, this.height / 2);
+				this.drawTexturedModalRect(this.xPosition, this.yPosition + this.height / 2, 0, 256 - this.height / 2, this.width, this.height / 2);
+			}
+			this.mouseDragged(var1, var2, var3);
+		}
+	}
+}
--- net/minecraft/src/ServerGUI.java
+++ net/minecraft/src/ServerGUI.java
@@ -13,9 +13,9 @@
 import javax.swing.UIManager;
 import javax.swing.border.EtchedBorder;
 import javax.swing.border.TitledBorder;
+
 import net.minecraft.server.MinecraftServer;
-
-public class ServerGUI extends JComponent implements ICommandListener {
+public class ServerGUI extends JComponent implements IListenToMyCommands {
 	public static Logger logger = Logger.getLogger("Minecraft");
 	private MinecraftServer mcServer;
 
@@ -86,7 +86,7 @@
 		return "CONSOLE";
 	}
 
-	static MinecraftServer getMinecraftServer(ServerGUI var0) {
+	public static MinecraftServer getMinecraftServer(ServerGUI var0) {
 		return var0.mcServer;
 	}
 }
--- net/minecraft/src/ChunkProviderLoadOrGenerate.java
+++ net/minecraft/src/ChunkProviderLoadOrGenerate.java
@@ -1,19 +1,23 @@
 package net.minecraft.src;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 
 public class ChunkProviderLoadOrGenerate implements IChunkProvider {
+	private Set droppedChunksSet = new HashSet();
 	private Chunk blankChunk;
 	private IChunkProvider chunkProvider;
 	private IChunkLoader chunkLoader;
-	private Chunk[] chunks = new Chunk[1024];
+	private MCHashTableLong chunkMap = new MCHashTableLong();
+	private List chunkList = new ArrayList();
 	private World worldObj;
-	int lastQueriedChunkXPos = -999999999;
-	int lastQueriedChunkZPos = -999999999;
-	private Chunk lastQueriedChunk;
+	private int chunkToUnload;
 
 	public ChunkProviderLoadOrGenerate(World var1, IChunkLoader var2, IChunkProvider var3) {
-		this.blankChunk = new Chunk(var1, new byte[-Short.MIN_VALUE], 0, 0);
+		this.blankChunk = new EmptyChunk(var1, new short[65536], 0, 0);
 		this.blankChunk.isChunkRendered = true;
 		this.blankChunk.neverSave = true;
 		this.worldObj = var1;
@@ -21,67 +25,52 @@
 		this.chunkProvider = var3;
 	}
 
+	public void dropChunk(int var1, int var2) {
+		int var4 = var1 * 16 + 8 - this.worldObj.spawnX;
+		int var5 = var2 * 16 + 8 - this.worldObj.spawnZ;
+		short var6 = 128;
+		if(var4 < -var6 || var4 > var6 || var5 < -var6 || var5 > var6) {
+			this.droppedChunksSet.add(Long.valueOf(ChunkCoordIntPair.chunkXZ2Int(var1, var2)));
+		}
+	}
+
 	public boolean chunkExists(int var1, int var2) {
-		if(var1 == this.lastQueriedChunkXPos && var2 == this.lastQueriedChunkZPos && this.lastQueriedChunk != null) {
-			return true;
-		} else {
-			int var3 = var1 & 31;
-			int var4 = var2 & 31;
-			int var5 = var3 + var4 * 32;
-			return this.chunks[var5] != null && (this.chunks[var5] == this.blankChunk || this.chunks[var5].isAtLocation(var1, var2));
+		return this.chunkMap.lookup(ChunkCoordIntPair.chunkXZ2Int(var1, var2)) != null;
+	}
+
+	public Chunk loadChunk(int var1, int var2) {
+		long var3 = ChunkCoordIntPair.chunkXZ2Int(var1, var2);
+		this.droppedChunksSet.remove(Long.valueOf(var3));
+		Chunk var5 = (Chunk)this.chunkMap.lookup(var3);
+		if(var5 == null) {
+			int var6 = 1875004;
+			if(var1 < -var6 || var2 < -var6 || var1 >= var6 || var2 >= var6) {
+				return this.blankChunk;
+			}
+
+			var5 = this.getChunkAt(var1, var2);
+			if(var5 == null) {
+				if(this.chunkProvider == null) {
+					var5 = this.blankChunk;
+				} else {
+					var5 = this.chunkProvider.provideChunk(var1, var2);
+				}
+			}
+
+			this.chunkMap.addKey(var3, var5);
+			this.chunkList.add(var5);
+			if(var5 != null) {
+				var5.onChunkLoad();
+				var5.populateChunk(this, this, var1, var2);
+			}
 		}
+
+		return var5;
 	}
 
 	public Chunk provideChunk(int var1, int var2) {
-		if(var1 == this.lastQueriedChunkXPos && var2 == this.lastQueriedChunkZPos && this.lastQueriedChunk != null) {
-			return this.lastQueriedChunk;
-		} else {
-			int var3 = var1 & 31;
-			int var4 = var2 & 31;
-			int var5 = var3 + var4 * 32;
-			if(!this.chunkExists(var1, var2)) {
-				if(this.chunks[var5] != null) {
-					this.chunks[var5].onChunkUnload();
-					this.saveChunk(this.chunks[var5]);
-					this.saveExtraChunkData(this.chunks[var5]);
-				}
-
-				Chunk var6 = this.getChunkAt(var1, var2);
-				if(var6 == null) {
-					if(this.chunkProvider == null) {
-						var6 = this.blankChunk;
-					} else {
-						var6 = this.chunkProvider.provideChunk(var1, var2);
-					}
-				}
-
-				this.chunks[var5] = var6;
-				if(this.chunks[var5] != null) {
-					this.chunks[var5].onChunkLoad();
-				}
-
-				if(!this.chunks[var5].isTerrainPopulated && this.chunkExists(var1 + 1, var2 + 1) && this.chunkExists(var1, var2 + 1) && this.chunkExists(var1 + 1, var2)) {
-					this.populate(this, var1, var2);
-				}
-
-				if(this.chunkExists(var1 - 1, var2) && !this.provideChunk(var1 - 1, var2).isTerrainPopulated && this.chunkExists(var1 - 1, var2 + 1) && this.chunkExists(var1, var2 + 1) && this.chunkExists(var1 - 1, var2)) {
-					this.populate(this, var1 - 1, var2);
-				}
-
-				if(this.chunkExists(var1, var2 - 1) && !this.provideChunk(var1, var2 - 1).isTerrainPopulated && this.chunkExists(var1 + 1, var2 - 1) && this.chunkExists(var1, var2 - 1) && this.chunkExists(var1 + 1, var2)) {
-					this.populate(this, var1, var2 - 1);
-				}
-
-				if(this.chunkExists(var1 - 1, var2 - 1) && !this.provideChunk(var1 - 1, var2 - 1).isTerrainPopulated && this.chunkExists(var1 - 1, var2 - 1) && this.chunkExists(var1, var2 - 1) && this.chunkExists(var1 - 1, var2)) {
-					this.populate(this, var1 - 1, var2 - 1);
-				}
-			}
-
-			this.lastQueriedChunkXPos = var1;
-			this.lastQueriedChunkZPos = var2;
-			this.lastQueriedChunk = this.chunks[var5];
-			return this.chunks[var5];
-		}
+		Chunk var3 = (Chunk)this.chunkMap.lookup(ChunkCoordIntPair.chunkXZ2Int(var1, var2));
+		return var3 == null ? this.loadChunk(var1, var2) : var3;
 	}
 
 	private Chunk getChunkAt(int var1, int var2) {
@@ -137,40 +126,40 @@
 
 	}
 
+	public void populateUnderworld(IChunkProvider var1, int var2, int var3) {
+		Chunk var4 = this.provideChunk(var2, var3);
+		if(!var4.isUnderworldPopulated) {
+			var4.isUnderworldPopulated = true;
+			if(this.chunkProvider != null) {
+				this.chunkProvider.populateUnderworld(var1, var2, var3);
+				var4.setChunkModified();
+			}
+		}
+
+	}
+
+	public void upgradeHeight(IChunkProvider var1, Chunk var2, World var3) {
+		if(this.chunkProvider != null) {
+			this.chunkProvider.upgradeHeight(var1, var2, var3);
+			var2.setChunkModified();
+		}
+	}
+
 	public boolean saveChunks(boolean var1, IProgressUpdate var2) {
 		int var3 = 0;
-		int var4 = 0;
-		int var5;
-		if(var2 != null) {
-			for(var5 = 0; var5 < this.chunks.length; ++var5) {
-				if(this.chunks[var5] != null && this.chunks[var5].needsSaving(var1)) {
-					++var4;
-				}
+
+		for(int var4 = 0; var4 < this.chunkList.size(); ++var4) {
+			Chunk var5 = (Chunk)this.chunkList.get(var4);
+			if(var1) {
+				this.saveExtraChunkData(var5);
 			}
-		}
-
-		var5 = 0;
-
-		for(int var6 = 0; var6 < this.chunks.length; ++var6) {
-			if(this.chunks[var6] != null) {
-				if(var1 && !this.chunks[var6].neverSave) {
-					this.saveExtraChunkData(this.chunks[var6]);
-				}
-
-				if(this.chunks[var6].needsSaving(var1)) {
-					this.saveChunk(this.chunks[var6]);
-					this.chunks[var6].isModified = false;
-					++var3;
-					if(var3 == 2 && !var1) {
-						return false;
-					}
-
-					if(var2 != null) {
-						++var5;
-						if(var5 % 10 == 0) {
-							var2.setLoadingProgress(var5 * 100 / var4);
-						}
-					}
+
+			if(var5.needsSaving(var1)) {
+				this.saveChunk(var5);
+				var5.isModified = false;
+				++var3;
+				if(var3 == 24 && !var1) {
+					return false;
 				}
 			}
 		}
@@ -187,6 +176,33 @@
 	}
 
 	public boolean unload100OldestChunks() {
+		int var1;
+		for(var1 = 0; var1 < 100; ++var1) {
+			if(!this.droppedChunksSet.isEmpty()) {
+				Long var2 = (Long)this.droppedChunksSet.iterator().next();
+				Chunk var3 = (Chunk)this.chunkMap.lookup(var2.longValue());
+				var3.onChunkUnload();
+				this.saveChunk(var3);
+				this.saveExtraChunkData(var3);
+				this.droppedChunksSet.remove(var2);
+				this.chunkMap.removeEntry(var2.longValue());
+				this.chunkList.remove(var3);
+			}
+		}
+
+		for(var1 = 0; var1 < 10; ++var1) {
+			if(this.chunkToUnload >= this.chunkList.size()) {
+				this.chunkToUnload = 0;
+				break;
+			}
+
+			Chunk var4 = (Chunk)this.chunkList.get(this.chunkToUnload++);
+			EntityPlayer var5 = this.worldObj.getClosestPlayer2D((double)(var4.xPosition << 4) + 8.0D, (double)(var4.zPosition << 4) + 8.0D, 288.0D);
+			if(var5 == null) {
+				this.dropChunk(var4.xPosition, var4.zPosition);
+			}
+		}
+
 		if(this.chunkLoader != null) {
 			this.chunkLoader.chunkTick();
 		}
@@ -196,5 +212,17 @@
 
 	public boolean canSave() {
 		return true;
+	}
+
+	public String[] getDebugInfo(int x, int y, int z) {
+		return this.chunkProvider.getDebugInfo(x, y, z);
+	}
+
+	public boolean isOcean(int x, int z) {
+		return this.chunkProvider.isOcean(x, z);
+	}
+
+	public boolean isRiver(int x, int z) {
+		return this.chunkProvider.isRiver(x, z);
 	}
 }
--- net/minecraft/src/BlockFire.java
+++ net/minecraft/src/BlockFire.java
@@ -3,17 +3,20 @@
 import java.util.Random;
 
 public class BlockFire extends Block {
-	private int[] chanceToEncourageFire = new int[256];
-	private int[] abilityToCatchFire = new int[256];
+	private int[] chanceToEncourageFire = new int[65535];
+	private int[] abilityToCatchFire = new int[65535];
 
-	protected BlockFire(int var1, int var2) {
+	public BlockFire(int var1, int var2) {
 		super(var1, var2, Material.fire);
-		this.initializeBlock(Block.planks.blockID, 5, 20);
-		this.initializeBlock(Block.wood.blockID, 5, 5);
-		this.initializeBlock(Block.leaves.blockID, 30, 60);
-		this.initializeBlock(Block.bookshelf.blockID, 30, 20);
-		this.initializeBlock(Block.tnt.blockID, 15, 100);
-		this.initializeBlock(Block.cloth.blockID, 30, 60);
+		this.initializeBlock(5, 5, 20);
+		this.initializeBlock(17, 5, 5);
+		this.initializeBlock(18, 30, 60);
+		this.initializeBlock(22, 5, 5);
+		this.initializeBlock(23, 5, 5);
+		this.initializeBlock(35, 30, 60);
+		this.initializeBlock(46, 15, 100);
+		this.initializeBlock(47, 30, 20);
+		this.initializeBlock(53, 5, 5);
 		this.setTickOnLoad(true);
 	}
 
--- /dev/null
+++ net/minecraft/src/WorldType.java
@@ -1,0 +1,66 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+public enum WorldType {
+	NORMAL("Normal", new ItemTooltip(BETA_GRAD, "World Type: Normal",
+			"The intended Minecraft Diverge", DESCRIPTION_COL,
+			"experience with plenty of biomes", DESCRIPTION_COL)),
+	CLASSIC("Classic", new ItemTooltip(BETA_GRAD, "World Type: Classic",
+			"The classic Minecraft generation,", DESCRIPTION_COL,
+			"like the old Diverge days", DESCRIPTION_COL)),
+	WINTER("Winter", new ItemTooltip(BETA_GRAD, "World Type: Winter",
+			"Eternal frost in the tundra biome", DESCRIPTION_COL),
+			0x88e7ff, 0xc0fffc, 0xffffff),
+	ARID("Arid", new ItemTooltip(BETA_GRAD, "World Type: Arid",
+			"No oceans, mostly desert", DESCRIPTION_COL,
+			"with occasional savanna", DESCRIPTION_COL),
+			0xfff988, 0xfff8bf, 0xffffff),
+	TROPICAL("Tropical", new ItemTooltip(BETA_GRAD, "World Type: Tropical",
+			"A bright world featuring", DESCRIPTION_COL,
+			"seasonal forests and rainforests", DESCRIPTION_COL),
+			0x80ffdb, 0xc2fff9, 0xffffff),
+	AMPLIFIED("Amplified", new ItemTooltip(BETA_GRAD, "World Type: Amplified",
+			"Greatly increased world height", DESCRIPTION_COL)),
+	SUPERFLAT("Superflat", new ItemTooltip(BETA_GRAD, "World Type: Superflat",
+			"Completely flat terrain", DESCRIPTION_COL,
+			"great for building", DESCRIPTION_COL));
+
+	private final String name;
+	private final ItemTooltip tooltip;
+	private final long skyColor;
+	private final long fogColor;
+	private final long cloudColor;
+
+	WorldType(String name, ItemTooltip tooltip) {
+		this(name, tooltip, 8961023L, 12638463L, 16777215L);
+	}
+
+	WorldType(String name, ItemTooltip tooltip, long skyColor, long fogColor, long cloudColor) {
+		this.name = name;
+		this.tooltip = tooltip;
+		this.skyColor = skyColor;
+		this.fogColor = fogColor;
+		this.cloudColor = cloudColor;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public ItemTooltip getTooltip() {
+		return tooltip;
+	}
+
+	public long getSkyColor() {
+		return skyColor;
+	}
+
+	public long getFogColor() {
+		return fogColor;
+	}
+
+	public long getCloudColor() {
+		return cloudColor;
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiDeleteWorldNew.java
@@ -1,0 +1,20 @@
+package net.minecraft.src;
+
+public class GuiDeleteWorldNew extends GuiSelectWorldNew {
+	public GuiDeleteWorldNew(GuiScreen var1) {
+		super(var1);
+		this.screenTitle = "Delete world";
+		if (var1 instanceof GuiSelectWorldNew) {
+			this.scrollbar = ((GuiSelectWorldNew)var1).scrollbar;
+		}
+	}
+
+	protected void initButtons() {
+		this.controlList.add(new GuiButton(-2, this.width / 2 - 50, this.height - 24, 100, 20, "Cancel"));
+	}
+
+	public void selectWorld(String world, String displayName) {
+		this.mc.displayGuiScreen(new GuiDeleteWorldConfirm(this.parentScreen, world, displayName));
+		this.selected = false;
+	}
+}
--- /dev/null
+++ net/minecraft/src/NamedBitField.java
@@ -1,0 +1,20 @@
+package net.minecraft.src;
+
+import java.util.List;
+
+public class NamedBitField extends BitField {
+	public final List<String> names;
+
+	public NamedBitField(String name, int offset, int size, List<String> names) {
+		super(name, offset, size);
+		this.names = names;
+	}
+
+	public String getString(int number) {
+		int value = this.get(number);
+		if (value >= names.size() || names.get(value) == null) {
+			return String.valueOf(value);
+		}
+		return names.get(value);
+	}
+}
--- net/minecraft/src/ItemArmor.java
+++ net/minecraft/src/ItemArmor.java
@@ -1,20 +1,28 @@
 package net.minecraft.src;
 
-public class ItemArmor extends Item {
-	private static final int[] damageReduceAmountArray = new int[]{3, 8, 6, 3};
-	private static final int[] maxDamageArray = new int[]{11, 16, 15, 13};
+import static net.minecraft.src.ItemTooltip.*;
+
+public class ItemArmor extends ItemEquipable {
+	private static final int[] protectionValues = new int[] { 3, 8, 6, 3 };
+	private static final int[] maxDamageArray = new int[] { 11, 16, 15, 13 };
 	public final int armorLevel;
-	public final int armorType;
-	public final int damageReduceAmount;
+	public final int defense;
 	public final int renderIndex;
 
-	public ItemArmor(int var1, int var2, int var3, int var4) {
-		super(var1);
+	public ItemArmor(int var1, int var2, int var3, int var4, double var5) {
+		super(var1, var4);
 		this.armorLevel = var2;
-		this.armorType = var4;
 		this.renderIndex = var3;
-		this.damageReduceAmount = damageReduceAmountArray[var4];
-		this.maxDamage = maxDamageArray[var4] * 3 << var2;
-		this.maxStackSize = 1;
+		this.defense = (int) Math.round(protectionValues[var4] * var5);
+		this.maxDamage = maxDamageArray[var4] * 4 << var2;
+		if (var2 > 2) {
+			this.maxDamage *= 1 << var2 - 2;
+		}
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				this.defense + " defense", INFO_COL
+		};
 	}
 }
--- net/minecraft/src/WorldGenBigTree.java
+++ net/minecraft/src/WorldGenBigTree.java
@@ -3,21 +3,32 @@
 import java.util.Random;
 
 public class WorldGenBigTree extends WorldGenerator {
-	static final byte[] otherCoordPairs = new byte[]{(byte)2, (byte)0, (byte)0, (byte)1, (byte)2, (byte)1};
-	Random rand = new Random();
-	World worldObj;
-	int[] basePos = new int[]{0, 0, 0};
-	int heightLimit = 0;
-	int height;
-	double heightAttenuation = 0.618D;
-	double branchDensity = 1.0D;
-	double branchSlope = 0.381D;
-	double scaleWidth = 1.0D;
-	double leafDensity = 1.0D;
-	int trunkSize = 1;
-	int heightLimitLimit = 12;
-	int leafDistanceLimit = 4;
-	int[][] leafNodes;
+	public static final byte[] otherCoordPairs = new byte[]{(byte)2, (byte)0, (byte)0, (byte)1, (byte)2, (byte)1};
+	public Random rand = new Random();
+	public World worldObj;
+	public int[] basePos = new int[]{0, 0, 0};
+	public int heightLimit = 0;
+	public int height;
+	public double heightAttenuation = 0.618D;
+	public double branchDensity = 1.0D;
+	public double branchSlope = 0.381D;
+	public double scaleWidth = 1.0D;
+	public double leafDensity = 1.0D;
+	public int trunkSize = 1;
+	public int heightLimitLimit = 12;
+	public int leafDistanceLimit = 4;
+	public int[][] leafNodes;
+
+	private int altMetadata = 0;
+	private double altChance = 0.0D;
+
+	private int meta;
+
+	public WorldGenBigTree withAltForm(int altMetadata, double altChance) {
+		this.altMetadata = altMetadata;
+		this.altChance = altChance;
+		return this;
+	}
 
 	void generateLeafNodeList() {
 		this.height = (int)((double)this.heightLimit * this.heightAttenuation);
@@ -116,7 +127,7 @@
 						if(var14 != 0 && var14 != 18) {
 							++var13;
 						} else {
-							this.worldObj.setBlock(var11[0], var11[1], var11[2], var6);
+							this.worldObj.setBlockAndMetadata(var11[0], var11[1], var11[2], var6, this.meta);
 							++var13;
 						}
 					}
@@ -191,7 +202,7 @@
 				var14[var6] = MathHelper.floor_double((double)(var1[var6] + var15) + 0.5D);
 				var14[var7] = MathHelper.floor_double((double)var1[var7] + (double)var15 * var10 + 0.5D);
 				var14[var8] = MathHelper.floor_double((double)var1[var8] + (double)var15 * var12 + 0.5D);
-				this.worldObj.setBlock(var14[0], var14[1], var14[2], var3);
+				this.worldObj.setBlockAndMetadata(var14[0], var14[1], var14[2], var3, this.meta);
 			}
 
 		}
@@ -325,15 +336,17 @@
 	}
 
 	public boolean generate(World var1, Random var2, int var3, int var4, int var5) {
+		this.meta = var2.nextDouble() < this.altChance ? altMetadata : 0;
+
 		this.worldObj = var1;
 		long var6 = var2.nextLong();
 		this.rand.setSeed(var6);
 		this.basePos[0] = var3;
 		this.basePos[1] = var4;
 		this.basePos[2] = var5;
-		if(this.heightLimit == 0) {
-			this.heightLimit = 5 + this.rand.nextInt(this.heightLimitLimit);
-		}
+//		if(this.heightLimit == 0) {
+		this.heightLimit = 5 + this.rand.nextInt(this.heightLimitLimit);
+//		}
 
 		if(!this.validTreeLocation()) {
 			return false;
--- /dev/null
+++ net/minecraft/src/Packet28EntityVelocity.java
@@ -1,0 +1,73 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet28EntityVelocity extends Packet {
+	public int entityId;
+	public int motionX;
+	public int motionY;
+	public int motionZ;
+
+	public Packet28EntityVelocity() {
+	}
+
+	public Packet28EntityVelocity(Entity var1) {
+		this(var1.entityID, var1.motionX, var1.motionY, var1.motionZ);
+	}
+
+	public Packet28EntityVelocity(int var1, double var2, double var4, double var6) {
+		this.entityId = var1;
+		double var8 = 3.9D;
+		if(var2 < -var8) {
+			var2 = -var8;
+		}
+
+		if(var4 < -var8) {
+			var4 = -var8;
+		}
+
+		if(var6 < -var8) {
+			var6 = -var8;
+		}
+
+		if(var2 > var8) {
+			var2 = var8;
+		}
+
+		if(var4 > var8) {
+			var4 = var8;
+		}
+
+		if(var6 > var8) {
+			var6 = var8;
+		}
+
+		this.motionX = (int)(var2 * 8000.0D);
+		this.motionY = (int)(var4 * 8000.0D);
+		this.motionZ = (int)(var6 * 8000.0D);
+	}
+
+	public void readPacketData(DataInputStream var1) throws IOException {
+		this.entityId = var1.readInt();
+		this.motionX = var1.readShort();
+		this.motionY = var1.readShort();
+		this.motionZ = var1.readShort();
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+		var1.writeInt(this.entityId);
+		var1.writeShort(this.motionX);
+		var1.writeShort(this.motionY);
+		var1.writeShort(this.motionZ);
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleEntityVelocity(this);
+	}
+
+	public int getPacketSize() {
+		return 10;
+	}
+}
--- net/minecraft/src/ItemSnowball.java
+++ net/minecraft/src/ItemSnowball.java
@@ -9,7 +9,9 @@
 	public ItemStack onItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
 		--var1.stackSize;
 		var2.playSoundAtEntity(var3, "random.bow", 0.5F, 0.4F / (rand.nextFloat() * 0.4F + 0.8F));
-		var2.spawnEntityInWorld(new EntitySnowball(var2, var3));
+		if (var2.canDoClientAction()) {
+			var2.spawnEntityInWorld(new EntitySnowball(var2, var3, EntitySnowballType.snowball));
+		}
 		return var1;
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet40EntityMetadata.java
@@ -1,0 +1,37 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.List;
+
+public class Packet40EntityMetadata extends Packet {
+    public int entityId;
+    public List changedObjects;
+
+    public Packet40EntityMetadata() {
+    }
+
+    public Packet40EntityMetadata(int var1, DataWatcher var2) {
+        this.entityId = var1;
+        this.changedObjects = var2.getChangedObjects();
+    }
+
+    public void readPacketData(DataInputStream var1) throws IOException {
+        this.entityId = var1.readInt();
+        this.changedObjects = DataWatcher.readWatchableObjects(var1);
+    }
+
+    public void writePacket(DataOutputStream var1) throws IOException {
+        var1.writeInt(this.entityId);
+        DataWatcher.writeObjectsInListToStream(this.changedObjects, var1);
+    }
+
+    public void processPacket(NetHandler var1) {
+        var1.handleEntityMetadata(this);
+    }
+
+    public int getPacketSize() {
+        return 5;
+    }
+}
--- /dev/null
+++ net/minecraft/src/HookOnEntityDeath.java
@@ -1,0 +1,5 @@
+package net.minecraft.src;
+
+public interface HookOnEntityDeath<E extends EntityLiving> {
+	void call(BaseMod mod, Class<? extends E> clazz, E target, Entity enemy);
+}
--- /dev/null
+++ net/minecraft/src/GuiCreateWorld.java
@@ -1,0 +1,196 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+import java.io.File;
+import java.util.Random;
+
+import org.lwjgl.input.Keyboard;
+
+public class GuiCreateWorld extends GuiScreen {
+	private static final String[] adjectives = new String[] {
+			"Dubious",
+			"Gloomy",
+			"Beautiful",
+			"Radical",
+			"Exciting",
+			"Intriguing",
+			"Glorious",
+			"Shimmering",
+			"Green",
+			"Deep",
+			"Tranquil"
+	};
+	private static final String[] nouns = new String[] {
+			"Depths",
+			"Plains",
+			"Pastures",
+			"Woods",
+			"Land",
+			"World",
+			"Peaks",
+			"Hills",
+			"Shores"
+	};
+
+	private static final ItemTooltip TOOLTIP_WORLD_NAME = new ItemTooltip(BETA_GRAD, "World Name");
+	private static final ItemTooltip TOOLTIP_SEED = new ItemTooltip(BETA_GRAD, "World Seed",
+			"Seed for the world generator", DESCRIPTION_COL,
+			"Leave blank for a random seed", DESCRIPTION_COL);
+	private static final ItemTooltip TOOLTIP_SURVIVAL = new ItemTooltip(BETA_GRAD, "Gamemode: Survival",
+			"Limited resources, health and stamina", DESCRIPTION_COL);
+	private static final ItemTooltip TOOLTIP_CREATIVE = new ItemTooltip(BETA_GRAD, "Gamemode: Creative",
+			"Infinite blocks and items, provides", DESCRIPTION_COL,
+			"invincibility for disruption-free creativity", DESCRIPTION_COL);
+
+	private final GuiScreen parent;
+	private final String randomName;
+	private GuiTextField textboxWorldName;
+	private GuiTextField textboxSeed;
+	private GuiButton buttonWorldType;
+	private GuiButton buttonGamemode;
+	private String displayName;
+	private String folderName;
+	private boolean createClicked;
+	private byte worldType;
+	private boolean creative;
+
+	public GuiCreateWorld(GuiScreen guiScreen1) {
+		this.parent = guiScreen1;
+
+		Random rand = new Random();
+		this.randomName = adjectives[rand.nextInt(adjectives.length)]
+				+ " "
+				+ nouns[rand.nextInt(nouns.length)];
+	}
+
+	public void updateScreen() {
+		this.textboxWorldName.updateCursorCounter();
+		this.textboxSeed.updateCursorCounter();
+	}
+
+	public void initGui() {
+		Keyboard.enableRepeatEvents(true);
+		this.controlList.clear();
+		this.controlList.add(new GuiButton(0, this.width / 2 - 152, this.height - 24, 150, 20, "Create New World"));
+		this.controlList.add(new GuiButton(1, this.width / 2 + 2, this.height - 24, 150, 20, "Cancel"));
+
+		this.textboxWorldName = new GuiTextField(this, this.fontRenderer, this.width / 2 - 100, 48, 200, 20,
+				this.textboxWorldName != null ? this.textboxWorldName.getText() : this.randomName);
+		this.textboxWorldName.isFocused = true;
+		this.textboxWorldName.setMaxStringLength(32);
+		this.textboxSeed = new GuiTextField(this, this.fontRenderer, this.width / 2 - 100, 72, 200, 20, "");
+
+		this.buttonWorldType = new GuiButton(2, this.width / 2 - 100, 96, 200, 20, "Type: " + WorldType.values()[this.worldType].getName());
+		this.buttonGamemode = new GuiButton(3, this.width / 2 - 100, 120, 200, 20, "Gamemode: " + (this.creative ? "Creative" : "Survival"));
+		this.controlList.add(this.buttonWorldType);
+		this.controlList.add(this.buttonGamemode);
+		this.updateFolderName();
+	}
+
+	private void updateFolderName() {
+		this.displayName = this.textboxWorldName.getText().trim();
+		if(this.displayName.isEmpty()) {
+			this.displayName = this.randomName;
+		}
+		this.folderName = World.toFolderName(this.displayName, new File(this.mc.mcDataDir, "saves"));
+	}
+
+	public void onGuiClosed() {
+		Keyboard.enableRepeatEvents(false);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if(!var1.enabled) {
+			return;
+		}
+		switch (var1.id) {
+			case 0:
+				this.mc.displayGuiScreen((GuiScreen)null);
+				if(this.createClicked) {
+					return;
+				}
+
+				this.createClicked = true;
+				long var2 = (new Random()).nextLong();
+				String var4 = this.textboxSeed.getText();
+				if(var4 != null && var4.length() > 0) {
+					try {
+						long var5 = Long.parseLong(var4);
+						if(var5 != 0L) {
+							var2 = var5;
+						}
+					} catch (NumberFormatException numberFormatException7) {
+						var2 = (long)var4.hashCode();
+					}
+				}
+
+				this.mc.playerController = new PlayerControllerSP(this.mc);
+				this.mc.startWorld(this.folderName, new CreateWorldInfo()
+						.withName(this.displayName)
+						.withSeed(var2)
+						.withWorldType(WorldType.values()[this.worldType])
+						.withCreative(this.creative));
+				this.mc.displayGuiScreen((GuiScreen)null);
+				break;
+
+			case 1:
+				this.mc.displayGuiScreen(this.parent);
+				break;
+
+			case 2:
+				this.worldType++;
+				if (this.worldType >= WorldType.values().length) {
+					this.worldType = 0;
+				}
+				var1.displayString = "Type: " + WorldType.values()[this.worldType].getName();
+				break;
+
+			case 3:
+				this.creative = !this.creative;
+				var1.displayString = "Gamemode: " + (this.creative ? "Creative" : "Survival");
+				break;
+		}
+	}
+
+	protected void keyTyped(char var1, int var2) {
+		if(this.textboxWorldName.isFocused) {
+			this.textboxWorldName.textboxKeyTyped(var1, var2);
+		} else {
+			this.textboxSeed.textboxKeyTyped(var1, var2);
+		}
+
+		if(var1 == 13) {
+			this.actionPerformed((GuiButton)this.controlList.get(0));
+		}
+
+		((GuiButton)this.controlList.get(0)).enabled = this.textboxWorldName.getText().length() > 0;
+		this.updateFolderName();
+	}
+
+	protected void mouseClicked(int var1, int var2, int var3) {
+		super.mouseClicked(var1, var2, var3);
+		this.textboxWorldName.mouseClicked(var1, var2, var3);
+		this.textboxSeed.mouseClicked(var1, var2, var3);
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground(var3);
+		this.drawHeader("Create new world");
+		this.textboxWorldName.drawTextBox();
+		this.textboxSeed.drawTextBox();
+		super.drawScreen(var1, var2, var3);
+
+		if (this.textboxWorldName.mouseHover(var1, var2))
+			this.drawTooltip(TOOLTIP_WORLD_NAME.copy()
+					.addLine("Will be saved in:", INFO_COL)
+					.addLine(this.folderName, INFO_COL),
+					var1, var2);
+		if (this.textboxSeed.mouseHover(var1, var2))
+			this.drawTooltip(TOOLTIP_SEED, var1, var2);
+		if (this.buttonWorldType.mouseHover(var1, var2))
+			this.drawTooltip(WorldType.values()[this.worldType].getTooltip(), var1, var2);
+		if (this.buttonGamemode.mouseHover(var1, var2))
+			this.drawTooltip(this.creative ? TOOLTIP_CREATIVE : TOOLTIP_SURVIVAL, var1, var2);
+	}
+}
--- net/minecraft/src/Gui.java
+++ net/minecraft/src/Gui.java
@@ -63,8 +63,12 @@
 	}
 
 	public void drawTexturedModalRect(int var1, int var2, int var3, int var4, int var5, int var6) {
-		float var7 = 0.00390625F;
-		float var8 = 0.00390625F;
+		this.drawTexturedModalRect(var1, var2, var3, var4, var5, var6, 256.0F);
+	}
+
+	public void drawTexturedModalRect(int var1, int var2, int var3, int var4, int var5, int var6, float div) {
+		float var7 = 1.0F / div;
+		float var8 = 1.0F / div;
 		Tessellator var9 = Tessellator.instance;
 		var9.startDrawingQuads();
 		var9.addVertexWithUV((double)(var1 + 0), (double)(var2 + var6), (double)this.zLevel, (double)((float)(var3 + 0) * var7), (double)((float)(var4 + var6) * var8));
--- net/minecraft/src/BlockLadder.java
+++ net/minecraft/src/BlockLadder.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockLadder extends Block {
-	protected BlockLadder(int var1, int var2) {
+	public BlockLadder(int var1, int var2) {
 		super(var1, var2, Material.circuits);
 	}
 
@@ -67,25 +67,24 @@
 		return var1.isBlockNormalCube(var2 - 1, var3, var4) ? true : (var1.isBlockNormalCube(var2 + 1, var3, var4) ? true : (var1.isBlockNormalCube(var2, var3, var4 - 1) ? true : var1.isBlockNormalCube(var2, var3, var4 + 1)));
 	}
 
-	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = var1.getBlockMetadata(var2, var3, var4);
-		if((var6 == 0 || var5 == 2) && var1.isBlockNormalCube(var2, var3, var4 + 1)) {
-			var6 = 2;
-		}
-
-		if((var6 == 0 || var5 == 3) && var1.isBlockNormalCube(var2, var3, var4 - 1)) {
-			var6 = 3;
-		}
-
-		if((var6 == 0 || var5 == 4) && var1.isBlockNormalCube(var2 + 1, var3, var4)) {
-			var6 = 4;
-		}
-
-		if((var6 == 0 || var5 == 5) && var1.isBlockNormalCube(var2 - 1, var3, var4)) {
-			var6 = 5;
-		}
-
-		var1.setBlockMetadataWithNotify(var2, var3, var4, var6);
+	public int onBlockPlaced(World var1, int var2, int var3, int var4, int var5, float hitx, float hity, float hitz, int meta) {
+		if((meta == 0 || var5 == 2) && var1.isBlockNormalCube(var2, var3, var4 + 1)) {
+			meta = 2;
+		}
+
+		if((meta == 0 || var5 == 3) && var1.isBlockNormalCube(var2, var3, var4 - 1)) {
+			meta = 3;
+		}
+
+		if((meta == 0 || var5 == 4) && var1.isBlockNormalCube(var2 + 1, var3, var4)) {
+			meta = 4;
+		}
+
+		if((meta == 0 || var5 == 5) && var1.isBlockNormalCube(var2 - 1, var3, var4)) {
+			meta = 5;
+		}
+
+		return meta;
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
--- net/minecraft/src/NetServerHandler.java
+++ net/minecraft/src/NetServerHandler.java
@@ -1,10 +1,14 @@
 package net.minecraft.src;
 
-import java.io.IOException;
+import static net.minecraft.src.Constants.ALLOWED_CHARACTERS;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.logging.Logger;
+
 import net.minecraft.server.MinecraftServer;
-
-public class NetServerHandler extends NetHandler implements ICommandListener {
+public class NetServerHandler extends NetHandler implements IListenToMyCommands {
 	public static Logger logger = Logger.getLogger("Minecraft");
 	public NetworkManager netManager;
 	public boolean connectionClosed = false;
@@ -15,7 +19,7 @@
 	private double lastPosY;
 	private double lastPosZ;
 	private boolean hasMoved = true;
-	private ItemStack heldItem = null;
+	private Map heldItems = new HashMap();
 
 	public NetServerHandler(MinecraftServer var1, NetworkManager var2, EntityPlayerMP var3) {
 		this.mcServer = var1;
@@ -25,17 +29,17 @@
 		var3.playerNetServerHandler = this;
 	}
 
-	public void handlePackets() throws IOException {
+	public void handlePackets() {
 		this.netManager.processReadPackets();
 		if(this.playerInAirTime++ % 20 == 0) {
 			this.netManager.addToSendQueue(new Packet0KeepAlive());
 		}
-
 	}
 
 	public void kickPlayer(String var1) {
 		this.netManager.addToSendQueue(new Packet255KickDisconnect(var1));
 		this.netManager.serverShutdown();
+		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("\u00a7e" + this.playerEntity.username + " left the game."));
 		this.mcServer.configManager.playerLoggedOut(this.playerEntity);
 		this.connectionClosed = true;
 	}
@@ -50,67 +54,161 @@
 		}
 
 		if(this.hasMoved) {
+			double var5;
+			double var7;
+			double var9;
+			double var13;
+			if(this.playerEntity.ridingEntity != null) {
+				float var28 = this.playerEntity.rotationYaw;
+				float var4 = this.playerEntity.rotationPitch;
+				this.playerEntity.ridingEntity.updateRiderPosition();
+				var5 = this.playerEntity.posX;
+				var7 = this.playerEntity.posY;
+				var9 = this.playerEntity.posZ;
+				double var29 = 0.0D;
+				var13 = 0.0D;
+				if(var1.rotating) {
+					var28 = var1.yaw;
+					var4 = var1.pitch;
+				}
+
+				if(var1.moving && var1.yPosition == -999.0D && var1.stance == -999.0D) {
+					if(var1.xPosition > 1.0D || var1.zPosition > 1.0D) {
+						System.err.println(this.playerEntity.username + " was caught trying to crash the server with an invalid position.");
+						this.kickPlayer("Nope!");
+						return;
+					}
+
+					var29 = var1.xPosition;
+					var13 = var1.zPosition;
+				}
+
+				this.playerEntity.onGround = var1.onGround;
+				this.playerEntity.onUpdateEntity(true);
+				this.playerEntity.moveEntity(var29, 0.0D, var13);
+				this.playerEntity.setPositionAndRotation(var5, var7, var9, var28, var4);
+				this.playerEntity.motionX = var29;
+				this.playerEntity.motionZ = var13;
+				if(this.playerEntity.ridingEntity != null) {
+					this.mcServer.worldMngr.updateEntity(this.playerEntity.ridingEntity);
+				}
+
+				if(this.playerEntity.ridingEntity != null) {
+					this.playerEntity.ridingEntity.updateRiderPosition();
+				}
+
+				this.mcServer.configManager.serverUpdateMountedMovingPlayer(this.playerEntity);
+				this.lastPosX = this.playerEntity.posX;
+				this.lastPosY = this.playerEntity.posY;
+				this.lastPosZ = this.playerEntity.posZ;
+				this.mcServer.worldMngr.updateEntity(this.playerEntity);
+				return;
+			}
+
+			double var3 = this.playerEntity.posY;
 			this.lastPosX = this.playerEntity.posX;
 			this.lastPosY = this.playerEntity.posY;
 			this.lastPosZ = this.playerEntity.posZ;
-			var2 = this.playerEntity.posX;
-			double var4 = this.playerEntity.posY;
-			double var6 = this.playerEntity.posZ;
-			float var8 = this.playerEntity.rotationYaw;
-			float var9 = this.playerEntity.rotationPitch;
-			double var10;
+			var5 = this.playerEntity.posX;
+			var7 = this.playerEntity.posY;
+			var9 = this.playerEntity.posZ;
+			float var11 = this.playerEntity.rotationYaw;
+			float var12 = this.playerEntity.rotationPitch;
+			if(var1.moving && var1.yPosition == -999.0D && var1.stance == -999.0D) {
+				var1.moving = false;
+			}
+
 			if(var1.moving) {
-				var2 = var1.xPosition;
-				var4 = var1.yPosition;
-				var6 = var1.zPosition;
-				var10 = var1.stance - var1.yPosition;
-				if(var10 > 1.65D || var10 < 0.1D) {
+				var5 = var1.xPosition;
+				var7 = var1.yPosition;
+				var9 = var1.zPosition;
+				var13 = var1.stance - var1.yPosition;
+				if(var13 > 1.65D || var13 < 0.1D) {
 					this.kickPlayer("Illegal stance");
-					logger.warning(this.playerEntity.username + " had an illegal stance: " + var10);
+					logger.warning(this.playerEntity.username + " had an illegal stance: " + var13);
+					return;
 				}
 
-				this.playerEntity.managedPosY = var1.stance;
+				if(Math.abs(var1.xPosition) > 3.2E7D || Math.abs(var1.zPosition) > 3.2E7D) {
+					this.kickPlayer("Illegal position");
+					return;
+				}
 			}
 
 			if(var1.rotating) {
-				var8 = var1.yaw;
-				var9 = var1.pitch;
+				var11 = var1.yaw;
+				var12 = var1.pitch;
 			}
 
-			this.playerEntity.onUpdateEntity();
+			this.playerEntity.onUpdateEntity(true);
 			this.playerEntity.ySize = 0.0F;
-			this.playerEntity.setPositionAndRotation(this.lastPosX, this.lastPosY, this.lastPosZ, var8, var9);
-			var10 = var2 - this.playerEntity.posX;
-			double var12 = var4 - this.playerEntity.posY;
-			double var14 = var6 - this.playerEntity.posZ;
-			float var16 = 1.0F / 16.0F;
-			boolean var17 = this.mcServer.worldMngr.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().removeCoord((double)var16, (double)var16, (double)var16)).size() == 0;
-			this.playerEntity.moveEntity(var10, var12, var14);
-			var10 = var2 - this.playerEntity.posX;
-			var12 = var4 - this.playerEntity.posY;
-			if(var12 > -0.5D || var12 < 0.5D) {
-				var12 = 0.0D;
-			}
-
-			var14 = var6 - this.playerEntity.posZ;
-			double var18 = var10 * var10 + var12 * var12 + var14 * var14;
-			boolean var20 = false;
-			if(var18 > 1.0D / 16.0D) {
-				var20 = true;
+			this.playerEntity.setPositionAndRotation(this.lastPosX, this.lastPosY, this.lastPosZ, var11, var12);
+			if(!this.hasMoved) {
+				return;
+			}
+
+			var13 = var5 - this.playerEntity.posX;
+			double var15 = var7 - this.playerEntity.posY;
+			double var17 = var9 - this.playerEntity.posZ;
+			double var19 = var13 * var13 + var15 * var15 + var17 * var17;
+			// Minecraft Diverge is FAST
+//			if(var19 > 100.0D) {
+//				logger.warning(this.playerEntity.username + " moved too quickly!");
+//				this.kickPlayer("You moved too quickly :( (Hacking?)");
+//				return;
+//			}
+
+			float var21 = 1.0F / 16.0F;
+			boolean var22 = this.mcServer.worldMngr.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var21, (double)var21, (double)var21)).size() == 0;
+
+			this.playerEntity.moveEntity(var13, var15, var17);
+			this.playerEntity.onGround = var1.onGround;
+			double var23 = var15;
+			var13 = var5 - this.playerEntity.posX;
+			var15 = var7 - this.playerEntity.posY;
+			if(var15 > -0.5D || var15 < 0.5D) {
+				var15 = 0.0D;
+			}
+
+			var17 = var9 - this.playerEntity.posZ;
+			var19 = var13 * var13 + var15 * var15 + var17 * var17;
+			boolean var25 = false;
+			if(var19 > 1.0D / 16.0D && !this.playerEntity.creative) {
+				var25 = true;
 				logger.warning(this.playerEntity.username + " moved wrongly!");
+				System.out.println("Got position " + var5 + ", " + var7 + ", " + var9);
+				System.out.println("Expected " + this.playerEntity.posX + ", " + this.playerEntity.posY + ", " + this.playerEntity.posZ);
 			}
 
-			this.playerEntity.setPositionAndRotation(var2, var4, var6, var8, var9);
-			boolean var21 = this.mcServer.worldMngr.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().removeCoord((double)var16, (double)var16, (double)var16)).size() == 0;
-			if(var17 && (var20 || !var21)) {
-				this.teleportTo(this.lastPosX, this.lastPosY, this.lastPosZ, var8, var9);
+			this.playerEntity.setPositionAndRotation(var5, var7, var9, var11, var12);
+			boolean var26 = this.mcServer.worldMngr.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var21, (double)var21, (double)var21)).size() == 0;
+			if(var22 && (var25 || !var26)) {
+				this.teleportTo(this.lastPosX, this.lastPosY, this.lastPosZ, var11, var12);
 				return;
 			}
 
+			AxisAlignedBB var27 = this.playerEntity.boundingBox.copy().expand((double)var21, (double)var21, (double)var21).addCoord(0.0D, -0.55D, 0.0D);
+			if(!this.playerEntity.creative && !this.mcServer.worldMngr.isAABBEmpty(var27)) {
+				if(var23 >= -0.03125D) {
+					++this.playerInAirTime;
+					if(this.playerInAirTime > 80) {
+						logger.warning(this.playerEntity.username + " was kicked for floating too long!");
+						this.kickPlayer("Flying is not enabled on this server");
+						return;
+					}
+				}
+			} else {
+				this.playerInAirTime = 0;
+			}
+
 			this.playerEntity.onGround = var1.onGround;
-			this.mcServer.configManager.serverUpdateMountedMovingPlayer(this.playerEntity);
+			this.playerEntity.handleFalling(this.playerEntity.posY - var3, var1.onGround);
 		}
+		this.mcServer.configManager.serverUpdateMountedMovingPlayer(this.playerEntity);
+	}
 
+	public void handleLoadChunks(Packet54LoadChunks var1) {
+		this.mcServer.configManager.serverLoadChunks(this.playerEntity);
 	}
 
 	public void teleportTo(double var1, double var3, double var5, float var7, float var8) {
@@ -123,7 +221,10 @@
 	}
 
 	public void handleBlockDig(Packet14BlockDig var1) {
-		this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem] = this.heldItem;
+		if (var1.status == 4) {
+			this.playerEntity.dropOneItem();
+			return;
+		}
 		boolean var2 = this.mcServer.worldMngr.disableSpawnProtection = this.mcServer.configManager.isOp(this.playerEntity.username);
 		boolean var3 = false;
 		if(var1.status == 0) {
@@ -134,47 +235,57 @@
 			var3 = true;
 		}
 
-		if(var3) {
-			double var4 = this.playerEntity.posY;
-			this.playerEntity.posY = this.playerEntity.managedPosY;
-			MovingObjectPosition var6 = this.playerEntity.rayTrace(4.0D, 1.0F);
-			this.playerEntity.posY = var4;
-			if(var6 == null) {
-				return;
-			}
-
-			if(var6.blockX != var1.xPosition || var6.blockY != var1.yPosition || var6.blockZ != var1.zPosition || var6.sideHit != var1.face) {
+//		if(var3) {
+//			double var4 = this.playerEntity.posY;
+//			this.playerEntity.posY = this.playerEntity.managedPosY;
+//			MovingObjectPosition var6 = this.playerEntity.rayTrace(4.0D, 1.0F);
+//			this.playerEntity.posY = var4;
+//			if(var6 == null) {
+//				return;
+//			}
+//
+//			if(var6.blockX != var1.xPosition || var6.blockY != var1.yPosition || var6.blockZ != var1.zPosition || var6.sideHit != var1.face) {
+//				return;
+//			}
+//		}
+
+		int var5 = var1.xPosition;
+		int var6 = var1.yPosition;
+		int var7 = var1.zPosition;
+
+		if (var3) {
+			double var8 = this.playerEntity.posX - ((double)var5 + 0.5D);
+			double var10 = this.playerEntity.posY - ((double)var6 + 0.5D) + 1.5D;
+			double var12 = this.playerEntity.posZ - ((double)var7 + 0.5D);
+			double var14 = var8 * var8 + var10 * var10 + var12 * var12;
+			if(var14 > 36.0D) {
 				return;
 			}
 		}
 
-		int var18 = var1.xPosition;
-		int var5 = var1.yPosition;
-		int var19 = var1.zPosition;
-		int var7 = var1.face;
-		int var8 = (int)MathHelper.abs((float)(var18 - this.mcServer.worldMngr.spawnX));
-		int var9 = (int)MathHelper.abs((float)(var19 - this.mcServer.worldMngr.spawnZ));
+		int var8 = (int)MathHelper.abs((float)(var5 - this.mcServer.worldMngr.spawnX));
+		int var9 = (int)MathHelper.abs((float)(var7 - this.mcServer.worldMngr.spawnZ));
 		if(var8 > var9) {
 			var9 = var8;
 		}
 
 		if(var1.status == 0) {
 			if(var9 > 16 || var2) {
-				this.playerEntity.theItemInWorldManager.onBlockClicked(var18, var5, var19);
+				this.playerEntity.theItemInWorldManager.onBlockClicked(var5, var6, var7);
 			}
+			this.playerEntity.playerNetServerHandler.sendPacket(new Packet53BlockChange(var5, var6, var7, this.mcServer.worldMngr));
 		} else if(var1.status == 2) {
-			this.playerEntity.theItemInWorldManager.blockRemoving();
-		} else if(var1.status == 1) {
-			if(var9 > 16 || var2) {
-				this.playerEntity.theItemInWorldManager.updateBlockRemoving(var18, var5, var19, var7);
+			this.playerEntity.theItemInWorldManager.updateBlockRemoving(var5, var6, var7);
+			if (this.mcServer.worldMngr.getBlockId(var5, var6, var7) != 0) {
+				this.playerEntity.playerNetServerHandler.sendPacket(new Packet53BlockChange(var5, var6, var7, this.mcServer.worldMngr));
 			}
 		} else if(var1.status == 3) {
-			double var10 = this.playerEntity.posX - ((double)var18 + 0.5D);
-			double var12 = this.playerEntity.posY - ((double)var5 + 0.5D);
-			double var14 = this.playerEntity.posZ - ((double)var19 + 0.5D);
+			double var10 = this.playerEntity.posX - ((double)var5 + 0.5D);
+			double var12 = this.playerEntity.posY - ((double)var6 + 0.5D);
+			double var14 = this.playerEntity.posZ - ((double)var7 + 0.5D);
 			double var16 = var10 * var10 + var12 * var12 + var14 * var14;
 			if(var16 < 256.0D) {
-				this.playerEntity.playerNetServerHandler.sendPacket(new Packet53BlockChange(var18, var5, var19, this.mcServer.worldMngr));
+				this.playerEntity.playerNetServerHandler.sendPacket(new Packet53BlockChange(var5, var6, var7, this.mcServer.worldMngr));
 			}
 		}
 
@@ -182,23 +293,50 @@
 	}
 
 	public void handlePlace(Packet15Place var1) {
+		ItemStack item = this.playerEntity.inventory.getCurrentItem();
 		boolean var2 = this.mcServer.worldMngr.disableSpawnProtection = this.mcServer.configManager.isOp(this.playerEntity.username);
-		int var3 = var1.xPosition;
-		int var4 = var1.yPosition;
-		int var5 = var1.zPosition;
-		int var6 = var1.direction;
-		int var7 = (int)MathHelper.abs((float)(var3 - this.mcServer.worldMngr.spawnX));
-		int var8 = (int)MathHelper.abs((float)(var5 - this.mcServer.worldMngr.spawnZ));
-		if(var7 > var8) {
-			var8 = var7;
-		}
-
-		if(var8 > 16 || var2) {
-			ItemStack var9 = var1.id >= 0 ? new ItemStack(var1.id) : null;
-			this.playerEntity.theItemInWorldManager.activeBlockOrUseItem(this.playerEntity, this.mcServer.worldMngr, var9, var3, var4, var5, var6);
-		}
-
-		this.playerEntity.playerNetServerHandler.sendPacket(new Packet53BlockChange(var3, var4, var5, this.mcServer.worldMngr));
+		if (var1.direction == 255) {
+			if (item != null)
+				this.playerEntity.theItemInWorldManager.func_6154_a(this.playerEntity, this.mcServer.worldMngr, item);
+		} else {
+			int var3 = var1.xPosition;
+			int var4 = var1.yPosition;
+			int var5 = var1.zPosition;
+			int var6 = var1.direction;
+			int var7 = (int)MathHelper.abs((float)(var3 - this.mcServer.worldMngr.spawnX));
+			int var8 = (int)MathHelper.abs((float)(var5 - this.mcServer.worldMngr.spawnZ));
+			if(var7 > var8) {
+				var8 = var7;
+			}
+
+			if(var8 > 16 || var2) {
+				this.playerEntity.theItemInWorldManager.activeBlockOrUseItem(this.playerEntity, this.mcServer.worldMngr, item, var3, var4, var5, var6, var1.hitX, var1.hitY, var1.hitZ);
+			}
+
+			this.playerEntity.playerNetServerHandler.sendPacket(new Packet53BlockChange(var3, var4, var5, this.mcServer.worldMngr));
+			if(var6 == 0) --var4;
+			if(var6 == 1) ++var4;
+			if(var6 == 2) --var5;
+			if(var6 == 3) ++var5;
+			if(var6 == 4) --var3;
+			if(var6 == 5) ++var3;
+			this.playerEntity.playerNetServerHandler.sendPacket(new Packet53BlockChange(var3, var4, var5, this.mcServer.worldMngr));
+		}
+
+		item = this.playerEntity.inventory.getCurrentItem();
+		if(item != null && item.stackSize == 0) {
+			this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem] = null;
+		}
+
+		this.playerEntity.isChangingQuantityOnly = true;
+		this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem] = ItemStack.safeCopy(this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem]);
+		Slot var12 = this.playerEntity.craftingInventory.getSlot(this.playerEntity.inventory, this.playerEntity.inventory.currentItem);
+		this.playerEntity.craftingInventory.updateCraftingMatrix();
+		this.playerEntity.isChangingQuantityOnly = false;
+		if(!ItemStack.areItemStacksEqual(this.playerEntity.inventory.getCurrentItem(), var1.itemStack)) {
+			this.sendPacket(new Packet103SetSlot(this.playerEntity.craftingInventory.windowId, var12.id, this.playerEntity.inventory.getCurrentItem()));
+		}
+
 		this.mcServer.worldMngr.disableSpawnProtection = false;
 	}
 
@@ -206,6 +344,7 @@
 		logger.info(this.playerEntity.username + " lost connection: " + var1);
 		this.mcServer.configManager.playerLoggedOut(this.playerEntity);
 		this.connectionClosed = true;
+		this.mcServer.configManager.sendPacketToAllPlayers(new Packet3Chat("Â§e" + this.playerEntity.username + " left the game."));
 	}
 
 	public void registerPacket(Packet var1) {
@@ -218,23 +357,14 @@
 	}
 
 	public void handleBlockItemSwitch(Packet16BlockItemSwitch var1) {
-		int var2 = var1.id;
-		this.playerEntity.inventory.currentItem = this.playerEntity.inventory.mainInventory.length - 1;
-		if(var2 == 0) {
-			this.heldItem = null;
-		} else {
-			this.heldItem = new ItemStack(var2);
-		}
-
-		this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem] = this.heldItem;
-		this.mcServer.entityTracker.sendPacketToTrackedPlayers(this.playerEntity, new Packet16BlockItemSwitch(this.playerEntity.entityID, var2));
+		this.playerEntity.inventory.currentItem = var1.id;
 	}
 
 	public void handlePickupSpawn(Packet21PickupSpawn var1) {
 		double var2 = (double)var1.xPosition / 32.0D;
 		double var4 = (double)var1.yPosition / 32.0D;
 		double var6 = (double)var1.zPosition / 32.0D;
-		EntityItem var8 = new EntityItem(this.mcServer.worldMngr, var2, var4, var6, new ItemStack(var1.itemID, var1.count));
+		EntityItem var8 = new EntityItem(this.mcServer.worldMngr, var2, var4, var6, new ItemStack(var1.itemID, var1.count, var1.itemDamage, var1.itemMetadata).withStorage(var1.storage));
 		var8.motionX = (double)var1.rotation / 128.0D;
 		var8.motionY = (double)var1.pitch / 128.0D;
 		var8.motionZ = (double)var1.roll / 128.0D;
@@ -250,7 +380,7 @@
 			var2 = var2.trim();
 
 			for(int var3 = 0; var3 < var2.length(); ++var3) {
-				if(" !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\'abcdefghijklmnopqrstuvwxyz{|}~\u2302\u00c7\u00fc\u00e9\u00e2\u00e4\u00e0\u00e5\u00e7\u00ea\u00eb\u00e8\u00ef\u00ee\u00ec\u00c4\u00c5\u00c9\u00e6\u00c6\u00f4\u00f6\u00f2\u00fb\u00f9\u00ff\u00d6\u00dc\u00f8\u00a3\u00d8\u00d7\u0192\u00e1\u00ed\u00f3\u00fa\u00f1\u00d1\u00aa\u00ba\u00bf\u00ae\u00ac\u00bd\u00bc\u00a1\u00ab\u00bb".indexOf(var2.charAt(var3)) < 0) {
+				if(ALLOWED_CHARACTERS.indexOf(var2.charAt(var3)) < 0) {
 					this.kickPlayer("Illegal characters in chat");
 					return;
 				}
@@ -332,7 +462,6 @@
 		if(var1.animate == 1) {
 			this.playerEntity.swingItem();
 		}
-
 	}
 
 	public void handleKickDisconnect(Packet255KickDisconnect var1) {
@@ -351,33 +480,116 @@
 		return this.playerEntity.username;
 	}
 
-	public void handlePlayerInventory(Packet5PlayerInventory var1) {
-		if(var1.inventoryType == -1) {
-			this.playerEntity.inventory.mainInventory = var1.inventory;
-		}
-
-		if(var1.inventoryType == -2) {
-			this.playerEntity.inventory.craftingInventory = var1.inventory;
-		}
-
-		if(var1.inventoryType == -3) {
-			this.playerEntity.inventory.armorInventory = var1.inventory;
-		}
-
-	}
-
-	public void sendInventoryPackets() {
-		this.netManager.addToSendQueue(new Packet5PlayerInventory(-1, this.playerEntity.inventory.mainInventory));
-		this.netManager.addToSendQueue(new Packet5PlayerInventory(-2, this.playerEntity.inventory.craftingInventory));
-		this.netManager.addToSendQueue(new Packet5PlayerInventory(-3, this.playerEntity.inventory.armorInventory));
-	}
-
-	public void handleComplexEntity(Packet59ComplexEntity var1) {
-		TileEntity var2 = this.mcServer.worldMngr.getBlockTileEntity(var1.xCoord, var1.yCoord, var1.zCoord);
-		if(var2 != null) {
-			var2.readFromNBT(var1.tileEntityNBT);
-			var2.onInventoryChanged();
-		}
-
-	}
+	public void handleUseEntity(Packet7UseEntity var1) {
+		WorldServer var2 = this.mcServer.worldMngr;
+		Entity var3 = var2.getEntityFromId(var1.targetEntity);
+		if(var3 != null && this.playerEntity.canEntityBeSeen(var3) && this.playerEntity.getDistanceSqToEntity(var3) < 36.0D) {
+			if(var1.isLeftClick == 0) {
+				this.playerEntity.interactWithEntity(var3);
+			} else if(var1.isLeftClick == 1) {
+				this.playerEntity.attackEntity(var3);
+			}
+		}
+	}
+
+	public void handleRespawnPacket(Packet9Respawn var1) {
+		if(this.playerEntity.health <= 0) {
+			this.playerEntity = this.mcServer.configManager.recreatePlayerEntity(this.playerEntity, 0);
+//			this.kickPlayer(this.playerEntity.username);
+		}
+	}
+
+	public void handleCloseWindow(Packet101CloseWindow var1) {
+		this.playerEntity.func_20059_K();
+	}
+
+	public void handleWindowClick(Packet102WindowClick var1) {
+		if(this.playerEntity.craftingInventory.windowId == var1.window_Id && this.playerEntity.craftingInventory.notInCraftResult(this.playerEntity)) {
+			if (var1.action < 0 && this.playerEntity.craftingInventory instanceof ContainerCreative) {
+				((ContainerCreative) this.playerEntity.craftingInventory).setupItems(var1.inventorySlot);
+				return;
+			}
+
+			ItemStack var2 = this.playerEntity.craftingInventory.updateSlots(var1.inventorySlot, var1.mouseClick, this.playerEntity);
+			if(ItemStack.areItemStacksEqual(var1.itemStack, var2)) {
+				this.playerEntity.playerNetServerHandler.sendPacket(new Packet106Transaction(var1.window_Id, var1.action, true));
+				this.playerEntity.isChangingQuantityOnly = true;
+				this.playerEntity.craftingInventory.updateCraftingMatrix();
+				this.playerEntity.func_20058_J();
+				this.playerEntity.isChangingQuantityOnly = false;
+			} else {
+				this.heldItems.put(this.playerEntity.craftingInventory.windowId, var1.action);
+				this.playerEntity.playerNetServerHandler.sendPacket(new Packet106Transaction(var1.window_Id, var1.action, false));
+				this.playerEntity.craftingInventory.setCraftResult(this.playerEntity, false);
+				ArrayList var3 = new ArrayList();
+
+				for(int var4 = 0; var4 < this.playerEntity.craftingInventory.slots.size(); ++var4) {
+					var3.add(((Slot)this.playerEntity.craftingInventory.slots.get(var4)).getStack());
+				}
+
+				this.playerEntity.setBothSlots(this.playerEntity.craftingInventory, var3);
+			}
+		}
+	}
+
+	public void handleTransaction(Packet106Transaction var1) {
+		Short var2 = (Short)this.heldItems.get(this.playerEntity.craftingInventory.windowId);
+		if(var2 != null
+			&& var1.mysteryShort == var2
+			&& this.playerEntity.craftingInventory.windowId == var1.windowId
+			&& !this.playerEntity.craftingInventory.notInCraftResult(this.playerEntity)) {
+			this.playerEntity.craftingInventory.setCraftResult(this.playerEntity, true);
+		}
+	}
+
+	public void handleUpdateSign(Packet130UpdateSign var1) {
+		if(this.mcServer.worldMngr.blockExists(var1.xPosition, var1.yPosition, var1.zPosition)) {
+			TileEntity var2 = this.mcServer.worldMngr.getBlockTileEntity(var1.xPosition, var1.yPosition, var1.zPosition);
+
+			for(int var3 = 0; var3 < 4; ++var3) {
+				boolean var4 = true;
+				if(var1.signLines[var3].length() > 15) {
+					var4 = false;
+				} else {
+					for(int var5 = 0; var5 < var1.signLines[var3].length(); ++var5) {
+						if(ALLOWED_CHARACTERS.indexOf(var1.signLines[var3].charAt(var5)) < 0) {
+							var4 = false;
+						}
+					}
+				}
+
+				if(!var4) {
+					var1.signLines[var3] = "!?";
+				}
+			}
+
+			if(var2 instanceof TileEntitySign) {
+				int var8 = var1.xPosition;
+				int var9 = var1.yPosition;
+				int var10 = var1.zPosition;
+				TileEntitySign var6 = (TileEntitySign)var2;
+
+				for(int var7 = 0; var7 < 4; ++var7) {
+					var6.signText[var7] = var1.signLines[var7];
+				}
+
+				var6.onInventoryChange();
+				this.mcServer.worldMngr.markBlockNeedsUpdate(var8, var9, var10);
+			}
+		}
+	}
+
+	public void handleOpenWindow(Packet100OpenWindow var1) {
+		if (var1.inventoryType == 4) {
+			this.playerEntity.displayGUICreative();
+		}
+	}
+
+	public void handleEntityAction(Packet19EntityAction var1) {
+        if (var1.state == 1) {
+            this.playerEntity.setSneaking(true);
+        } else if (var1.state == 2) {
+            this.playerEntity.setSneaking(false);
+        }
+    }
 }
--- /dev/null
+++ net/minecraft/src/GuiCreative.java
@@ -1,0 +1,191 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+import net.minecraft.client.Minecraft;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.Map;
+
+public class GuiCreative extends GuiContainer {
+	protected String title = "Creative";
+	protected InventoryReadonly inventory;
+	protected int row = 0;
+	private int maxRow;
+	private GuiSliderGeneric rowSlider;
+
+	public GuiCreative(InventoryPlayer inv, Minecraft minecraft) {
+		super(new ContainerCreative(inv, minecraft.creativeDebugEnabled
+				? InventoryReadonly.generateCreativeInventory(true)
+				: InventoryReadonly.getCreativeInventory()));
+		this.xSize = 176;
+		this.ySize = 190;
+		this.mc = minecraft;
+
+		this.inventory = ((ContainerCreative)this.inventorySlots).inventory;
+		this.maxRow = this.inventory.getInventorySize() / 8 - 7;
+		this.setupItems();
+	}
+
+	public void initGui() {
+		this.rowSlider = null;
+		this.setupItems();
+		this.setupControls();
+
+		if (this.mc.options.creativeDebug) {
+			this.controlList.add(new GuiButton(100, this.width - 150, this.height - 20, 150, 20,
+											   (this.mc.creativeDebugEnabled ? "Disable " : "Enable ") + "Debug ;)"));
+		}
+		super.initGui();
+	}
+
+	protected void drawGuiContainerBackgroundLayer(float var1) {
+		int bg = this.mc.renderEngine.getTexture("@@/gui/creative.png");
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		this.mc.renderEngine.bindTexture(bg);
+		int posX = (this.width - this.xSize) / 2;
+		int posY = (this.height - this.ySize) / 2;
+		this.drawTexturedModalRect(posX, posY, 0, 0, this.xSize, this.ySize);
+
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("@@/gui/creative.png"));
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		for (int i = 1; i < 9; i++) {
+			if (this.inventory.getLabel(i + row) != null) {
+				this.drawTexturedModalRect(posX + 7, posY + i * 18 - 1, 0, 238, 144, 18);
+			}
+		}
+	}
+
+	protected void drawGuiContainerForegroundLayer() {
+		this.fontRenderer.drawString(this.mc.creativeDebugEnabled ? "Cheats" : this.title, 8, 6, this.mc.options.getTextColor());
+		for (int i = 1; i < 9; i++) {
+			String label = this.inventory.getLabel(i + row);
+			if (label != null) {
+				this.fontRenderer.drawStringWithShadow(label, 12, i * 18 + 4, 0xFFFFFF);
+			}
+		}
+	}
+
+	protected void setupItems() {
+		this.inventory.pickOne = this.mc.thePlayer != null && this.mc.thePlayer.creative;
+		((ContainerCreative)this.inventorySlots).setupItems(this.row);
+		this.mc.playerController.setupCreativeItems(this.inventorySlots.windowId, this.row);
+	}
+
+	private void setupControls() {
+		int posX = (this.width - this.xSize) / 2 + 151;
+		int posY = (this.height - this.ySize) / 2 + 17;
+
+		if (this.mc.creativeDebugEnabled) {
+			this.controlList.add(new GuiButton(101, posX + 18, posY + 81, 18, 18, "FB"));
+			this.controlList.add(new GuiButton(102, posX + 18, posY + 99, 18, 18, "NC"));
+			this.controlList.add(new GuiButton(103, posX + 38, posY + 81, 64, 18, "Day"));
+			this.controlList.add(new GuiButton(104, posX + 38, posY + 99, 64, 18, "Night"));
+			this.controlList.add(new GuiButton(105, posX + 38, posY + 117, 64, 18, "Sunset"));
+		}
+
+		this.rowSlider = new GuiSliderGeneric(4, (this.width - this.xSize) / 2 + 151, (this.height - this.ySize) / 2 + 17, 18, 144, "Page", 0.0F, this.maxRow);
+		this.rowSlider.round = true;
+		this.rowSlider.vertical = true;
+		this.rowSlider.displayString = this.rowSlider.getDisplayString();
+		this.controlList.add(this.rowSlider);
+
+		if (this.inventory.labels != null) {
+			int y = 8;
+			for (Iterator<Map.Entry<Integer, String>> it = this.inventory.labels
+					.entrySet()
+					.stream()
+					.sorted(Comparator.comparingInt(Map.Entry::getKey))
+					.iterator(); it.hasNext(); ) {
+				Map.Entry<Integer, String> label = it.next();
+				this.controlList.add(new GuiTransparentButton(200 + label.getKey(), 8, y, (this.width - this.xSize) / 2, 12, label.getValue()));
+				y += 12;
+			}
+		}
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		switch (var1.id) {
+			case 0:
+				this.row = Math.max(this.row - 4, 0);
+				break;
+
+			case 1:
+				this.row = Math.max(this.row - 1, 0);
+				break;
+
+			case 2:
+				this.row = Math.min(this.row + 1, this.maxRow);
+				break;
+
+			case 3:
+				this.row = Math.min(this.row + 4, this.maxRow);
+				break;
+
+			case 100:
+				this.mc.creativeDebugEnabled = !this.mc.creativeDebugEnabled;
+
+				this.controlList.clear();
+				this.controlList.add(var1);
+				var1.displayString = (this.mc.creativeDebugEnabled ? "Disable " : "Enable ") + "Debug ;)";
+
+				((ContainerCreative)this.inventorySlots).inventory =
+						this.inventory = this.mc.creativeDebugEnabled
+								? InventoryReadonly.generateCreativeInventory(true)
+								: InventoryReadonly.getCreativeInventory();
+				this.maxRow = this.inventory.getInventorySize() / 8 - 7;
+				this.row = 0;
+
+				this.setupItems();
+				this.setupControls();
+				break;
+
+			case 101:
+				this.mc.renderGlobal.toggleFullbright();
+				break;
+
+			case 102:
+				this.mc.thePlayer.noClip = !this.mc.thePlayer.noClip;
+				this.mc.thePlayer.flying = this.mc.thePlayer.noClip;
+				break;
+
+			case 103:
+				this.mc.theWorld.worldTime = 1000;
+				break;
+
+			case 104:
+				this.mc.theWorld.worldTime = 14000;
+				break;
+
+			case 105:
+				this.mc.theWorld.worldTime = 12000;
+				break;
+		}
+
+		if (var1.id >= 200) {
+			this.row = var1.id - 201;
+			if (this.row > this.maxRow) {
+				this.row = this.maxRow;
+			}
+		}
+
+		setupItems();
+		if (var1.id != 4) {
+			this.rowSlider.sliderValue = row / rowSlider.multiplier;
+			this.rowSlider.displayString = this.rowSlider.getDisplayString();
+		}
+	}
+
+	public void updateScreen() {
+		int oldRow = this.row;
+		this.row = (int) this.rowSlider.getValue();
+		if (this.row != oldRow) {
+			setupItems();
+		}
+	}
+
+	protected void mouseScrolled(int delta) {
+		this.rowSlider.mouseScrolled(delta);
+	}
+}
--- net/minecraft/src/BlockBookshelf.java
+++ net/minecraft/src/BlockBookshelf.java
@@ -7,11 +7,23 @@
 		super(var1, var2, Material.wood);
 	}
 
-	public int getBlockTextureFromSide(int var1) {
-		return var1 <= 1 ? 4 : this.blockIndexInTexture;
+	public int getBlockTextureFromSide(int side) {
+		return side <= 1 ? textureXY(2, 8) : this.blockIndexInTexture;
 	}
 
 	public int quantityDropped(Random var1) {
-		return 0;
+		return 3;
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.book.shiftedIndex;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return 1;
 	}
 }
--- /dev/null
+++ net/minecraft/src/ModLoader.java
@@ -1,0 +1,176 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+import net.minecraft.server.MinecraftServer;
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+public class ModLoader {
+	public static final List<BaseMod> mods = new ArrayList<>();
+
+	public static Minecraft mc;
+	public static MinecraftServer mcServ;
+
+	public static ModLoaderRegistry registry;
+
+	private ModLoader() {
+	}
+
+	public static void init(File mcDir, Consumer<String> logger, Minecraft mc) throws Exception {
+		init(mcDir, logger, mc, null);
+	}
+
+	public static void init(File mcDir, Consumer<String> logger, MinecraftServer mcServ) throws Exception {
+		init(mcDir, logger, null, mcServ);
+	}
+
+	public static void init(File mcDir, Consumer<String> logger, Minecraft mc, MinecraftServer mcServ) throws Exception {
+		if (!System.getProperty("java.version").startsWith("1.")) {
+			return;
+		}
+
+		File modDir = new File(mcDir, "/dvmods/");
+		modDir.mkdirs();
+
+		ClassLoader classLoader = ModLoader.class.getClassLoader();
+		if (classLoader == null) {
+			throw new NullPointerException("Cannot get Minecraft's class loader!");
+		}
+
+		Method addUrl = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+		addUrl.setAccessible(true);
+
+		int modCount = 0;
+		Iterator<File> modJarList = Arrays.stream(Objects.requireNonNull(modDir.listFiles()))
+				.filter(f -> f.isFile() && (f.getName().endsWith(".jar") || f.getName().endsWith(".zip")))
+				.sorted()
+				.iterator();
+		logger.accept("Finding mods...");
+		while (modJarList.hasNext()) {
+			File file = modJarList.next();
+			if (file.isFile() && (file.getName().endsWith(".jar") || file.getName().endsWith(".zip"))) {
+				if (classLoader instanceof URLClassLoader) {
+					addUrl.invoke(classLoader, file.toURI().toURL());
+				}
+
+				logger.accept("> Found \"" + file.getName() + "\"");
+				try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(file))) {
+					ZipEntry zipEntry;
+        			while ((zipEntry = zipInputStream.getNextEntry()) != null) {
+        				String s1 = zipEntry.getName();
+        				if (!zipEntry.isDirectory() && s1.endsWith(".class")) {
+							String className = s1.split("\\.")[0];
+							if (className.contains("$")) {
+								continue;
+							}
+
+							Class<?> clazz;
+							try {
+								clazz = classLoader.loadClass(className);
+							} catch (NoClassDefFoundError | ClassNotFoundException e) {
+								e.printStackTrace();
+								continue;
+							}
+
+							if (!BaseMod.class.isAssignableFrom(clazz)) {
+								continue;
+							}
+
+							BaseMod mod = (BaseMod)clazz.newInstance();
+							mods.add(mod);
+							modCount++;
+        				}
+        			}
+				}
+			}
+		}
+
+		if (modCount == 0) {
+			logger.accept("No mods found.");
+			return;
+		}
+
+		ModLoader.mc = mc;
+		ModLoader.mcServ = mcServ;
+
+		registry = isClient() ? new ModLoaderRegistryClient() : new ModLoaderRegistry();
+
+		logger.accept("Found " + modCount + (modCount == 1 ? " mod." : " mods."));
+		for (BaseMod mod : mods) {
+			logger.accept("Loading \"" + mod + "\"");
+			mod.load();
+		}
+		logger.accept("Finished loading mods.");
+
+		for (BaseMod mod : mods) {
+			mod.postLoad();
+		}
+	}
+
+	public static boolean isClient() {
+		return mc != null && mcServ == null;
+	}
+
+	public static boolean isServer() {
+		return mc == null && mcServ != null;
+	}
+
+	public static ModSide getSide() {
+		return mcServ != null ? ModSide.SERVER : ModSide.CLIENT;
+	}
+
+	public static BufferedImage loadImage(String path) throws IOException {
+		InputStream stream = ModLoader.class.getResourceAsStream(path);
+		if (stream == null) throw new IOException("Failed to open image \"" + path + "\"");
+
+		BufferedImage img = ImageIO.read(stream);
+		if (img == null) throw new IOException("Failed to load image \"" + path + "\"");
+
+		return img;
+	}
+
+	//#region Hooks and callbacks
+	public static <T1> void callHook(Hook1<T1> hook, T1 t1) {
+		mods.forEach(hook.bind(t1)::call);
+	}
+
+	public static <T1, T2> void callHook(Hook2<T1, T2> hook, T1 t1, T2 t2) {
+		mods.forEach(hook.bind(t1, t2)::call);
+	}
+
+	public static <T1, T2, T3> void callHook(Hook3<T1, T2, T3> hook, T1 t1, T2 t2, T3 t3) {
+		mods.forEach(hook.bind(t1, t2, t3)::call);
+	}
+
+	public static boolean callHook(BooleanHookRenderBlock hook, IBlockAccess blockAccess, Block block, int x, int y, int z, int type) {
+		for (BaseMod mod : mods) if (hook.call(mod, blockAccess, block, x, y, z, type)) return true;
+		return false;
+	}
+
+	public static boolean callHook(BooleanHookInt hook, int i) {
+		for (BaseMod mod : mods) if (hook.call(mod, i)) return true;
+		return false;
+	}
+
+	public static boolean callHook(BooleanHookRenderBlockOnInventory hook, Tessellator tessellator, Block block, int metadata, int type) {
+		for (BaseMod mod : mods) if (hook.call(mod, tessellator, block, metadata, type)) return true;
+		return false;
+	}
+
+	public static <E extends EntityLiving> int callHook(IntHookAttackEntityFrom<E> hook, Class<? extends E> clazz, E target, Entity enemy, int damage) {
+		for (BaseMod mod : mods) damage = hook.call(mod, clazz, target, enemy, damage);
+		return damage;
+	}
+	//#endregion
+}
--- /dev/null
+++ net/minecraft/src/ItemShield.java
@@ -1,0 +1,26 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.ItemTooltip.*;
+
+public class ItemShield extends ItemCharm {
+	public int blockDelay;
+	public float blockAmount;
+
+	public ItemShield(int id, int durability, int blockDelay, float blockAmount) {
+		super(id, durability);
+		this.blockDelay = blockDelay;
+		this.blockAmount = blockAmount;
+	}
+
+	public boolean incompatibleWith(ItemCharm otherCharm) {
+		return super.incompatibleWith(otherCharm) || otherCharm instanceof ItemShield;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				"Sneak to block damage", DESCRIPTION_COL,
+				"Blocks " + (int)(blockAmount * 100.0F) + "% of damage", INFO_COL,
+				"every " + (blockDelay == 20 ? "second" : formatFloat(blockDelay / 20.0F) + " seconds"), INFO_COL
+		};
+	}
+}
--- /dev/null
+++ net/minecraft/src/EntityFox.java
@@ -1,0 +1,82 @@
+package net.minecraft.src;
+
+public class EntityFox extends EntityAnimal {
+	public EntityFox(World var1) {
+		super(var1);
+		this.texture = "/mob/fox.png";
+		this.setSize(0.6F, 0.7F);
+		this.moveSpeed = 1.0F;
+		this.runSpeed = 1.5F;
+		this.dataWatcher.addObject(16, (byte)0);
+	}
+
+	public boolean isRunning() {
+		return true;
+	}
+
+	public void setArctic(boolean arctic) {
+		this.dataWatcher.updateObject(16, (byte)(arctic ? 1 : 0));
+	}
+
+	public boolean getArctic() {
+		return this.dataWatcher.getWatchableObjectByte(16) > 0;
+	}
+
+	public void readEntityFromNBT(NBTTagCompound var1) {
+		super.readEntityFromNBT(var1);
+		this.setArctic(var1.getBoolean("Arctic"));
+	}
+
+	public void writeEntityToNBT(NBTTagCompound var1) {
+		super.writeEntityToNBT(var1);
+		var1.setBoolean("Arctic", this.getArctic());
+	}
+
+	protected String getLivingSound() {
+		return "mob.fox";
+	}
+
+	protected String getHurtSound() {
+		return "mob.foxhurt";
+	}
+
+	protected String getDeathSound() {
+		return this.worldObj.blueFoxDay ? "ambient.cave.cave.forced" : "mob.foxdeath";
+	}
+
+	protected int getDropItemId() {
+		return Item.fur.shiftedIndex;
+	}
+
+	public String getTexture() {
+		return this.getArctic() ? "/mob/fox_arctic.png"
+				: this.worldObj.blueFoxDay ? "/mob/fox_blue.png"
+				: "/mob/fox.png";
+	}
+
+	protected Entity findPlayerToAttack() {
+		double dist = -1.0D;
+		Entity prey = null;
+
+		for (Object entityObj : this.worldObj.loadedEntityList) {
+			if (!(entityObj instanceof EntityChicken))
+				continue;
+
+			Entity entity = (Entity)entityObj;
+			double itsDist = entity.getDistanceSqToEntity(this);
+			if (itsDist < 16.0D && (dist == -1.0D || itsDist < dist)) {
+				dist = itsDist;
+				prey = entity;
+			}
+		}
+
+		return prey;
+	}
+
+	protected void attackEntity(Entity var1, float var2) {
+		if((double)var2 < 2.5D && var1.boundingBox.maxY > this.boundingBox.minY && var1.boundingBox.minY < this.boundingBox.maxY) {
+			this.attackTime = 20;
+			var1.attackEntityFrom(this, 1);
+		}
+	}
+}
--- /dev/null
+++ net/minecraft/src/BiomeRainforest.java
@@ -1,0 +1,21 @@
+package net.minecraft.src;
+
+public class BiomeRainforest extends Biome {
+	private static final TreePopulator trees = new TreePopulator()
+			.withTree(new WorldGenMahoganyTrees())
+			.withDensity(0.2D, 2.5D, 0.4D, 5.0D, 50.0D);
+
+	protected BiomeRainforest(int id, String name, float priority, ClimateZone... climateZones) {
+		super(id, name, priority, climateZones);
+	}
+
+	public void populate(PopulatorHost host) {
+		trees.populate(host);
+		host.generateSurface(new WorldGenShrubs().withMetadata(3), 4, 8);
+		host.generateFlowers(4);
+	}
+
+	public int[] getMapColor() {
+		return new int[] { 128, 255, 64 };
+	}
+}
--- net/minecraft/src/ItemPickaxe.java
+++ net/minecraft/src/ItemPickaxe.java
@@ -1,15 +1,89 @@
 package net.minecraft.src;
 
+import java.util.Arrays;
+
 public class ItemPickaxe extends ItemTool {
-	private static Block[] blocksEffectiveAgainst = new Block[]{Block.cobblestone, Block.stairDouble, Block.stairSingle, Block.stone, Block.cobblestoneMossy, Block.oreIron, Block.blockSteel, Block.oreCoal, Block.blockGold, Block.oreGold, Block.oreDiamond, Block.blockDiamond, Block.ice};
-	private int harvestLevel;
+	private static final Block[] tier3 = new Block[] {
+			Block.obsidian,
+			Block.oreRuby,
+			Block.oreSapphire,
+			Block.refabricator,
+			Block.umbrashardCrystal,
+	};
+	private static final Block[] tier2 = new Block[] {
+			Block.blockDiamond,
+			Block.oreDiamond,
+			Block.blockGold,
+			Block.oreGold,
+			Block.oreRedstone,
+			Block.oreRedstoneGlowing,
+	};
+	private static final Block[] tier1 = new Block[] {
+			Block.blockSteel,
+			Block.oreIron,
+	};
+
+	private static final Block[] blocksEffectiveAgainst = new Block[] {
+			Block.cobblestone,
+			Block.stairDouble,
+			Block.stairSingle,
+			Block.stone,
+			Block.polishedStone,
+			Block.cobblestoneMossy,
+			Block.oreIron,
+			Block.blockSteel,
+			Block.oreCoal,
+			Block.blockGold,
+			Block.oreGold,
+			Block.oreDiamond,
+			Block.blockDiamond,
+			Block.oreRedstone,
+			Block.oreRedstoneGlowing,
+			Block.blockRedstone,
+			Block.blockCoal,
+			Block.ice,
+			Block.mobSpawner,
+			Block.stoneOvenIdle,
+			Block.stoneOvenActive,
+			Block.stairCompactCobblestone,
+			Block.stairCompactStone,
+			Block.stairCompactPolishedStone,
+			Block.stairCompactStoneBricks,
+			Block.minecartTrack,
+			Block.doorSteel,
+			Block.obsidian,
+			Block.oreRuby,
+			Block.oreSapphire,
+			Block.blasterIdle,
+			Block.blasterActive,
+			Block.refabricator,
+			Block.speleothem,
+			Block.stoneBricks,
+			Block.brickStairDouble,
+			Block.brickStairSingle,
+			Block.umbrashardCrystal,
+	};
+	private final int harvestLevel;
 
 	public ItemPickaxe(int var1, int var2) {
-		super(var1, 2, var2, blocksEffectiveAgainst);
-		this.harvestLevel = var2;
+		super(var1, 2, Math.abs(var2), blocksEffectiveAgainst, var2 < 0);
+		this.harvestLevel = Math.abs(var2);
+		if (var2 < 0) {
+			this.efficiencyOnProperMaterial *= 2.5F;
+			this.maxDamage *= 3;
+		}
 	}
 
 	public boolean canHarvestBlock(Block var1) {
-		return var1 == Block.obsidian ? this.harvestLevel == 3 : (var1 != Block.blockDiamond && var1 != Block.oreDiamond ? (var1 != Block.blockGold && var1 != Block.oreGold ? (var1 != Block.blockSteel && var1 != Block.oreIron ? (var1 != Block.oreRedstone && var1 != Block.oreRedstoneGlowing ? (var1.material == Material.rock ? true : var1.material == Material.iron) : this.harvestLevel >= 2) : this.harvestLevel >= 1) : this.harvestLevel >= 2) : this.harvestLevel >= 2);
+		if (Arrays.asList(tier3).contains(var1)) {
+			return this.harvestLevel >= 3;
+		}
+		if (Arrays.asList(tier2).contains(var1)) {
+			return this.harvestLevel >= 2;
+		}
+		if (Arrays.asList(tier1).contains(var1)) {
+			return this.harvestLevel >= 1;
+		}
+		return var1.material == Material.rock || var1.material == Material.iron;
 	}
 }
--- net/minecraft/src/RenderSheep.java
+++ net/minecraft/src/RenderSheep.java
@@ -8,7 +8,7 @@
 
 	protected boolean renderFur(EntitySheep var1, int var2) {
 		this.loadTexture("/mob/sheep_fur.png");
-		return var2 == 0 && !var1.sheared;
+		return var2 == 0 && !var1.getSheared();
 	}
 
 	protected boolean shouldRenderPass(EntityLiving var1, int var2) {
--- net/minecraft/src/ThreadLoginVerifier.java
+++ net/minecraft/src/ThreadLoginVerifier.java
@@ -4,11 +4,11 @@
 import java.io.InputStreamReader;
 import java.net.URL;
 
-class ThreadLoginVerifier extends Thread {
-	final Packet1Login loginPacket;
-	final NetLoginHandler loginHandler;
+public class ThreadLoginVerifier extends Thread {
+	public final Packet1Login loginPacket;
+	public final NetLoginHandler loginHandler;
 
-	ThreadLoginVerifier(NetLoginHandler var1, Packet1Login var2) {
+	public ThreadLoginVerifier(NetLoginHandler var1, Packet1Login var2) {
 		this.loginHandler = var1;
 		this.loginPacket = var2;
 	}
--- net/minecraft/src/EnumMobType.java
+++ net/minecraft/src/EnumMobType.java
@@ -3,5 +3,5 @@
 public enum EnumMobType {
 	everything,
 	mobs,
-	players;
+	players
 }
--- net/minecraft/src/RedstoneUpdateInfo.java
+++ net/minecraft/src/RedstoneUpdateInfo.java
@@ -1,10 +1,10 @@
 package net.minecraft.src;
 
-class RedstoneUpdateInfo {
-	int x;
-	int y;
-	int z;
-	long updateTime;
+public class RedstoneUpdateInfo {
+	public int x;
+	public int y;
+	public int z;
+	public long updateTime;
 
 	public RedstoneUpdateInfo(int var1, int var2, int var3, long var4) {
 		this.x = var1;
--- net/minecraft/src/ServerConfigurationManager.java
+++ net/minecraft/src/ServerConfigurationManager.java
@@ -12,8 +12,8 @@
 import java.util.List;
 import java.util.Set;
 import java.util.logging.Logger;
+
 import net.minecraft.server.MinecraftServer;
-
 public class ServerConfigurationManager {
 	public static Logger logger = Logger.getLogger("Minecraft");
 	public List playerEntities = new ArrayList();
@@ -33,7 +33,9 @@
 		this.bannedPlayersFile = var1.getFile("banned-players.txt");
 		this.ipBanFile = var1.getFile("banned-ips.txt");
 		this.opFile = var1.getFile("ops.txt");
-		this.playerManagerObj = new PlayerManager(var1);
+		this.playerManagerObj = new PlayerManager(var1,
+				var1.propertyManagerObj.getIntProperty("view-distance", 10),
+				var1.propertyManagerObj.getIntProperty("max-chunk-load", 10));
 		this.maxPlayers = var1.propertyManagerObj.getIntProperty("max-players", 20);
 		this.readBannedPlayers();
 		this.loadBannedList();
@@ -68,6 +70,10 @@
 		this.playerManagerObj.updateMountedMovingPlayer(var1);
 	}
 
+	public void serverLoadChunks(EntityPlayerMP var1) {
+		this.playerManagerObj.loadChunks(var1);
+	}
+
 	public void playerLoggedOut(EntityPlayerMP var1) {
 		this.playerManagerObj.removePlayer(var1);
 		this.playerNBTManagerObj.writePlayerNBT(var1);
@@ -118,6 +124,21 @@
 
 	}
 
+	public void sendPacketToOtherPlayers(EntityPlayer var1, double var2, double var4, double var6, double var8, Packet var11) {
+        for (int var12 = 0; var12 < this.playerEntities.size(); ++var12) {
+            EntityPlayerMP var13 = (EntityPlayerMP) this.playerEntities.get(var12);
+            if (var13 != var1) {
+                double var14 = var2 - var13.posX;
+                double var16 = var4 - var13.posY;
+                double var18 = var6 - var13.posZ;
+                if (var14 * var14 + var16 * var16 + var18 * var18 < var8 * var8) {
+                    var13.playerNetServerHandler.sendPacket(var11);
+                }
+            }
+        }
+
+    }
+
 	public String getPlayerList() {
 		String var1 = "";
 
@@ -322,13 +343,38 @@
 	}
 
 	public void sentTileEntityToPlayer(int var1, int var2, int var3, TileEntity var4) {
-		this.playerManagerObj.sendTileEntity(new Packet59ComplexEntity(var1, var2, var3, var4), var1, var2, var3);
 	}
 
 	public void savePlayerStates() {
 		for(int var1 = 0; var1 < this.playerEntities.size(); ++var1) {
 			this.playerNBTManagerObj.writePlayerNBT((EntityPlayerMP)this.playerEntities.get(var1));
 		}
-
+	}
+
+	public EntityPlayerMP recreatePlayerEntity(EntityPlayerMP var1, int var2) {
+		this.mcServer.entityTracker.removeTrackedPlayerSymmetric(var1);
+		this.mcServer.entityTracker.untrackEntity(var1);
+		this.playerManagerObj.removePlayer(var1);
+		this.playerEntities.remove(var1);
+		this.mcServer.worldMngr.removePlayer(var1);
+		EntityPlayerMP var4 = new EntityPlayerMP(this.mcServer, this.mcServer.worldMngr, var1.username, new ItemInWorldManager(this.mcServer.worldMngr));
+		var4.entityID = var1.entityID;
+		var4.playerNetServerHandler = var1.playerNetServerHandler;
+		WorldServer var5 = this.mcServer.worldMngr;
+
+		var5.chunkProviderServer.loadChunk((int)var4.posX >> 4, (int)var4.posZ >> 4);
+
+		while(var5.getCollidingBoundingBoxes(var4, var4.boundingBox).size() != 0) {
+			var4.setPosition(var4.posX, var4.posY + 1.0D, var4.posZ);
+		}
+
+		var4.playerNetServerHandler.sendPacket(new Packet9Respawn());
+		var4.playerNetServerHandler.teleportTo(var4.posX, var4.posY, var4.posZ, var4.rotationYaw, var4.rotationPitch);
+		var4.playerNetServerHandler.sendPacket(new Packet4UpdateTime(var5.worldTime));
+		this.playerManagerObj.addPlayer(var4);
+		var5.spawnEntityInWorld(var4);
+		this.playerEntities.add(var4);
+		var4.craftingInventory.addCrafter(var4);
+		return var4;
 	}
 }
--- net/minecraft/src/MovementInputFromOptions.java
+++ net/minecraft/src/MovementInputFromOptions.java
@@ -34,6 +34,10 @@
 			var3 = 5;
 		}
 
+		if(var1 == this.gameSettings.keyBindRun.keyCode) {
+			var3 = 6;
+		}
+
 		if(var3 >= 0) {
 			this.movementKeyStates[var3] = var2;
 		}
@@ -68,6 +72,7 @@
 
 		this.jump = this.movementKeyStates[4];
 		this.sneak = this.movementKeyStates[5];
+		this.run = this.movementKeyStates[6];
 		if(this.sneak) {
 			this.moveStrafe = (float)((double)this.moveStrafe * 0.3D);
 			this.moveForward = (float)((double)this.moveForward * 0.3D);
--- net/minecraft/src/CraftingInventoryPlayerCB.java
+++ /dev/null
@@ -1,43 +1,0 @@
-package net.minecraft.src;
-
-public class CraftingInventoryPlayerCB extends CraftingInventoryCB {
-	public InventoryCrafting craftMatrix;
-	public IInventory craftResult = new InventoryCraftResult();
-
-	public CraftingInventoryPlayerCB(ItemStack[] var1) {
-		this.craftMatrix = new InventoryCrafting(this, var1);
-		this.onCraftMatrixChanged(this.craftMatrix);
-	}
-
-	public void onCraftMatrixChanged(IInventory var1) {
-		int[] var2 = new int[9];
-
-		for(int var3 = 0; var3 < 3; ++var3) {
-			for(int var4 = 0; var4 < 3; ++var4) {
-				int var5 = -1;
-				if(var3 < 2 && var4 < 2) {
-					ItemStack var6 = this.craftMatrix.getStackInSlot(var3 + var4 * 2);
-					if(var6 != null) {
-						var5 = var6.itemID;
-					}
-				}
-
-				var2[var3 + var4 * 3] = var5;
-			}
-		}
-
-		this.craftResult.setInventorySlotContents(0, CraftingManager.getInstance().findMatchingRecipe(var2));
-	}
-
-	public void onCraftGuiClosed(EntityPlayer var1) {
-		super.onCraftGuiClosed(var1);
-
-		for(int var2 = 0; var2 < 9; ++var2) {
-			ItemStack var3 = this.craftMatrix.getStackInSlot(var2);
-			if(var3 != null) {
-				var1.dropPlayerItem(var3);
-			}
-		}
-
-	}
-}
--- net/minecraft/src/InventoryCraftResult.java
+++ net/minecraft/src/InventoryCraftResult.java
@@ -3,19 +3,19 @@
 public class InventoryCraftResult implements IInventory {
 	private ItemStack[] stackResult = new ItemStack[1];
 
-	public int getSizeInventory() {
+	public int getInventorySize() {
 		return 1;
 	}
 
-	public ItemStack getStackInSlot(int var1) {
+	public ItemStack getStack(int var1) {
 		return this.stackResult[var1];
 	}
 
-	public String getInvName() {
+	public String getInventoryName() {
 		return "Result";
 	}
 
-	public ItemStack decrStackSize(int var1, int var2) {
+	public ItemStack decrStack(int var1, int var2) {
 		if(this.stackResult[var1] != null) {
 			ItemStack var3 = this.stackResult[var1];
 			this.stackResult[var1] = null;
@@ -25,14 +25,18 @@
 		}
 	}
 
-	public void setInventorySlotContents(int var1, ItemStack var2) {
+	public void setInventorySlotItem(int var1, ItemStack var2) {
 		this.stackResult[var1] = var2;
 	}
 
-	public int getInventoryStackLimit() {
+	public int getStackLimit() {
 		return 64;
 	}
 
-	public void onInventoryChanged() {
+	public void onInventoryChange() {
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return true;
 	}
 }
--- /dev/null
+++ net/minecraft/src/ModLoaderRegistry.java
@@ -1,0 +1,95 @@
+package net.minecraft.src;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+
+public class ModLoaderRegistry {
+	protected int nextBlockId = 1000;
+	protected int nextItemId = 11000;
+	protected int nextBiomeId = 100;
+	protected int nextEntityId = 1;
+
+	public ModLoaderRegistry() {
+		if (ModLoader.registry != null) {
+			throw new IllegalStateException("Cannot create another ModLoaderRegistry!");
+		}
+	}
+
+	public int blockId() {
+		while (Block.blocksList[nextBlockId] != null) {
+			nextBlockId++;
+			if (nextBlockId >= 10000) {
+				throw new RuntimeException("Ran out of block IDs!");
+			}
+		}
+		return nextBlockId;
+	}
+
+	public int itemId() {
+		while (Item.itemsList[nextItemId + 10000] != null) {
+			nextItemId++;
+			if (nextItemId >= 55535) {
+				throw new RuntimeException("Ran out of item IDs!");
+			}
+		}
+		return nextItemId;
+	}
+
+	public int biomeId() {
+		while (Biome.biomesList[nextBiomeId] != null) {
+			nextBiomeId++;
+			if (nextBiomeId >= 256) {
+				throw new RuntimeException("Ran out of biome IDs!");
+			}
+		}
+		return nextBiomeId;
+	}
+
+	public void addAchievement(Achievement achievement) {
+	}
+
+	public int addArmor(String name) {
+		return 0;
+	}
+
+	public void addRecipe(ItemStack result, Object... recipe) {
+		CraftingManager.getInstance().addRecipe(result, recipe);
+	}
+
+	public void addRecipeNoGuide(ItemStack result, Object... recipe) {
+		CraftingManager.getInstance().addRecipeNoGuide(result, recipe);
+	}
+
+	public void registerEntity(Class<? extends Entity> entity, String name) {
+		while (EntityList.idTaken(this.nextEntityId)) {
+			this.nextEntityId++;
+		}
+		EntityList.addMapping(entity, name, this.nextEntityId);
+	}
+
+	public void registerItemBlock(Block block) {
+		Item.itemsList[block.blockID] = new ItemBlock(block.blockID - 10000);
+		Item.itemsList[block.blockID].maxStackSize = block.maxStackSize;
+	}
+
+	public void registerItemBlock(Block block, Class<? extends Item> item) {
+		try {
+			Item.itemsList[block.blockID] = item.getConstructor(Integer.TYPE).newInstance(block.blockID - 10000);
+			Item.itemsList[block.blockID].maxStackSize = block.maxStackSize;
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	public int addBlockTexture(String path) {
+		return 0;
+	}
+
+	public int addItemTexture(String path) {
+		return 0;
+	}
+
+	public boolean overrideWorldTexture(int index, String path, boolean isItem) {
+		return true;
+	}
+}
--- net/minecraft/src/Render.java
+++ net/minecraft/src/Render.java
@@ -24,12 +24,12 @@
 	private void renderEntityOnFire(Entity var1, double var2, double var4, double var6, float var8) {
 		GL11.glDisable(GL11.GL_LIGHTING);
 		int var9 = Block.fire.blockIndexInTexture;
-		int var10 = (var9 & 15) << 4;
-		int var11 = var9 & 240;
-		float var12 = (float)var10 / 256.0F;
-		float var13 = ((float)var10 + 15.99F) / 256.0F;
-		float var14 = (float)var11 / 256.0F;
-		float var15 = ((float)var11 + 15.99F) / 256.0F;
+		int var10 = var9 % 32 * 16;
+		int var11 = var9 / 32 * 16;
+		float var12 = (float)var10 / 512.0F;
+		float var13 = ((float)var10 + 15.99F) / 512.0F;
+		float var14 = (float)var11 / 512.0F;
+		float var15 = ((float)var11 + 15.99F) / 512.0F;
 		GL11.glPushMatrix();
 		GL11.glTranslatef((float)var2, (float)var4, (float)var6);
 		float var16 = var1.width * 1.4F;
@@ -208,7 +208,7 @@
 	}
 
 	public void doRenderShadowAndFire(Entity var1, double var2, double var4, double var6, float var8, float var9) {
-		if(this.renderManager.options.fancyGraphics && this.shadowSize > 0.0F) {
+		if(this.renderManager.options.fancyGraphics > 0 && this.shadowSize > 0.0F) {
 			double var10 = this.renderManager.getDistanceToCamera(var1.posX, var1.posY, var1.posZ);
 			float var12 = (float)((1.0D - var10 / 256.0D) * (double)this.shadowOpaque);
 			if(var12 > 0.0F) {
--- net/minecraft/src/Item.java
+++ net/minecraft/src/Item.java
@@ -1,116 +1,189 @@
 package net.minecraft.src;
 
 import java.util.Random;
+import java.util.Set;
+import java.util.stream.Collectors;
 
 public class Item {
 	protected static Random rand = new Random();
-	public static Item[] itemsList = new Item[32000];
-	public static Item shovel = (new ItemSpade(0, 2)).setIconIndex(82);
-	public static Item pickaxeSteel = (new ItemPickaxe(1, 2)).setIconIndex(98);
-	public static Item axeSteel = (new ItemAxe(2, 2)).setIconIndex(114);
-	public static Item striker = (new ItemFlintAndSteel(3)).setIconIndex(5);
-	public static Item appleRed = (new ItemFood(4, 4)).setIconIndex(10);
-	public static Item bow = (new ItemBow(5)).setIconIndex(21);
-	public static Item arrow = (new Item(6)).setIconIndex(37);
-	public static Item coal = (new Item(7)).setIconIndex(7);
-	public static Item diamond = (new Item(8)).setIconIndex(55);
-	public static Item ingotIron = (new Item(9)).setIconIndex(23);
-	public static Item ingotGold = (new Item(10)).setIconIndex(39);
-	public static Item swordSteel = (new ItemSword(11, 2)).setIconIndex(66);
-	public static Item swordWood = (new ItemSword(12, 0)).setIconIndex(64);
-	public static Item shovelWood = (new ItemSpade(13, 0)).setIconIndex(80);
-	public static Item pickaxeWood = (new ItemPickaxe(14, 0)).setIconIndex(96);
-	public static Item axeWood = (new ItemAxe(15, 0)).setIconIndex(112);
-	public static Item swordStone = (new ItemSword(16, 1)).setIconIndex(65);
-	public static Item shovelStone = (new ItemSpade(17, 1)).setIconIndex(81);
-	public static Item pickaxeStone = (new ItemPickaxe(18, 1)).setIconIndex(97);
-	public static Item axeStone = (new ItemAxe(19, 1)).setIconIndex(113);
-	public static Item swordDiamond = (new ItemSword(20, 3)).setIconIndex(67);
-	public static Item shovelDiamond = (new ItemSpade(21, 3)).setIconIndex(83);
-	public static Item pickaxeDiamond = (new ItemPickaxe(22, 3)).setIconIndex(99);
-	public static Item axeDiamond = (new ItemAxe(23, 3)).setIconIndex(115);
-	public static Item stick = (new Item(24)).setIconIndex(53).setFull3D();
-	public static Item bowlEmpty = (new Item(25)).setIconIndex(71);
-	public static Item bowlSoup = (new ItemSoup(26, 10)).setIconIndex(72);
-	public static Item swordGold = (new ItemSword(27, 0)).setIconIndex(68);
-	public static Item shovelGold = (new ItemSpade(28, 0)).setIconIndex(84);
-	public static Item pickaxeGold = (new ItemPickaxe(29, 0)).setIconIndex(100);
-	public static Item axeGold = (new ItemAxe(30, 0)).setIconIndex(116);
-	public static Item silk = (new Item(31)).setIconIndex(8);
-	public static Item feather = (new Item(32)).setIconIndex(24);
-	public static Item gunpowder = (new Item(33)).setIconIndex(40);
-	public static Item hoeWood = (new ItemHoe(34, 0)).setIconIndex(128);
-	public static Item hoeStone = (new ItemHoe(35, 1)).setIconIndex(129);
-	public static Item hoeSteel = (new ItemHoe(36, 2)).setIconIndex(130);
-	public static Item hoeDiamond = (new ItemHoe(37, 3)).setIconIndex(131);
-	public static Item hoeGold = (new ItemHoe(38, 1)).setIconIndex(132);
-	public static Item seeds = (new ItemSeeds(39, Block.crops.blockID)).setIconIndex(9);
-	public static Item wheat = (new Item(40)).setIconIndex(25);
-	public static Item bread = (new ItemFood(41, 5)).setIconIndex(41);
-	public static Item helmetLeather = (new ItemArmor(42, 0, 0, 0)).setIconIndex(0);
-	public static Item plateLeather = (new ItemArmor(43, 0, 0, 1)).setIconIndex(16);
-	public static Item legsLeather = (new ItemArmor(44, 0, 0, 2)).setIconIndex(32);
-	public static Item bootsLeather = (new ItemArmor(45, 0, 0, 3)).setIconIndex(48);
-	public static Item helmetChain = (new ItemArmor(46, 1, 1, 0)).setIconIndex(1);
-	public static Item plateChain = (new ItemArmor(47, 1, 1, 1)).setIconIndex(17);
-	public static Item legsChain = (new ItemArmor(48, 1, 1, 2)).setIconIndex(33);
-	public static Item bootsChain = (new ItemArmor(49, 1, 1, 3)).setIconIndex(49);
-	public static Item helmetSteel = (new ItemArmor(50, 2, 2, 0)).setIconIndex(2);
-	public static Item plateSteel = (new ItemArmor(51, 2, 2, 1)).setIconIndex(18);
-	public static Item legsSteel = (new ItemArmor(52, 2, 2, 2)).setIconIndex(34);
-	public static Item bootsSteel = (new ItemArmor(53, 2, 2, 3)).setIconIndex(50);
-	public static Item helmetDiamond = (new ItemArmor(54, 3, 3, 0)).setIconIndex(3);
-	public static Item plateDiamond = (new ItemArmor(55, 3, 3, 1)).setIconIndex(19);
-	public static Item legsDiamond = (new ItemArmor(56, 3, 3, 2)).setIconIndex(35);
-	public static Item bootsDiamond = (new ItemArmor(57, 3, 3, 3)).setIconIndex(51);
-	public static Item helmetGold = (new ItemArmor(58, 1, 4, 0)).setIconIndex(4);
-	public static Item plateGold = (new ItemArmor(59, 1, 4, 1)).setIconIndex(20);
-	public static Item legsGold = (new ItemArmor(60, 1, 4, 2)).setIconIndex(36);
-	public static Item bootsGold = (new ItemArmor(61, 1, 4, 3)).setIconIndex(52);
-	public static Item flint = (new Item(62)).setIconIndex(6);
-	public static Item porkRaw = (new ItemFood(63, 3)).setIconIndex(87);
-	public static Item porkCooked = (new ItemFood(64, 8)).setIconIndex(88);
-	public static Item painting = (new ItemPainting(65)).setIconIndex(26);
-	public static Item appleGold = (new ItemFood(66, 42)).setIconIndex(11);
-	public static Item sign = (new ItemSign(67)).setIconIndex(42);
-	public static Item doorWood = (new ItemDoor(68, Material.wood)).setIconIndex(43);
-	public static Item bucketEmpty = (new ItemBucket(69, 0)).setIconIndex(74);
-	public static Item bucketWater = (new ItemBucket(70, Block.waterMoving.blockID)).setIconIndex(75);
-	public static Item bucketLava = (new ItemBucket(71, Block.lavaMoving.blockID)).setIconIndex(76);
-	public static Item minecartEmpty = (new ItemMinecart(72, 0)).setIconIndex(135);
-	public static Item saddle = (new ItemSaddle(73)).setIconIndex(104);
-	public static Item doorSteel = (new ItemDoor(74, Material.iron)).setIconIndex(44);
-	public static Item redstone = (new ItemRedstone(75)).setIconIndex(56);
-	public static Item snowball = (new ItemSnowball(76)).setIconIndex(14);
-	public static Item boat = (new ItemBoat(77)).setIconIndex(136);
-	public static Item leather = (new Item(78)).setIconIndex(103);
-	public static Item bucketMilk = (new ItemBucket(79, -1)).setIconIndex(77);
-	public static Item brick = (new Item(80)).setIconIndex(22);
-	public static Item clay = (new Item(81)).setIconIndex(57);
-	public static Item reed = (new ItemReed(82, Block.reed)).setIconIndex(27);
-	public static Item paper = (new Item(83)).setIconIndex(58);
-	public static Item book = (new Item(84)).setIconIndex(59);
-	public static Item slimeBall = (new Item(85)).setIconIndex(30);
-	public static Item minecartBox = (new ItemMinecart(86, 1)).setIconIndex(151);
-	public static Item minecartEngine = (new ItemMinecart(87, 2)).setIconIndex(167);
-	public static Item egg = (new Item(88)).setIconIndex(12);
-	public static Item compass = (new Item(89)).setIconIndex(54);
-	public static Item fishingRod = (new Item(90)).setIconIndex(69);
-	public static Item record13 = (new ItemRecord(2000, "13")).setIconIndex(240);
-	public static Item recordCat = (new ItemRecord(2001, "cat")).setIconIndex(241);
+	public static Item[] itemsList = new Item[65536];
+	public static final Item shovel = (new ItemSpade(0, 2)).setIconIndex(textureXY(2, 5));
+	public static final Item pickaxeSteel = (new ItemPickaxe(1, 2)).setIconIndex(textureXY(2, 6));
+	public static final Item axeSteel = (new ItemAxe(2, 2)).setIconIndex(textureXY(2, 7));
+	public static final Item striker = (new ItemFlintAndSteel(3)).setIconIndex(textureXY(5, 4));
+	public static final Item appleRed = (new ItemFood(4, 4)).setIconIndex(textureXY(9, 0));
+	public static final Item bow = (new ItemBow(5)).setIconIndex(textureXY(5, 5));
+	public static final Item arrow = (new Item(6)).setIconIndex(textureXY(5, 6));
+	public static final Item coal = (new Item(7)).setIconIndex(textureXY(16, 0));
+	public static final Item diamond = (new Item(8)).setIconIndex(textureXY(16, 3));
+	public static final Item ingotIron = (new Item(9)).setIconIndex(textureXY(16, 1));
+	public static final Item ingotGold = (new Item(10)).setIconIndex(textureXY(16, 2));
+	public static final Item swordSteel = (new ItemSword(11, 2)).setIconIndex(textureXY(2, 4));
+	public static final Item swordWood = (new ItemSword(12, 0)).setIconIndex(textureXY(0, 4));
+	public static final Item shovelWood = (new ItemSpade(13, 0)).setIconIndex(textureXY(0, 5));
+	public static final Item pickaxeWood = (new ItemPickaxe(14, 0)).setIconIndex(textureXY(0, 6));
+	public static final Item axeWood = (new ItemAxe(15, 0)).setIconIndex(textureXY(0, 7));
+	public static final Item swordStone = (new ItemSword(16, 1)).setIconIndex(textureXY(1, 4));
+	public static final Item shovelStone = (new ItemSpade(17, 1)).setIconIndex(textureXY(1, 5));
+	public static final Item pickaxeStone = (new ItemPickaxe(18, 1)).setIconIndex(textureXY(1, 6));
+	public static final Item axeStone = (new ItemAxe(19, 1)).setIconIndex(textureXY(1, 7));
+	public static final Item swordDiamond = (new ItemSword(20, 3)).setIconIndex(textureXY(3, 4));
+	public static final Item shovelDiamond = (new ItemSpade(21, 3)).setIconIndex(textureXY(3, 5));
+	public static final Item pickaxeDiamond = (new ItemPickaxe(22, 3)).setIconIndex(textureXY(3, 6));
+	public static final Item axeDiamond = (new ItemAxe(23, 3)).setIconIndex(textureXY(3, 7));
+	public static final Item stick = (new Item(24)).setIconIndex(textureXY(17, 4)).setFull3D();
+	public static final Item bowlEmpty = (new Item(25)).setIconIndex(textureXY(12, 0));
+	public static final Item bowlSoup = (new ItemSoup(26, 10)).setIconIndex(textureXY(12, 1));
+	public static final Item swordGold = (new ItemSword(27, -1)).setIconIndex(textureXY(4, 4));
+	public static final Item shovelGold = (new ItemSpade(28, -1)).setIconIndex(textureXY(4, 5));
+	public static final Item pickaxeGold = (new ItemPickaxe(29, -1)).setIconIndex(textureXY(4, 6));
+	public static final Item axeGold = (new ItemAxe(30, -1)).setIconIndex(textureXY(4, 7));
+	public static final Item silk = (new Item(31)).setIconIndex(textureXY(18, 0));
+	public static final Item feather = (new Item(32)).setIconIndex(textureXY(18, 1));
+	public static final Item gunpowder = (new Item(33)).setIconIndex(textureXY(18, 5));
+	public static final Item hoeWood = (new ItemHoe(34, 0)).setIconIndex(textureXY(0, 8));
+	public static final Item hoeStone = (new ItemHoe(35, 1)).setIconIndex(textureXY(1, 8));
+	public static final Item hoeSteel = (new ItemHoe(36, 2)).setIconIndex(textureXY(2, 8));
+	public static final Item hoeDiamond = (new ItemHoe(37, 3)).setIconIndex(textureXY(3, 8));
+	public static final Item hoeGold = (new ItemHoe(38, -1)).setIconIndex(textureXY(4, 8));
+	public static final Item seeds = (new ItemSeeds(39, 59)).setIconIndex(textureXY(10, 0));
+	public static final Item wheat = (new Item(40)).setIconIndex(textureXY(10, 1));
+	public static final Item bread = (new ItemFood(41, 5)).setIconIndex(textureXY(13, 0));
+	public static final Item helmetLeather = (new ItemArmor(42, 0, 0, 0, 0.35D)).setIconIndex(textureXY(0, 0));
+	public static final Item plateLeather = (new ItemArmor(43, 0, 0, 1, 0.35D)).setIconIndex(textureXY(0, 1));
+	public static final Item legsLeather = (new ItemArmor(44, 0, 0, 2, 0.35D)).setIconIndex(textureXY(0, 2));
+	public static final Item bootsLeather = (new ItemArmor(45, 0, 0, 3, 0.35D)).setIconIndex(textureXY(0, 3));
+	public static final Item helmetChain = (new ItemArmor(46, 1, 1, 0, 0.6D)).setIconIndex(textureXY(1, 0));
+	public static final Item plateChain = (new ItemArmor(47, 1, 1, 1, 0.6D)).setIconIndex(textureXY(1, 1));
+	public static final Item legsChain = (new ItemArmor(48, 1, 1, 2, 0.6D)).setIconIndex(textureXY(1, 2));
+	public static final Item bootsChain = (new ItemArmor(49, 1, 1, 3, 0.6D)).setIconIndex(textureXY(1, 3));
+	public static final Item helmetSteel = (new ItemArmor(50, 2, 2, 0, 0.75D)).setIconIndex(textureXY(2, 0));
+	public static final Item plateSteel = (new ItemArmor(51, 2, 2, 1, 0.75D)).setIconIndex(textureXY(2, 1));
+	public static final Item legsSteel = (new ItemArmor(52, 2, 2, 2, 0.75D)).setIconIndex(textureXY(2, 2));
+	public static final Item bootsSteel = (new ItemArmor(53, 2, 2, 3, 0.75D)).setIconIndex(textureXY(2, 3));
+	public static final Item helmetDiamond = (new ItemArmor(54, 3, 3, 0, 1.0D)).setIconIndex(textureXY(3, 0));
+	public static final Item plateDiamond = (new ItemArmor(55, 3, 3, 1, 1.0D)).setIconIndex(textureXY(3, 1));
+	public static final Item legsDiamond = (new ItemArmor(56, 3, 3, 2, 1.0D)).setIconIndex(textureXY(3, 2));
+	public static final Item bootsDiamond = (new ItemArmor(57, 3, 3, 3, 1.0D)).setIconIndex(textureXY(3, 3));
+	public static final Item helmetGold = (new ItemArmor(58, 1, 4, 0, 0.55D)).setIconIndex(textureXY(4, 0));
+	public static final Item plateGold = (new ItemArmor(59, 1, 4, 1, 0.55D)).setIconIndex(textureXY(4, 1));
+	public static final Item legsGold = (new ItemArmor(60, 1, 4, 2, 0.55D)).setIconIndex(textureXY(4, 2));
+	public static final Item bootsGold = (new ItemArmor(61, 1, 4, 3, 0.55D)).setIconIndex(textureXY(4, 3));
+	public static final Item flint = (new Item(62)).setIconIndex(textureXY(17, 0));
+	public static final Item porkRaw = (new ItemFood(63, 3)).setIconIndex(textureXY(5, 0));
+	public static final Item porkCooked = (new ItemFood(64, 8)).setIconIndex(textureXY(5, 1));
+	public static final Item painting = (new ItemPainting(65)).setIconIndex(textureXY(19, 5));
+	public static final Item appleGold = (new ItemFood(66, 20, EffectType.sugarRush, 1000)).setIconIndex(textureXY(9, 1));
+	public static final Item sign = (new ItemSign(67)).setIconIndex(textureXY(19, 2));
+	public static final Item doorWood = (new ItemDoor(68, Material.wood)).setIconIndex(textureXY(19, 3));
+	public static final Item bucketEmpty = (new ItemBucket(69, 0)).setIconIndex(textureXY(0, 9));
+	public static final Item bucketWater = (new ItemBucket(70, Block.waterMoving.blockID)).setIconIndex(textureXY(1, 9));
+	public static final Item bucketLava = (new ItemBucket(71, Block.lavaMoving.blockID)).setIconIndex(textureXY(2, 9));
+	public static final Item minecartEmpty = (new ItemMinecart(72, 0)).setIconIndex(textureXY(1, 10));
+	public static final Item saddle = (new ItemSaddle(73)).setIconIndex(textureXY(0, 10));
+	public static final Item doorSteel = (new ItemDoor(74, Material.iron)).setIconIndex(textureXY(19, 4));
+	public static final Item redstone = (new ItemRedstone(75)).setIconIndex(textureXY(16, 4));
+	public static final Item snowball = (new ItemSnowball(76)).setIconIndex(textureXY(17, 3));
+	public static final Item boat = (new ItemBoat(77)).setIconIndex(textureXY(4, 10));
+	public static final Item leather = (new Item(78)).setIconIndex(textureXY(18, 3));
+	public static final Item bucketMilk = (new ItemBucket(79, -1)).setIconIndex(textureXY(3, 9));
+	public static final Item brick = (new Item(80)).setIconIndex(textureXY(17, 2));
+	public static final Item clay = (new Item(81)).setIconIndex(textureXY(17, 1));
+	public static final Item reed = (new ItemReed(82, 83)).setIconIndex(textureXY(11, 0));
+	public static final Item paper = (new Item(83)).setIconIndex(textureXY(19, 0));
+	public static final Item book = (new Item(84)).setIconIndex(textureXY(19, 1));
+	public static final Item slimeBall = (new Item(85)).setIconIndex(textureXY(18, 4));
+	public static final Item minecartBox = (new ItemMinecart(86, 1)).setIconIndex(textureXY(2, 10));
+	public static final Item minecartEngine = (new ItemMinecart(87, 2)).setIconIndex(textureXY(3, 10));
+	public static final Item egg = (new Item(88)).setIconIndex(textureXY(18, 2));
+	public static final Item compass = (new Item(89)).setIconIndex(textureXY(6, 4));
+	public static final Item fishingRod = (new Item(90)).setIconIndex(textureXY(5, 7));
+	public static final Item quiver = (new ItemQuiver(91)).setIconIndex(textureXY(0, 11));
+	public static final Item staffRuby = (new ItemStaff(92, 10.0F, 512, EntitySnowballType.ruby)).setIconIndex(textureXY(8, 4));
+	public static final Item staffSapphire = (new ItemStaff(93, 6.0F, 512, EntitySnowballType.sapphire)).setIconIndex(textureXY(9, 4));
+	public static final Item ruby = (new Item(94)).setIconIndex(textureXY(20, 0));
+	public static final Item sapphire = (new Item(95)).setIconIndex(textureXY(20, 1));
+	public static final Item beefRaw = (new ItemFood(96, 2)).setIconIndex(textureXY(6, 0));
+	public static final Item beefCooked = (new ItemFood(97, 5)).setIconIndex(textureXY(6, 1));
+	public static final Item chickenRaw = (new ItemFood(98, 2)).setIconIndex(textureXY(7, 0));
+	public static final Item chickenCooked = (new ItemFood(99, 5)).setIconIndex(textureXY(7, 1));
+	public static final Item muttonRaw = (new ItemFood(100, 2)).setIconIndex(textureXY(8, 0));
+	public static final Item muttonCooked = (new ItemFood(101, 5)).setIconIndex(textureXY(8, 1));
+	public static final Item wardingRing = (new ItemWardingRing(102)).setIconIndex(textureXY(1, 11));
+	public static final Item repairKit = (new ItemRepairKit(103)).setIconIndex(textureXY(3, 11));
+	public static final Item starChunk = (new Item(104)).setIconIndex(textureXY(20, 2));
+	public static final Item starDust = (new Item(105)).setIconIndex(textureXY(20, 3));
+	public static final Item staffSparkle = (new ItemStaff(106, 15.0F, 256, EntitySnowballType.sparkle)).setIconIndex(textureXY(10, 4));
+	public static final Item slimeShoes = (new ItemSlimeShoes(107)).setIconIndex(textureXY(2, 11));
+	public static final Item dye = (new ItemDye(108)).setIconIndex(textureXY(28, 28));
+	public static final Item nimbleBoots = (new ItemNimbleBoots(109)).setIconIndex(textureXY(4, 11));
+	public static final Item wings = (new ItemWings(110)).setIconIndex(textureXY(5, 11));
+	public static final Item sugar = (new Item(111)).setIconIndex(textureXY(11, 1));
+	public static final Item cookie = (new ItemFood(112, 3, EffectType.sugarRush, 500)).setIconIndex(textureXY(13, 1));
+	public static final Item shardGlass = (new Item(113)).setIconIndex(textureXY(20, 4));
+	public static final Item shardIce = (new Item(114)).setIconIndex(textureXY(20, 5));
+	public static final Item fluffyEars = (new ItemVanity(115, -1, "fluffy/fluffy_", false, true)).setIconIndex(textureXY(27, 31));
+	public static final Item fluffySnout = (new ItemVanity(116, -1, "fluffy/fluffy_", false, true)).setIconIndex(textureXY(26, 31));
+	public static final Item fluffyTail = (new ItemVanity(117, -1, "fluffy/fluffy_", false, true)).setIconIndex(textureXY(25, 31));
+	public static final Item topHat = (new ItemVanity(118, 0, "tophat/tophat_", true, true)).setIconIndex(textureXY(27, 30));
+	public static final Item fur = (new Item(119)).setIconIndex(textureXY(24, 31));
+	public static final Item rawIron = (new Item(120)).setIconIndex(textureXY(16, 5));
+	public static final Item rawGold = (new Item(121)).setIconIndex(textureXY(16, 6));
+	public static final Item sunglasses = (new ItemVanity(122, 0, "sunglasses", false, false)).setIconIndex(textureXY(26, 30));
+	public static final Item baseballCap = (new ItemVanity(123, 0, "cap/cap_", true, true)).setIconIndex(textureXY(25, 30));
+	public static final Item starNecklace = (new ItemStarNecklace(124)).setIconIndex(textureXY(6, 11));
+	public static final Item shieldIron = (new ItemShield(125, 128, 80, 0.5F)).setIconIndex(textureXY(0, 12));
+	public static final Item shieldGold = (new ItemShield(126, 320, 60, 0.5F)).setIconIndex(textureXY(1, 12));
+	public static final Item shieldDiamond = (new ItemShield(127, 512, 40, 0.5F)).setIconIndex(textureXY(2, 12));
+	public static final Item shieldRuby = (new ItemShield(128, 768, 30, 0.75F)).setIconIndex(textureXY(3, 12));
+	public static final Item shieldSapphire = (new ItemShield(129, 768, 60, 1.0F)).setIconIndex(textureXY(4, 12));
+	public static final Item umbrashard = (new Item(130)).setIconIndex(textureXY(17, 5));
+	public static final Item voidEssence = (new Item(131)).setIconIndex(textureXY(17, 6));
+	public static final Item frogHat = (new ItemVanity(132, 0, "froghat/froghat_", true, true)).setIconIndex(textureXY(24, 30));
+	public static final Item furyTrinket = (new ItemFuryTrinket(133, "Fury", 1.5F)).setIconIndex(textureXY(8, 6));
+	public static final Item salvationTrinket = (new ItemSalvationTrinket(134, "Salvation", 0.5F)).setIconIndex(textureXY(9, 6));
+	public static final Item hasteTrinket = (new ItemHasteTrinket(135, "Haste", 0.75F, 1.5F)).setIconIndex(textureXY(10, 6));
+	public static final Item creeperSpirit = (new ItemVanity(136, 0, "/mob/creeper.png", false, false)).setIconIndex(textureXY(23, 31));
+	public static final Item skeletonSpirit = (new ItemVanity(137, 0, "/mob/skeleton.png", false, false)).setIconIndex(textureXY(22, 31));
+	public static final Item glasses = (new ItemVanity(138, 0, "glasses", false, false)).setIconIndex(textureXY(23, 30));
+	public static final Item fluffyPaws = (new ItemVanity(139, -1, "fluffy/paws_", false, true)).setIconIndex(textureXY(22, 30));
+	public static final Item moustache = (new ItemVanity(140, 0, "moustache", false, false)).setIconIndex(textureXY(27, 29));
+	public static final Item cyberneticHeadgear = (new ItemVanity(141, 0, "cybernetic_headgear", true, false)).setIconIndex(textureXY(26, 29));
+	public static final Item longFluffySnout = (new ItemVanity(142, -1, "fluffy/fluffy_", false, true)).setIconIndex(textureXY(25, 29));
+	public static final Item helmetCardboard = (new ItemVanity(143, 0, "cardboard_1", true, false)).setIconIndex(textureXY(21, 28));
+	public static final Item plateCardboard = (new ItemVanity(144, 1, "cardboard_1", true, false)).setIconIndex(textureXY(21, 29));
+	public static final Item legsCardboard = (new ItemVanity(145, 2, "cardboard_2", true, false)).setIconIndex(textureXY(21, 30));
+	public static final Item bootsCardboard = (new ItemVanity(146, 3, "cardboard_1", true, false)).setIconIndex(textureXY(21, 31));
+	public static final Item cloak = (new ItemVanity(147, 1, "cloak/cloak_", true, true)).setIconIndex(textureXY(24, 29));
+	public static final Item record13 = (new ItemRecord(2000, "13", "C418 - 13")).setIconIndex(textureXY(0, 31));
+	public static final Item recordCat = (new ItemRecord(2001, "cat", "C418 - cat")).setIconIndex(textureXY(1, 31));
+	public static final Item recordMagnet = (new ItemRecord(2002, "magnet", "Notch - Magnetic Circuit")).setIconIndex(textureXY(2, 31));
+	public static final Item recordBlocks = (new ItemRecord(2003, "blocks", "C418 - blocks")).setIconIndex(textureXY(3, 31));
+	public static final Item recordWait = (new ItemRecord(2004, "wait", "C418 - wait")).setIconIndex(textureXY(4, 31));
+	public static final Item recordChris = (new ItemRecord(2005, "chris", "C418 - chris")).setIconIndex(textureXY(5, 31));
+	public static final Item missingItem = (new ItemMissing());
 	public final int shiftedIndex;
-	protected int maxStackSize = 64;
-	protected int maxDamage = 32;
-	protected int iconIndex;
+	public int maxStackSize = 64;
+	public int maxDamage = 0;
+	public int iconIndex;
+	public int startingDamage = 0;
 	protected boolean bFull3D = false;
 
-	protected Item(int var1) {
-		this.shiftedIndex = 256 + var1;
-		if(itemsList[256 + var1] != null) {
+	public static int textureXY(int x, int y) {
+		return y * 32 + x;
+	}
+
+	public Item(int var1) {
+		this.shiftedIndex = 10000 + var1;
+		if(itemsList[10000 + var1] != null) {
 			System.out.println("CONFLICT @ " + var1);
 		}
 
-		itemsList[256 + var1] = this;
+		itemsList[10000 + var1] = this;
+	}
+
+	public static void override(int var1) {
+		itemsList[10000 + var1] = null;
 	}
 
 	public Item setIconIndex(int var1) {
@@ -122,7 +195,7 @@
 		return this.iconIndex;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		return false;
 	}
 
@@ -166,5 +239,69 @@
 
 	public boolean isFull3D() {
 		return this.bFull3D;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[0];
+	}
+
+	public ItemTooltip getTooltip(ItemStack itemStack) {
+		ItemTooltip tooltip = null;
+
+		if (ItemTooltip.fromMetadata[this.shiftedIndex] != null) {
+			tooltip = ItemTooltip.fromMetadata[this.shiftedIndex][itemStack.itemMetadata];
+		}
+
+		if (tooltip == null) {
+			tooltip = ItemTooltip.items[this.shiftedIndex];
+		}
+
+		if (tooltip != null) {
+			tooltip = tooltip.copy();
+
+			if (this.maxDamage > 0) {
+				tooltip.addLine((this.maxDamage - itemStack.itemDmg) + " / " + this.maxDamage + " durability", ItemTooltip.INFO_COL);
+			}
+
+			if (itemStack.getTrinket() != null) {
+				tooltip.addLine("Trinket: " + itemStack.getTrinket().shortName, ItemTooltip.INFO_COL);
+			}
+
+			for (int i = 0; i < tooltip.lines.size(); i++) {
+				tooltip.lines.set(i, tooltip.lines.get(i)
+						.replace("$damageVsEntity$", String.valueOf(itemStack.getDamageVsEntity(null)))
+						.replace("$strVsBlock$", ItemTooltip.formatFloat(itemStack.getStrVsBlock(null)))
+				);
+			}
+		}
+
+
+		return tooltip;
+	}
+
+	public boolean isMagic() {
+		return false;
+	}
+
+	public boolean allowRepair() {
+		return true;
+	}
+
+	public int[] availableMetadata() {
+		return new int[] { 0 };
+	}
+
+	public boolean isSilk() { return false; }
+
+	public Item setTooltip(ItemTooltip tooltip) {
+		ItemTooltip.items[this.shiftedIndex] = tooltip;
+		return this;
+	}
+
+	public Item setMetaTooltip(int data, ItemTooltip tooltip) {
+		if (ItemTooltip.fromMetadata[this.shiftedIndex] == null)
+			ItemTooltip.fromMetadata[this.shiftedIndex] = new ItemTooltip[256];
+		ItemTooltip.fromMetadata[this.shiftedIndex][data] = tooltip;
+		return this;
 	}
 }
--- net/minecraft/src/ModelBiped.java
+++ net/minecraft/src/ModelBiped.java
@@ -17,36 +17,43 @@
 	}
 
 	public ModelBiped(float var1) {
-		this(var1, 0.0F);
+		this(var1, false);
 	}
 
-	public ModelBiped(float var1, float var2) {
+	public ModelBiped(float var1, boolean var2) {
 		this.heldItemLeft = false;
 		this.heldItemRight = false;
 		this.isSneak = false;
 		this.bipedHead = new ModelRenderer(0, 0);
+		this.bipedHead.bigTex = var2;
 		this.bipedHead.addBox(-4.0F, -8.0F, -4.0F, 8, 8, 8, var1);
-		this.bipedHead.setRotationPoint(0.0F, 0.0F + var2, 0.0F);
+		this.bipedHead.setRotationPoint(0.0F, 0.0F, 0.0F);
 		this.bipedHeadwear = new ModelRenderer(32, 0);
+		this.bipedHeadwear.bigTex = var2;
 		this.bipedHeadwear.addBox(-4.0F, -8.0F, -4.0F, 8, 8, 8, var1 + 0.5F);
-		this.bipedHeadwear.setRotationPoint(0.0F, 0.0F + var2, 0.0F);
+		this.bipedHeadwear.setRotationPoint(0.0F, 0.0F, 0.0F);
 		this.bipedBody = new ModelRenderer(16, 16);
+		this.bipedBody.bigTex = var2;
 		this.bipedBody.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, var1);
-		this.bipedBody.setRotationPoint(0.0F, 0.0F + var2, 0.0F);
+		this.bipedBody.setRotationPoint(0.0F, 0.0F, 0.0F);
 		this.bipedRightArm = new ModelRenderer(40, 16);
+		this.bipedRightArm.bigTex = var2;
 		this.bipedRightArm.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, var1);
-		this.bipedRightArm.setRotationPoint(-5.0F, 2.0F + var2, 0.0F);
+		this.bipedRightArm.setRotationPoint(-5.0F, 2.0F, 0.0F);
 		this.bipedLeftArm = new ModelRenderer(40, 16);
+		this.bipedLeftArm.bigTex = var2;
 		this.bipedLeftArm.mirror = true;
 		this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, var1);
-		this.bipedLeftArm.setRotationPoint(5.0F, 2.0F + var2, 0.0F);
+		this.bipedLeftArm.setRotationPoint(5.0F, 2.0F, 0.0F);
 		this.bipedRightLeg = new ModelRenderer(0, 16);
+		this.bipedRightLeg.bigTex = var2;
 		this.bipedRightLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, var1);
-		this.bipedRightLeg.setRotationPoint(-2.0F, 12.0F + var2, 0.0F);
+		this.bipedRightLeg.setRotationPoint(-2.0F, 12.0F, 0.0F);
 		this.bipedLeftLeg = new ModelRenderer(0, 16);
+		this.bipedLeftLeg.bigTex = var2;
 		this.bipedLeftLeg.mirror = true;
 		this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, var1);
-		this.bipedLeftLeg.setRotationPoint(2.0F, 12.0F + var2, 0.0F);
+		this.bipedLeftLeg.setRotationPoint(2.0F, 12.0F, 0.0F);
 	}
 
 	public void render(float var1, float var2, float var3, float var4, float var5, float var6) {
@@ -124,6 +131,7 @@
 			this.bipedRightLeg.rotationPointY = 9.0F;
 			this.bipedLeftLeg.rotationPointY = 9.0F;
 			this.bipedHead.rotationPointY = 1.0F;
+			this.bipedHeadwear.rotationPointY = 1.0F;
 		} else {
 			this.bipedBody.rotateAngleX = 0.0F;
 			this.bipedRightLeg.rotationPointZ = 0.0F;
@@ -131,11 +139,37 @@
 			this.bipedRightLeg.rotationPointY = 12.0F;
 			this.bipedLeftLeg.rotationPointY = 12.0F;
 			this.bipedHead.rotationPointY = 0.0F;
+			this.bipedHeadwear.rotationPointY = 0.0F;
 		}
 
 		this.bipedRightArm.rotateAngleZ += MathHelper.cos(var3 * 0.09F) * 0.05F + 0.05F;
 		this.bipedLeftArm.rotateAngleZ -= MathHelper.cos(var3 * 0.09F) * 0.05F + 0.05F;
 		this.bipedRightArm.rotateAngleX += MathHelper.sin(var3 * 0.067F) * 0.05F;
 		this.bipedLeftArm.rotateAngleX -= MathHelper.sin(var3 * 0.067F) * 0.05F;
+	}
+
+	public void showHead(boolean var1) {
+		this.bipedHead.showModel = var1;
+		this.bipedHeadwear.showModel = var1;
+	}
+
+	public void showBody(boolean var1) {
+		this.bipedBody.showModel = var1;
+	}
+
+	public void showRightArm(boolean var1) {
+		this.bipedRightArm.showModel = var1;
+	}
+
+	public void showLeftArm(boolean var1) {
+		this.bipedLeftArm.showModel = var1;
+	}
+
+	public void showRightLeg(boolean var1) {
+		this.bipedRightLeg.showModel = var1;
+	}
+
+	public void showLeftLeg(boolean var1) {
+		this.bipedLeftLeg.showModel = var1;
 	}
 }
--- net/minecraft/src/BlockRedstoneWire.java
+++ net/minecraft/src/BlockRedstoneWire.java
@@ -11,7 +11,7 @@
 	}
 
 	public int getBlockTextureFromSideAndMetadata(int var1, int var2) {
-		return this.blockIndexInTexture + (var2 > 0 ? 16 : 0);
+		return this.blockIndexInTexture + (var2 > 0 ? 32 : 0);
 	}
 
 	public AxisAlignedBB getCollisionBoundingBoxFromPool(World var1, int var2, int var3, int var4) {
@@ -184,6 +184,10 @@
 
 	public void onBlockRemoval(World var1, int var2, int var3, int var4) {
 		super.onBlockRemoval(var1, var2, var3, var4);
+		if (true) {
+			return;
+		}
+
 		var1.notifyBlocksOfNeighborChange(var2, var3 + 1, var4, this.blockID);
 		var1.notifyBlocksOfNeighborChange(var2, var3 - 1, var4, this.blockID);
 		this.updateAndPropagateCurrentStrength(var1, var2, var3, var4);
--- /dev/null
+++ net/minecraft/src/WorldGenMahoganyTrees.java
@@ -1,0 +1,122 @@
+package net.minecraft.src;
+
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
+import java.util.Random;
+
+public class WorldGenMahoganyTrees extends WorldGenerator {
+	private int trunkHeightVariation = 6;
+	private int trunkHeightMin = 6;
+	private int leavesHeightVariation = 4;
+
+	public void setScale(double var1, double var3, double var5) {
+		this.trunkHeightVariation = (int)(Math.max(var1, 0)) + 6;
+		this.trunkHeightMin = (int)(Math.max(var3, 0)) + 6;
+		this.leavesHeightVariation = (int)(Math.max(var5, 0)) + 4;
+	}
+
+	public boolean generate(World world, Random rand, int x, int y, int z) {
+		final int maxLeaves = 4;
+		int trunkHeight = rand.nextInt(trunkHeightVariation) + trunkHeightMin;
+		int leavesWidth = rand.nextInt(2) + 1;
+		int leavesHeight = rand.nextInt(leavesHeightVariation) + 2;
+
+		while (y + trunkHeight >= CHUNK_HEIGHT) {
+			trunkHeight /= 2;
+			if (trunkHeight == 0) {
+				return false;
+			}
+		}
+
+		int ground = world.getBlockId(x, y - 1, z);
+		if (ground != Block.dirt.blockID && ground != Block.grass.blockID) {
+			return false;
+		}
+
+		for (int sy = y; sy < y + trunkHeight; sy++) {
+			if (sy < 0 || sy >= CHUNK_HEIGHT)
+				continue;
+
+			for (int sx = x - leavesWidth; sx <= x + leavesWidth; sx++)
+				for (int sz = z - leavesWidth; sz <= z + leavesWidth; sz++) {
+					int block = world.getBlockId(sx, sy, sz);
+					if (block != 0 && block != Block.leaves.blockID) {
+						return false;
+					}
+				}
+		}
+
+		int ogx = x;
+		int ogz = z;
+
+		world.setBlock(x, y - 1, z, Block.dirt.blockID);
+		for (int ty = y; ty < y + trunkHeight; ty++) {
+			world.setBlockAndMetadata(x, ty, z, Block.wood.blockID, 3);
+			if (rand.nextInt(5) == 0) {
+				int add = rand.nextInt(3) - 1;
+				if (rand.nextInt(2) == 0) {
+					x += add;
+					x = Math.min(Math.max(x, ogx - 1), ogx + 1);
+				} else {
+					z += add;
+					z = Math.min(Math.max(z, ogz - 1), ogz + 1);
+				}
+			}
+		}
+
+		for (int ly = 0; ly < leavesHeight; ly++) {
+			int lyWorld = y + trunkHeight - ly;
+			int lq = Math.min(ly + 2, maxLeaves);
+
+			for (int i = 0; i < lq; i++) {
+				int lx = x + (rand.nextInt(leavesWidth * 2 + 1) - leavesWidth);
+				int lz = z + (rand.nextInt(leavesWidth * 2 + 1) - leavesWidth);
+				placeLeaves(world, lx, lyWorld, lz, rand.nextInt(3) == 0 ? 2 : 1);
+			}
+		}
+
+		int branchCount = trunkHeight / 10;
+		if (branchCount > 0) {
+			for (int i = 0; i < branchCount; i++) {
+				int by = rand.nextInt(trunkHeight / 2) + trunkHeight / 4 + y;
+				int bdx = rand.nextInt(3) - 1;
+				int bdz = rand.nextInt(3) - 1;
+				int blen = rand.nextInt(3) + 3;
+
+				int bx = x;
+				int bz = z;
+				world.setBlockAndMetadata(bx, by, bz, Block.wood.blockID, 3);
+				for (int j = 0; j < blen; j++) {
+					if (rand.nextInt(2) == 0)
+						by++;
+
+					bx += bdx;
+					bz += bdz;
+					world.setBlockAndMetadata(bx, by, bz, Block.wood.blockID, 3);
+				}
+
+				for (int ly = 0; ly < 3; ly++) {
+					int lyWorld = ly + by - 1;
+					int lc = ly < 2 ? 2 : 1;
+
+					for (int j = 0; j < lc; j++) {
+						int lx = bx + (rand.nextInt(3) - 1);
+						int lz = bz + (rand.nextInt(3) - 1);
+						placeLeaves(world, lx, lyWorld, lz, 1);
+					}
+				}
+			}
+		}
+
+		return true;
+	}
+
+	private static void placeLeaves(World world, int x, int y, int z, int leafSize) {
+		for (int lx = x - leafSize; lx <= x + leafSize; lx++)
+			for (int lz = z - leafSize; lz <= z + leafSize; lz++) {
+				if (world.getBlockId(lx, y, lz) == 0) {
+				   world.setBlockAndMetadata(lx, y, lz, Block.leaves.blockID, 3);
+				}
+			}
+	}
+}
--- /dev/null
+++ net/minecraft/src/EntityPhantom.java
@@ -1,0 +1,60 @@
+package net.minecraft.src;
+
+import java.util.List;
+
+public class EntityPhantom extends EntityMob {
+	private boolean achievementCheck;
+
+	public EntityPhantom(World var1) {
+		super(var1);
+		this.texture = "/mob/phantom.png";
+		this.moveSpeed = 2.0F;
+		this.attackStrength = 5;
+	}
+
+	protected float getBlockPathWeight(int var1, int var2, int var3) {
+		return 1.0F - this.worldObj.getBrightness(var1, var2, var3) * 5.0F;
+	}
+
+	public void onLivingUpdate() {
+		if (this.worldObj.getBrightness((int) (this.posX), (int) (this.posY), (int) (this.posZ)) >= 0.2F) {
+			this.attackEntityFrom(null, 5);
+
+			if (this.worldObj.achievements != null && !this.achievementCheck) {
+				this.achievementCheck = true;
+
+				for (EntityPlayer player : (List<EntityPlayer>)this.worldObj.playerEntities) {
+					if (this.getDistanceToEntity(player) < 16.0F && player.canEntityBeSeen(this)) {
+						this.worldObj.achievements.updateProgress(Achievement.VAMPIRIC_DEMISE, 1);
+					}
+				}
+			}
+		}
+
+		super.onLivingUpdate();
+	}
+
+	public void onDeath(Entity var1) {
+		super.onDeath(var1);
+	}
+
+	protected String getLivingSound() {
+		return "mob.phantom";
+	}
+
+	protected String getHurtSound() {
+		return "mob.phantom";
+	}
+
+	protected String getDeathSound() {
+		return "mob.phantomdeath";
+	}
+
+	protected float getSoundVolume() {
+		return 0.2F;
+	}
+
+	protected int getDropItemId() {
+		return Item.flint.shiftedIndex;
+	}
+}
--- net/minecraft/src/MetadataChunkBlock.java
+++ net/minecraft/src/MetadataChunkBlock.java
@@ -1,5 +1,7 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.Constants.CHUNK_HEIGHT;
+
 public class MetadataChunkBlock {
 	public final EnumSkyBlock skyBlock;
 	public int minX;
@@ -32,7 +34,7 @@
 				for(int var7 = this.minZ; var7 <= this.maxZ; ++var7) {
 					if(var1.blockExists(var6, 0, var7)) {
 						for(int var8 = this.minY; var8 <= this.maxY; ++var8) {
-							if(var8 >= 0 && var8 < 128) {
+							if(var8 >= 0 && var8 < CHUNK_HEIGHT) {
 								int var9 = var1.getSavedLightValue(this.skyBlock, var6, var8, var7);
 								boolean var10 = false;
 								int var11 = var1.getBlockId(var6, var8, var7);
--- /dev/null
+++ net/minecraft/src/ItemWings.java
@@ -1,0 +1,19 @@
+package net.minecraft.src;
+
+public class ItemWings extends ItemCharm {
+	public ItemWings(int id) {
+		super(id, 384, "wings");
+	}
+
+	public void updateCharm(EntityPlayer player, ItemStack stack) {
+		if (player.justJumped()
+				&& !player.onGround
+				&& !player.flying
+				&& !player.isInsideOfMaterial(Material.water)
+				&& !player.isInsideOfMaterial(Material.lava)
+				&& player.useMana(15.0F)) {
+			player.midairJump();
+			stack.damageItem(1);
+		}
+	}
+}
--- net/minecraft/src/GuiCrafting.java
+++ net/minecraft/src/GuiCrafting.java
@@ -3,43 +3,22 @@
 import org.lwjgl.opengl.GL11;
 
 public class GuiCrafting extends GuiContainer {
-	public CraftingInventoryWorkbenchCB craftingInventory = new CraftingInventoryWorkbenchCB();
-
-	public GuiCrafting(InventoryPlayer var1) {
-		this.inventorySlots.add(new SlotCrafting(this, this.craftingInventory.craftMatrix, this.craftingInventory.craftResult, 0, 124, 35));
-
-		int var2;
-		int var3;
-		for(var2 = 0; var2 < 3; ++var2) {
-			for(var3 = 0; var3 < 3; ++var3) {
-				this.inventorySlots.add(new SlotInventory(this, this.craftingInventory.craftMatrix, var3 + var2 * 3, 30 + var3 * 18, 17 + var2 * 18));
-			}
-		}
-
-		for(var2 = 0; var2 < 3; ++var2) {
-			for(var3 = 0; var3 < 9; ++var3) {
-				this.inventorySlots.add(new SlotInventory(this, var1, var3 + (var2 + 1) * 9, 8 + var3 * 18, 84 + var2 * 18));
-			}
-		}
-
-		for(var2 = 0; var2 < 9; ++var2) {
-			this.inventorySlots.add(new SlotInventory(this, var1, var2, 8 + var2 * 18, 142));
-		}
-
+	public GuiCrafting(InventoryPlayer var1, World var2, int var3, int var4, int var5) {
+		super(new ContainerWorkbench(var1, var2, var3, var4, var5));
 	}
 
 	public void onGuiClosed() {
 		super.onGuiClosed();
-		this.craftingInventory.onCraftGuiClosed(this.mc.thePlayer);
+		this.inventorySlots.onCraftGuiClosed(this.mc.thePlayer);
 	}
 
 	protected void drawGuiContainerForegroundLayer() {
-		this.fontRenderer.drawString("Crafting", 28, 6, 4210752);
-		this.fontRenderer.drawString("Inventory", 8, this.ySize - 96 + 2, 4210752);
+		this.fontRenderer.drawString("Crafting", 28, 6, this.mc.options.getTextColor());
+		this.fontRenderer.drawString("Inventory", 8, this.ySize - 96 + 2, this.mc.options.getTextColor());
 	}
 
 	protected void drawGuiContainerBackgroundLayer(float var1) {
-		int var2 = this.mc.renderEngine.getTexture("/gui/crafting.png");
+		int var2 = this.mc.renderEngine.getTexture("@@/gui/crafting.png");
 		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
 		this.mc.renderEngine.bindTexture(var2);
 		int var3 = (this.width - this.xSize) / 2;
--- net/minecraft/src/RenderPainting.java
+++ net/minecraft/src/RenderPainting.java
@@ -45,8 +45,8 @@
 				float var23 = 1.0F / 16.0F;
 				float var24 = 12.0F / 16.0F;
 				float var25 = 13.0F / 16.0F;
-				float var26 = 0.001953125F;
-				float var27 = 0.001953125F;
+				float var26 = 1.0F / 512.0F;
+				float var27 = 1.0F / 512.0F;
 				float var28 = 385.0F / 512.0F;
 				float var29 = 385.0F / 512.0F;
 				float var30 = 0.0F;
--- net/minecraft/src/GuiDeleteWorld.java
+++ net/minecraft/src/GuiDeleteWorld.java
@@ -1,8 +1,8 @@
 package net.minecraft.src;
 
 import java.io.File;
+
 import net.minecraft.client.Minecraft;
-
 public class GuiDeleteWorld extends GuiSelectWorld {
 	public GuiDeleteWorld(GuiScreen var1) {
 		super(var1);
@@ -10,7 +10,7 @@
 	}
 
 	public void initButtons() {
-		this.controlList.add(new GuiButton(6, this.width / 2 - 100, this.height / 6 + 168, "Cancel"));
+		this.controlList.add(new GuiButton(106, this.width / 2 - 100, this.height / 6 + 168, "Cancel"));
 	}
 
 	public void selectWorld(int var1) {
@@ -18,15 +18,21 @@
 		if(var2 != null) {
 			this.mc.displayGuiScreen(new GuiYesNo(this, "Are you sure you want to delete this world?", "\'" + var2 + "\' will be lost forever!", var1));
 		}
-
 	}
 
 	public void deleteWorld(boolean var1, int var2) {
 		if(var1) {
 			File var3 = Minecraft.getMinecraftDir();
-			World.deleteWorld(var3, this.getSaveName(var2));
+			World.deleteWorld(var3, "World" + var2);
 		}
 
 		this.mc.displayGuiScreen(this.parentScreen);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1.id == 106)
+			this.mc.displayGuiScreen(this.parentScreen);
+		else
+			super.actionPerformed(var1);
 	}
 }
--- net/minecraft/src/BlockButton.java
+++ net/minecraft/src/BlockButton.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockButton extends Block {
-	protected BlockButton(int var1, int var2) {
+	public BlockButton(int var1, int var2) {
 		super(var1, var2, Material.circuits);
 		this.setTickOnLoad(true);
 	}
@@ -28,27 +28,26 @@
 		return var1.isBlockNormalCube(var2 - 1, var3, var4) ? true : (var1.isBlockNormalCube(var2 + 1, var3, var4) ? true : (var1.isBlockNormalCube(var2, var3, var4 - 1) ? true : var1.isBlockNormalCube(var2, var3, var4 + 1)));
 	}
 
-	public void onBlockPlaced(World var1, int var2, int var3, int var4, int var5) {
-		int var6 = var1.getBlockMetadata(var2, var3, var4);
-		int var7 = var6 & 8;
-		var6 &= 7;
+	public int onBlockPlaced(World var1, int var2, int var3, int var4, int var5, float hitx, float hity, float hitz, int meta) {
+		int var7 = meta & 8;
+		meta &= 7;
 		if(var5 == 2 && var1.isBlockNormalCube(var2, var3, var4 + 1)) {
-			var6 = 4;
+			meta = 4;
 		}
 
 		if(var5 == 3 && var1.isBlockNormalCube(var2, var3, var4 - 1)) {
-			var6 = 3;
+			meta = 3;
 		}
 
 		if(var5 == 4 && var1.isBlockNormalCube(var2 + 1, var3, var4)) {
-			var6 = 2;
+			meta = 2;
 		}
 
 		if(var5 == 5 && var1.isBlockNormalCube(var2 - 1, var3, var4)) {
-			var6 = 1;
+			meta = 1;
 		}
 
-		var1.setBlockMetadataWithNotify(var2, var3, var4, var6 + var7);
+		return meta + var7;
 	}
 
 	public void onBlockAdded(World var1, int var2, int var3, int var4) {
--- net/minecraft/src/BlockTNT.java
+++ net/minecraft/src/BlockTNT.java
@@ -8,7 +8,7 @@
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 0 ? this.blockIndexInTexture + 2 : (var1 == 1 ? this.blockIndexInTexture + 1 : this.blockIndexInTexture);
+		return var1 == 0 ? this.blockIndexInTexture + 32 : (var1 == 1 ? this.blockIndexInTexture - 32 : this.blockIndexInTexture);
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
--- /dev/null
+++ net/minecraft/src/GuiSelectWorldNew.java
@@ -1,0 +1,167 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Objects;
+
+public class GuiSelectWorldNew extends GuiScreen {
+	protected final GuiScreen parentScreen;
+	protected String screenTitle = "Select world";
+	protected GuiSliderGeneric scrollbar;
+	private List<GuiWorldPanel> worldPanels = new ArrayList<>();
+	protected boolean selected = false;
+
+	public GuiSelectWorldNew(GuiScreen var1) {
+		this.parentScreen = var1;
+	}
+
+	public void initGui() {
+		this.loadSaves();
+		this.initButtons();
+		if (this.scrollbar == null) {
+			this.scrollbar = new GuiSliderGeneric(-1, this.width - 18, 32, 18, this.height - 64, null, 0.0F,
+					Math.max((this.worldPanels.size() * 56) - this.height + 72, 0.0F));
+			this.scrollbar.vertical = true;
+			this.scrollbar.hideBg = true;
+		} else {
+			this.scrollbar.xPosition = this.width - 18;
+			this.scrollbar.height = this.height - 64;
+			this.scrollbar.multiplier = Math.max((this.worldPanels.size() * 56) - this.height + 72, 0.0F);
+		}
+		this.controlList.add(this.scrollbar);
+	}
+
+	protected void initButtons() {
+		this.controlList.add(new GuiButton(-2, this.width / 2 - 154, this.height - 24, 100, 20, "Exit"));
+		this.controlList.add(new GuiButton(-3, this.width / 2 - 50, this.height - 24, 100, 20, "Create"));
+		this.controlList.add(new GuiButton(-4, this.width / 2 + 54, this.height - 24, 100, 20, "Delete..."));
+		if (this.worldPanels.size() == 0) {
+			this.controlList.add(new GuiButton(-3, this.width / 2 - 100, this.height / 2 + 4, 200, 20, "Create your first world!"));
+		}
+	}
+
+	private void loadSaves() {
+		this.worldPanels.clear();
+
+		File mcDir = Minecraft.getMinecraftDir();
+		File saves = new File(mcDir, "saves");
+		if (!saves.isDirectory()) return;
+
+		for (File world : Objects.requireNonNull(saves.listFiles())) {
+			if (world.isDirectory()) {
+				NBTTagCompound level = World.getLevelData(mcDir, world.getName());
+				if (level != null) {
+					String displayName = level.getString("DisplayName");
+					if (displayName != null && !displayName.isEmpty()) {
+						String folderName = World.toFolderName(displayName, saves);
+						if (!folderName.startsWith(world.getName())) {
+							File dest = new File(saves, folderName);
+							if (world.renameTo(dest)) {
+								world = dest;
+							}
+						}
+					}
+
+					this.worldPanels.add(new GuiWorldPanel(this, this.worldPanels.size(),
+							(this.width - 256) / 2, 40, world.getName(), level));
+				}
+			}
+		}
+
+		this.worldPanels.sort((a, b) -> Long.compare(b.lastPlayed, a.lastPlayed));
+		for (int i = 0; i < this.worldPanels.size(); i++) {
+			this.worldPanels.get(i).yPosition = 40 + i * 56;
+		}
+
+		this.controlList.addAll(this.worldPanels);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		if (var1 instanceof GuiWorldPanel) {
+			this.selectWorld(((GuiWorldPanel)var1).folder, ((GuiWorldPanel)var1).name);
+			return;
+		}
+
+		switch (var1.id) {
+			case -2:
+				this.mc.displayGuiScreen(this.parentScreen);
+				break;
+
+			case -3:
+				this.mc.displayGuiScreen(new GuiCreateWorld(this));
+				break;
+
+			case -4:
+				this.mc.displayGuiScreen(new GuiDeleteWorldNew(this));
+				break;
+		}
+	}
+
+	public void selectWorld(String world, String displayName) {
+		if (!this.selected) {
+			this.selected = true;
+
+			NBTTagCompound data = World.getLevelData(Minecraft.getMinecraftDir(), world);
+			if (data == null) {
+				this.mc.displayGuiScreen(new GuiCreateWorld(this));
+				this.selected = false;
+				return;
+			}
+
+			NBTTagList mods = data.getTagList("Mods");
+			if (mods.tagCount() != ModLoader.mods.size()) {
+				this.mc.displayGuiScreen(new GuiModConflict(this, world, displayName, mods));
+				this.selected = false;
+				return;
+			}
+
+			for (int i = 0; i < mods.tagCount(); i++) {
+				NBTTagCompound worldMod = (NBTTagCompound)mods.tagAt(i);
+				BaseMod currentMod = ModLoader.mods.get(i);
+
+				if (!worldMod.getString("Name").equals(currentMod.getName())
+						|| !worldMod.getString("Version").equals(currentMod.getVersion())
+						|| !worldMod.getString("Author").equals(currentMod.getAuthor())) {
+					this.mc.displayGuiScreen(new GuiModConflict(this, world, displayName, mods));
+					this.selected = false;
+					return;
+				}
+			}
+
+			this.mc.playerController = new PlayerControllerSP(this.mc);
+			this.mc.startWorld(world);
+			this.mc.displayGuiScreen(null);
+		}
+	}
+
+	public void updateScreen() {
+		for (int i = 0; i < this.worldPanels.size(); i++) {
+			GuiWorldPanel world = this.worldPanels.get(i);
+			world.yPosition = 40 + i * 56 + (int)(-this.scrollbar.sliderValue * this.scrollbar.multiplier);
+		}
+	}
+
+	protected void mouseScrolled(int delta) {
+		this.scrollbar.mouseScrolled(delta / 10.0F * this.scrollbar.multiplier);
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground(var3);
+
+		for (GuiWorldPanel worldPanel : this.worldPanels) {
+			worldPanel.drawWorldPanel(this.mc);
+		}
+
+		this.drawRect(this.width - 18, 32, this.width, this.height - 32, 0xFF202020);
+		this.drawHeader(this.screenTitle);
+
+		if (this.worldPanels.size() == 0) {
+			this.drawCenteredString(this.fontRenderer, "You have not created any worlds yet.", this.width / 2, this.height / 2 - 12, 0xFFFFFF);
+		}
+
+		super.drawScreen(var1, var2, var3);
+	}
+}
--- /dev/null
+++ net/minecraft/src/ModelFrogHat.java
@@ -1,0 +1,35 @@
+package net.minecraft.src;
+
+public class ModelFrogHat extends ModelBiped {
+	public ModelRenderer bipedHat;
+	public ModelRenderer bipedLeftEye;
+	public ModelRenderer bipedRightEye;
+
+	public ModelFrogHat(float var1) {
+		super(var1);
+		this.bipedHat = new ModelRenderer(0, 0);
+		this.bipedHat.addBox(-4.0F, -8.0F, -4.0F, 8, 4, 8, var1);
+		this.bipedHat.setRotationPoint(0.0F, 0.0F, 0.0F);
+		this.bipedLeftEye = new ModelRenderer(0, 12);
+		this.bipedLeftEye.addBox(-4.0F, -11.0F, -1.0F, 3, 3, 2, var1);
+		this.bipedLeftEye.setRotationPoint(0.0F, 0.0F, 0.0F);
+		this.bipedRightEye = new ModelRenderer(10, 12);
+		this.bipedRightEye.addBox(1.0F, -11.0F, -1.0F, 3, 3, 2, var1);
+		this.bipedRightEye.setRotationPoint(0.0F, 0.0F, 0.0F);
+	}
+
+	public void render(float var1, float var2, float var3, float var4, float var5, float var6) {
+		this.setRotationAngles(var1, var2, var3, var4, var5, var6);
+		this.bipedHat.render(var6);
+		this.bipedLeftEye.render(var6);
+		this.bipedRightEye.render(var6);
+	}
+
+	public void setRotationAngles(float var1, float var2, float var3, float var4, float var5, float var6) {
+		super.setRotationAngles(var1, var2, var3, var4, var5, var6);
+		this.bipedHat.rotateAngleX = this.bipedLeftEye.rotateAngleX = this.bipedRightEye.rotateAngleX = this.bipedHead.rotateAngleX;
+		this.bipedHat.rotateAngleY = this.bipedLeftEye.rotateAngleY = this.bipedRightEye.rotateAngleY = this.bipedHead.rotateAngleY;
+		this.bipedHat.rotateAngleZ = this.bipedLeftEye.rotateAngleZ = this.bipedRightEye.rotateAngleZ = this.bipedHead.rotateAngleZ;
+		this.bipedHat.rotationPointY = this.bipedLeftEye.rotationPointY = this.bipedRightEye.rotationPointY = this.bipedHead.rotationPointY;
+	}
+}
--- /dev/null
+++ net/minecraft/src/IAnimal.java
@@ -1,0 +1,4 @@
+package net.minecraft.src;
+
+public interface IAnimal {
+}
--- net/minecraft/src/ItemSaddle.java
+++ net/minecraft/src/ItemSaddle.java
@@ -4,7 +4,6 @@
 	public ItemSaddle(int var1) {
 		super(var1);
 		this.maxStackSize = 1;
-		this.maxDamage = 64;
 	}
 
 	public void saddleEntity(ItemStack var1, EntityLiving var2) {
--- net/minecraft/src/ItemRenderer.java
+++ net/minecraft/src/ItemRenderer.java
@@ -17,21 +17,21 @@
 
 	public void renderItem(ItemStack var1) {
 		GL11.glPushMatrix();
-		if(var1.itemID < 256 && RenderBlocks.renderItemIn3d(Block.blocksList[var1.itemID].getRenderType())) {
+		if(var1.getItem() instanceof ItemBlock && RenderBlocks.renderItemIn3d(Block.blocksList[var1.itemID].getRenderType())) {
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
-			this.renderBlocksInstance.renderBlockOnInventory(Block.blocksList[var1.itemID]);
+			this.renderBlocksInstance.renderBlockOnInventory(Block.blocksList[var1.itemID], Math.max(var1.itemMetadata, 0));
 		} else {
-			if(var1.itemID < 256) {
+			if(var1.getItem() instanceof ItemBlock) {
 				GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/terrain.png"));
 			} else {
 				GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("/gui/items.png"));
 			}
 
 			Tessellator var2 = Tessellator.instance;
-			float var3 = (float)(var1.getIconIndex() % 16 * 16 + 0) / 256.0F;
-			float var4 = (float)(var1.getIconIndex() % 16 * 16 + 16) / 256.0F;
-			float var5 = (float)(var1.getIconIndex() / 16 * 16 + 0) / 256.0F;
-			float var6 = (float)(var1.getIconIndex() / 16 * 16 + 16) / 256.0F;
+			float var3 = (float)(var1.getIconIndex() % 32 * 16 + 0) / 512.0F;
+			float var4 = (float)(var1.getIconIndex() % 32 * 16 + 15.999F) / 512.0F;
+			float var5 = (float)(var1.getIconIndex() / 32 * 16 + 0) / 512.0F;
+			float var6 = (float)(var1.getIconIndex() / 32 * 16 + 15.999F) / 512.0F;
 			float var7 = 1.0F;
 			float var8 = 0.0F;
 			float var9 = 0.3F;
@@ -66,7 +66,7 @@
 			float var15;
 			for(var12 = 0; var12 < 16; ++var12) {
 				var13 = (float)var12 / 16.0F;
-				var14 = var4 + (var3 - var4) * var13 - 0.001953125F;
+				var14 = var4 + (var3 - var4) * var13;
 				var15 = var7 * var13;
 				var2.addVertexWithUV((double)var15, 0.0D, (double)(0.0F - var11), (double)var14, (double)var6);
 				var2.addVertexWithUV((double)var15, 0.0D, 0.0D, (double)var14, (double)var6);
@@ -80,7 +80,7 @@
 
 			for(var12 = 0; var12 < 16; ++var12) {
 				var13 = (float)var12 / 16.0F;
-				var14 = var4 + (var3 - var4) * var13 - 0.001953125F;
+				var14 = var4 + (var3 - var4) * var13;
 				var15 = var7 * var13 + 1.0F / 16.0F;
 				var2.addVertexWithUV((double)var15, 1.0D, (double)(0.0F - var11), (double)var14, (double)var5);
 				var2.addVertexWithUV((double)var15, 1.0D, 0.0D, (double)var14, (double)var5);
@@ -94,7 +94,7 @@
 
 			for(var12 = 0; var12 < 16; ++var12) {
 				var13 = (float)var12 / 16.0F;
-				var14 = var6 + (var5 - var6) * var13 - 0.001953125F;
+				var14 = var6 + (var5 - var6) * var13;
 				var15 = var7 * var13 + 1.0F / 16.0F;
 				var2.addVertexWithUV(0.0D, (double)var15, 0.0D, (double)var4, (double)var14);
 				var2.addVertexWithUV((double)var7, (double)var15, 0.0D, (double)var3, (double)var14);
@@ -108,7 +108,7 @@
 
 			for(var12 = 0; var12 < 16; ++var12) {
 				var13 = (float)var12 / 16.0F;
-				var14 = var6 + (var5 - var6) * var13 - 0.001953125F;
+				var14 = var6 + (var5 - var6) * var13;
 				var15 = var7 * var13;
 				var2.addVertexWithUV((double)var7, (double)var15, 0.0D, (double)var3, (double)var14);
 				var2.addVertexWithUV(0.0D, (double)var15, 0.0D, (double)var4, (double)var14);
@@ -131,7 +131,8 @@
 		GL11.glRotatef(var3.prevRotationYaw + (var3.rotationYaw - var3.prevRotationYaw) * var1, 0.0F, 1.0F, 0.0F);
 		RenderHelper.enableStandardItemLighting();
 		GL11.glPopMatrix();
-		float var4 = this.mc.theWorld.getBrightness(MathHelper.floor_double(var3.posX), MathHelper.floor_double(var3.posY), MathHelper.floor_double(var3.posZ));
+		float var4 = this.mc.theWorld.getBrightness(MathHelper.floor_double(var3.posX), MathHelper.floor_double(var3.posY), MathHelper.floor_double(var3.posZ))
+				   * (1 - RenderGlobal.globalBrightness) + RenderGlobal.globalBrightness;
 		GL11.glColor4f(var4, var4, var4, 1.0F);
 		float var5;
 		float var6;
@@ -183,7 +184,8 @@
 			RenderPlayer var10 = (RenderPlayer)var9;
 			var8 = 1.0F;
 			GL11.glScalef(var8, var8, var8);
-			var10.drawFirstPersonHand();
+			if (RenderManager.instance.renderEngine != null)
+				var10.drawFirstPersonHand(var3);
 			GL11.glPopMatrix();
 		}
 
@@ -208,7 +210,7 @@
 			GL11.glBindTexture(GL11.GL_TEXTURE_2D, var5);
 			int var6 = this.mc.theWorld.getBlockId(var2, var3, var4);
 			if(Block.blocksList[var6] != null) {
-				this.renderInsideOfBlock(var1, Block.blocksList[var6].getBlockTextureFromSide(2));
+				this.renderInsideOfBlock(var1, Block.blocksList[var6].getBlockTextureFromSideAndMetadata(2, this.mc.theWorld.getBlockMetadata(var2, var3, var4)));
 			}
 		}
 
@@ -233,10 +235,10 @@
 		float var8 = 1.0F;
 		float var9 = -0.5F;
 		float var10 = 0.0078125F;
-		float var11 = (float)(var2 % 16) / 256.0F - var10;
-		float var12 = ((float)(var2 % 16) + 15.99F) / 256.0F + var10;
-		float var13 = (float)(var2 / 16) / 256.0F - var10;
-		float var14 = ((float)(var2 / 16) + 15.99F) / 256.0F + var10;
+		float var11 = (float)(var2 % 32 * 16) / 512.0F - var10;
+		float var12 = ((float)(var2 % 32 * 16) + 15.99F) / 512.0F + var10;
+		float var13 = (float)(var2 / 32 * 16) / 512.0F - var10;
+		float var14 = ((float)(var2 / 32 * 16) + 15.99F) / 512.0F + var10;
 		var3.startDrawingQuads();
 		var3.addVertexWithUV((double)var5, (double)var7, (double)var9, (double)var12, (double)var14);
 		var3.addVertexWithUV((double)var6, (double)var7, (double)var9, (double)var11, (double)var14);
@@ -249,7 +251,7 @@
 
 	private void renderWarpedTextureOverlay(float var1) {
 		Tessellator var2 = Tessellator.instance;
-		float var3 = this.mc.thePlayer.getBrightness(var1);
+		float var3 = this.mc.thePlayer.getBrightness(var1) * (1 - RenderGlobal.globalBrightness) + RenderGlobal.globalBrightness;
 		GL11.glColor4f(var3, var3, var3, 0.5F);
 		GL11.glEnable(GL11.GL_BLEND);
 		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
@@ -282,13 +284,13 @@
 
 		for(int var4 = 0; var4 < 2; ++var4) {
 			GL11.glPushMatrix();
-			int var5 = Block.fire.blockIndexInTexture + var4 * 16;
-			int var6 = (var5 & 15) << 4;
-			int var7 = var5 & 240;
-			float var8 = (float)var6 / 256.0F;
-			float var9 = ((float)var6 + 15.99F) / 256.0F;
-			float var10 = (float)var7 / 256.0F;
-			float var11 = ((float)var7 + 15.99F) / 256.0F;
+			int var5 = Block.fire.blockIndexInTexture + var4 * 32;
+			int var6 = var5 % 32 * 16;
+			int var7 = var5 / 32 * 16;
+			float var8 = (float)var6 / 512.0F;
+			float var9 = ((float)var6 + 15.99F) / 512.0F;
+			float var10 = (float)var7 / 512.0F;
+			float var11 = ((float)var7 + 15.99F) / 512.0F;
 			float var12 = (0.0F - var3) / 2.0F;
 			float var13 = var12 + var3;
 			float var14 = 0.0F - var3 / 2.0F;
--- net/minecraft/src/MinecraftAppletImpl.java
+++ net/minecraft/src/MinecraftAppletImpl.java
@@ -5,9 +5,8 @@
 import java.awt.Component;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.MinecraftApplet;
-
 public class MinecraftAppletImpl extends Minecraft {
-	final MinecraftApplet mainFrame;
+	public final MinecraftApplet mainFrame;
 
 	public MinecraftAppletImpl(MinecraftApplet var1, Component var2, Canvas var3, MinecraftApplet var4, int var5, int var6, boolean var7) {
 		super(var2, var3, var4, var5, var6, var7);
--- /dev/null
+++ net/minecraft/src/ItemQuiver.java
@@ -1,0 +1,37 @@
+package net.minecraft.src;
+
+public class ItemQuiver extends ItemCharm {
+	public ItemQuiver(int var1) {
+		super(var1, 256, "quiver");
+		this.startingDamage = this.maxDamage;
+	}
+
+	public ItemStack onItemRightClick(ItemStack var1, World var2, EntityPlayer var3) {
+		InventoryPlayer inventory = var3.inventory;
+
+		for (int i = 0; i < inventory.getInventorySize(); ++i) {
+			ItemStack stack = inventory.getStack(i);
+			if (stack != null && stack.itemID == Item.arrow.shiftedIndex) {
+				while (var1.itemDmg > 0 && var3.inventory.consumeInventoryItem(Item.arrow.shiftedIndex)) {
+					var1.itemDmg--;
+				}
+				var3.swingItem();
+				return var1;
+			}
+		}
+
+		if (var1.itemDmg < this.maxDamage) {
+			for (int i = this.maxDamage - var1.itemDmg; i > 0; i -= 16) {
+				var3.dropPlayerItem(new ItemStack(Item.arrow, Math.min(i, 16)));
+			}
+			var1.itemDmg = this.maxDamage;
+			var3.swingItem();
+		}
+
+		return var1;
+	}
+
+	public boolean allowRepair() {
+		return false;
+	}
+}
--- /dev/null
+++ net/minecraft/src/BitFieldGroup.java
@@ -1,0 +1,51 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+public class BitFieldGroup {
+	private final List<IBitField> fields = new ArrayList<>();
+	private int totalOffset = 0;
+
+	public BitField addBitField(String name, int size) {
+		BitField field = new BitField(name, this.totalOffset, size);
+		this.fields.add(field);
+		this.totalOffset += size;
+		return field;
+	}
+
+	public <E extends Enum<E>> EnumBitField<E> addBitField(String name, Class<E> clazz, int size) {
+		EnumBitField<E> field = new EnumBitField<>(name, clazz, this.totalOffset, size);
+		this.fields.add(field);
+		this.totalOffset += size;
+		return field;
+	}
+
+	public BitFlag addBitFlag(String name) {
+		BitFlag field = new BitFlag(name, this.totalOffset);
+		this.fields.add(field);
+		this.totalOffset++;
+		return field;
+	}
+
+	public NamedBitFlag addBitFlag(String name, String nameFalse, String nameTrue) {
+		NamedBitFlag field = new NamedBitFlag(name, this.totalOffset, nameFalse, nameTrue);
+		this.fields.add(field);
+		this.totalOffset++;
+		return field;
+	}
+
+	public NamedBitField addBitField(String name, int size, List<String> names) {
+		NamedBitField field = new NamedBitField(name, this.totalOffset, size, names);
+		this.fields.add(field);
+		this.totalOffset += size;
+		return field;
+	}
+
+	public List<String> getStates(int metadata) {
+		return fields.stream()
+				.map(bf -> bf.getName() + "=" + bf.getString(metadata))
+				.collect(Collectors.toList());
+	}
+}
--- net/minecraft/src/CraftingRecipe.java
+++ net/minecraft/src/CraftingRecipe.java
@@ -4,25 +4,27 @@
 	private int width;
 	private int height;
 	private int[] ingredientMap;
+	private int[] metadataMap;
 	private ItemStack resultStack;
 	public final int resultId;
 
-	public CraftingRecipe(int var1, int var2, int[] var3, ItemStack var4) {
-		this.resultId = var4.itemID;
+	public CraftingRecipe(int var1, int var2, int[] var3, int[] var4, ItemStack var5) {
+		this.resultId = var5.itemID;
 		this.width = var1;
 		this.height = var2;
 		this.ingredientMap = var3;
-		this.resultStack = var4;
+		this.metadataMap = var4;
+		this.resultStack = var5;
 	}
 
-	public boolean matches(int[] var1) {
+	public boolean matches(int[] var1, int[] metadata) {
 		for(int var2 = 0; var2 <= 3 - this.width; ++var2) {
 			for(int var3 = 0; var3 <= 3 - this.height; ++var3) {
-				if(this.checkMatch(var1, var2, var3, true)) {
+				if(this.checkMatch(var1, var2, var3, metadata, true)) {
 					return true;
 				}
 
-				if(this.checkMatch(var1, var2, var3, false)) {
+				if(this.checkMatch(var1, var2, var3, metadata, false)) {
 					return true;
 				}
 			}
@@ -31,21 +33,24 @@
 		return false;
 	}
 
-	private boolean checkMatch(int[] var1, int var2, int var3, boolean var4) {
+	private boolean checkMatch(int[] var1, int var2, int var3, int[] metaMap, boolean var4) {
 		for(int var5 = 0; var5 < 3; ++var5) {
 			for(int var6 = 0; var6 < 3; ++var6) {
 				int var7 = var5 - var2;
 				int var8 = var6 - var3;
 				int var9 = -1;
+				int metadata = -1;
 				if(var7 >= 0 && var8 >= 0 && var7 < this.width && var8 < this.height) {
 					if(var4) {
 						var9 = this.ingredientMap[this.width - var7 - 1 + var8 * this.width];
+						metadata = this.metadataMap[this.width - var7 - 1 + var8 * this.width];
 					} else {
 						var9 = this.ingredientMap[var7 + var8 * this.width];
+						metadata = this.metadataMap[var7 + var8 * this.width];
 					}
 				}
 
-				if(var1[var5 + var6 * 3] != var9) {
+				if(var1[var5 + var6 * 3] != var9 || (metadata >= 0 && metaMap[var5 + var6 * 3] != metadata)) {
 					return false;
 				}
 			}
@@ -54,11 +59,26 @@
 		return true;
 	}
 
-	public ItemStack getCraftingResult(int[] var1) {
-		return new ItemStack(this.resultStack.itemID, this.resultStack.stackSize);
+	public ItemStack getCraftingResult() {
+		return new ItemStack(this.resultStack.itemID, this.resultStack.stackSize, -1, this.resultStack.itemMetadata);
 	}
 
 	public int getRecipeSize() {
 		return this.width * this.height;
+	}
+
+	public ItemStack[] asItemStacks() {
+		ItemStack[] items = new ItemStack[10];
+		for (int y = 0; y < this.height; y++) {
+			for (int x = 0; x < this.width; x++) {
+				int item = this.ingredientMap[x + y * this.width];
+				if (item > 0) {
+					int meta = this.metadataMap[x + y * this.width];
+					items[x + y * 3] = new ItemStack(item, 1, -1, meta);
+				}
+			}
+		}
+		items[9] = this.resultStack;
+		return items;
 	}
 }
--- /dev/null
+++ net/minecraft/src/ContainerCreative.java
@@ -1,0 +1,61 @@
+package net.minecraft.src;
+
+public class ContainerCreative extends Container {
+	public InventoryPlayer inventoryPlayer;
+	public InventoryReadonly inventory;
+
+	public ContainerCreative(InventoryPlayer inventoryPlayer, InventoryReadonly inventory) {
+		this.inventoryPlayer = inventoryPlayer;
+		this.inventory = inventory;
+	}
+
+	public void setupItems(int row) {
+		this.slots.clear();
+		for (int i = row * 8; i < 64 + row * 8; i++) {
+			this.addSlot(new Slot(this.inventory, i, ((i - row * 8) % 8) * 18 + 8,
+					((i - row * 8) / 8) * 18 + 18));
+		}
+		for (int i = 0; i < 9; i++) {
+			this.addSlot(new Slot(this.inventoryPlayer, i, 8 + i * 18, 166));
+		}
+	}
+
+	public void setupBlocks(int row) {
+		this.slots.clear();
+		for (int i = row * 8; i < 64 + row * 8; i++) {
+			boolean invalid = false;
+
+			checkBlock: {
+				ItemStack itemStack = this.inventory.getStack(i);
+				if (itemStack == null
+						|| itemStack.itemID <= 0
+						|| itemStack.itemID >= 10000) {
+					invalid = true;
+					break checkBlock;
+				}
+
+				Item item = itemStack.getItem();
+				if (!(item instanceof ItemBlock)) {
+					invalid = true;
+					break checkBlock;
+				}
+
+				Block block = Block.blocksList[item.shiftedIndex];
+				if (!block.isOpaqueCube()) {
+					invalid = true;
+					break checkBlock;
+				}
+			}
+
+			int var3 = ((i - row * 8) % 8) * 18 + 8;
+			int var4 = ((i - row * 8) / 8) * 18 + 18;
+			this.addSlot(invalid
+					? new SlotShadowed(this.inventory, i, var3, var4)
+					: new Slot(this.inventory, i, var3, var4));
+		}
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return true;
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemTooltip.java
@@ -1,0 +1,618 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ItemTooltip {
+	public static ItemTooltip[] items = new ItemTooltip[65536];
+	public static ItemTooltip[][] fromMetadata = new ItemTooltip[65536][];
+	public List<String> lines = new ArrayList<>();
+	public List<Integer> colors = new ArrayList<>();
+	public Pair<Integer, Integer> gradient;
+
+	public static final Pair<Integer, Integer> DEFAULT_GRAD = new Pair<>(0xC0333366, 0xC0101020);
+	public static final Pair<Integer, Integer> BETA_GRAD = new Pair<>(0xC0000000, 0xC0000000);
+	public static final Pair<Integer, Integer> NOVELTY_GRAD = new Pair<>(0xC0663399, 0xC0101020);
+	public static final Pair<Integer, Integer> INVALID_GRAD = new Pair<>(0xC07E1212, 0xC0101020);
+	public static final Pair<Integer, Integer> LEGENDARY_GRAD = new Pair<>(0xC0663366, 0xC0201020);
+	public static final int INVALID_COL = 0xFF5555;
+	public static final int DESCRIPTION_COL = 0xAAAAAA;
+	public static final int INFO_COL = 0xAAAA66;
+	public static final int UNCOMMON_COL = 0xFFFF55;
+	public static final int RARE_COL = 0x55FFFF;
+	public static final int LEGENDARY_COL = 0xFF55FF;
+
+	static {
+		items[0] = ItemTooltip.invalid("Air");
+		items[1] = new ItemTooltip("Stone");
+		fromMetadata[1] = new ItemTooltip[256];
+		fromMetadata[1][1] = new ItemTooltip("Marble");
+		fromMetadata[1][2] = new ItemTooltip("Slate");
+		fromMetadata[1][3] = new ItemTooltip("Granite");
+		fromMetadata[1][4] = new ItemTooltip("Shadorite");
+		items[2] = new ItemTooltip("Grass");
+		items[3] = new ItemTooltip("Dirt");
+		items[4] = new ItemTooltip("Cobblestone");
+		fromMetadata[4] = new ItemTooltip[256];
+		fromMetadata[4][1] = new ItemTooltip("Cobbled Marble");
+		fromMetadata[4][2] = new ItemTooltip("Cobbled Slate");
+		fromMetadata[4][3] = new ItemTooltip("Cobbled Granite");
+		fromMetadata[4][4] = new ItemTooltip("Cobbled Shadorite");
+		items[5] = new ItemTooltip("Planks");
+		fromMetadata[5] = new ItemTooltip[256];
+		fromMetadata[5][0] = new ItemTooltip("Oak Planks");
+		fromMetadata[5][1] = new ItemTooltip("Spruce Planks");
+		fromMetadata[5][2] = new ItemTooltip("Maple Planks");
+		fromMetadata[5][3] = new ItemTooltip("Mahogany Planks");
+		items[6] = new ItemTooltip("Sapling", "Grows into a tree", DESCRIPTION_COL);
+		fromMetadata[6] = new ItemTooltip[256];
+		fromMetadata[6][0] = new ItemTooltip("Oak Sapling", "Grows into an oak tree", DESCRIPTION_COL);
+		fromMetadata[6][1] = new ItemTooltip("Spruce Sapling", "Grows into a spruce tree", DESCRIPTION_COL);
+		fromMetadata[6][2] = new ItemTooltip("Maple Sapling", "Grows into a maple tree", DESCRIPTION_COL);
+		fromMetadata[6][3] = new ItemTooltip("Mahogany Sapling", "Grows into a mahogany tree", DESCRIPTION_COL);
+		items[7] = ItemTooltip.invalid("Bedrock");
+		items[8] = ItemTooltip.invalid("Flowing Water");
+		items[9] = ItemTooltip.invalid("Still Water");
+		items[10] = ItemTooltip.invalid("Flowing Lava");
+		items[11] = ItemTooltip.invalid("Still Lava");
+		items[12] = new ItemTooltip("Sand");
+		items[13] = new ItemTooltip("Gravel");
+		items[14] = new ItemTooltip("Gold Ore", UNCOMMON_COL);
+		items[15] = new ItemTooltip("Iron Ore", UNCOMMON_COL);
+		items[16] = new ItemTooltip("Coal Ore");
+		items[17] = new ItemTooltip("Log");
+		fromMetadata[17] = new ItemTooltip[256];
+		fromMetadata[17][0] = new ItemTooltip("Oak Log");
+		fromMetadata[17][1] = new ItemTooltip("Spruce Log");
+		fromMetadata[17][2] = new ItemTooltip("Maple Log");
+		fromMetadata[17][3] = new ItemTooltip("Mahogany Log");
+		items[18] = new ItemTooltip("Leaves");
+		fromMetadata[18] = new ItemTooltip[256];
+		fromMetadata[18][0] = new ItemTooltip("Oak Leaves");
+		fromMetadata[18][1] = new ItemTooltip("Spruce Leaves");
+		fromMetadata[18][2] = new ItemTooltip("Maple Leaves");
+		fromMetadata[18][3] = new ItemTooltip("Mahogany Leaves");
+		items[19] = ItemTooltip.invalid("Sponge");
+		items[20] = new ItemTooltip("Glass");
+		items[21] = new ItemTooltip("Polished Stone");
+		fromMetadata[21] = new ItemTooltip[256];
+		fromMetadata[21][1] = new ItemTooltip("Polished Marble");
+		fromMetadata[21][2] = new ItemTooltip("Polished Slate");
+		fromMetadata[21][3] = new ItemTooltip("Polished Granite");
+		fromMetadata[21][4] = new ItemTooltip("Polished Shadorite");
+		items[22] = ItemTooltip.invalid("Double Plank Slab");
+		fromMetadata[22] = new ItemTooltip[256];
+		fromMetadata[22][0] = ItemTooltip.invalid("Double Oak Plank Slab");
+		fromMetadata[22][1] = ItemTooltip.invalid("Double Spruce Plank Slab");
+		fromMetadata[22][2] = ItemTooltip.invalid("Double Maple Plank Slab");
+		fromMetadata[22][3] = ItemTooltip.invalid("Double Mahogany Plank Slab");
+		items[23] = new ItemTooltip("Plank Slab");
+		fromMetadata[23] = new ItemTooltip[256];
+		fromMetadata[23][0] = new ItemTooltip("Oak Plank Slab");
+		fromMetadata[23][1] = new ItemTooltip("Spruce Plank Slab");
+		fromMetadata[23][2] = new ItemTooltip("Maple Plank Slab");
+		fromMetadata[23][3] = new ItemTooltip("Mahogany Plank Slab");
+		items[24] = ItemTooltip.invalid("Old Double Brick Slab");
+		items[25] = ItemTooltip.invalid("Old Brick Slab");
+		items[26] = new ItemTooltip("Stone Bricks");
+		fromMetadata[26] = new ItemTooltip[256];
+		fromMetadata[26][1] = new ItemTooltip("Marble Bricks");
+		fromMetadata[26][2] = new ItemTooltip("Slate Bricks");
+		fromMetadata[26][3] = new ItemTooltip("Granite Bricks");
+		fromMetadata[26][4] = new ItemTooltip("Shadorite Bricks");
+		items[27] = ItemTooltip.invalid("Stone Stairs");
+		fromMetadata[27] = new ItemTooltip[256];
+		fromMetadata[27][0] = new ItemTooltip("Stone Stairs");
+		fromMetadata[27][4] = new ItemTooltip("Marble Stairs");
+		fromMetadata[27][8] = new ItemTooltip("Slate Stairs");
+		fromMetadata[27][12] = new ItemTooltip("Granite Stairs");
+		fromMetadata[27][16] = new ItemTooltip("Shadorite Stairs");
+		items[28] = ItemTooltip.invalid("Polished Stone Stairs");
+		fromMetadata[28] = new ItemTooltip[256];
+		fromMetadata[28][0] = new ItemTooltip("Polished Stone Stairs");
+		fromMetadata[28][4] = new ItemTooltip("Polished Marble Stairs");
+		fromMetadata[28][8] = new ItemTooltip("Polished Slate Stairs");
+		fromMetadata[28][12] = new ItemTooltip("Polished Granite Stairs");
+		fromMetadata[28][16] = new ItemTooltip("Polished Shadorite Stairs");
+		items[29] = ItemTooltip.invalid("Stone Brick Stairs");
+		fromMetadata[29] = new ItemTooltip[256];
+		fromMetadata[29][0] = new ItemTooltip("Stone Brick Stairs");
+		fromMetadata[29][4] = new ItemTooltip("Marble Brick Stairs");
+		fromMetadata[29][8] = new ItemTooltip("Slate Brick Stairs");
+		fromMetadata[29][12] = new ItemTooltip("Granite Brick Stairs");
+		fromMetadata[29][16] = new ItemTooltip("Shadorite Brick Stairs");
+		items[35] = new ItemTooltip("Wool");
+		fromMetadata[35] = new ItemTooltip[256];
+		fromMetadata[35][0] = new ItemTooltip("White Wool");
+		fromMetadata[35][1] = new ItemTooltip("Red Wool");
+		fromMetadata[35][2] = new ItemTooltip("Orange Wool");
+		fromMetadata[35][3] = new ItemTooltip("Yellow Wool");
+		fromMetadata[35][4] = new ItemTooltip("Chartreuse Wool");
+		fromMetadata[35][5] = new ItemTooltip("Green Wool");
+		fromMetadata[35][6] = new ItemTooltip("Spring Green Wool");
+		fromMetadata[35][7] = new ItemTooltip("Cyan Wool");
+		fromMetadata[35][8] = new ItemTooltip("Capri Wool");
+		fromMetadata[35][9] = new ItemTooltip("Ultramarine Wool");
+		fromMetadata[35][10] = new ItemTooltip("Violet Wool");
+		fromMetadata[35][11] = new ItemTooltip("Purple Wool");
+		fromMetadata[35][12] = new ItemTooltip("Magenta Wool");
+		fromMetadata[35][13] = new ItemTooltip("Rose Wool");
+		fromMetadata[35][14] = new ItemTooltip("Black Wool");
+		fromMetadata[35][15] = new ItemTooltip("Gray Wool");
+		items[36] = new ItemTooltip("Cornflower");
+		items[37] = new ItemTooltip("Dandelion");
+		items[38] = new ItemTooltip("Rose");
+		items[39] = new ItemTooltip("Brown Mushroom");
+		items[40] = new ItemTooltip("Red Mushroom");
+		items[41] = new ItemTooltip("Block of Gold", UNCOMMON_COL);
+		items[42] = new ItemTooltip("Block of Iron", UNCOMMON_COL);
+		items[43] = ItemTooltip.invalid("Double Stone Slab");
+		fromMetadata[43] = new ItemTooltip[256];
+		fromMetadata[43][0] = ItemTooltip.invalid("Double Cobblestone Slab");
+		fromMetadata[43][1] = ItemTooltip.invalid("Double Cobbled Marble Slab");
+		fromMetadata[43][2] = ItemTooltip.invalid("Double Cobbled Slate Slab");
+		fromMetadata[43][3] = ItemTooltip.invalid("Double Stone Slab");
+		fromMetadata[43][4] = ItemTooltip.invalid("Double Marble Slab");
+		fromMetadata[43][5] = ItemTooltip.invalid("Double Slate Slab");
+		fromMetadata[43][6] = ItemTooltip.invalid("Double Polished Stone Slab");
+		fromMetadata[43][7] = ItemTooltip.invalid("Double Polished Marble Slab");
+		fromMetadata[43][8] = ItemTooltip.invalid("Double Polished Slate Slab");
+		fromMetadata[43][9] = ItemTooltip.invalid("Double Granite Slab");
+		fromMetadata[43][10] = ItemTooltip.invalid("Double Cobbled Granite Slab");
+		fromMetadata[43][11] = ItemTooltip.invalid("Double Polished Granite Slab");
+		fromMetadata[43][12] = ItemTooltip.invalid("Double Stone Brick Slab");
+		fromMetadata[43][13] = ItemTooltip.invalid("Double Marble Brick Slab");
+		fromMetadata[43][14] = ItemTooltip.invalid("Double Slate Brick Slab");
+		fromMetadata[43][15] = ItemTooltip.invalid("Double Granite Brick Slab");
+		fromMetadata[43][16] = ItemTooltip.invalid("Double Brick Slab");
+		fromMetadata[43][17] = ItemTooltip.invalid("Double Shadorite Slab");
+		fromMetadata[43][18] = ItemTooltip.invalid("Double Cobbled Shadorite Slab");
+		fromMetadata[43][19] = ItemTooltip.invalid("Double Polished Shadorite Slab");
+		fromMetadata[43][20] = ItemTooltip.invalid("Double Shadorite Brick Slab");
+		items[44] = new ItemTooltip("Stone Slab");
+		fromMetadata[44] = new ItemTooltip[256];
+		fromMetadata[44][0] = new ItemTooltip("Cobblestone Slab");
+		fromMetadata[44][1] = new ItemTooltip("Cobbled Marble Slab");
+		fromMetadata[44][2] = new ItemTooltip("Cobbled Slate Slab");
+		fromMetadata[44][3] = new ItemTooltip("Stone Slab");
+		fromMetadata[44][4] = new ItemTooltip("Marble Slab");
+		fromMetadata[44][5] = new ItemTooltip("Slate Slab");
+		fromMetadata[44][6] = new ItemTooltip("Polished Stone Slab");
+		fromMetadata[44][7] = new ItemTooltip("Polished Marble Slab");
+		fromMetadata[44][8] = new ItemTooltip("Polished Slate Slab");
+		fromMetadata[44][9] = new ItemTooltip("Cobbled Granite Slab");
+		fromMetadata[44][10] = new ItemTooltip("Granite Slab");
+		fromMetadata[44][11] = new ItemTooltip("Polished Granite Slab");
+		fromMetadata[44][12] = new ItemTooltip("Stone Brick Slab");
+		fromMetadata[44][13] = new ItemTooltip("Marble Brick Slab");
+		fromMetadata[44][14] = new ItemTooltip("Slate Brick Slab");
+		fromMetadata[44][15] = new ItemTooltip("Granite Brick Slab");
+		fromMetadata[44][16] = new ItemTooltip("Brick Slab");
+		fromMetadata[44][18] = new ItemTooltip("Cobbled Shadorite Slab");
+		fromMetadata[44][17] = new ItemTooltip("Shadorite Slab");
+		fromMetadata[44][19] = new ItemTooltip("Polished Shadorite Slab");
+		fromMetadata[44][20] = new ItemTooltip("Shadorite Brick Slab");
+		items[45] = new ItemTooltip("Bricks");
+		items[46] = new ItemTooltip("TNT", UNCOMMON_COL, "Punch for an explosion", DESCRIPTION_COL);
+		items[47] = new ItemTooltip("Bookshelf");
+		items[48] = new ItemTooltip("Mossy Cobblestone");
+		fromMetadata[48] = new ItemTooltip[256];
+		fromMetadata[48][1] = new ItemTooltip("Mossy Cobbled Marble");
+		fromMetadata[48][2] = new ItemTooltip("Mossy Cobbled Slate");
+		fromMetadata[48][3] = new ItemTooltip("Mossy Cobbled Granite");
+		fromMetadata[48][4] = new ItemTooltip("Mossy Cobbled Shadorite");
+		items[49] = new ItemTooltip("Obsidian", RARE_COL);
+		items[50] = new ItemTooltip("Torch");
+		items[51] = ItemTooltip.invalid("Fire");
+		items[52] = ItemTooltip.invalid("Mob Spawner");
+		items[53] = ItemTooltip.invalid("Plank Stairs");
+		fromMetadata[53] = new ItemTooltip[256];
+		fromMetadata[53][0] = new ItemTooltip("Oak Plank Stairs");
+		fromMetadata[53][4] = new ItemTooltip("Spruce Plank Stairs");
+		fromMetadata[53][8] = new ItemTooltip("Maple Plank Stairs");
+		fromMetadata[53][12] = new ItemTooltip("Mahogany Plank Stairs");
+		items[54] = new ItemTooltip("Chest");
+		items[55] = ItemTooltip.invalid("Redstone Dust (Block)");
+		items[56] = new ItemTooltip("Diamond Ore", RARE_COL);
+		items[57] = new ItemTooltip("Block of Diamond", RARE_COL);
+		items[58] = new ItemTooltip("Crafting Table", "The basic tool for crafting", DESCRIPTION_COL);
+		items[59] = ItemTooltip.invalid("Crops");
+		items[60] = ItemTooltip.invalid("Farmland");
+		items[61] = new ItemTooltip("Furnace", "Used for cooking items", DESCRIPTION_COL);
+		items[62] = ItemTooltip.invalid("Lit Furnace");
+		items[63] = ItemTooltip.invalid("Sign (Block)");
+		items[64] = ItemTooltip.invalid("Wooden Door (Block)");
+		items[65] = new ItemTooltip("Ladder");
+		items[66] = new ItemTooltip("Minecart Track", UNCOMMON_COL, "Used for travel with minecarts", DESCRIPTION_COL);
+		items[67] = ItemTooltip.invalid("Cobblestone Stairs");
+		fromMetadata[67] = new ItemTooltip[256];
+		fromMetadata[67][0] = new ItemTooltip("Cobblestone Stairs");
+		fromMetadata[67][4] = new ItemTooltip("Cobbled Marble Stairs");
+		fromMetadata[67][8] = new ItemTooltip("Cobbled Slate Stairs");
+		fromMetadata[67][12] = new ItemTooltip("Cobbled Granite Stairs");
+		fromMetadata[67][16] = new ItemTooltip("Cobbled Shadorite Stairs");
+		items[68] = ItemTooltip.invalid("Wall Sign (Block)");
+		items[69] = new ItemTooltip("Lever",
+				"Can be switched to toggle", DESCRIPTION_COL,
+				"a redstone signal", DESCRIPTION_COL);
+		items[70] = new ItemTooltip("Stone Pressure Plate",
+				"Emits a redstone signal when", DESCRIPTION_COL,
+				"a player steps on it", DESCRIPTION_COL);
+		items[71] = ItemTooltip.invalid("Iron Door (Block)");
+		items[72] = new ItemTooltip("Wooden Pressure Plate",
+				"Emits a redstone signal when", DESCRIPTION_COL,
+				"something steps on it", DESCRIPTION_COL);
+		items[73] = new ItemTooltip("Redstone Ore", RARE_COL);
+		items[74] = ItemTooltip.invalid("Glowing Redstone Ore");
+		items[75] = ItemTooltip.invalid("Redstone Torch (Off)");
+		items[76] = new ItemTooltip("Redstone Torch", RARE_COL);
+		items[77] = new ItemTooltip("Stone Button", "Press to emit a redstone signal", DESCRIPTION_COL);
+		items[78] = new ItemTooltip("Snow");
+		items[79] = new ItemTooltip("Ice");
+		items[80] = new ItemTooltip("Snow Block");
+		items[81] = new ItemTooltip("Cactus", "Hurts on contact", DESCRIPTION_COL);
+		items[82] = new ItemTooltip("Clay Block");
+		items[83] = ItemTooltip.invalid("Sugar Cane (Block)");
+		items[84] = new ItemTooltip("Jukebox", RARE_COL, "Can play music discs", DESCRIPTION_COL);
+		items[85] = new ItemTooltip("Fence");
+		fromMetadata[85] = new ItemTooltip[256];
+		fromMetadata[85][0] = new ItemTooltip("Oak Fence");
+		fromMetadata[85][1] = new ItemTooltip("Spruce Fence");
+		fromMetadata[85][2] = new ItemTooltip("Maple Fence");
+		fromMetadata[85][3] = new ItemTooltip("Mahogany Fence");
+		items[86] = new ItemTooltip("Speleothem");
+		items[87] = new ItemTooltip("Ruby Ore", RARE_COL);
+		items[88] = new ItemTooltip("Sapphire Ore", RARE_COL);
+		items[89] = new ItemTooltip("Block of Ruby", RARE_COL);
+		items[90] = new ItemTooltip("Block of Sapphire", RARE_COL);
+		items[91] = new ItemTooltip(LEGENDARY_GRAD, "Blaster", LEGENDARY_COL,
+				"Smelt items at quadruple", DESCRIPTION_COL,
+				"the speed of a furnace but", DESCRIPTION_COL,
+				"uses double the fuel", DESCRIPTION_COL);
+		items[92] = ItemTooltip.invalid("Lit Blaster");
+		items[93] = new ItemTooltip(LEGENDARY_GRAD, "Refabricator", LEGENDARY_COL,
+				"Repairs items using", DESCRIPTION_COL,
+				"the power of star dust", DESCRIPTION_COL);
+		items[94] = new ItemTooltip(LEGENDARY_GRAD, "Booster Track", LEGENDARY_COL,
+				"Makes minecarts move faster", DESCRIPTION_COL);
+		items[95] = new ItemTooltip("Star Lantern", RARE_COL);
+		items[96] = new ItemTooltip("Redstone Block", RARE_COL);
+		items[97] = new ItemTooltip("Coal Block");
+		items[98] = new ItemTooltip("Crate");
+		fromMetadata[98] = new ItemTooltip[256];
+		fromMetadata[98][0] = new ItemTooltip("Oak Crate");
+		fromMetadata[98][1] = new ItemTooltip("Spruce Crate");
+		fromMetadata[98][2] = new ItemTooltip("Maple Crate");
+		fromMetadata[98][3] = new ItemTooltip("Mahogany Crate");
+		items[99] = new ItemTooltip(LEGENDARY_GRAD, "Umbrashard Crystal", LEGENDARY_COL,
+				"Powers foul creatures down below", DESCRIPTION_COL);
+
+		items[10000] = new ItemTooltip("Iron Shovel", UNCOMMON_COL, Item.shovel);
+		items[10001] = new ItemTooltip("Iron Pickaxe", UNCOMMON_COL, Item.pickaxeSteel);
+		items[10002] = new ItemTooltip("Iron Axe", UNCOMMON_COL, Item.axeSteel);
+		items[10003] = new ItemTooltip("Flint and Steel", UNCOMMON_COL,
+				"Right click to create fire", DESCRIPTION_COL);
+		items[10004] = new ItemTooltip("Apple", UNCOMMON_COL, Item.appleRed);
+		items[10005] = new ItemTooltip("Bow", "Right click to shoot arrows", DESCRIPTION_COL);
+		items[10006] = new ItemTooltip("Arrow", "Shot with a bow", DESCRIPTION_COL);
+		items[10007] = new ItemTooltip("Coal");
+		items[10008] = new ItemTooltip("Diamond", RARE_COL);
+		items[10009] = new ItemTooltip("Iron Ingot", UNCOMMON_COL);
+		items[10010] = new ItemTooltip("Gold Ingot", UNCOMMON_COL);
+		items[10011] = new ItemTooltip("Iron Sword", UNCOMMON_COL, Item.swordSteel);
+		items[10012] = new ItemTooltip("Wooden Sword", Item.swordWood);
+		items[10013] = new ItemTooltip("Wooden Shovel", Item.shovelWood);
+		items[10014] = new ItemTooltip("Wooden Pickaxe", Item.pickaxeWood);
+		items[10015] = new ItemTooltip("Wooden Axe", Item.axeWood);
+		items[10016] = new ItemTooltip("Stone Sword", Item.swordStone);
+		items[10017] = new ItemTooltip("Stone Shovel", Item.shovelStone);
+		items[10018] = new ItemTooltip("Stone Pickaxe", Item.pickaxeStone);
+		items[10019] = new ItemTooltip("Stone Axe", Item.axeStone);
+		items[10020] = new ItemTooltip("Diamond Sword", RARE_COL, Item.swordDiamond);
+		items[10021] = new ItemTooltip("Diamond Shovel", RARE_COL, Item.shovelDiamond);
+		items[10022] = new ItemTooltip("Diamond Pickaxe", RARE_COL, Item.pickaxeDiamond);
+		items[10023] = new ItemTooltip("Diamond Axe", RARE_COL, Item.axeDiamond);
+		items[10024] = new ItemTooltip("Stick");
+		items[10025] = new ItemTooltip("Bowl");
+		items[10026] = new ItemTooltip("Mushroom Stew", UNCOMMON_COL, Item.bowlSoup);
+		items[10027] = new ItemTooltip("Golden Sword", UNCOMMON_COL, Item.swordGold);
+		items[10028] = new ItemTooltip("Golden Shovel", UNCOMMON_COL, Item.shovelGold);
+		items[10029] = new ItemTooltip("Golden Pickaxe", UNCOMMON_COL, Item.pickaxeGold);
+		items[10030] = new ItemTooltip("Golden Axe", UNCOMMON_COL, Item.axeGold);
+		items[10031] = new ItemTooltip("String");
+		items[10032] = new ItemTooltip("Feather");
+		items[10033] = new ItemTooltip("Gunpowder");
+		items[10034] = new ItemTooltip("Wooden Hoe", Item.hoeWood);
+		items[10035] = new ItemTooltip("Stone Hoe", Item.hoeStone);
+		items[10036] = new ItemTooltip("Iron Hoe", UNCOMMON_COL, Item.hoeSteel);
+		items[10037] = new ItemTooltip("Diamond Hoe", RARE_COL, Item.hoeDiamond);
+		items[10038] = new ItemTooltip("Golden Hoe", UNCOMMON_COL, Item.hoeGold);
+		items[10039] = new ItemTooltip("Seeds", "Can be planted on farmland", DESCRIPTION_COL);
+		items[10040] = new ItemTooltip("Wheat", "Can be crafted into bread", DESCRIPTION_COL);
+		items[10041] = new ItemTooltip("Bread", Item.bread);
+		items[10042] = new ItemTooltip("Leather Cap", Item.helmetLeather);
+		items[10043] = new ItemTooltip("Leather Tunic", Item.plateLeather);
+		items[10044] = new ItemTooltip("Leather Pants", Item.legsLeather);
+		items[10045] = new ItemTooltip("Leather Boots", Item.bootsLeather);
+		items[10046] = new ItemTooltip("Chainmail Helmet", UNCOMMON_COL, Item.helmetChain);
+		items[10047] = new ItemTooltip("Chainmail Chestplate", UNCOMMON_COL, Item.plateChain);
+		items[10048] = new ItemTooltip("Chainmail Leggings", UNCOMMON_COL, Item.legsChain);
+		items[10049] = new ItemTooltip("Chainmail Boots", UNCOMMON_COL, Item.bootsChain);
+		items[10050] = new ItemTooltip("Iron Helmet", UNCOMMON_COL, Item.helmetSteel);
+		items[10051] = new ItemTooltip("Iron Chestplate", UNCOMMON_COL, Item.plateSteel);
+		items[10052] = new ItemTooltip("Iron Leggings", UNCOMMON_COL, Item.legsSteel);
+		items[10053] = new ItemTooltip("Iron Boots", UNCOMMON_COL, Item.bootsSteel);
+		items[10054] = new ItemTooltip("Diamond Helmet", RARE_COL, Item.helmetDiamond);
+		items[10055] = new ItemTooltip("Diamond Chestplate", RARE_COL, Item.plateDiamond);
+		items[10056] = new ItemTooltip("Diamond Leggings", RARE_COL, Item.legsDiamond);
+		items[10057] = new ItemTooltip("Diamond Boots", RARE_COL, Item.bootsDiamond);
+		items[10058] = new ItemTooltip("Golden Helmet", UNCOMMON_COL, Item.helmetGold);
+		items[10059] = new ItemTooltip("Golden Chestplate", UNCOMMON_COL, Item.plateGold);
+		items[10060] = new ItemTooltip("Golden Leggings", UNCOMMON_COL, Item.legsGold);
+		items[10061] = new ItemTooltip("Golden Boots", UNCOMMON_COL, Item.bootsGold);
+		items[10062] = new ItemTooltip("Flint");
+		items[10063] = new ItemTooltip("Raw Porkchop", Item.porkRaw);
+		items[10064] = new ItemTooltip("Cooked Porkchop", Item.porkCooked);
+		items[10065] = new ItemTooltip("Painting", "Display a random piece of artwork", DESCRIPTION_COL);
+		items[10066] = new ItemTooltip("Golden Apple", Item.appleGold);
+		items[10067] = new ItemTooltip("Sign");
+		items[10068] = new ItemTooltip("Wooden Door");
+		items[10069] = new ItemTooltip("Bucket",
+				"Right click to pick up", DESCRIPTION_COL,
+				"a liquid", DESCRIPTION_COL);
+		items[10070] = new ItemTooltip("Bucket of Water", "Right click to place water", DESCRIPTION_COL);
+		items[10071] = new ItemTooltip("Bucket of Lava", "Right click to place lava", DESCRIPTION_COL);
+		items[10072] = new ItemTooltip("Minecart", UNCOMMON_COL,
+				"Used for travelling on", DESCRIPTION_COL,
+				"minecart tracks", DESCRIPTION_COL);
+		items[10073] = new ItemTooltip("Saddle", UNCOMMON_COL, "Used for riding a pig", DESCRIPTION_COL);
+		items[10074] = new ItemTooltip("Iron Door", UNCOMMON_COL,
+				"Cannot be opened without", DESCRIPTION_COL,
+				"a restone signal", DESCRIPTION_COL);
+		items[10075] = new ItemTooltip("Redstone Dust", RARE_COL, "Electrically charged powder", DESCRIPTION_COL);
+		items[10076] = new ItemTooltip("Snowball", "Right click to throw", DESCRIPTION_COL);
+		items[10077] = new ItemTooltip("Boat", "Used for travelling on water", DESCRIPTION_COL);
+		items[10078] = new ItemTooltip("Leather");
+		items[10079] = new ItemTooltip("Bucket of Milk");
+		items[10080] = new ItemTooltip("Brick");
+		items[10081] = new ItemTooltip("Clay Ball");
+		items[10082] = new ItemTooltip("Sugar Cane");
+		items[10083] = new ItemTooltip("Paper");
+		items[10084] = new ItemTooltip("Book");
+		items[10085] = new ItemTooltip("Slime Ball", UNCOMMON_COL);
+		items[10086] = new ItemTooltip("Minecart with Chest", UNCOMMON_COL,
+				"Used for carrying items", DESCRIPTION_COL,
+				"on minecart tracks", DESCRIPTION_COL);
+		items[10087] = new ItemTooltip("Minecart with Furnace", UNCOMMON_COL,
+				"Uses fuel to move fast", DESCRIPTION_COL,
+				"on minecart tracks", DESCRIPTION_COL);
+		items[10088] = new ItemTooltip("Egg");
+		items[10089] = new ItemTooltip("Compass", UNCOMMON_COL,
+				"Points in the direction to", DESCRIPTION_COL,
+				"your spawnpoint", DESCRIPTION_COL);
+		items[10090] = new ItemTooltip("Fishing Rod");
+		items[10091] = new ItemTooltip("Quiver",
+				"Stores up to 256 arrows", DESCRIPTION_COL,
+				"Can be equipped in", INFO_COL,
+				"the charm slot", INFO_COL);
+		items[10092] = new ItemTooltip("Ruby Staff", RARE_COL,
+				"Right click to shoot a", DESCRIPTION_COL,
+				"flaming ruby crystal", DESCRIPTION_COL,
+				Item.staffRuby);
+		items[10093] = new ItemTooltip("Sapphire Staff", RARE_COL,
+				"Right click to shoot a", DESCRIPTION_COL,
+				"piercing sapphire shard", DESCRIPTION_COL,
+				Item.staffSapphire);
+		items[10094] = new ItemTooltip("Ruby", RARE_COL,
+				"A gem capable of magic", DESCRIPTION_COL);
+		items[10095] = new ItemTooltip("Sapphire", RARE_COL,
+				"A gem capable of magic", DESCRIPTION_COL);
+		items[10096] = new ItemTooltip("Raw Beef", Item.beefRaw);
+		items[10097] = new ItemTooltip("Cooked Beef", Item.beefCooked);
+		items[10098] = new ItemTooltip("Raw Chicken", Item.chickenRaw);
+		items[10099] = new ItemTooltip("Cooked Chicken", Item.chickenCooked);
+		items[10100] = new ItemTooltip("Raw Mutton", Item.muttonRaw);
+		items[10101] = new ItemTooltip("Cooked Mutton", Item.muttonCooked);
+		items[10102] = new ItemTooltip(LEGENDARY_GRAD, "Warding Ring", LEGENDARY_COL,
+				"Heals half a heart every minute", DESCRIPTION_COL,
+				Item.wardingRing);
+		items[10103] = new ItemTooltip(LEGENDARY_GRAD, "Repair Kit", LEGENDARY_COL,
+				"Crouch to repair the", DESCRIPTION_COL,
+				"currently held item", DESCRIPTION_COL,
+				Item.repairKit);
+		items[10104] = new ItemTooltip("Star Chunk", RARE_COL,
+				"A fallen star from the", DESCRIPTION_COL,
+				"night sky; provides great", DESCRIPTION_COL,
+				"energy when heated", DESCRIPTION_COL,
+				"Disappears at daytime", INFO_COL);
+		items[10105] = new ItemTooltip("Star Dust", RARE_COL,
+				"This extraterrestrial dust", DESCRIPTION_COL,
+				"emanates powerful energy", DESCRIPTION_COL);
+		items[10106] = new ItemTooltip("Sparkle Staff", RARE_COL,
+				"Right click to shoot a", DESCRIPTION_COL,
+				"star blast", DESCRIPTION_COL,
+				Item.staffSparkle);
+		items[10107] = new ItemTooltip("Slime Shoes", UNCOMMON_COL,
+				"Bounces the player when falling", DESCRIPTION_COL,
+				Item.slimeShoes);
+		items[10108] = new ItemTooltip("Dye");
+		fromMetadata[10108] = new ItemTooltip[256];
+		fromMetadata[10108][0] = new ItemTooltip("White Dye");
+		fromMetadata[10108][1] = new ItemTooltip("Red Dye");
+		fromMetadata[10108][2] = new ItemTooltip("Orange Dye");
+		fromMetadata[10108][3] = new ItemTooltip("Yellow Dye");
+		fromMetadata[10108][4] = new ItemTooltip("Chartreuse Dye");
+		fromMetadata[10108][5] = new ItemTooltip("Green Dye");
+		fromMetadata[10108][6] = new ItemTooltip("Spring Green Dye");
+		fromMetadata[10108][7] = new ItemTooltip("Cyan Dye");
+		fromMetadata[10108][8] = new ItemTooltip("Capri Dye");
+		fromMetadata[10108][9] = new ItemTooltip("Ultramarine Dye");
+		fromMetadata[10108][10] = new ItemTooltip("Violet Dye");
+		fromMetadata[10108][11] = new ItemTooltip("Purple Dye");
+		fromMetadata[10108][12] = new ItemTooltip("Magenta Dye");
+		fromMetadata[10108][13] = new ItemTooltip("Rose Dye");
+		fromMetadata[10108][14] = new ItemTooltip("Black Dye");
+		fromMetadata[10108][15] = new ItemTooltip("Gray Dye");
+		items[10109] = new ItemTooltip(LEGENDARY_GRAD, "Nimble Boots", LEGENDARY_COL,
+				"Increases running speed", DESCRIPTION_COL,
+				Item.nimbleBoots);
+		items[10110] = new ItemTooltip(LEGENDARY_GRAD, "Wings", LEGENDARY_COL,
+				"Allows jumping in midair", DESCRIPTION_COL,
+				"using 15 points of mana", DESCRIPTION_COL,
+                Item.wings);
+		items[10111] = new ItemTooltip("Sugar");
+		items[10112] = new ItemTooltip("Cookie", Item.cookie);
+		items[10113] = new ItemTooltip("Glass Shard");
+		items[10114] = new ItemTooltip("Ice Shard");
+		items[10115] = new ItemTooltip(NOVELTY_GRAD, "Fluffy Ears", Item.fluffyEars);
+		items[10116] = new ItemTooltip(NOVELTY_GRAD, "Fluffy Snout", Item.fluffySnout);
+		items[10117] = new ItemTooltip(NOVELTY_GRAD, "Fluffy Tail", Item.fluffyTail);
+		items[10118] = new ItemTooltip(NOVELTY_GRAD, "Top Hat",
+				"The top gentleman's style", DESCRIPTION_COL,
+				Item.topHat);
+		items[10119] = new ItemTooltip("Fur");
+		items[10120] = new ItemTooltip("Raw Iron", UNCOMMON_COL);
+		items[10121] = new ItemTooltip("Raw Gold", UNCOMMON_COL);
+		items[10122] = new ItemTooltip(NOVELTY_GRAD, "Sunglasses",
+				"Deal with it", DESCRIPTION_COL,
+				Item.sunglasses);
+		items[10123] = new ItemTooltip(NOVELTY_GRAD, "Baseball Cap",
+				"Batter up!", DESCRIPTION_COL,
+				Item.baseballCap);
+		items[10124] = new ItemTooltip(LEGENDARY_GRAD, "Star Necklace", LEGENDARY_COL,
+				"Boosts mana regeneration", DESCRIPTION_COL,
+				Item.starNecklace);
+		items[10125] = new ItemTooltip("Iron Shield", UNCOMMON_COL, Item.shieldIron);
+		items[10126] = new ItemTooltip("Gold Shield", UNCOMMON_COL, Item.shieldGold);
+		items[10127] = new ItemTooltip("Diamond Shield", RARE_COL, Item.shieldDiamond);
+		items[10128] = new ItemTooltip("Ruby Shield", RARE_COL, Item.shieldRuby);
+		items[10129] = new ItemTooltip("Sapphire Shield", RARE_COL, Item.shieldSapphire);
+		items[10130] = new ItemTooltip(LEGENDARY_GRAD, "Umbrashard", LEGENDARY_COL,
+				"Powers foul creatures down below", DESCRIPTION_COL);
+		items[10131] = new ItemTooltip(LEGENDARY_GRAD, "Void Essence", LEGENDARY_COL,
+				"Contained by foul creatures down below", DESCRIPTION_COL);
+		items[10132] = new ItemTooltip(NOVELTY_GRAD, "Frog Hat", UNCOMMON_COL,
+				"A little girl must have dropped this", DESCRIPTION_COL,
+				Item.frogHat);
+		items[10133] = new ItemTooltip(LEGENDARY_GRAD, "Trinket of Fury", LEGENDARY_COL, Item.furyTrinket);
+		items[10134] = new ItemTooltip(LEGENDARY_GRAD, "Trinket of Salvation", LEGENDARY_COL, Item.salvationTrinket);
+		items[10135] = new ItemTooltip(LEGENDARY_GRAD, "Trinket of Haste", LEGENDARY_COL, Item.hasteTrinket);
+		items[10136] = new ItemTooltip(NOVELTY_GRAD, "Creeper Spirit", LEGENDARY_COL,
+				"Now it's your turn to", DESCRIPTION_COL,
+				"freak people out!", DESCRIPTION_COL,
+				Item.creeperSpirit);
+		items[10137] = new ItemTooltip(NOVELTY_GRAD, "Skeleton Spirit", LEGENDARY_COL,
+				"Now it's your turn to", DESCRIPTION_COL,
+				"freak people out!", DESCRIPTION_COL,
+				Item.skeletonSpirit);
+		items[10138] = new ItemTooltip(NOVELTY_GRAD, "Glasses",
+				"Umm, akshually, they're", DESCRIPTION_COL,
+				"called spectacles", DESCRIPTION_COL,
+				Item.glasses);
+		items[10139] = new ItemTooltip(NOVELTY_GRAD, "Fluffy Paws", Item.fluffyPaws);
+		items[10140] = new ItemTooltip(NOVELTY_GRAD, "Fancy Moustache",
+				"The top gentleman's cut", DESCRIPTION_COL,
+				Item.moustache);
+		items[10141] = new ItemTooltip(NOVELTY_GRAD, "Cybernetic Headgear", UNCOMMON_COL,
+				"3X73RM1N8-0R!!", DESCRIPTION_COL,
+				Item.cyberneticHeadgear);
+		items[10142] = new ItemTooltip(NOVELTY_GRAD, "Long Fluffy Snout", Item.longFluffySnout);
+		items[10143] = new ItemTooltip(NOVELTY_GRAD, "Cardboard Helmet",
+				"Imagine how strong you can be!", DESCRIPTION_COL,
+				Item.helmetCardboard);
+		items[10144] = new ItemTooltip(NOVELTY_GRAD, "Cardboard Chestplate",
+				"Imagine how strong you can be!", DESCRIPTION_COL,
+				Item.plateCardboard);
+		items[10145] = new ItemTooltip(NOVELTY_GRAD, "Cardboard Leggings",
+				"Imagine how strong you can be!", DESCRIPTION_COL,
+				Item.legsCardboard);
+		items[10146] = new ItemTooltip(NOVELTY_GRAD, "Cardboard Boots",
+				"Imagine how strong you can be!", DESCRIPTION_COL,
+				Item.bootsCardboard);
+		items[10147] = new ItemTooltip(NOVELTY_GRAD, "Linen Cloak", UNCOMMON_COL,
+				"Fits well on wizards,", DESCRIPTION_COL,
+				"monarchs and paladins", DESCRIPTION_COL,
+				Item.cloak);
+
+		items[12000] = new ItemTooltip(NOVELTY_GRAD, "Music Disc", RARE_COL, Item.record13);
+		items[12001] = new ItemTooltip(NOVELTY_GRAD, "Music Disc", RARE_COL, Item.recordCat);
+		items[12002] = new ItemTooltip(NOVELTY_GRAD, "Music Disc", RARE_COL, Item.recordMagnet);
+		items[12003] = new ItemTooltip(NOVELTY_GRAD, "Music Disc", RARE_COL, Item.recordBlocks);
+		items[12004] = new ItemTooltip(NOVELTY_GRAD, "Music Disc", RARE_COL, Item.recordWait);
+		items[12005] = new ItemTooltip(NOVELTY_GRAD, "Music Disc", RARE_COL, Item.recordChris);
+
+		items[65535] = new ItemTooltip(INVALID_GRAD, "Missing Item", INVALID_COL,
+				"This item loaded incorrectly!", DESCRIPTION_COL);
+	}
+
+	public ItemTooltip(Pair<Integer, Integer> gradient, Object... lines) {
+		this.gradient = gradient;
+		for (Object line : lines) {
+			if (Item.class.isAssignableFrom(line.getClass())) {
+				for (Object subLine : ((Item)line).getTooltipInfo()) {
+					this.parseLine(subLine);
+				}
+			} else {
+				this.parseLine(line);
+			}
+		}
+		if (this.parsedString) {
+			this.lines.add(this.nextText);
+			this.colors.add(0xFFFFFF);
+		}
+	}
+
+	public ItemTooltip(Object... lines) {
+		this(DEFAULT_GRAD, lines);
+	}
+
+	private ItemTooltip(Pair<Integer, Integer> gradient, List<String> lines, List<Integer> colors) {
+		this.gradient = gradient;
+		this.lines = lines;
+		this.colors = colors;
+	}
+
+	public static ItemTooltip invalid(String name, Object... objects) {
+		return new ItemTooltip(INVALID_GRAD, name, INVALID_COL, objects);
+	}
+
+	public int size() {
+		return lines.size();
+	}
+
+	private boolean parsedString;
+	private String nextText;
+
+	private void parseLine(Object line) {
+		if (line instanceof String) {
+			if (this.parsedString) {
+				this.lines.add(this.nextText);
+				this.colors.add(0xFFFFFF);
+			}
+			this.nextText = (String) line;
+			this.parsedString = true;
+		} else if (line instanceof Integer) {
+			if (this.parsedString) {
+				this.lines.add(this.nextText);
+				this.colors.add((int) line);
+			}
+			this.parsedString = false;
+		}
+	}
+
+	public ItemTooltip copy() {
+		return new ItemTooltip(this.gradient, new ArrayList<>(this.lines), new ArrayList<>(this.colors));
+	}
+
+	public ItemTooltip addLine(String text, int color) {
+		this.lines.add(text);
+		this.colors.add(color);
+		return this;
+	}
+
+	public static String formatFloat(float f) {
+		return f % 1.0F == 0
+				? String.valueOf((int)f)
+				: String.valueOf(f);
+	}
+}
--- net/minecraft/src/GuiControls.java
+++ net/minecraft/src/GuiControls.java
@@ -1,51 +1,89 @@
 package net.minecraft.src;
 
+import java.util.List;
+import java.util.stream.Collectors;
+
 public class GuiControls extends GuiScreen {
 	private GuiScreen parentScreen;
 	protected String screenTitle = "Controls";
 	private GameSettings options;
 	private int buttonId = -1;
+	private final int maxPages;
+	private int currentPage;
 
 	public GuiControls(GuiScreen var1, GameSettings var2) {
 		this.parentScreen = var1;
 		this.options = var2;
+		this.maxPages = Math.floorDiv(this.options.keyBindings.length, 10) + 1;
 	}
 
 	public void initGui() {
-		for(int var1 = 0; var1 < this.options.keyBindings.length; ++var1) {
-			this.controlList.add(new GuiSmallButton(var1, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), this.options.getKeyBindingDescription(var1)));
-		}
+		this.controlList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 132, "Done"));
+		this.controlList.add(new GuiButton(300, this.width / 2 - 140, this.height / 6 + 132, 20, 20, "<"));
+		this.controlList.add(new GuiButton(301, this.width / 2 + 120, this.height / 6 + 132, 20, 20, ">"));
+		initPage();
+	}
 
-		this.controlList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 168, "Done"));
+	public void initPage() {
+		this.controlList = (List) this.controlList.stream().filter(button -> ((GuiButton) button).id >= 200).collect(Collectors.toList());
+		for(int var1 = 0; var1 < Math.min(this.options.keyBindings.length - currentPage * 10, 10); ++var1) {
+			int var11 = var1 + currentPage * 10;
+			this.controlList.add(new GuiSmallButton(var11, this.width / 2 - 155 + var1 % 2 * 160, this.height / 6 + 24 * (var1 >> 1), this.options.getKeyBindingDescription(var11)));
+		}
 	}
 
 	protected void actionPerformed(GuiButton var1) {
-		for(int var2 = 0; var2 < this.options.keyBindings.length; ++var2) {
-			((GuiButton)this.controlList.get(var2)).displayString = this.options.getKeyBindingDescription(var2);
-		}
-
-		if(var1.id == 200) {
-			this.mc.displayGuiScreen(this.parentScreen);
-		} else {
+		if(var1.id < 200) {
 			this.buttonId = var1.id;
 			var1.displayString = "> " + this.options.getKeyBindingDescription(var1.id) + " <";
 		}
 
+		if(var1.id == 200) {
+			this.mc.displayGuiScreen(this.parentScreen);
+		}
+
+		if(var1.id == 300) {
+			this.currentPage--;
+			if (this.currentPage < 0) {
+				this.currentPage = maxPages - 1;
+			}
+			this.initPage();
+		}
+
+		if(var1.id == 301) {
+			this.currentPage++;
+			if (this.currentPage >= maxPages) {
+				this.currentPage = 0;
+			}
+			this.initPage();
+		}
+
+		for (int i = currentPage * 10; i < Math.min(currentPage * 10 + 1, this.mc.options.keyBindings.length); i++) {
+			int finalI = i;
+			((GuiButton) this.controlList
+					.stream()
+					.filter(o -> o instanceof GuiButton && ((GuiButton) o).id == finalI)
+					.findAny()
+					.get()).displayString = this.options.getKeyBindingDescription(i);
+		}
 	}
 
 	protected void keyTyped(char var1, int var2) {
 		if(this.buttonId >= 0) {
 			this.options.setKeyBinding(this.buttonId, var2);
-			((GuiButton)this.controlList.get(this.buttonId)).displayString = this.options.getKeyBindingDescription(this.buttonId);
+			((GuiButton)this.controlList
+					.stream()
+					.filter(o -> o instanceof GuiButton && ((GuiButton) o).id == this.buttonId)
+					.findAny()
+					.get()).displayString = this.options.getKeyBindingDescription(this.buttonId);
 			this.buttonId = -1;
 		} else {
 			super.keyTyped(var1, var2);
 		}
-
 	}
 
 	public void drawScreen(int var1, int var2, float var3) {
-		this.drawDefaultBackground();
+		this.drawDefaultBackground(var3);
 		this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 20, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
--- /dev/null
+++ net/minecraft/src/GuiCredits.java
@@ -1,0 +1,46 @@
+package net.minecraft.src;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+
+public class GuiCredits extends GuiScreen {
+	private final GuiScreen parent;
+	private List<String> lines = new ArrayList<>();
+
+	public GuiCredits(GuiScreen parent) {
+		this.parent = parent;
+
+		try {
+			BufferedReader bufferedReader2 = new BufferedReader(new InputStreamReader(GuiCredits.class.getResourceAsStream("/credits.txt")));
+			String var3;
+
+			while((var3 = bufferedReader2.readLine()) != null) {
+				var3 = var3.trim();
+				if(var3.length() > 0) {
+					this.lines.add(var3);
+				}
+			}
+		} catch (IOException e) {
+			this.lines.add("Failed to get credits");
+		}
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(1, this.width / 2 - 50, this.height - 30, 100, 20, "Exit"));
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		this.mc.displayGuiScreen(this.parent);
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground(var3);
+		for (int i = 0; i < lines.size(); i++) {
+			this.drawString(this.fontRenderer, lines.get(i), 10, 10 + i * 10, 0xFFFFFF);
+		}
+		super.drawScreen(var1, var2, var3);
+	}
+}
--- /dev/null
+++ net/minecraft/src/Container.java
@@ -1,0 +1,241 @@
+package net.minecraft.src;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+public abstract class Container {
+	public List items = new ArrayList();
+	public List slots = new ArrayList();
+	public int windowId = 0;
+	private short craftMatrix = 0;
+	protected List crafters = new ArrayList();
+	private Set craftResult = new HashSet();
+
+	protected void addSlot(Slot var1) {
+		var1.id = this.slots.size();
+		this.slots.add(var1);
+		this.items.add((Object)null);
+	}
+
+	public void addCrafter(ICrafting var1) {
+		if(this.crafters.contains(var1)) {
+			throw new IllegalArgumentException("Listener already listening");
+		} else {
+			this.crafters.add(var1);
+			var1.setBothSlots(this, this.func_28127_b());
+			this.updateCraftingMatrix();
+		}
+	}
+
+	public List func_28127_b() {
+		ArrayList var1 = new ArrayList();
+
+		for(int var2 = 0; var2 < this.slots.size(); ++var2) {
+			var1.add(((Slot)this.slots.get(var2)).getStack());
+		}
+
+		return var1;
+	}
+
+	public void updateCraftingMatrix() {
+		for(int var1 = 0; var1 < this.slots.size(); ++var1) {
+			ItemStack var2 = ((Slot)this.slots.get(var1)).getStack();
+			ItemStack var3 = (ItemStack)this.items.get(var1);
+			if(!ItemStack.areItemStacksEqual(var3, var2)) {
+				var3 = var2 == null ? null : var2.copy();
+				this.items.set(var1, var3);
+
+				for(int var4 = 0; var4 < this.crafters.size(); ++var4) {
+					((ICrafting)this.crafters.get(var4)).setSlot(this, var1, var3);
+				}
+			}
+		}
+
+	}
+
+	public Slot getSlot(IInventory var1, int var2) {
+		for(int var3 = 0; var3 < this.slots.size(); ++var3) {
+			Slot var4 = (Slot)this.slots.get(var3);
+			if (var4.matchesSlot(var1, var2)) {
+				return var4;
+			}
+		}
+
+		return null;
+	}
+
+	public Slot getSlot(int var1) {
+		return (Slot)this.slots.get(var1);
+	}
+
+	public ItemStack updateSlots(int var1, int var2, EntityPlayer var3) {
+		ItemStack var4 = null;
+		if(var2 == 0 || var2 == 1) {
+			InventoryPlayer var5 = var3.inventory;
+			if(var1 == -999) {
+				if(var5.getDraggedItemStack() != null && var1 == -999) {
+					if(var2 == 0) {
+						var3.dropPlayerItem(var5.getDraggedItemStack());
+						var5.setDraggedItemStack((ItemStack)null);
+					}
+
+					if(var2 == 1) {
+						var3.dropPlayerItem(var5.getDraggedItemStack().splitStack(1));
+						if(var5.getDraggedItemStack().stackSize == 0) {
+							var5.setDraggedItemStack((ItemStack)null);
+						}
+					}
+				}
+			} else {
+				Slot var6 = (Slot)this.slots.get(var1);
+				if(var6 != null) {
+					var6.onSlotChanged();
+					ItemStack var7 = var6.getStack();
+					if(var7 != null) {
+						var4 = var7.copy();
+					}
+
+					if(var7 != null || var5.getDraggedItemStack() != null) {
+						int var8;
+						if(var7 != null && var5.getDraggedItemStack() == null) {
+							var8 = var2 == 0 ? var7.stackSize : (var7.stackSize + 1) / 2;
+							var5.setDraggedItemStack(var6.decrStackSize(var8));
+							if(var7.stackSize == 0) {
+								var6.putStack((ItemStack)null);
+							}
+
+							var6.onPickupFromSlot();
+						} else if(var7 == null && var5.getDraggedItemStack() != null && var6.isItemValid(var5.getDraggedItemStack())) {
+							var8 = var2 == 0 ? var5.getDraggedItemStack().stackSize : 1;
+							if(var8 > var6.getSlotStackLimit()) {
+								var8 = var6.getSlotStackLimit();
+							}
+
+							var6.putStack(var5.getDraggedItemStack().splitStack(var8));
+							if(var5.getDraggedItemStack().stackSize == 0) {
+								var5.setDraggedItemStack((ItemStack)null);
+							}
+						} else if(var7 != null && var5.getDraggedItemStack() != null) {
+							if(var6.isItemValid(var5.getDraggedItemStack())) {
+								if(var7.itemID != var5.getDraggedItemStack().itemID
+										|| var7.itemMetadata != var5.getDraggedItemStack().itemMetadata) {
+									if(var5.getDraggedItemStack().stackSize <= var6.getSlotStackLimit()) {
+										var6.putStack(var5.getDraggedItemStack());
+										var5.setDraggedItemStack(var7);
+									}
+								} else if(var7.itemID == var5.getDraggedItemStack().itemID
+										&& var7.itemMetadata == var5.getDraggedItemStack().itemMetadata
+										&& var7.storage == null
+										&& var5.getDraggedItemStack().storage == null) {
+									if(var2 == 0) {
+										var8 = var5.getDraggedItemStack().stackSize;
+										if(var8 > var6.getSlotStackLimit() - var7.stackSize) {
+											var8 = var6.getSlotStackLimit() - var7.stackSize;
+										}
+
+										if(var8 > var5.getDraggedItemStack().getMaxStackSize() - var7.stackSize) {
+											var8 = var5.getDraggedItemStack().getMaxStackSize() - var7.stackSize;
+										}
+
+										var5.getDraggedItemStack().splitStack(var8);
+										if(var5.getDraggedItemStack().stackSize == 0) {
+											var5.setDraggedItemStack((ItemStack)null);
+										}
+
+										var7.stackSize += var8;
+									} else if(var2 == 1) {
+										var8 = 1;
+										if(var8 > var6.getSlotStackLimit() - var7.stackSize) {
+											var8 = var6.getSlotStackLimit() - var7.stackSize;
+										}
+
+										if(var8 > var5.getDraggedItemStack().getMaxStackSize() - var7.stackSize) {
+											var8 = var5.getDraggedItemStack().getMaxStackSize() - var7.stackSize;
+										}
+
+										var5.getDraggedItemStack().splitStack(var8);
+										if(var5.getDraggedItemStack().stackSize == 0) {
+											var5.setDraggedItemStack((ItemStack)null);
+										}
+
+										var7.stackSize += var8;
+									}
+								}
+							} else if(var7.itemID == var5.getDraggedItemStack().itemID
+									&& var7.itemMetadata == var5.getDraggedItemStack().itemMetadata
+									&& var5.getDraggedItemStack().getMaxStackSize() > 1) {
+								var8 = var7.stackSize;
+								if(var8 > 0 && var8 + var5.getDraggedItemStack().stackSize <= var5.getDraggedItemStack().getMaxStackSize()) {
+									ItemStack var10000 = var5.getDraggedItemStack();
+									var10000.stackSize += var8;
+									var7.splitStack(var8);
+									if(var7.stackSize == 0) {
+										var6.putStack((ItemStack)null);
+									}
+
+									var6.onPickupFromSlot();
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+
+		return var4;
+	}
+
+	public void onCraftGuiClosed(EntityPlayer var1) {
+		InventoryPlayer var2 = var1.inventory;
+		if(var2.getDraggedItemStack() != null) {
+			var1.dropPlayerItem(var2.getDraggedItemStack());
+			var2.setDraggedItemStack((ItemStack)null);
+		}
+
+	}
+
+	public void onCraftMatrixChanged(IInventory var1) {
+		this.updateCraftingMatrix();
+	}
+
+	public boolean notInCraftResult(EntityPlayer var1) {
+		return !this.craftResult.contains(var1);
+	}
+
+	public void setCraftResult(EntityPlayer var1, boolean var2) {
+		if (var2) {
+			this.craftResult.remove(var1);
+		} else {
+			this.craftResult.add(var1);
+		}
+	}
+
+	public void setSlot(int var1, ItemStack var2) {
+		this.getSlot(var1).putStack(var2);
+	}
+
+	public void func_20115_a(ItemStack[] var1) {
+		for(int var2 = 0; var2 < var1.length; ++var2) {
+			this.getSlot(var2).putStack(var1[var2]);
+		}
+
+	}
+
+	public void func_20112_a(int var1, int var2) {
+	}
+
+	public short func_20111_a(InventoryPlayer var1) {
+		++this.craftMatrix;
+		return this.craftMatrix;
+	}
+
+	public void func_20113_a(short var1) {
+	}
+
+	public void func_20110_b(short var1) {
+	}
+
+	public abstract boolean stayOpen(EntityPlayer var1);
+}
--- /dev/null
+++ net/minecraft/src/GuiRefabricator.java
@@ -1,0 +1,29 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+public class GuiRefabricator extends GuiContainer {
+	private TileEntityRefabricator refabricatorInventory;
+
+	public GuiRefabricator(InventoryPlayer var1, TileEntityRefabricator var2) {
+		super(new ContainerRefabricator(var1, var2));
+		this.refabricatorInventory = var2;
+	}
+
+	protected void drawGuiContainerForegroundLayer() {
+		this.fontRenderer.drawString("Refabricator", 60, 6, this.mc.options.getTextColor());
+		this.fontRenderer.drawString("Inventory", 8, this.ySize - 96 + 2, this.mc.options.getTextColor());
+	}
+
+	protected void drawGuiContainerBackgroundLayer(float renderPartialTick) {
+		int bg = this.mc.renderEngine.getTexture("@@/gui/refabricator.png");
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		this.mc.renderEngine.bindTexture(bg);
+		int posX = (this.width - this.xSize) / 2;
+		int posY = (this.height - this.ySize) / 2;
+		this.drawTexturedModalRect(posX, posY, 0, 0, this.xSize, this.ySize);
+
+		int var5 = this.refabricatorInventory.getProgressScaled(48);
+		this.drawTexturedModalRect(posX + 55, posY + 26 + (48 - var5), 176, 48 - var5, 16, var5);
+	}
+}
--- /dev/null
+++ net/minecraft/src/ClimateZone.java
@@ -1,0 +1,15 @@
+package net.minecraft.src;
+
+public class ClimateZone {
+	public final float minTemperature;
+	public final float minHumidity;
+	public final float maxTemperature;
+	public final float maxHumidity;
+
+	public ClimateZone(float minTemperature, float minHumidity, float maxTemperature, float maxHumidity) {
+		this.minTemperature = minTemperature;
+		this.minHumidity = minHumidity;
+		this.maxTemperature = maxTemperature;
+		this.maxHumidity = maxHumidity;
+	}
+}
--- /dev/null
+++ net/minecraft/src/ContainerChest.java
@@ -1,0 +1,34 @@
+package net.minecraft.src;
+
+public class ContainerChest extends Container {
+	private final IInventory inventory;
+
+	public ContainerChest(IInventory var1, IInventory var2) {
+		this.inventory = var2;
+		int var3 = var2.getInventorySize() / 9;
+		int var4 = (var3 - 4) * 18;
+
+		int var5;
+		int var6;
+		for(var5 = 0; var5 < var3; ++var5) {
+			for(var6 = 0; var6 < 9; ++var6) {
+				this.addSlot(new Slot(var2, var6 + var5 * 9, 8 + var6 * 18, 18 + var5 * 18));
+			}
+		}
+
+		for(var5 = 0; var5 < 3; ++var5) {
+			for(var6 = 0; var6 < 9; ++var6) {
+				this.addSlot(new Slot(var1, var6 + var5 * 9 + 9, 8 + var6 * 18, 103 + var5 * 18 + var4));
+			}
+		}
+
+		for(var5 = 0; var5 < 9; ++var5) {
+			this.addSlot(new Slot(var1, var5, 8 + var5 * 18, 161 + var4));
+		}
+
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return this.inventory.isNearPlayer(var1);
+	}
+}
--- net/minecraft/src/BlockReed.java
+++ net/minecraft/src/BlockReed.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockReed extends Block {
-	protected BlockReed(int var1, int var2) {
+	public BlockReed(int var1, int var2) {
 		super(var1, Material.plants);
 		this.blockIndexInTexture = var2;
 		float var3 = 6.0F / 16.0F;
@@ -32,7 +32,14 @@
 
 	public boolean canPlaceBlockAt(World var1, int var2, int var3, int var4) {
 		int var5 = var1.getBlockId(var2, var3 - 1, var4);
-		return var5 == this.blockID ? true : (var5 != Block.grass.blockID && var5 != Block.dirt.blockID ? false : (var1.getBlockMaterial(var2 - 1, var3 - 1, var4) == Material.water ? true : (var1.getBlockMaterial(var2 + 1, var3 - 1, var4) == Material.water ? true : (var1.getBlockMaterial(var2, var3 - 1, var4 - 1) == Material.water ? true : var1.getBlockMaterial(var2, var3 - 1, var4 + 1) == Material.water))));
+		return var5 == this.blockID
+				|| ((var5 == Block.grass.blockID
+						|| var5 == Block.dirt.blockID
+						|| var5 == Block.sand.blockID)
+				&& (var1.getBlockMaterial(var2 - 1, var3 - 1, var4) == Material.water
+						|| var1.getBlockMaterial(var2 + 1, var3 - 1, var4) == Material.water
+						|| var1.getBlockMaterial(var2, var3 - 1, var4 - 1) == Material.water
+						|| var1.getBlockMaterial(var2, var3 - 1, var4 + 1) == Material.water));
 	}
 
 	public void onNeighborBlockChange(World var1, int var2, int var3, int var4, int var5) {
--- net/minecraft/src/Pathfinder.java
+++ net/minecraft/src/Pathfinder.java
@@ -3,7 +3,7 @@
 public class Pathfinder {
 	private IBlockAccess worldMap;
 	private Path path = new Path();
-	private MCHashTable pointMap = new MCHashTable();
+	private MCHashTableInteger pointMap = new MCHashTableInteger();
 	private PathPoint[] pathOptions = new PathPoint[32];
 
 	public Pathfinder(IBlockAccess var1) {
--- net/minecraft/src/GuiGameOver.java
+++ net/minecraft/src/GuiGameOver.java
@@ -10,7 +10,6 @@
 		if(this.mc.session == null) {
 			((GuiButton)this.controlList.get(1)).enabled = false;
 		}
-
 	}
 
 	protected void keyTyped(char var1, int var2) {
@@ -21,7 +20,7 @@
 		}
 
 		if(var1.id == 1) {
-			this.mc.respawn();
+			this.mc.thePlayer.respawnPlayer();
 			this.mc.displayGuiScreen((GuiScreen)null);
 		}
 
@@ -38,7 +37,7 @@
 		GL11.glScalef(2.0F, 2.0F, 2.0F);
 		this.drawCenteredString(this.fontRenderer, "Game over!", this.width / 2 / 2, 30, 16777215);
 		GL11.glPopMatrix();
-		this.drawCenteredString(this.fontRenderer, "Score: &e" + this.mc.thePlayer.getScore(), this.width / 2, 100, 16777215);
+		this.drawCenteredString(this.fontRenderer, "Score: " + this.mc.thePlayer.getScore(), this.width / 2, 100, 16777215);
 		super.drawScreen(var1, var2, var3);
 	}
 
--- /dev/null
+++ net/minecraft/src/BlockRefabricator.java
@@ -1,0 +1,24 @@
+package net.minecraft.src;
+
+public class BlockRefabricator extends BlockContainer {
+	public BlockRefabricator(int id) {
+		super(id, Material.iron);
+		this.blockIndexInTexture = textureXY(29, 6);
+	}
+
+	public int getBlockTextureFromSide(int side) {
+		return side == 1 ? textureXY(28, 6) : side == 0 ? textureXY(29, 2) : textureXY(29, 6);
+	}
+
+	public boolean blockActivated(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+		if (var1.canDoClientAction()) {
+			TileEntityRefabricator tileEntityRefabricator = (TileEntityRefabricator) var1.getBlockTileEntity(var2, var3, var4);
+			var5.displayGUIRefabricator(tileEntityRefabricator);
+		}
+		return true;
+	}
+
+	protected TileEntity getBlockEntity() {
+		return new TileEntityRefabricator();
+	}
+}
--- /dev/null
+++ net/minecraft/src/ItemStarNecklace.java
@@ -1,0 +1,16 @@
+package net.minecraft.src;
+
+public class ItemStarNecklace extends ItemCharm {
+	public ItemStarNecklace(int id) {
+		super(id, 1024, "starnecklace");
+	}
+
+	public void updateCharm(EntityPlayer player, ItemStack stack) {
+		if (player.mana < 20.0F) {
+			player.mana = Math.min(player.mana + 0.1F, 20.0F);
+			if (player.ticksExisted % 20 == 0) {
+				stack.damageItem(1);
+			}
+		}
+	}
+}
--- net/minecraft/src/ItemTool.java
+++ net/minecraft/src/ItemTool.java
@@ -1,26 +1,34 @@
 package net.minecraft.src;
 
+import static net.minecraft.src.ItemTooltip.*;
+
 public class ItemTool extends Item {
-	private Block[] blocksEffectiveAgainst;
-	private float efficiencyOnProperMaterial = 4.0F;
-	private int damageVsEntity;
+	private final Block[] blocksEffectiveAgainst;
+	protected float efficiencyOnProperMaterial;
+	private final int damageVsEntity;
 	protected int toolMaterial;
+	private final boolean silk;
 
-	public ItemTool(int var1, int var2, int var3, Block[] var4) {
+	public ItemTool(int var1, int var2, int var3, Block[] var4, boolean silk) {
 		super(var1);
 		this.toolMaterial = var3;
 		this.blocksEffectiveAgainst = var4;
 		this.maxStackSize = 1;
-		this.maxDamage = 32 << var3;
-		if(var3 == 3) {
-			this.maxDamage *= 4;
+		this.maxDamage = 64 << var3;
+		if(var3 >= 3) {
+			this.maxDamage *= 3;
 		}
 
 		this.efficiencyOnProperMaterial = (float)((var3 + 1) * 2);
 		this.damageVsEntity = var2 + var3;
+		this.silk = silk;
 	}
 
 	public float getStrVsBlock(ItemStack var1, Block var2) {
+		if (var2 == null) {
+			return this.efficiencyOnProperMaterial;
+		}
+
 		for(int var3 = 0; var3 < this.blocksEffectiveAgainst.length; ++var3) {
 			if(this.blocksEffectiveAgainst[var3] == var2) {
 				return this.efficiencyOnProperMaterial;
@@ -44,5 +52,25 @@
 
 	public boolean isFull3D() {
 		return true;
+	}
+
+	public boolean isSilk() {
+		return this.silk;
+	}
+
+	public boolean effectiveAgainst(Block block) {
+		for (Block value : this.blocksEffectiveAgainst) {
+			if (value == block) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				"x$strVsBlock$ efficiency", INFO_COL,
+				"$damageVsEntity$ attack damage", INFO_COL
+		};
 	}
 }
--- /dev/null
+++ net/minecraft/src/Packet54LoadChunks.java
@@ -1,0 +1,21 @@
+package net.minecraft.src;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class Packet54LoadChunks extends Packet {
+	public void readPacketData(DataInputStream var1) throws IOException {
+	}
+
+	public void writePacket(DataOutputStream var1) throws IOException {
+	}
+
+	public void processPacket(NetHandler var1) {
+		var1.handleLoadChunks(this);
+	}
+
+	public int getPacketSize() {
+		return 0;
+	}
+}
--- net/minecraft/src/ItemMinecart.java
+++ net/minecraft/src/ItemMinecart.java
@@ -9,7 +9,7 @@
 		this.minecartType = var2;
 	}
 
-	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7) {
+	public boolean onItemUse(ItemStack var1, EntityPlayer var2, World var3, int var4, int var5, int var6, int var7, float hitx, float hity, float hitz) {
 		int var8 = var3.getBlockId(var4, var5, var6);
 		if(var8 == Block.minecartTrack.blockID) {
 			var3.spawnEntityInWorld(new EntityMinecart(var3, (double)((float)var4 + 0.5F), (double)((float)var5 + 0.5F), (double)((float)var6 + 0.5F), this.minecartType));
--- /dev/null
+++ net/minecraft/src/BooleanHookInt.java
@@ -1,0 +1,5 @@
+package net.minecraft.src;
+
+public interface BooleanHookInt {
+	boolean call(BaseMod mod, int i);
+}
--- net/minecraft/src/NetworkReaderThread.java
+++ net/minecraft/src/NetworkReaderThread.java
@@ -1,9 +1,9 @@
 package net.minecraft.src;
 
-class NetworkReaderThread extends Thread {
-	final NetworkManager netManager;
+public class NetworkReaderThread extends Thread {
+	public final NetworkManager netManager;
 
-	NetworkReaderThread(NetworkManager var1, String var2) {
+	public NetworkReaderThread(NetworkManager var1, String var2) {
 		super(var2);
 		this.netManager = var1;
 	}
--- /dev/null
+++ net/minecraft/src/BlockBlaster.java
@@ -1,0 +1,49 @@
+package net.minecraft.src;
+
+import java.util.Random;
+
+public class BlockBlaster extends BlockFurnace {
+	public BlockBlaster(int var1, boolean var2) {
+		super(var1, var2, Material.iron);
+		this.blockIndexInTexture = textureXY(30, 3);
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Block.blasterIdle.blockID;
+	}
+
+	public int getBlockTexture(IBlockAccess var1, int var2, int var3, int var4, int var5) {
+		if (var5 == 1) {
+			return Block.blockSteel.blockIndexInTexture - 32;
+		} else if (var5 == 0) {
+			return Block.blockSteel.blockIndexInTexture + 32;
+		} else {
+			int var6 = var1.getBlockMetadata(var2, var3, var4);
+			return var5 != var6 ? Block.blockSteel.blockIndexInTexture
+					: (this.isActive ? this.blockIndexInTexture + 32 : this.blockIndexInTexture);
+		}
+	}
+
+	public int getBlockTextureFromSide(int var1) {
+		return var1 == 1 ? Block.blockSteel.blockIndexInTexture - 32
+				: (var1 == 0 ? Block.blockSteel.blockIndexInTexture + 32
+						: (var1 == 3 ? this.blockIndexInTexture : Block.blockSteel.blockIndexInTexture));
+	}
+
+	protected TileEntity getBlockEntity() {
+		return new TileEntityFurnace(50, 2);
+	}
+
+	public void updateFurnaceBlockState(boolean var0, World var1, int var2, int var3, int var4) {
+		int var5 = var1.getBlockMetadata(var2, var3, var4);
+		TileEntity tileEntity6 = var1.getBlockTileEntity(var2, var3, var4);
+		if (var0) {
+			var1.setBlockWithNotify(var2, var3, var4, Block.blasterActive.blockID);
+		} else {
+			var1.setBlockWithNotify(var2, var3, var4, Block.blasterIdle.blockID);
+		}
+
+		var1.setBlockMetadataWithNotify(var2, var3, var4, var5);
+		var1.setBlockTileEntity(var2, var3, var4, tileEntity6);
+	}
+}
--- net/minecraft/src/TexturedQuad.java
+++ net/minecraft/src/TexturedQuad.java
@@ -6,20 +6,24 @@
 	private boolean invertNormal;
 
 	public TexturedQuad(PositionTexureVertex[] var1) {
-		this.nVertices = 0;
 		this.invertNormal = false;
 		this.vertexPositions = var1;
 		this.nVertices = var1.length;
 	}
 
 	public TexturedQuad(PositionTexureVertex[] var1, int var2, int var3, int var4, int var5) {
+		this(var1, var2, var3, var4, var5, false);
+	}
+
+	public TexturedQuad(PositionTexureVertex[] var1, int var2, int var3, int var4, int var5, boolean bigTex) {
 		this(var1);
 		float var6 = 0.0015625F;
-		float var7 = 0.003125F;
-		var1[0] = var1[0].setTexturePosition((float)var4 / 64.0F - var6, (float)var3 / 32.0F + var7);
-		var1[1] = var1[1].setTexturePosition((float)var2 / 64.0F + var6, (float)var3 / 32.0F + var7);
-		var1[2] = var1[2].setTexturePosition((float)var2 / 64.0F + var6, (float)var5 / 32.0F - var7);
-		var1[3] = var1[3].setTexturePosition((float)var4 / 64.0F - var6, (float)var5 / 32.0F - var7);
+		float var7 = bigTex ? 0.0015625F : 0.003125F;
+		float var8 = bigTex ? 64.0F : 32.0F;
+		var1[0] = var1[0].setTexturePosition((float)var4 / 64.0F - var6, (float)var3 / var8 + var7);
+		var1[1] = var1[1].setTexturePosition((float)var2 / 64.0F + var6, (float)var3 / var8 + var7);
+		var1[2] = var1[2].setTexturePosition((float)var2 / 64.0F + var6, (float)var5 / var8 - var7);
+		var1[3] = var1[3].setTexturePosition((float)var4 / 64.0F - var6, (float)var5 / var8 - var7);
 	}
 
 	public void flipFace() {
--- net/minecraft/src/ChunkProviderIso.java
+++ net/minecraft/src/ChunkProviderIso.java
@@ -6,7 +6,7 @@
 	private Chunk[] chunks = new Chunk[256];
 	private World worldObj;
 	private IChunkLoader chunkLoader;
-	byte[] blocks = new byte[-Short.MIN_VALUE];
+	short[] blocks = new short[65536];
 
 	public ChunkProviderIso(World var1, IChunkLoader var2) {
 		this.worldObj = var1;
@@ -50,6 +50,12 @@
 	}
 
 	public void populate(IChunkProvider var1, int var2, int var3) {
+	}
+
+	public void populateUnderworld(IChunkProvider var1, int var2, int var3) {
+	}
+
+	public void upgradeHeight(IChunkProvider var1, Chunk var2, World var3) {
 	}
 
 	public boolean saveChunks(boolean var1, IProgressUpdate var2) {
--- net/minecraft/src/StepSoundSand.java
+++ net/minecraft/src/StepSoundSand.java
@@ -1,7 +1,7 @@
 package net.minecraft.src;
 
-final class StepSoundSand extends StepSound {
-	StepSoundSand(String var1, float var2, float var3) {
+public final class StepSoundSand extends StepSound {
+	public StepSoundSand(String var1, float var2, float var3) {
 		super(var1, var2, var3);
 	}
 
--- net/minecraft/src/LoadingScreenRenderer.java
+++ net/minecraft/src/LoadingScreenRenderer.java
@@ -10,11 +10,16 @@
 	private String currentlyDisplayedText = "";
 	private long systemTime = System.currentTimeMillis();
 	private boolean noError = false;
+	private boolean patience = false;
 
 	public LoadingScreenRenderer(Minecraft var1) {
 		this.mc = var1;
 	}
 
+	public void beHereForAWhile(boolean patience) {
+		this.patience = patience;
+	}
+
 	public void resetProgressAndMessage(String var1) {
 		this.noError = false;
 		this.drawScreen(var1);
@@ -32,7 +37,7 @@
 			}
 		} else {
 			this.currentlyDisplayedText = var1;
-			ScaledResolution var2 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
+			ScaledResolution var2 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight, this.mc.options.guiScale);
 			int var3 = var2.getScaledWidth();
 			int var4 = var2.getScaledHeight();
 			GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
@@ -67,9 +72,10 @@
 			long var2 = System.currentTimeMillis();
 			if(var2 - this.systemTime >= 20L) {
 				this.systemTime = var2;
-				ScaledResolution var4 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight);
+				ScaledResolution var4 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight, this.mc.options.guiScale);
 				int var5 = var4.getScaledWidth();
 				int var6 = var4.getScaledHeight();
+				double off = (double)(this.systemTime % 2500L) / 2500.0D;
 				GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
 				GL11.glMatrixMode(GL11.GL_PROJECTION);
 				GL11.glLoadIdentity();
@@ -84,10 +90,10 @@
 				float var9 = 32.0F;
 				var7.startDrawingQuads();
 				var7.setColorOpaque_I(4210752);
-				var7.addVertexWithUV(0.0D, (double)var6, 0.0D, 0.0D, (double)((float)var6 / var9));
-				var7.addVertexWithUV((double)var5, (double)var6, 0.0D, (double)((float)var5 / var9), (double)((float)var6 / var9));
-				var7.addVertexWithUV((double)var5, 0.0D, 0.0D, (double)((float)var5 / var9), 0.0D);
-				var7.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+				var7.addVertexWithUV(0.0D,  var6,   0.0D,   off,                        (double)var6 / var9);
+				var7.addVertexWithUV(var5,  var6,   0.0D,   (double)var5 / var9 + off,  (double)var6 / var9);
+				var7.addVertexWithUV(var5,  0.0D,   0.0D,   (double)var5 / var9 + off,  0.0D);
+				var7.addVertexWithUV(0.0D,  0.0D,   0.0D,   off,                        0.0D);
 				var7.draw();
 				if(var1 >= 0) {
 					byte var10 = 100;
@@ -119,6 +125,13 @@
 				} catch (Exception var14) {
 				}
 
+				if (patience) {
+					if (this.mc.sndManager.getMusicType() != SoundManager.MusicType.WAITING) {
+
+						this.mc.sndManager.fadeOutBackgroundMusic();
+					}
+					this.mc.sndManager.playRandomWaitingMusicIfReady();
+				}
 			}
 		}
 	}
--- /dev/null
+++ net/minecraft/src/BiomeSeasonalForest.java
@@ -1,0 +1,22 @@
+package net.minecraft.src;
+
+public class BiomeSeasonalForest extends Biome {
+	private static final TreePopulator trees = new TreePopulator()
+			.withTree(new WorldGenTrees().withAltForm(2, 0.5D))
+			.withBigTree(new WorldGenBigTree().withAltForm(2, 0.75D), 10, 2)
+			.withDensity(2.0D, 2.0D, 1.0D, 4.0D, 100.0D);
+
+	protected BiomeSeasonalForest(int id, String name, float priority, ClimateZone... climateZones) {
+		super(id, name, priority, climateZones);
+		this.spawnableAnimals.add(EntityFox.class);
+	}
+
+	public void populate(PopulatorHost host) {
+		trees.populate(host);
+		host.generateFlowers(4);
+	}
+
+	public int[] getMapColor() {
+		return new int[] { 255, 64, 128 };
+	}
+}
--- net/minecraft/src/BlockOreBlock.java
+++ net/minecraft/src/BlockOreBlock.java
@@ -7,6 +7,6 @@
 	}
 
 	public int getBlockTextureFromSide(int var1) {
-		return var1 == 1 ? this.blockIndexInTexture - 16 : (var1 == 0 ? this.blockIndexInTexture + 16 : this.blockIndexInTexture);
+		return var1 == 1 ? this.blockIndexInTexture - 32 : (var1 == 0 ? this.blockIndexInTexture + 32 : this.blockIndexInTexture);
 	}
 }
--- net/minecraft/src/RecipesCrafting.java
+++ net/minecraft/src/RecipesCrafting.java
@@ -1,9 +1,15 @@
 package net.minecraft.src;
 
 public class RecipesCrafting {
-	public void addRecipes(CraftingManager var1) {
-		var1.addRecipe(new ItemStack(Block.chest), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.planks});
-		var1.addRecipe(new ItemStack(Block.stoneOvenIdle), new Object[]{"###", "# #", "###", Character.valueOf('#'), Block.cobblestone});
-		var1.addRecipe(new ItemStack(Block.workbench), new Object[]{"##", "##", Character.valueOf('#'), Block.planks});
+	public void addRecipes(CraftingManager craftingManager) {
+		craftingManager.addRecipe(new ItemStack(Block.chest), "###", "# #", "###", '#', Block.planks);
+		craftingManager.addRecipe(new ItemStack(Block.stoneOvenIdle), "###", "# #", "###", '#', Block.cobblestone);
+		craftingManager.addRecipe(new ItemStack(Block.workbench), "##", "##", '#', Block.planks);
+		craftingManager.addRecipe(new ItemStack(Block.blasterIdle), "###", "#X#", "###", '#', Item.ingotIron, 'X', Block.blockRuby);
+		craftingManager.addRecipe(new ItemStack(Block.refabricator), "XXX", "#S#", "#D#", 'X', Item.starDust, '#', Item.ingotGold, 'S', Block.blockSapphire, 'D', Block.blockDiamond);
+
+		for (int i = 0; i < BlockWood.woodTypeNames.size(); i++) {
+			craftingManager.addRecipe(new ItemStack(Block.crate, 1, i), "###", "#X#", "###", '#', new Pair<>(Block.wood, i), 'X', Block.chest);
+		}
 	}
 }
--- /dev/null
+++ net/minecraft/src/ScreenAchievement.java
@@ -1,0 +1,20 @@
+package net.minecraft.src;
+
+public class ScreenAchievement {
+	public final Achievement type;
+	public final int row;
+	public int updateTick;
+
+	public ScreenAchievement(Achievement type, int row) {
+		this.type = type;
+		this.row = row;
+	}
+
+	public int getY(float var1) {
+		float lerp = 1.0F;
+		float renderTick = this.updateTick + var1;
+		if (renderTick < 10) lerp = (float)Math.sin(renderTick / 20.0D * Math.PI);
+		if (renderTick > 150) lerp = (float)Math.cos((renderTick - 150) / 20.0D * Math.PI);
+		return (int)MathHelper.lerp(-32, this.row * 40 + 8, lerp);
+	}
+}
--- net/minecraft/src/Packet24MobSpawn.java
+++ net/minecraft/src/Packet24MobSpawn.java
@@ -3,47 +3,53 @@
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.util.List;
 
 public class Packet24MobSpawn extends Packet {
 	public int entityId;
-	public byte type;
+	public int type;
 	public int xPosition;
 	public int yPosition;
 	public int zPosition;
 	public byte yaw;
 	public byte pitch;
+	private DataWatcher metaData;
+	private List receivedMetadata;
 
 	public Packet24MobSpawn() {
 	}
 
 	public Packet24MobSpawn(EntityLiving var1) {
 		this.entityId = var1.entityID;
-		this.type = (byte)EntityList.getEntityID(var1);
+		this.type = EntityList.getEntityID(var1);
 		this.xPosition = MathHelper.floor_double(var1.posX * 32.0D);
 		this.yPosition = MathHelper.floor_double(var1.posY * 32.0D);
 		this.zPosition = MathHelper.floor_double(var1.posZ * 32.0D);
 		this.yaw = (byte)((int)(var1.rotationYaw * 256.0F / 360.0F));
 		this.pitch = (byte)((int)(var1.rotationPitch * 256.0F / 360.0F));
+		this.metaData = var1.getDataWatcher();
 	}
 
 	public void readPacketData(DataInputStream var1) throws IOException {
 		this.entityId = var1.readInt();
-		this.type = var1.readByte();
+		this.type = var1.readInt();
 		this.xPosition = var1.readInt();
 		this.yPosition = var1.readInt();
 		this.zPosition = var1.readInt();
 		this.yaw = var1.readByte();
 		this.pitch = var1.readByte();
+		this.receivedMetadata = DataWatcher.readWatchableObjects(var1);
 	}
 
 	public void writePacket(DataOutputStream var1) throws IOException {
 		var1.writeInt(this.entityId);
-		var1.writeByte(this.type);
+		var1.writeInt(this.type);
 		var1.writeInt(this.xPosition);
 		var1.writeInt(this.yPosition);
 		var1.writeInt(this.zPosition);
 		var1.writeByte(this.yaw);
 		var1.writeByte(this.pitch);
+		this.metaData.writeWatchableObjects(var1);
 	}
 
 	public void processPacket(NetHandler var1) {
@@ -51,6 +57,10 @@
 	}
 
 	public int getPacketSize() {
-		return 19;
+		return 23;
+	}
+
+	public List getMetadata() {
+		return this.receivedMetadata;
 	}
 }
--- net/minecraft/src/TextureFlamesFX.java
+++ net/minecraft/src/TextureFlamesFX.java
@@ -5,7 +5,7 @@
 	protected float[] lastFireFrame = new float[320];
 
 	public TextureFlamesFX(int var1) {
-		super(Block.fire.blockIndexInTexture + var1 * 16);
+		super(Block.fire.blockIndexInTexture + var1 * 32);
 	}
 
 	public void onTick() {
--- net/minecraft/src/EntityMinecart.java
+++ net/minecraft/src/EntityMinecart.java
@@ -12,13 +12,25 @@
 	public int fuel;
 	public double pushX;
 	public double pushZ;
-	private static final int[][][] matrix = new int[][][]{{{0, 0, -1}, {0, 0, 1}}, {{-1, 0, 0}, {1, 0, 0}}, {{-1, -1, 0}, {1, 0, 0}}, {{-1, 0, 0}, {1, -1, 0}}, {{0, 0, -1}, {0, -1, 1}}, {{0, -1, -1}, {0, 0, 1}}, {{0, 0, 1}, {1, 0, 0}}, {{0, 0, 1}, {-1, 0, 0}}, {{0, 0, -1}, {-1, 0, 0}}, {{0, 0, -1}, {1, 0, 0}}};
+	private static final int[][][] matrix = new int[][][]{
+			{{0, 0, -1}, {0, 0, 1}},
+			{{-1, 0, 0}, {1, 0, 0}},
+			{{-1, -1, 0}, {1, 0, 0}},
+			{{-1, 0, 0}, {1, -1, 0}},
+			{{0, 0, -1}, {0, -1, 1}},
+			{{0, -1, -1}, {0, 0, 1}},
+			{{0, 0, 1}, {1, 0, 0}},
+			{{0, 0, 1}, {-1, 0, 0}},
+			{{0, 0, -1}, {-1, 0, 0}},
+			{{0, 0, -1}, {1, 0, 0}}
+	};
 	private int turnProgress;
 	private double minecartX;
 	private double minecartY;
 	private double minecartZ;
 	private double minecartYaw;
 	private double minecartPitch;
+	private double boost;
 
 	public EntityMinecart(World var1) {
 		super(var1);
@@ -62,18 +74,43 @@
 	}
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
-		this.forwardDirection = -this.forwardDirection;
-		this.timeSinceHit = 10;
-		this.damageTaken += var2 * 10;
-		if(this.damageTaken > 40) {
-			this.entityDropItem(Item.minecartEmpty.shiftedIndex, 1, 0.0F);
-			if(this.minecartType == 1) {
-				this.entityDropItem(Block.chest.blockID, 1, 0.0F);
-			} else if(this.minecartType == 2) {
-				this.entityDropItem(Block.stoneOvenIdle.blockID, 1, 0.0F);
+		if (this.worldObj.canDoClientAction() && !this.isDead) {
+			this.forwardDirection = -this.forwardDirection;
+			this.timeSinceHit = 20;
+			this.damageTaken += var2 * 20;
+			if(this.damageTaken > 80) {
+				this.entityDropItem(Item.minecartEmpty.shiftedIndex, 1, 0.0F);
+				if(this.minecartType == 1) {
+					this.entityDropItem(Block.chest.blockID, 1, 0.0F);
+					for(int var4 = 0; var4 < this.getInventorySize(); ++var4) {
+						ItemStack var5 = this.getStack(var4);
+						if(var5 != null) {
+							float var6 = this.rand.nextFloat() * 0.8F + 0.1F;
+							float var7 = this.rand.nextFloat() * 0.8F + 0.1F;
+							float var8 = this.rand.nextFloat() * 0.8F + 0.1F;
+
+							while(var5.stackSize > 0) {
+								int var9 = this.rand.nextInt(21) + 10;
+								if(var9 > var5.stackSize) {
+									var9 = var5.stackSize;
+								}
+
+								var5.stackSize -= var9;
+								EntityItem var10 = new EntityItem(this.worldObj, this.posX + (double)var6, this.posY + (double)var7, this.posZ + (double)var8, new ItemStack(var5.itemID, var9, var5.itemDmg, var5.itemMetadata).withStorage(var5.storage));
+								double var11 = 0.05F;
+								var10.motionX = this.rand.nextGaussian() * var11;
+								var10.motionY = this.rand.nextGaussian() * var11 + 0.2D;
+								var10.motionZ = this.rand.nextGaussian() * var11;
+								this.worldObj.spawnEntityInWorld(var10);
+							}
+						}
+					}
+				} else if(this.minecartType == 2) {
+					this.entityDropItem(Block.stoneOvenIdle.blockID, 1, 0.0F);
+				}
+
+				this.setEntityDead();
 			}
-
-			this.setEntityDead();
 		}
 
 		return true;
@@ -84,8 +121,8 @@
 	}
 
 	public void setEntityDead() {
-		for(int var1 = 0; var1 < this.getSizeInventory(); ++var1) {
-			ItemStack var2 = this.getStackInSlot(var1);
+		for(int var1 = 0; var1 < this.getInventorySize(); ++var1) {
+			ItemStack var2 = this.getStack(var1);
 			if(var2 != null) {
 				float var3 = this.rand.nextFloat() * 0.8F + 0.1F;
 				float var4 = this.rand.nextFloat() * 0.8F + 0.1F;
@@ -98,7 +135,7 @@
 					}
 
 					var2.stackSize -= var6;
-					EntityItem var7 = new EntityItem(this.worldObj, this.posX + (double)var3, this.posY + (double)var4, this.posZ + (double)var5, new ItemStack(var2.itemID, var6, var2.itemDmg));
+					EntityItem var7 = new EntityItem(this.worldObj, this.posX + (double)var3, this.posY + (double)var4, this.posZ + (double)var5, new ItemStack(var2.itemID, var6, var2.itemDmg, var2.itemMetadata).withStorage(var2.storage));
 					float var8 = 0.05F;
 					var7.motionX = (double)((float)this.rand.nextGaussian() * var8);
 					var7.motionY = (double)((float)this.rand.nextGaussian() * var8 + 0.2F);
@@ -113,7 +150,7 @@
 
 	public void onUpdate() {
 		double var7;
-		if(this.worldObj.multiplayerWorld) {
+		if(!this.worldObj.canDoClientAction()) {
 			if(this.turnProgress > 0) {
 				double var41 = this.posX + (this.minecartX - this.posX) / (double)this.turnProgress;
 				double var42 = this.posY + (this.minecartY - this.posY) / (double)this.turnProgress;
@@ -152,14 +189,14 @@
 			int var1 = MathHelper.floor_double(this.posX);
 			int var2 = MathHelper.floor_double(this.posY);
 			int var3 = MathHelper.floor_double(this.posZ);
-			if(this.worldObj.getBlockId(var1, var2 - 1, var3) == Block.minecartTrack.blockID) {
+			if(MinecartTrackLogic.isBlockMinecartTrack(this.worldObj, var1, var2 - 1, var3)) {
 				--var2;
 			}
 
-			double var4 = 0.4D;
+			double var4 = 0.5D;
 			boolean var6 = false;
 			var7 = 1.0D / 128.0D;
-			if(this.worldObj.getBlockId(var1, var2, var3) == Block.minecartTrack.blockID) {
+			if(MinecartTrackLogic.isBlockMinecartTrack(this.worldObj, var1, var2, var3)) {
 				Vec3D var9 = this.getPos(this.posX, this.posY, this.posZ);
 				int var10 = this.worldObj.getBlockMetadata(var1, var2, var3);
 				this.posY = (double)var2;
@@ -183,6 +220,18 @@
 					this.motionZ -= var7;
 				}
 
+				if (this.worldObj.getBlockId(var1, var2, var3) == Block.boosterTrack.blockID) {
+					if (boost < 1.0D) {
+						this.playSound("random.boost", 0.25F, 1.0F);
+					}
+					boost = 1.0D;
+				} else if (boost > 0.0D) {
+					boost -= 0.1D;
+				}
+
+				this.motionX *= 1.0D + boost;
+				this.motionZ *= 1.0D + boost;
+
 				int[][] var11 = matrix[var10];
 				double var12 = (double)(var11[1][0] - var11[0][0]);
 				double var14 = (double)(var11[1][2] - var11[0][2]);
@@ -245,7 +294,7 @@
 					var34 = var4;
 				}
 
-				this.moveEntity(var32, 0.0D, var34);
+				this.moveEntity(var32 * 1.5D, 0.0D, var34 * 1.5D);
 				if(var11[0][1] != 0 && MathHelper.floor_double(this.posX) - var1 == var11[0][0] && MathHelper.floor_double(this.posZ) - var3 == var11[0][2]) {
 					this.setPosition(this.posX, this.posY + (double)var11[0][1], this.posZ);
 				} else if(var11[1][1] != 0 && MathHelper.floor_double(this.posX) - var1 == var11[1][0] && MathHelper.floor_double(this.posZ) - var3 == var11[1][2]) {
@@ -253,9 +302,11 @@
 				}
 
 				if(this.riddenByEntity != null) {
-					this.motionX *= (double)0.997F;
+					if (boost > 0.0D) {
+						this.motionX *= (double)0.997F;
+						this.motionZ *= (double)0.997F;
+					}
 					this.motionY *= 0.0D;
-					this.motionZ *= (double)0.997F;
 				} else {
 					if(this.minecartType == 2) {
 						var36 = (double)MathHelper.sqrt_double(this.pushX * this.pushX + this.pushZ * this.pushZ);
@@ -400,11 +451,11 @@
 		int var9 = MathHelper.floor_double(var1);
 		int var10 = MathHelper.floor_double(var3);
 		int var11 = MathHelper.floor_double(var5);
-		if(this.worldObj.getBlockId(var9, var10 - 1, var11) == Block.minecartTrack.blockID) {
+		if(MinecartTrackLogic.isBlockMinecartTrack(this.worldObj, var9, var10 - 1, var11)) {
 			--var10;
 		}
 
-		if(this.worldObj.getBlockId(var9, var10, var11) == Block.minecartTrack.blockID) {
+		if(MinecartTrackLogic.isBlockMinecartTrack(this.worldObj, var9, var10, var11)) {
 			int var12 = this.worldObj.getBlockMetadata(var9, var10, var11);
 			var3 = (double)var10;
 			if(var12 >= 2 && var12 <= 5) {
@@ -435,11 +486,11 @@
 		int var7 = MathHelper.floor_double(var1);
 		int var8 = MathHelper.floor_double(var3);
 		int var9 = MathHelper.floor_double(var5);
-		if(this.worldObj.getBlockId(var7, var8 - 1, var9) == Block.minecartTrack.blockID) {
+		if(MinecartTrackLogic.isBlockMinecartTrack(this.worldObj, var7, var8 - 1, var9)) {
 			--var8;
 		}
 
-		if(this.worldObj.getBlockId(var7, var8, var9) == Block.minecartTrack.blockID) {
+		if(MinecartTrackLogic.isBlockMinecartTrack(this.worldObj, var7, var8, var9)) {
 			int var10 = this.worldObj.getBlockMetadata(var7, var8, var9);
 			var3 = (double)var8;
 			if(var10 >= 2 && var10 <= 5) {
@@ -493,6 +544,7 @@
 			var1.setDouble("PushX", this.pushX);
 			var1.setDouble("PushZ", this.pushZ);
 			var1.setShort("Fuel", (short)this.fuel);
+			var1.setDouble("Boost", this.boost);
 		} else if(this.minecartType == 1) {
 			NBTTagList var2 = new NBTTagList();
 
@@ -516,9 +568,10 @@
 			this.pushX = var1.getDouble("PushX");
 			this.pushZ = var1.getDouble("PushZ");
 			this.fuel = var1.getShort("Fuel");
+			this.boost = var1.getDouble("Boost");
 		} else if(this.minecartType == 1) {
 			NBTTagList var2 = var1.getTagList("Items");
-			this.cargoItems = new ItemStack[this.getSizeInventory()];
+			this.cargoItems = new ItemStack[this.getInventorySize()];
 
 			for(int var3 = 0; var3 < var2.tagCount(); ++var3) {
 				NBTTagCompound var4 = (NBTTagCompound)var2.tagAt(var3);
@@ -564,13 +617,13 @@
 				if(var1 instanceof EntityMinecart) {
 					double var10 = var1.motionX + this.motionX;
 					double var12 = var1.motionZ + this.motionZ;
-					if(((EntityMinecart)var1).minecartType == 2 && this.minecartType != 2) {
+					if(((EntityMinecart) var1).minecartType == 2 && this.minecartType != 2) {
 						this.motionX *= (double)0.2F;
 						this.motionZ *= (double)0.2F;
 						this.addVelocity(var1.motionX - var2, 0.0D, var1.motionZ - var4);
 						var1.motionX *= (double)0.7F;
 						var1.motionZ *= (double)0.7F;
-					} else if(((EntityMinecart)var1).minecartType != 2 && this.minecartType == 2) {
+					} else if(((EntityMinecart) var1).minecartType != 2 && this.minecartType == 2) {
 						var1.motionX *= (double)0.2F;
 						var1.motionZ *= (double)0.2F;
 						var1.addVelocity(this.motionX + var2, 0.0D, this.motionZ + var4);
@@ -595,15 +648,15 @@
 		}
 	}
 
-	public int getSizeInventory() {
+	public int getInventorySize() {
 		return 27;
 	}
 
-	public ItemStack getStackInSlot(int var1) {
+	public ItemStack getStack(int var1) {
 		return this.cargoItems[var1];
 	}
 
-	public ItemStack decrStackSize(int var1, int var2) {
+	public ItemStack decrStack(int var1, int var2) {
 		if(this.cargoItems[var1] != null) {
 			ItemStack var3;
 			if(this.cargoItems[var1].stackSize <= var2) {
@@ -623,23 +676,23 @@
 		}
 	}
 
-	public void setInventorySlotContents(int var1, ItemStack var2) {
+	public void setInventorySlotItem(int var1, ItemStack var2) {
 		this.cargoItems[var1] = var2;
-		if(var2 != null && var2.stackSize > this.getInventoryStackLimit()) {
-			var2.stackSize = this.getInventoryStackLimit();
+		if(var2 != null && var2.stackSize > this.getStackLimit()) {
+			var2.stackSize = this.getStackLimit();
 		}
 
 	}
 
-	public String getInvName() {
+	public String getInventoryName() {
 		return "Minecart";
 	}
 
-	public int getInventoryStackLimit() {
+	public int getStackLimit() {
 		return 64;
 	}
 
-	public void onInventoryChanged() {
+	public void onInventoryChange() {
 	}
 
 	public boolean interact(EntityPlayer var1) {
@@ -651,7 +704,7 @@
 			ItemStack var2 = var1.inventory.getCurrentItem();
 			if(var2 != null && var2.itemID == Item.coal.shiftedIndex) {
 				if(--var2.stackSize == 0) {
-					var1.inventory.setInventorySlotContents(var1.inventory.currentItem, (ItemStack)null);
+					var1.inventory.setInventorySlotItem(var1.inventory.currentItem, (ItemStack)null);
 				}
 
 				this.fuel += 1200;
@@ -671,5 +724,9 @@
 		this.minecartYaw = (double)var7;
 		this.minecartPitch = (double)var8;
 		this.turnProgress = var9;
+	}
+
+	public boolean isNearPlayer(EntityPlayer var1) {
+		return !this.isDead && var1.getDistanceSqToEntity(this) <= 64.0D;
 	}
 }
--- net/minecraft/src/EntitySlimeFX.java
+++ net/minecraft/src/EntitySlimeFX.java
@@ -14,10 +14,10 @@
 	}
 
 	public void renderParticle(Tessellator var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-		float var8 = ((float)(this.particleTextureIndex % 16) + this.particleTextureJitterX / 4.0F) / 16.0F;
-		float var9 = var8 + 0.999F / 64.0F;
-		float var10 = ((float)(this.particleTextureIndex / 16) + this.particleTextureJitterY / 4.0F) / 16.0F;
-		float var11 = var10 + 0.999F / 64.0F;
+		float var8 = ((float)(this.particleTextureIndex % 32) + this.particleTextureJitterX / 4.0F) / 32.0F;
+		float var9 = var8 + 0.999F / 128.0F;
+		float var10 = ((float)(this.particleTextureIndex / 32) + this.particleTextureJitterY / 4.0F) / 32.0F;
+		float var11 = var10 + 0.999F / 128.0F;
 		float var12 = 0.1F * this.particleScale;
 		float var13 = (float)(this.prevPosX + (this.posX - this.prevPosX) * (double)var2 - interpPosX);
 		float var14 = (float)(this.prevPosY + (this.posY - this.prevPosY) * (double)var2 - interpPosY);
--- net/minecraft/src/EntityPainting.java
+++ net/minecraft/src/EntityPainting.java
@@ -6,9 +6,9 @@
 public class EntityPainting extends Entity {
 	private int tickCounter;
 	public int direction;
-	private int xPosition;
-	private int yPosition;
-	private int zPosition;
+	public int xPosition;
+	public int yPosition;
+	public int zPosition;
 	public EnumArt art;
 
 	public EntityPainting(World var1) {
@@ -44,6 +44,25 @@
 		this.setDirection(var5);
 	}
 
+	public EntityPainting(World var1, int var2, int var3, int var4, int var5, String var6) {
+		this(var1);
+		this.xPosition = var2;
+		this.yPosition = var3;
+		this.zPosition = var4;
+		EnumArt[] var7 = EnumArt.values();
+		int var8 = var7.length;
+
+		for(int var9 = 0; var9 < var8; ++var9) {
+			EnumArt var10 = var7[var9];
+			if(var10.title.equals(var6)) {
+				this.art = var10;
+				break;
+			}
+		}
+
+		this.setDirection(var5);
+	}
+
 	public void setDirection(int var1) {
 		this.direction = var1;
 		this.prevRotationYaw = this.rotationYaw = (float)(var1 * 90);
@@ -106,10 +125,12 @@
 	}
 
 	public void onUpdate() {
-		if(this.tickCounter++ == 100 && !this.onValidSurface()) {
+		if(this.tickCounter++ == 100 && this.worldObj.canDoClientAction()) {
 			this.tickCounter = 0;
-			this.setEntityDead();
-			this.worldObj.spawnEntityInWorld(new EntityItem(this.worldObj, this.posX, this.posY, this.posZ, new ItemStack(Item.painting)));
+			if (!this.onValidSurface()) {
+				this.setEntityDead();
+				this.worldObj.spawnEntityInWorld(new EntityItem(this.worldObj, this.posX, this.posY, this.posZ, new ItemStack(Item.painting)));
+			}
 		}
 
 	}
@@ -174,8 +195,10 @@
 	}
 
 	public boolean attackEntityFrom(Entity var1, int var2) {
-		this.setEntityDead();
-		this.worldObj.spawnEntityInWorld(new EntityItem(this.worldObj, this.posX, this.posY, this.posZ, new ItemStack(Item.painting)));
+		if (this.worldObj.canDoClientAction()) {
+			this.setEntityDead();
+			this.worldObj.spawnEntityInWorld(new EntityItem(this.worldObj, this.posX, this.posY, this.posZ, new ItemStack(Item.painting)));
+		}
 		return true;
 	}
 
--- /dev/null
+++ net/minecraft/src/ContainerFurnace.java
@@ -1,0 +1,67 @@
+package net.minecraft.src;
+
+public class ContainerFurnace extends Container {
+	private TileEntityFurnace furnaceTileEntity;
+	private int furnaceCookTime = 0;
+	private int furnaceBurnTime = 0;
+	private int currentItemBurnTime = 0;
+
+	public ContainerFurnace(IInventory var1, TileEntityFurnace var2) {
+		this.furnaceTileEntity = var2;
+		this.addSlot(new Slot(var2, 0, 56, 17));
+		this.addSlot(new Slot(var2, 1, 56, 53));
+		this.addSlot(new Slot(var2, 2, 116, 35));
+
+		int var3;
+		for(var3 = 0; var3 < 3; ++var3) {
+			for(int var4 = 0; var4 < 9; ++var4) {
+				this.addSlot(new Slot(var1, var4 + var3 * 9 + 9, 8 + var4 * 18, 84 + var3 * 18));
+			}
+		}
+
+		for(var3 = 0; var3 < 9; ++var3) {
+			this.addSlot(new Slot(var1, var3, 8 + var3 * 18, 142));
+		}
+	}
+
+	public void updateCraftingMatrix() {
+		super.updateCraftingMatrix();
+
+		for(int var1 = 0; var1 < this.crafters.size(); ++var1) {
+			ICrafting var2 = (ICrafting)this.crafters.get(var1);
+			if(this.furnaceCookTime != this.furnaceTileEntity.furnaceCookTime) {
+				var2.setOtherSlot(this, 0, this.furnaceTileEntity.furnaceCookTime);
+			}
+
+			if(this.furnaceBurnTime != this.furnaceTileEntity.furnaceBurnTime) {
+				var2.setOtherSlot(this, 1, this.furnaceTileEntity.furnaceBurnTime);
+			}
+
+			if(this.currentItemBurnTime != this.furnaceTileEntity.currentItemBurnTime) {
+				var2.setOtherSlot(this, 2, this.furnaceTileEntity.currentItemBurnTime);
+			}
+		}
+
+		this.furnaceCookTime = this.furnaceTileEntity.furnaceCookTime;
+		this.furnaceBurnTime = this.furnaceTileEntity.furnaceBurnTime;
+		this.currentItemBurnTime = this.furnaceTileEntity.currentItemBurnTime;
+	}
+
+	public void func_20112_a(int var1, int var2) {
+		if(var1 == 0) {
+			this.furnaceTileEntity.furnaceCookTime = var2;
+		}
+
+		if(var1 == 1) {
+			this.furnaceTileEntity.furnaceBurnTime = var2;
+		}
+
+		if(var1 == 2) {
+			this.furnaceTileEntity.currentItemBurnTime = var2;
+		}
+	}
+
+	public boolean stayOpen(EntityPlayer var1) {
+		return this.furnaceTileEntity.isNearPlayer(var1);
+	}
+}
--- /dev/null
+++ net/minecraft/src/GuiMods.java
@@ -1,0 +1,84 @@
+package net.minecraft.src;
+
+import org.lwjgl.opengl.GL11;
+
+import java.awt.*;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+public class GuiMods extends GuiScreen {
+	private final GuiScreen parentScreen;
+	private GuiSliderGeneric scrollbar;
+
+	public GuiMods(GuiScreen parentScreen) {
+		this.parentScreen = parentScreen;
+	}
+
+	public void initGui() {
+		this.controlList.add(new GuiButton(0, this.width / 2 - 102, this.height - 24, 100, 20, "Exit"));
+		this.controlList.add(new GuiButton(1, this.width / 2 + 2, this.height - 24, 100, 20, "Create a mod"));
+
+		this.scrollbar = new GuiSliderGeneric(1, this.width - 18, 32, 18, this.height - 64, null, 0.0F,
+				Math.max((ModLoader.mods.size() * 56) - this.height + 72, 0.0F));
+		this.scrollbar.vertical = true;
+		this.scrollbar.hideBg = true;
+		this.controlList.add(this.scrollbar);
+	}
+
+	protected void actionPerformed(GuiButton var1) {
+		switch (var1.id) {
+			case 0:
+				this.mc.displayGuiScreen(this.parentScreen);
+				break;
+
+			case 1:
+				try {
+					Desktop.getDesktop().browse(new URI("https://github.com/BlueStaggo/MCDiverge/blob/main/MODDING.md"));
+				} catch (Exception e) {
+					// Don't care
+				}
+				break;
+		}
+	}
+
+	public void drawScreen(int var1, int var2, float var3) {
+		this.drawDefaultBackground(var3);
+		this.drawRect(this.width - 18, 32, this.width, this.height - 32, 0xFF202020);
+		for (int i = 0; i < ModLoader.mods.size(); i++) {
+			this.drawMod(ModLoader.mods.get(i), i);
+		}
+
+		if (ModLoader.mods.size() == 0) {
+			this.drawCenteredString(this.fontRenderer, "You have no mods!", this.width / 2, this.height / 2 - 6, 0xFFFFFF);
+			this.drawCenteredString(this.fontRenderer, "Mods should be loaded from .minecraft/dvmods.", this.width / 2, this.height / 2 + 6, 0xFFFFFF);
+
+			if (!System.getProperty("java.version").startsWith("1.")) {
+				this.drawCenteredString(this.fontRenderer, "Note: Mods require exactly Java 8", this.width / 2, this.height / 2 + 24, 0xFF5555);
+			}
+		}
+
+		this.drawHeader("Mods");
+		super.drawScreen(var1, var2, var3);
+	}
+
+	public void drawMod(BaseMod mod, int i) {
+		int x = (this.width - 256) / 2;
+		int y = 40 + (int)(-this.scrollbar.sliderValue * this.scrollbar.multiplier) + i * 56;
+
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture("@@/gui/panel.png"));
+		this.drawTexturedModalRect(x, y, 0, 0, 256, 48);
+		this.drawTexturedModalRect(x + 7, y + 7, 0, 48, 34, 34);
+
+		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.mc.renderEngine.getTexture(mod.getIcon()));
+		this.drawTexturedModalRect(x + 8, y + 8, 0, 0, 32, 32, 32.0F);
+
+		this.fontRenderer.drawBoldStringWithShadow(mod.getName(), x + 43, y + 7, 0xFFFF55);
+		this.fontRenderer.drawStringWithShadow("Version " + mod.getVersion(), x + 43, y + 16, 0xFFFFFF);
+		this.fontRenderer.drawStringWithShadow("By " + mod.getAuthor(), x + 43, y + 25, 0xFFFFFF);
+	}
+
+	protected void mouseScrolled(int delta) {
+		this.scrollbar.mouseScrolled(delta / 10.0F * this.scrollbar.multiplier);
+	}
+}
--- net/minecraft/src/EntityTrackerEntry.java
+++ net/minecraft/src/EntityTrackerEntry.java
@@ -7,6 +7,9 @@
 
 public class EntityTrackerEntry {
 	public Entity trackedEntity;
+	public boolean field_9237_b = false;
+	public boolean field_9236_c = false;
+	public boolean field_9225_n = false;
 	public int trackingDistanceThreshold;
 	public int updateFrequency;
 	public int encodedPosX;
@@ -14,18 +17,23 @@
 	public int encodedPosZ;
 	public int encodedRotationYaw;
 	public int encodedRotationPitch;
+	public double encodedMotionX;
+	public double encodedMotionY;
+	public double encodedMotionZ;
 	public int updateCounter = 0;
 	private double lastTrackedEntityPosX;
 	private double lastTrackedEntityPosY;
 	private double lastTrackedEntityPosZ;
 	private boolean firstUpdateDone = false;
 	public boolean playerEntitiesUpdated = false;
+	public boolean shouldSendMotionUpdates;
 	public Set trackedPlayers = new HashSet();
 
-	public EntityTrackerEntry(Entity var1, int var2, int var3) {
+	public EntityTrackerEntry(Entity var1, int var2, int var3, boolean var4) {
 		this.trackedEntity = var1;
 		this.trackingDistanceThreshold = var2;
 		this.updateFrequency = var3;
+		this.shouldSendMotionUpdates = var4;
 		this.encodedPosX = MathHelper.floor_double(var1.posX * 32.0D);
 		this.encodedPosY = MathHelper.floor_double(var1.posY * 32.0D);
 		this.encodedPosZ = MathHelper.floor_double(var1.posZ * 32.0D);
@@ -71,17 +79,60 @@
 					var12 = new Packet31RelEntityMove(this.trackedEntity.entityID, (byte)var9, (byte)var10, (byte)var11);
 				} else if(var8) {
 					var12 = new Packet32EntityLook(this.trackedEntity.entityID, (byte)var5, (byte)var6);
-				} else {
-					var12 = new Packet30Entity(this.trackedEntity.entityID);
 				}
 			} else {
 				var12 = new Packet34EntityTeleport(this.trackedEntity.entityID, var2, var3, var4, (byte)var5, (byte)var6);
 			}
 
+			if(this.shouldSendMotionUpdates) {
+				double var13 = this.trackedEntity.motionX - this.encodedMotionX;
+				double var15 = this.trackedEntity.motionY - this.encodedMotionY;
+				double var17 = this.trackedEntity.motionZ - this.encodedMotionZ;
+				double var19 = 0.02;
+				double var21 = var13 * var13 + var15 * var15 + var17 * var17;
+				if(var21 > var19 * var19 || var21 > 0.0 && this.trackedEntity.motionX == 0.0 && this.trackedEntity.motionY == 0.0 && this.trackedEntity.motionZ == 0.0) {
+					this.encodedMotionX = this.trackedEntity.motionX;
+					this.encodedMotionY = this.trackedEntity.motionY;
+					this.encodedMotionZ = this.trackedEntity.motionZ;
+					this.sendPacketToTrackedPlayers(new Packet28EntityVelocity(this.trackedEntity.entityID, this.encodedMotionX, this.encodedMotionY, this.encodedMotionZ));
+				}
+			}
+
 			if(var12 != null) {
 				this.sendPacketToTrackedPlayers((Packet)var12);
 			}
 
+			DataWatcher var23 = this.trackedEntity.getDataWatcher();
+			if(var23.hasObjectChanged()) {
+				this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet40EntityMetadata(this.trackedEntity.entityID, var23));
+			}
+
+			if(this.field_9237_b && this.trackedEntity.ridingEntity == null) {
+				this.field_9237_b = false;
+				this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet18ArmAnimation(this.trackedEntity, 101));
+			} else if(!this.field_9237_b && this.trackedEntity.ridingEntity != null) {
+				this.field_9237_b = true;
+				this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet18ArmAnimation(this.trackedEntity, 100));
+			}
+
+			if(this.trackedEntity instanceof EntityLiving) {
+				if(this.field_9225_n && !this.trackedEntity.isSneaking()) {
+					this.field_9225_n = false;
+					this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet18ArmAnimation(this.trackedEntity, 105));
+				} else if(!this.field_9225_n && this.trackedEntity.isSneaking()) {
+					this.field_9225_n = true;
+					this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet18ArmAnimation(this.trackedEntity, 104));
+				}
+			}
+
+			if(this.field_9236_c && this.trackedEntity.fire <= 0) {
+				this.field_9236_c = false;
+				this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet18ArmAnimation(this.trackedEntity, 103));
+			} else if(!this.field_9236_c && this.trackedEntity.fire > 0) {
+				this.field_9236_c = true;
+				this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet18ArmAnimation(this.trackedEntity, 102));
+			}
+
 			this.encodedPosX = var2;
 			this.encodedPosY = var3;
 			this.encodedPosZ = var4;
@@ -89,6 +140,10 @@
 			this.encodedRotationPitch = var6;
 		}
 
+		if(this.trackedEntity.updateVelocity) {
+			this.sendPacketToTrackedPlayersAndTrackedEntity(new Packet28EntityVelocity(this.trackedEntity));
+			this.trackedEntity.updateVelocity = false;
+		}
 	}
 
 	public void sendPacketToTrackedPlayers(Packet var1) {
@@ -98,7 +153,13 @@
 			EntityPlayerMP var3 = (EntityPlayerMP)var2.next();
 			var3.playerNetServerHandler.sendPacket(var1);
 		}
+	}
 
+	public void sendPacketToTrackedPlayersAndTrackedEntity(Packet var1) {
+		this.sendPacketToTrackedPlayers(var1);
+		if(this.trackedEntity instanceof EntityPlayerMP) {
+			((EntityPlayerMP)this.trackedEntity).playerNetServerHandler.sendPacket(var1);
+		}
 	}
 
 	public void removeFromTrackedPlayers() {
@@ -113,12 +174,22 @@
 				if(!this.trackedPlayers.contains(var1)) {
 					this.trackedPlayers.add(var1);
 					var1.playerNetServerHandler.sendPacket(this.getSpawnPacket());
+
+					if(this.shouldSendMotionUpdates) {
+						var1.playerNetServerHandler.sendPacket(new Packet28EntityVelocity(this.trackedEntity.entityID, this.trackedEntity.motionX, this.trackedEntity.motionY, this.trackedEntity.motionZ));
+					}
+
+					ItemStack[] var6 = this.trackedEntity.getInventory();
+					if(var6 != null) {
+						for(int var7 = 0; var7 < var6.length; ++var7) {
+							var1.playerNetServerHandler.sendPacket(new Packet5PlayerInventory(this.trackedEntity.entityID, var7, var6[var7]));
+						}
+					}
 				}
 			} else if(this.trackedPlayers.contains(var1)) {
 				this.trackedPlayers.remove(var1);
 				var1.playerNetServerHandler.sendPacket(new Packet29DestroyEntity(this.trackedEntity.entityID));
 			}
-
 		}
 	}
 
@@ -136,9 +207,6 @@
 			var3.posX = (double)var2.xPosition / 32.0D;
 			var3.posY = (double)var2.yPosition / 32.0D;
 			var3.posZ = (double)var2.zPosition / 32.0D;
-			var3.motionX = (double)var2.rotation / 128.0D;
-			var3.motionY = (double)var2.pitch / 128.0D;
-			var3.motionZ = (double)var2.roll / 128.0D;
 			return var2;
 		} else if(this.trackedEntity instanceof EntityPlayerMP) {
 			return new Packet20NamedEntitySpawn((EntityPlayer)this.trackedEntity);
@@ -160,11 +228,26 @@
 
 			if(this.trackedEntity instanceof EntityBoat) {
 				return new Packet23VehicleSpawn(this.trackedEntity, 1);
-			} else if(this.trackedEntity instanceof IAnimals) {
+			} else if(this.trackedEntity instanceof IAnimal || this.trackedEntity instanceof IMobs) {
 				return new Packet24MobSpawn((EntityLiving)this.trackedEntity);
+			} else if(this.trackedEntity instanceof EntitySnowball) {
+				return new Packet23VehicleSpawn(this.trackedEntity, 61);
+			} else if(this.trackedEntity instanceof EntityArrow) {
+				return new Packet23VehicleSpawn(this.trackedEntity, 60);
+			} else if(this.trackedEntity instanceof EntityFallingSand) {
+				return new Packet23VehicleSpawn(this.trackedEntity, 70);
+			} else if(this.trackedEntity instanceof EntityPainting) {
+				return new Packet25EntityPainting((EntityPainting)this.trackedEntity);
 			} else {
 				throw new IllegalArgumentException("Don\'t know how to add " + this.trackedEntity.getClass() + "!");
 			}
+		}
+	}
+
+	public void removeTrackedPlayerSymmetric(EntityPlayerMP var1) {
+		if(this.trackedPlayers.contains(var1)) {
+			this.trackedPlayers.remove(var1);
+			var1.playerNetServerHandler.sendPacket(new Packet29DestroyEntity(this.trackedEntity.entityID));
 		}
 	}
 }
--- /dev/null
+++ net/minecraft/src/ItemVanity.java
@@ -1,0 +1,23 @@
+package net.minecraft.src;
+
+public class ItemVanity extends ItemEquipable {
+	public final int vanityType;
+	public final String texturePath;
+	public final boolean overrideArmor;
+	public final boolean dyable;
+
+	public ItemVanity(int var1, int var2, String var3, boolean var4, boolean var5) {
+		super(var1, 5);
+		this.vanityType = var2;
+		this.texturePath = var3;
+		this.overrideArmor = var4;
+		this.dyable = var5;
+	}
+
+	public Object[] getTooltipInfo() {
+		return new Object[] {
+				"Can be equipped in", ItemTooltip.INFO_COL,
+				"vanity slots", ItemTooltip.INFO_COL
+		};
+	}
+}
--- /dev/null
+++ net/minecraft/src/Pair.java
@@ -1,0 +1,24 @@
+package net.minecraft.src;
+
+import java.util.Objects;
+
+public class Pair<I0, I1> {
+	public I0 var0;
+	public I1 var1;
+
+	public Pair(I0 var0, I1 var1) {
+		this.var0 = var0;
+		this.var1 = var1;
+	}
+
+	public boolean equals(Object o) {
+		if (this == o) return true;
+		if (o == null || getClass() != o.getClass()) return false;
+		Pair<?, ?> pair = (Pair<?, ?>) o;
+		return Objects.equals(var0, pair.var0) && Objects.equals(var1, pair.var1);
+	}
+
+	public int hashCode() {
+		return Objects.hash(var0, var1);
+	}
+}
--- net/minecraft/src/BlockMushroom.java
+++ net/minecraft/src/BlockMushroom.java
@@ -1,7 +1,7 @@
 package net.minecraft.src;
 
 public class BlockMushroom extends BlockFlower {
-	protected BlockMushroom(int var1, int var2) {
+	public BlockMushroom(int var1, int var2) {
 		super(var1, var2);
 		float var3 = 0.2F;
 		this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 2.0F, 0.5F + var3);
--- net/minecraft/src/BlockFarmland.java
+++ net/minecraft/src/BlockFarmland.java
@@ -3,9 +3,11 @@
 import java.util.Random;
 
 public class BlockFarmland extends Block {
-	protected BlockFarmland(int var1) {
+	public final BitField moisture = this.fields.addBitField("moisture", 3);
+
+	public BlockFarmland(int var1) {
 		super(var1, Material.grass);
-		this.blockIndexInTexture = 87;
+		this.blockIndexInTexture = textureXY(3, 0);
 		this.setTickOnLoad(true);
 		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 15.0F / 16.0F, 1.0F);
 		this.setLightOpacity(255);
--- net/minecraft/src/GameSettings.java
+++ net/minecraft/src/GameSettings.java
@@ -5,37 +5,77 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.PrintWriter;
+
 import net.minecraft.client.Minecraft;
 import org.lwjgl.input.Keyboard;
+import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.GLContext;
+
+import static net.minecraft.src.ItemTooltip.formatFloat;
 
 public class GameSettings {
-	private static final String[] RENDER_DISTANCES = new String[]{"FAR", "NORMAL", "SHORT", "TINY"};
 	private static final String[] DIFFICULTY_LEVELS = new String[]{"Peaceful", "Easy", "Normal", "Hard"};
+	private static final String[] GUI_SCALES = new String[]{"Auto", "Small", "Normal", "Large"};
+	private static final String[] GRAPHICS_LEVELS = new String[]{"Fast", "Fancy", "Fabulous"};
 	public float musicVolume = 1.0F;
 	public float soundVolume = 1.0F;
+	public float musicDelay = 0.5F;
 	public float mouseSensitivity = 0.5F;
+	public float brightness = 0.0F;
+	public float fov = 4.0F / 9.0F;
+	public float fovEffects = 1.0F;
+	public float fovHand = 0.5F;
 	public boolean invertMouse = false;
-	public int renderDistance = 0;
+	public int renderDistance = 16;
+	public int simulationDistance = 8;
 	public boolean viewBobbing = true;
 	public boolean anaglyph = false;
-	public boolean limitFramerate = false;
-	public boolean fancyGraphics = true;
-	public KeyBinding keyBindForward = new KeyBinding("Forward", 17);
-	public KeyBinding keyBindLeft = new KeyBinding("Left", 30);
-	public KeyBinding keyBindBack = new KeyBinding("Back", 31);
-	public KeyBinding keyBindRight = new KeyBinding("Right", 32);
-	public KeyBinding keyBindJump = new KeyBinding("Jump", 57);
-	public KeyBinding keyBindInventory = new KeyBinding("Inventory", 23);
-	public KeyBinding keyBindDrop = new KeyBinding("Drop", 16);
-	public KeyBinding keyBindChat = new KeyBinding("Chat", 20);
-	public KeyBinding keyBindToggleFog = new KeyBinding("Toggle fog", 33);
-	public KeyBinding keyBindSneak = new KeyBinding("Sneak", 42);
-	public KeyBinding[] keyBindings = new KeyBinding[]{this.keyBindForward, this.keyBindLeft, this.keyBindBack, this.keyBindRight, this.keyBindJump, this.keyBindSneak, this.keyBindDrop, this.keyBindInventory, this.keyBindChat, this.keyBindToggleFog};
+	public int maxFps = 250;
+	public int fancyGraphics = 2;
+	public boolean caveSounds = false;
+	public boolean creativeDebug = false;
+	public boolean darkMode = false;
+	public boolean minimalDebugInfo = false;
+	public boolean ambientOcclusion = true;
+	public boolean fastLighting = true;
+	public boolean lazyLoading = true;
+	public boolean advancedOpengl = false;
+	public boolean occlusionFancy = false;
+	public boolean dynamicUpdates = false;
+	public boolean fastRender = true;
+	public int guiScale = 0;
+	public int headerBlockID = Block.planks.blockID;
+	public int headerBlockMeta = 0;
+	public int chunkUpdates = 1;
+	public int autosaveInterval = 60;
+	public KeyBinding keyBindForward = new KeyBinding("Forward", Keyboard.KEY_W);
+	public KeyBinding keyBindLeft = new KeyBinding("Left", Keyboard.KEY_A);
+	public KeyBinding keyBindBack = new KeyBinding("Back", Keyboard.KEY_S);
+	public KeyBinding keyBindRight = new KeyBinding("Right", Keyboard.KEY_D);
+	public KeyBinding keyBindJump = new KeyBinding("Jump", Keyboard.KEY_SPACE);
+	public KeyBinding keyBindInventory = new KeyBinding("Inventory", Keyboard.KEY_E);
+	public KeyBinding keyBindDrop = new KeyBinding("Drop", Keyboard.KEY_Q);
+	public KeyBinding keyBindChat = new KeyBinding("Chat", Keyboard.KEY_T);
+	public KeyBinding keyBindToggleFog = new KeyBinding("Toggle fog", Keyboard.KEY_F);
+	public KeyBinding keyBindSneak = new KeyBinding("Sneak", Keyboard.KEY_LSHIFT);
+	public KeyBinding keyBindRun = new KeyBinding("Run", Keyboard.KEY_LCONTROL);
+	public KeyBinding keyBindCreative = new KeyBinding("Creative", Keyboard.KEY_C);
+	public KeyBinding keyBindRecipeGuide = new KeyBinding("Recipe guide", Keyboard.KEY_R);
+	public KeyBinding keyBindZoom = new KeyBinding("Zoom", Keyboard.KEY_GRAVE);
+	public KeyBinding keyBindHideHud = new KeyBinding("Hide HUD", Keyboard.KEY_F1);
+	public KeyBinding keyBindScreenshot = new KeyBinding("Screenshot", Keyboard.KEY_F2);
+	public KeyBinding keyBindThirdPerson = new KeyBinding("Third Person", Keyboard.KEY_F5);
+	public KeyBinding[] keyBindings = new KeyBinding[] { this.keyBindForward, this.keyBindLeft, this.keyBindBack,
+			this.keyBindRight, this.keyBindJump, this.keyBindSneak, this.keyBindDrop, this.keyBindInventory,
+			this.keyBindChat, this.keyBindToggleFog, this.keyBindRun, this.keyBindCreative, this.keyBindRecipeGuide,
+			this.keyBindZoom, this.keyBindScreenshot, this.keyBindThirdPerson };
 	protected Minecraft mc;
 	private File optionsFile;
-	public int numberOfOptions = 10;
+	public int numberOfOptions = EnumOption.values().length - 2;
 	public int difficulty = 2;
-	public boolean thirdPersonView = false;
+	public int thirdPersonView = 0;
+	public boolean debugMenu = false;
+	public boolean lagometer = false;
 
 	public GameSettings(Minecraft var1, File var2) {
 		this.mc = var1;
@@ -46,6 +86,10 @@
 	public GameSettings() {
 	}
 
+	public int getTextColor() {
+		return this.darkMode ? 14737632 : 4210752;
+	}
+
 	public String getKeyBindingDescription(int var1) {
 		return this.keyBindings[var1].keyDescription + ": " + Keyboard.getKeyName(this.keyBindings[var1].keyCode);
 	}
@@ -56,50 +100,158 @@
 	}
 
 	public void setOptionFloatValue(int var1, float var2) {
-		if(var1 == 0) {
+		if (var1 == 0) {
 			this.musicVolume = var2;
 			this.mc.sndManager.onSoundOptionsChanged();
 		}
 
-		if(var1 == 1) {
+		if (var1 == 1) {
 			this.soundVolume = var2;
 			this.mc.sndManager.onSoundOptionsChanged();
 		}
 
-		if(var1 == 3) {
+		if (var1 == 3) {
 			this.mouseSensitivity = var2;
 		}
 
+		if (var1 == 4) {
+			this.renderDistance = (int)(var2 * 30 + 2);
+		}
+
+		if (var1 == 7) {
+			this.maxFps = (int)(var2 * 50) * 5;
+			Display.setVSyncEnabled(this.maxFps <= 0);
+		}
+
+		if (var1 == 11) {
+			this.brightness = var2;
+			RenderGlobal.globalBrightness = this.brightness * 0.2F;
+			this.mc.renderGlobal.loadRenderers();
+		}
+
+		if (var1 == 12) {
+			this.musicDelay = var2;
+		}
+
+		if (var1 == 14) {
+			this.fov = Math.round(var2 * 90.0F) / 90.0F;
+		}
+
+		if (var1 == 15) {
+			this.fovEffects = var2;
+		}
+
+		if (var1 == 20) {
+			this.simulationDistance = (int)(var2 * 30 + 2);
+		}
+
+		if (var1 == 22) {
+			this.chunkUpdates = (int)(var2 * 4 + 1);
+		}
+
+		if (var1 == 26) {
+			this.autosaveInterval = (int)(var2 * 59 + 1) * 5;
+		}
+
+		if (var1 == 28) {
+			this.fovHand = var2;
+		}
 	}
 
 	public void setOptionValue(int var1, int var2) {
-		if(var1 == 2) {
+		if (var1 == 2) {
 			this.invertMouse = !this.invertMouse;
 		}
 
-		if(var1 == 4) {
-			this.renderDistance = this.renderDistance + var2 & 3;
-		}
-
-		if(var1 == 5) {
+		if (var1 == 5) {
 			this.viewBobbing = !this.viewBobbing;
 		}
 
-		if(var1 == 6) {
+		if (var1 == 6) {
 			this.anaglyph = !this.anaglyph;
 			this.mc.renderEngine.refreshTextures();
 		}
 
-		if(var1 == 7) {
-			this.limitFramerate = !this.limitFramerate;
-		}
-
-		if(var1 == 8) {
+		if (var1 == 8) {
 			this.difficulty = this.difficulty + var2 & 3;
 		}
 
-		if(var1 == 9) {
-			this.fancyGraphics = !this.fancyGraphics;
+		if (var1 == 9) {
+			this.fancyGraphics = Math.floorMod(this.fancyGraphics + var2, 3);
+			this.mc.renderGlobal.loadRenderers();
+		}
+
+		if (var1 == 10) {
+			this.caveSounds = !this.caveSounds;
+			if (this.caveSounds) {
+				this.mc.sndManager.playSoundFX("ambient.cave.cave", 1.0F, 1.0F);
+			}
+		}
+
+		if (var1 == 13) {
+			this.darkMode = !this.darkMode;
+		}
+
+		if (var1 == 16) {
+			this.minimalDebugInfo = !this.minimalDebugInfo;
+		}
+
+		if (var1 == 17) {
+			this.guiScale = (this.guiScale + var2) % GUI_SCALES.length;
+			if (this.mc.currentScreen != null) {
+				ScaledResolution scaledResolution2 = new ScaledResolution(this.mc.displayWidth, this.mc.displayHeight, this.guiScale);
+				int var3 = scaledResolution2.getScaledWidth();
+				int var4 = scaledResolution2.getScaledHeight();
+				this.mc.currentScreen.setWorldAndResolution(this.mc, var3, var4);
+			}
+		}
+
+		if (var1 == 18) {
+			this.mc.displayGuiScreen(new GuiHeaderPicker(this.mc.currentScreen, this.mc));
+		}
+
+		if (var1 == 19) {
+			this.ambientOcclusion = !this.ambientOcclusion;
+			this.mc.renderGlobal.loadRenderers();
+		}
+
+		if (var1 == 21) {
+			this.fastLighting = !this.fastLighting;
+			if (this.mc.theWorld != null) {
+				this.mc.theWorld.fastLighting = this.fastLighting;
+			}
+		}
+
+		if (var1 == 23) {
+			this.lazyLoading = !this.lazyLoading;
+			if (this.mc.theWorld != null) {
+				this.mc.theWorld.lazyLoading = this.lazyLoading;
+			}
+		}
+
+		if (var1 == 24) {
+			if(!GLContext.getCapabilities().GL_ARB_occlusion_query) {
+				this.occlusionFancy = false;
+				this.advancedOpengl = false;
+			} else if(!this.advancedOpengl) {
+				this.advancedOpengl = true;
+				this.occlusionFancy = false;
+			} else if(!this.occlusionFancy) {
+				this.occlusionFancy = true;
+			} else {
+				this.occlusionFancy = false;
+				this.advancedOpengl = false;
+			}
+
+			this.mc.renderGlobal.setAllRenderersVisible();
+		}
+
+		if (var1 == 25) {
+			this.dynamicUpdates = !this.dynamicUpdates;
+		}
+
+		if (var1 == 27) {
+			this.fastRender = !this.fastRender;
 			this.mc.renderGlobal.loadRenderers();
 		}
 
@@ -107,80 +259,303 @@
 	}
 
 	public int isSlider(int var1) {
-		return var1 == 0 ? 1 : (var1 == 1 ? 1 : (var1 == 3 ? 1 : 0));
+		return var1 == 0
+				|| var1 == 1
+				|| var1 == 3
+				|| var1 == 4
+				|| var1 == 7
+				|| var1 == 11
+				|| var1 == 12
+				|| var1 == 14
+				|| var1 == 15
+				|| var1 == 20
+				|| var1 == 22
+				|| var1 == 26
+				|| var1 == 28
+				? 1 : 0;
 	}
 
 	public float getOptionFloatValue(int var1) {
-		return var1 == 0 ? this.musicVolume : (var1 == 1 ? this.soundVolume : (var1 == 3 ? this.mouseSensitivity : 0.0F));
+		switch (var1) {
+			case 0: return this.musicVolume;
+			case 1: return this.soundVolume;
+			case 3: return this.mouseSensitivity;
+			case 4: return (this.renderDistance - 2) / 30.0F;
+			case 7: return this.maxFps / 250.0F;
+			case 11: return this.brightness;
+			case 12: return this.musicDelay;
+			case 14: return this.fov;
+			case 15: return this.fovEffects;
+			case 20: return (this.simulationDistance - 2) / 30.0F;
+			case 22: return (this.chunkUpdates - 1) / 4.0F;
+			case 26: return ((int)(this.autosaveInterval / 5) - 1) / 59.0F;
+			case 28: return this.fovHand;
+			default: return 0.0F;
+		}
 	}
 
 	public String getOptionDisplayString(int var1) {
-		return var1 == 0 ? "Music: " + (this.musicVolume > 0.0F ? (int)(this.musicVolume * 100.0F) + "%" : "OFF") : (var1 == 1 ? "Sound: " + (this.soundVolume > 0.0F ? (int)(this.soundVolume * 100.0F) + "%" : "OFF") : (var1 == 2 ? "Invert mouse: " + (this.invertMouse ? "ON" : "OFF") : (var1 == 3 ? (this.mouseSensitivity == 0.0F ? "Sensitivity: *yawn*" : (this.mouseSensitivity == 1.0F ? "Sensitivity: HYPERSPEED!!!" : "Sensitivity: " + (int)(this.mouseSensitivity * 200.0F) + "%")) : (var1 == 4 ? "Render distance: " + RENDER_DISTANCES[this.renderDistance] : (var1 == 5 ? "View bobbing: " + (this.viewBobbing ? "ON" : "OFF") : (var1 == 6 ? "3d anaglyph: " + (this.anaglyph ? "ON" : "OFF") : (var1 == 7 ? "Limit framerate: " + (this.limitFramerate ? "ON" : "OFF") : (var1 == 8 ? "Difficulty: " + DIFFICULTY_LEVELS[this.difficulty] : (var1 == 9 ? "Graphics: " + (this.fancyGraphics ? "FANCY" : "FAST") : "")))))))));
+		switch (var1) {
+			case 0:
+				return "Music: " + (this.musicVolume > 0.0F ? (int) (this.musicVolume * 100.0F) + "%" : "OFF");
+			case 1:
+				return "Sound: " + (this.soundVolume > 0.0F ? (int) (this.soundVolume * 100.0F) + "%" : "OFF");
+			case 2:
+				return "Invert Mouse: " + (this.invertMouse ? "ON" : "OFF");
+			case 3:
+				return (this.mouseSensitivity == 0.0F ? "Sensitivity: *yawn*"
+						: (this.mouseSensitivity == 1.0F ? "Sensitivity: HYPERSPEED!!!"
+								: "Sensitivity: " + (int) (this.mouseSensitivity * 200.0F) + "%"));
+			case 4:
+				return "Render Distance: " + this.renderDistance;
+			case 5:
+				return "View Bobbing: " + (this.viewBobbing ? "ON" : "OFF");
+			case 6:
+				return "3D Anaglyph: " + (this.anaglyph ? "ON" : "OFF");
+			case 7:
+				return "Max FPS: " + (
+						this.maxFps <= 0 ? "VSync"
+						: this.maxFps >= 250 ? "Unlimited"
+						: this.maxFps);
+			case 8:
+				return "Difficulty: " + DIFFICULTY_LEVELS[this.difficulty];
+			case 9:
+				return "Graphics: " + GRAPHICS_LEVELS[this.fancyGraphics];
+			case 10:
+				return "Cave sounds: " + (this.caveSounds ? "ON" : "OFF");
+			case 11:
+				return "Brightness: " + (
+						this.brightness <= 0.0F ? "Moody"
+						: this.brightness >= 1.0F ? "Bright"
+						: (int) (this.brightness * 100.0F) + "%");
+			case 12:
+				float delay = (int) (this.musicDelay * 100.0F) / 10.0F;
+				return "Music Delay: " + formatFloat(delay) + "-" + formatFloat(delay * 2.0F) + " mins";
+			case 13:
+				return "Dark Mode: " + (this.darkMode ? "ON" : "OFF");
+			case 14:
+				int fov = (int) (30.0F + this.fov * 90.0F);
+				return "FOV: " + (
+						fov == 30 ? "Eye Sore"
+						: fov == 70 ? "Normal"
+						: fov == 120 ? "Quake Pro"
+						: fov);
+			case 15:
+				return "FOV Effects: " + (this.fovEffects > 0.0F ? (int) (this.fovEffects * 100.0F) + "%" : "OFF");
+			case 16:
+				return "Minimal Debug Info: " + (this.minimalDebugInfo ? "ON" : "OFF");
+			case 17:
+				return "Gui Scale: " + GUI_SCALES[this.guiScale];
+			case 18:
+				return "Header: " + (ItemTooltip.fromMetadata[this.headerBlockID] != null
+						&& ItemTooltip.fromMetadata[this.headerBlockID].length > this.headerBlockMeta
+						&& ItemTooltip.fromMetadata[this.headerBlockID][this.headerBlockMeta] != null
+						? ItemTooltip.fromMetadata[this.headerBlockID][this.headerBlockMeta]
+						: ItemTooltip.items[this.headerBlockID]).lines.get(0);
+			case 19:
+				return "Smooth Lighting: " + (this.ambientOcclusion ? "ON" : "OFF");
+			case 20:
+				return "Simulation Distance: " + this.simulationDistance;
+			case 21:
+				return "Fast Lighting: " + (this.fastLighting ? "ON" : "OFF");
+			case 22:
+				return "Chunk Updates: " + this.chunkUpdates;
+			case 23:
+				return "Lazy Loading: " + (this.lazyLoading ? "ON" : "OFF");
+			case 24:
+				return "Advanced OpenGL: " + (this.advancedOpengl ? (this.occlusionFancy ? "Fancy" : "Fast") : "OFF");
+			case 25:
+				return "Dynamic Updates: " + (this.dynamicUpdates ? "ON" : "OFF");
+			case 26:
+				int seconds = this.autosaveInterval % 60;
+				int minutes = this.autosaveInterval / 60;
+
+				String text = "Autosave:";
+				if (minutes > 0) {
+					text += " ";
+					text += minutes;
+					text += minutes == 1 ? " min" : " mins";
+				}
+
+				if (seconds > 0) {
+					text += " ";
+					text += seconds;
+					text += seconds == 1 ? " sec" : " secs";
+				}
+
+				return text;
+			case 27:
+				return "Fast Render: " + (this.fastRender ? "ON" : "OFF");
+			case 28:
+				return "Hand FOV Modifer: " + (this.fovHand > 0.0F ? (int) (this.fovHand * 100.0F) + "%" : "OFF");
+			default:
+				return "NULL";
+		}
 	}
 
 	public void loadOptions() {
 		try {
-			if(!this.optionsFile.exists()) {
+			this.fancyGraphics = 0;
+			if (!this.optionsFile.exists()) {
 				return;
 			}
 
 			BufferedReader var1 = new BufferedReader(new FileReader(this.optionsFile));
-			String var2 = "";
-
-			while(true) {
-				var2 = var1.readLine();
-				if(var2 == null) {
-					var1.close();
-					break;
-				}
-
+			String var2;
+
+			while ((var2 = var1.readLine()) != null) {
 				String[] var3 = var2.split(":");
-				if(var3[0].equals("music")) {
+				if (var3[0].equals("music")) {
 					this.musicVolume = this.parseFloat(var3[1]);
 				}
 
-				if(var3[0].equals("sound")) {
+				if (var3[0].equals("sound")) {
 					this.soundVolume = this.parseFloat(var3[1]);
 				}
 
-				if(var3[0].equals("mouseSensitivity")) {
+				if (var3[0].equals("mouseSensitivity")) {
 					this.mouseSensitivity = this.parseFloat(var3[1]);
 				}
 
-				if(var3[0].equals("invertYMouse")) {
+				if (var3[0].equals("invertYMouse")) {
 					this.invertMouse = var3[1].equals("true");
 				}
 
-				if(var3[0].equals("viewDistance")) {
+				if (var3[0].equals("viewDistance")) {
+					this.renderDistance = 16 >> Integer.parseInt(var3[1]);
+				}
+
+				if (var3[0].equals("renderDistance")) {
 					this.renderDistance = Integer.parseInt(var3[1]);
 				}
 
-				if(var3[0].equals("bobView")) {
+				if (var3[0].equals("bobView")) {
 					this.viewBobbing = var3[1].equals("true");
 				}
 
-				if(var3[0].equals("anaglyph3d")) {
+				if (var3[0].equals("anaglyph3d")) {
 					this.anaglyph = var3[1].equals("true");
 				}
 
-				if(var3[0].equals("limitFramerate")) {
-					this.limitFramerate = var3[1].equals("true");
+				if (var3[0].equals("maxFps")) {
+					this.maxFps = Integer.parseInt(var3[1]);
 				}
 
-				if(var3[0].equals("difficulty")) {
+				if (var3[0].equals("difficulty")) {
 					this.difficulty = Integer.parseInt(var3[1]);
 				}
 
-				if(var3[0].equals("fancyGraphics")) {
-					this.fancyGraphics = var3[1].equals("true");
-				}
-
-				for(int var4 = 0; var4 < this.keyBindings.length; ++var4) {
-					if(var3[0].equals("key_" + this.keyBindings[var4].keyDescription)) {
+				if (var3[0].equals("fancyGraphics")) {
+					this.fancyGraphics += var3[1].equals("true") ? 1 : 0;
+				}
+
+				if (var3[0].equals("fabulousGraphics")) {
+					this.fancyGraphics += var3[1].equals("true") ? 1 : 0;
+				}
+
+				if (var3[0].equals("caveSounds")) {
+					this.caveSounds = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("brightness")) {
+					this.brightness = this.parseFloat(var3[1]);
+				}
+
+				if (var3[0].equals("musicDelay")) {
+					this.musicDelay = this.parseFloat(var3[1]);
+				}
+
+				if (var3[0].equals("darkMode")) {
+					this.darkMode = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("fov")) {
+					this.fov = this.parseFloat(var3[1]);
+					if (this.fov >= 30.0F) { // Convert from Diverge's old FOV
+						this.fov = Math.round(this.fov - 30.0F) / 90.0F;
+					}
+				}
+
+				if (var3[0].equals("fovEffects")) {
+					this.fovEffects = this.parseFloat(var3[1]);
+				}
+
+				if (var3[0].equals("guiScale")) {
+					this.guiScale = Integer.parseInt(var3[1]);
+				}
+
+				if (var3[0].equals("headerBlockID")) {
+					this.headerBlockID = Integer.parseInt(var3[1]);
+				}
+
+				if (var3[0].equals("headerBlockMeta")) {
+					this.headerBlockMeta = Integer.parseInt(var3[1]);
+				}
+
+				if (var3[0].equals("darkMode")) {
+					this.darkMode = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("minimalDebugInfo")) {
+					this.minimalDebugInfo = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("ao")) {
+					this.ambientOcclusion = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("simulationDistance")) {
+					this.simulationDistance = Integer.parseInt(var3[1]);
+				}
+
+				if (var3[0].equals("fastLighting")) {
+					this.fastLighting = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("chunkUpdates")) {
+					this.chunkUpdates = Integer.parseInt(var3[1]);
+				}
+
+				if (var3[0].equals("lazyLoading")) {
+					this.lazyLoading = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("advancedOpengl")) {
+					this.advancedOpengl = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("occlusionFancy")) {
+					this.occlusionFancy = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("dynamicUpdates")) {
+					this.dynamicUpdates = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("autosaveInterval")) {
+					this.autosaveInterval = Integer.parseInt(var3[1]);
+				}
+
+				if (var3[0].equals("fastRender")) {
+					this.fastRender = var3[1].equals("true");
+				}
+
+				if (var3[0].equals("fovHand")) {
+					this.fovHand = this.parseFloat(var3[1]);
+				}
+
+				for (int var4 = 0; var4 < this.keyBindings.length; ++var4) {
+					if (var3[0].equals("key_" + this.keyBindings[var4].keyDescription)) {
 						this.keyBindings[var4].keyCode = Integer.parseInt(var3[1]);
 					}
 				}
 			}
+
+			var1.close();
+
+			this.creativeDebug = Minecraft.developmentVersion;
+		} catch (RuntimeException e) {
+			throw e;
 		} catch (Exception var5) {
 			System.out.println("Failed to load options");
 			var5.printStackTrace();
@@ -194,27 +569,48 @@
 
 	public void saveOptions() {
 		try {
-			PrintWriter var1 = new PrintWriter(new FileWriter(this.optionsFile));
-			var1.println("music:" + this.musicVolume);
-			var1.println("sound:" + this.soundVolume);
-			var1.println("invertYMouse:" + this.invertMouse);
-			var1.println("mouseSensitivity:" + this.mouseSensitivity);
-			var1.println("viewDistance:" + this.renderDistance);
-			var1.println("bobView:" + this.viewBobbing);
-			var1.println("anaglyph3d:" + this.anaglyph);
-			var1.println("limitFramerate:" + this.limitFramerate);
-			var1.println("difficulty:" + this.difficulty);
-			var1.println("fancyGraphics:" + this.fancyGraphics);
+			PrintWriter printWriter1 = new PrintWriter(new FileWriter(this.optionsFile));
+			printWriter1.println("music:" + Math.floor(this.musicVolume * 100.0F) / 100.0F);
+			printWriter1.println("sound:" + Math.floor(this.soundVolume * 100.0F) / 100.0F);
+			printWriter1.println("invertYMouse:" + this.invertMouse);
+			printWriter1.println("mouseSensitivity:" + Math.floor(this.mouseSensitivity * 100.0F) / 100.0F);
+			printWriter1.println("renderDistance:" + this.renderDistance);
+			printWriter1.println("bobView:" + this.viewBobbing);
+			printWriter1.println("anaglyph3d:" + this.anaglyph);
+			printWriter1.println("maxFps:" + this.maxFps);
+			printWriter1.println("difficulty:" + this.difficulty);
+			printWriter1.println("fancyGraphics:" + (this.fancyGraphics > 0));
+			printWriter1.println("fabulousGraphics:" + (this.fancyGraphics > 1));
+			printWriter1.println("caveSounds:" + this.caveSounds);
+			printWriter1.println("brightness:" + Math.floor(this.brightness * 100.0F) / 100.0F);
+			printWriter1.println("darkMode:" + this.darkMode);
+			printWriter1.println("musicDelay:" + Math.floor(this.musicDelay * 100.0F) / 100.0F);
+			printWriter1.println("fov:" + this.fov);
+			printWriter1.println("fovEffects:" + Math.floor(this.fovEffects * 100.0F) / 100.0F);
+			printWriter1.println("guiScale:" + this.guiScale);
+			printWriter1.println("headerBlockID:" + this.headerBlockID);
+			printWriter1.println("headerBlockMeta:" + this.headerBlockMeta);
+			printWriter1.println("minimalDebugInfo:" + this.minimalDebugInfo);
+			printWriter1.println("ao:" + this.ambientOcclusion);
+			printWriter1.println("simulationDistance:" + this.simulationDistance);
+			printWriter1.println("fastLighting:" + this.fastLighting);
+			printWriter1.println("chunkUpdates:" + this.chunkUpdates);
+			printWriter1.println("lazyLoading:" + this.lazyLoading);
+			printWriter1.println("advancedOpengl:" + this.advancedOpengl);
+			printWriter1.println("occlusionFancy:" + this.occlusionFancy);
+			printWriter1.println("dynamicUpdates:" + this.dynamicUpdates);
+			printWriter1.println("autosaveInterval:" + this.autosaveInterval);
+			printWriter1.println("fastRender:" + this.fastRender);
+			printWriter1.println("fovHand:" + this.fovHand);
 
-			for(int var2 = 0; var2 < this.keyBindings.length; ++var2) {
-				var1.println("key_" + this.keyBindings[var2].keyDescription + ":" + this.keyBindings[var2].keyCode);
+			for (KeyBinding keyBinding : this.keyBindings) {
+				printWriter1.println("key_" + keyBinding.keyDescription + ":" + keyBinding.keyCode);
 			}
 
-			var1.close();
+			printWriter1.close();
 		} catch (Exception var3) {
 			System.out.println("Failed to save options");
 			var3.printStackTrace();
 		}
-
 	}
 }
--- net/minecraft/src/BlockCactus.java
+++ net/minecraft/src/BlockCactus.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockCactus extends Block {
-	protected BlockCactus(int var1, int var2) {
+	public BlockCactus(int var1, int var2) {
 		super(var1, var2, Material.cactus);
 		this.setTickOnLoad(true);
 	}
--- net/minecraft/src/ServerWindowAdapter.java
+++ net/minecraft/src/ServerWindowAdapter.java
@@ -2,12 +2,13 @@
 
 import java.awt.event.WindowAdapter;
 import java.awt.event.WindowEvent;
+
 import net.minecraft.server.MinecraftServer;
 
-final class ServerWindowAdapter extends WindowAdapter {
-	final MinecraftServer mcServer;
+public final class ServerWindowAdapter extends WindowAdapter {
+	public final MinecraftServer mcServer;
 
-	ServerWindowAdapter(MinecraftServer var1) {
+	public ServerWindowAdapter(MinecraftServer var1) {
 		this.mcServer = var1;
 	}
 
--- net/minecraft/src/BlockStationary.java
+++ net/minecraft/src/BlockStationary.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockStationary extends BlockFluid {
-	protected BlockStationary(int var1, Material var2) {
+	public BlockStationary(int var1, Material var2) {
 		super(var1, var2);
 		this.setTickOnLoad(false);
 		if(var2 == Material.lava) {
@@ -37,14 +37,16 @@
 				var2 += var5.nextInt(3) - 1;
 				++var3;
 				var4 += var5.nextInt(3) - 1;
-				int var8 = var1.getBlockId(var2, var3, var4);
-				if(var8 == 0) {
-					if(this.isFlammable(var1, var2 - 1, var3, var4) || this.isFlammable(var1, var2 + 1, var3, var4) || this.isFlammable(var1, var2, var3, var4 - 1) || this.isFlammable(var1, var2, var3, var4 + 1) || this.isFlammable(var1, var2, var3 - 1, var4) || this.isFlammable(var1, var2, var3 + 1, var4)) {
-						var1.setBlockWithNotify(var2, var3, var4, Block.fire.blockID);
+				if (!var1.lazyLoading || var1.chunkExists(var2 << 4, var4 << 4)) {
+					int var8 = var1.getBlockId(var2, var3, var4);
+					if(var8 == 0) {
+						if(this.isFlammable(var1, var2 - 1, var3, var4) || this.isFlammable(var1, var2 + 1, var3, var4) || this.isFlammable(var1, var2, var3, var4 - 1) || this.isFlammable(var1, var2, var3, var4 + 1) || this.isFlammable(var1, var2, var3 - 1, var4) || this.isFlammable(var1, var2, var3 + 1, var4)) {
+							var1.setBlockWithNotify(var2, var3, var4, Block.fire.blockID);
+							return;
+						}
+					} else if(Block.blocksList[var8].material.getIsSolid()) {
 						return;
 					}
-				} else if(Block.blocksList[var8].material.getIsSolid()) {
-					return;
 				}
 			}
 		}
--- /dev/null
+++ net/minecraft/src/ModTexture.java
@@ -1,0 +1,20 @@
+package net.minecraft.src;
+
+import java.awt.image.BufferedImage;
+
+public class ModTexture extends TextureFX {
+	public ModTexture(int index, boolean isItem, BufferedImage image) {
+		super(index);
+		this.tileImage = isItem ? 1 : 0;
+
+		int[] pixels = new int[256];
+		image.getRGB(0, 0, 16, 16, pixels, 0, 16);
+
+		for (int i = 0; i < 256; i++) {
+			imageData[4 * i + 0] = (byte)((pixels[i] >> 16) & 0xFF);
+			imageData[4 * i + 1] = (byte)((pixels[i] >> 8) & 0xFF);
+			imageData[4 * i + 2] = (byte)((pixels[i] >> 0) & 0xFF);
+			imageData[4 * i + 3] = (byte)((pixels[i] >> 24) & 0xFF);
+		}
+	}
+}
--- net/minecraft/src/BlockCrops.java
+++ net/minecraft/src/BlockCrops.java
@@ -3,7 +3,7 @@
 import java.util.Random;
 
 public class BlockCrops extends BlockFlower {
-	protected BlockCrops(int var1, int var2) {
+	public BlockCrops(int var1, int var2) {
 		super(var1, var2);
 		this.blockIndexInTexture = var2;
 		this.setTickOnLoad(true);
--- /dev/null
+++ net/minecraft/src/MCHashTableInteger.java
@@ -1,0 +1,151 @@
+package net.minecraft.src;
+
+public class MCHashTableInteger {
+	private transient MCHashEntryInteger[] slots = new MCHashEntryInteger[16];
+	private transient int count;
+	private int threshold = 12;
+	private final float growFactor = 12.0F / 16.0F;
+	private transient volatile int versionStamp;
+
+	private static int computeHash(int var0) {
+		var0 ^= var0 >>> 20 ^ var0 >>> 12;
+		return var0 ^ var0 >>> 7 ^ var0 >>> 4;
+	}
+
+	private static int getSlotIndex(int var0, int var1) {
+		return var0 & var1 - 1;
+	}
+
+	public Object lookup(int var1) {
+		int var2 = computeHash(var1);
+
+		for(MCHashEntryInteger var3 = this.slots[getSlotIndex(var2, this.slots.length)]; var3 != null; var3 = var3.nextEntry) {
+			if(var3.hashEntry == var1) {
+				return var3.valueEntry;
+			}
+		}
+
+		return null;
+	}
+
+	public boolean containsItem(int var1) {
+		return this.lookupEntry(var1) != null;
+	}
+
+	public final MCHashEntryInteger lookupEntry(int var1) {
+		int var2 = computeHash(var1);
+
+		for(MCHashEntryInteger var3 = this.slots[getSlotIndex(var2, this.slots.length)]; var3 != null; var3 = var3.nextEntry) {
+			if(var3.hashEntry == var1) {
+				return var3;
+			}
+		}
+
+		return null;
+	}
+
+	public void addKey(int var1, Object var2) {
+		int var3 = computeHash(var1);
+		int var4 = getSlotIndex(var3, this.slots.length);
+
+		for(MCHashEntryInteger var5 = this.slots[var4]; var5 != null; var5 = var5.nextEntry) {
+			if(var5.hashEntry == var1) {
+				var5.valueEntry = var2;
+			}
+		}
+
+		++this.versionStamp;
+		this.insert(var3, var1, var2, var4);
+	}
+
+	private void grow(int var1) {
+		MCHashEntryInteger[] var2 = this.slots;
+		int var3 = var2.length;
+		if(var3 == 1073741824) {
+			this.threshold = Integer.MAX_VALUE;
+		} else {
+			MCHashEntryInteger[] var4 = new MCHashEntryInteger[var1];
+			this.copyTo(var4);
+			this.slots = var4;
+			this.threshold = (int)((float)var1 * this.growFactor);
+		}
+	}
+
+	private void copyTo(MCHashEntryInteger[] var1) {
+		MCHashEntryInteger[] var2 = this.slots;
+		int var3 = var1.length;
+
+		for(int var4 = 0; var4 < var2.length; ++var4) {
+			MCHashEntryInteger var5 = var2[var4];
+			if(var5 != null) {
+				var2[var4] = null;
+
+				MCHashEntryInteger var6;
+				do {
+					var6 = var5.nextEntry;
+					int var7 = getSlotIndex(var5.slotHash, var3);
+					var5.nextEntry = var1[var7];
+					var1[var7] = var5;
+					var5 = var6;
+				} while(var6 != null);
+			}
+		}
+
+	}
+
+	public Object removeObject(int var1) {
+		MCHashEntryInteger var2 = this.removeEntry(var1);
+		return var2 == null ? null : var2.valueEntry;
+	}
+
+	public final MCHashEntryInteger removeEntry(int var1) {
+		int var2 = computeHash(var1);
+		int var3 = getSlotIndex(var2, this.slots.length);
+		MCHashEntryInteger var4 = this.slots[var3];
+
+		MCHashEntryInteger var5;
+		MCHashEntryInteger var6;
+		for(var5 = var4; var5 != null; var5 = var6) {
+			var6 = var5.nextEntry;
+			if(var5.hashEntry == var1) {
+				++this.versionStamp;
+				--this.count;
+				if(var4 == var5) {
+					this.slots[var3] = var6;
+				} else {
+					var4.nextEntry = var6;
+				}
+
+				return var5;
+			}
+
+			var4 = var5;
+		}
+
+		return var5;
+	}
+
+	public void clearMap() {
+		++this.versionStamp;
+		MCHashEntryInteger[] var1 = this.slots;
+
+		for(int var2 = 0; var2 < var1.length; ++var2) {
+			var1[var2] = null;
+		}
+
+		this.count = 0;
+	}
+
+	private void insert(int var1, int var2, Object var3, int var4) {
+		MCHashEntryInteger var5 = this.slots[var4];
+		this.slots[var4] = new MCHashEntryInteger(var1, var2, var3, var5);
+		if(this.count++ >= this.threshold) {
+			this.grow(2 * this.slots.length);
+		}
+
+	}
+
+	public static int getHash(int var0) {
+		return computeHash(var0);
+	}
+}
--- /dev/null
+++ net/minecraft/src/MCHashEntryInteger.java
@@ -1,0 +1,50 @@
+package net.minecraft.src;
+
+public class MCHashEntryInteger {
+	public final int hashEntry;
+	public Object valueEntry;
+	public MCHashEntryInteger nextEntry;
+	public final int slotHash;
+
+	MCHashEntryInteger(int var1, int var2, Object var3, MCHashEntryInteger var4) {
+		this.valueEntry = var3;
+		this.nextEntry = var4;
+		this.hashEntry = var2;
+		this.slotHash = var1;
+	}
+
+	public final int getHash() {
+		return this.hashEntry;
+	}
+
+	public final Object getValue() {
+		return this.valueEntry;
+	}
+
+	public final boolean equals(Object var1) {
+		if(!(var1 instanceof MCHashEntryInteger)) {
+			return false;
+		} else {
+			MCHashEntryInteger var2 = (MCHashEntryInteger)var1;
+			Integer var3 = Integer.valueOf(this.getHash());
+			Integer var4 = Integer.valueOf(var2.getHash());
+			if(var3 == var4 || var3 != null && var3.equals(var4)) {
+				Object var5 = this.getValue();
+				Object var6 = var2.getValue();
+				if(var5 == var6 || var5 != null && var5.equals(var6)) {
+					return true;
+				}
+			}
+
+			return false;
+		}
+	}
+
+	public final int hashCode() {
+		return MCHashTableInteger.getHash(this.hashEntry);
+	}
+
+	public final String toString() {
+		return this.getHash() + "=" + this.getValue();
+	}
+}
--- net/minecraft/src/BlockGlass.java
+++ net/minecraft/src/BlockGlass.java
@@ -8,6 +8,18 @@
 	}
 
 	public int quantityDropped(Random var1) {
-		return 0;
+		return var1.nextInt(3) + 2;
+	}
+
+	public int idDropped(int var1, Random var2) {
+		return Item.shardGlass.shiftedIndex;
+	}
+
+	public int quantityDroppedSilk(Random var1) {
+		return 1;
+	}
+
+	public int idDroppedSilk(int var1, Random var2) {
+		return this.blockID;
 	}
 }
--- net/minecraft/src/ChunkCoordinates.java
+++ net/minecraft/src/ChunkCoordinates.java
@@ -1,6 +1,6 @@
 package net.minecraft.src;
 
-final class ChunkCoordinates {
+public final class ChunkCoordinates {
 	public final int posX;
 	public final int posZ;
 
